<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Mon Apr  7 17:26:12 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GIT-PULL</title>

</head>
<body>

<h1 align="center">GIT-PULL</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#Options related to merging">Options related to merging</a><br>
<a href="#Options related to fetching">Options related to fetching</a><br>
<a href="#GIT URLS">GIT URLS</a><br>
<a href="#REMOTES">REMOTES</a><br>
<a href="#Named remote in configuration file">Named remote in configuration file</a><br>
<a href="#Named file in $GIT_DIR/remotes">Named file in $GIT_DIR/remotes</a><br>
<a href="#Named file in $GIT_DIR/branches">Named file in $GIT_DIR/branches</a><br>
<a href="#MERGE STRATEGIES">MERGE STRATEGIES</a><br>
<a href="#DEFAULT BEHAVIOUR">DEFAULT BEHAVIOUR</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SECURITY">SECURITY</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#GIT">GIT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">git-pull - Fetch
from and integrate with another repository or a local
branch</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em"><i>git pull</i>
[&lt;options&gt;] [&lt;repository&gt;
[&lt;refspec&gt;...]]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">Incorporates
changes from a remote repository into the current branch. If
the current branch is behind the remote, then by default it
will fast-forward the current branch to match the remote. If
the current branch and the remote have diverged, the user
needs to specify how to reconcile the divergent branches
with <b>--rebase</b> or <b>--no-rebase</b> (or the
corresponding configuration option in
<b>pull.rebase</b>).</p>

<p style="margin-left:9%; margin-top: 1em">More precisely,
<b>git pull</b> runs <b>git fetch</b> with the given
parameters and then depending on configuration options or
command line flags, will call either <b>git rebase</b> or
<b>git merge</b> to reconcile diverging branches.</p>


<p style="margin-left:9%; margin-top: 1em">&lt;repository&gt;
should be the name of a remote repository as passed to
<b>git-fetch</b>(1). &lt;refspec&gt; can name an arbitrary
remote ref (for example, the name of a tag) or even a
collection of refs with corresponding remote-tracking
branches (e.g., refs/heads/*:refs/remotes/origin/*), but
usually it is the name of a branch in the remote
repository.</p>

<p style="margin-left:9%; margin-top: 1em">Default values
for &lt;repository&gt; and &lt;branch&gt; are read from the
&quot;remote&quot; and &quot;merge&quot; configuration for
the current branch as set by <b>git-branch</b>(1)
<b>--track</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Assume the
following history exists and the current branch is
&quot;<b>master</b>&quot;:</p>

<p style="margin-left:14%; margin-top: 1em">A---B---C
master on origin <br>
/ <br>
D---E---F---G master <br>
&#710; <br>
origin/master in your repository</p>

<p style="margin-left:9%; margin-top: 1em">Then
&quot;<b>git pull</b>&quot; will fetch and replay the
changes from the remote <b>master</b> branch since it
diverged from the local <b>master</b> (i.e., <b>E</b>) until
its current commit (<b>C</b>) on top of <b>master</b> and
record the result in a new commit along with the names of
the two parent commits and a log message from the user
describing the changes.</p>

<p style="margin-left:14%; margin-top: 1em">A---B---C
origin/master <br>
/ \ <br>
D---E---F---G---H master</p>

<p style="margin-left:9%; margin-top: 1em">See
<b>git-merge</b>(1) for details, including how conflicts are
presented and handled.</p>

<p style="margin-left:9%; margin-top: 1em">In Git 1.7.0 or
later, to cancel a conflicting merge, use <b>git reset
--merge</b>. <b>Warning</b>: In older versions of Git,
running <i>git pull</i> with uncommitted changes is
discouraged: while possible, it leaves you in a state that
may be hard to back out of in the case of a conflict.</p>

<p style="margin-left:9%; margin-top: 1em">If any of the
remote changes overlap with local uncommitted changes, the
merge will be automatically canceled and the work tree
untouched. It is generally best to get any local changes in
working order before pulling or stash them away with
<b>git-stash</b>(1).</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">-q, --quiet</p>

<p style="margin-left:14%;">This is passed to both
underlying git-fetch to squelch reporting of during
transfer, and underlying git-merge to squelch output during
merging.</p>

<p style="margin-left:9%; margin-top: 1em">-v,
--verbose</p>

<p style="margin-left:14%;">Pass --verbose to git-fetch and
git-merge.</p>


<p style="margin-left:9%; margin-top: 1em">--[no-]recurse-submodules[=(yes|on-demand|no)]</p>

<p style="margin-left:14%;">This option controls if new
commits of populated submodules should be fetched, and if
the working trees of active submodules should be updated,
too (see <b>git-fetch</b>(1), <b>git-config</b>(1) and
<b>gitmodules</b>(5)).</p>

<p style="margin-left:14%; margin-top: 1em">If the checkout
is done via rebase, local submodule commits are rebased as
well.</p>

<p style="margin-left:14%; margin-top: 1em">If the update
is done via merge, the submodule conflicts are resolved and
checked out.</p>

<h3>Options related to merging
<a name="Options related to merging"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">--commit,
--no-commit</p>

<p style="margin-left:14%;">Perform the merge and commit
the result. This option can be used to override --no-commit.
Only useful when merging.</p>

<p style="margin-left:14%; margin-top: 1em">With
--no-commit perform the merge and stop just before creating
a merge commit, to give the user a chance to inspect and
further tweak the merge result before committing.</p>

<p style="margin-left:14%; margin-top: 1em">Note that
fast-forward updates do not create a merge commit and
therefore there is no way to stop those merges with
--no-commit. Thus, if you want to ensure your branch is not
changed or updated by the merge command, use --no-ff with
--no-commit.</p>

<p style="margin-left:9%; margin-top: 1em">--edit, -e,
--no-edit</p>

<p style="margin-left:14%;">Invoke an editor before
committing successful mechanical merge to further edit the
auto-generated merge message, so that the user can explain
and justify the merge. The <b>--no-edit</b> option can be
used to accept the auto-generated message (this is generally
discouraged).</p>

<p style="margin-left:14%; margin-top: 1em">Older scripts
may depend on the historical behaviour of not allowing the
user to edit the merge log message. They will see an editor
opened when they run <b>git merge</b>. To make it easier to
adjust such scripts to the updated behaviour, the
environment variable <b>GIT_MERGE_AUTOEDIT</b> can be set to
<b>no</b> at the beginning of them.</p>


<p style="margin-left:9%; margin-top: 1em">--cleanup=&lt;mode&gt;</p>

<p style="margin-left:14%;">This option determines how the
merge message will be cleaned up before committing. See
<b>git-commit</b>(1) for more details. In addition, if the
<i>&lt;mode&gt;</i> is given a value of <b>scissors</b>,
scissors will be appended to <b>MERGE_MSG</b> before being
passed on to the commit machinery in the case of a merge
conflict.</p>

<p style="margin-left:9%; margin-top: 1em">--ff-only</p>

<p style="margin-left:14%;">Only update to the new history
if there is no divergent local history. This is the default
when no method for reconciling divergent histories is
provided (via the --rebase=* flags).</p>

<p style="margin-left:9%; margin-top: 1em">--ff,
--no-ff</p>

<p style="margin-left:14%;">When merging rather than
rebasing, specifies how a merge is handled when the
merged-in history is already a descendant of the current
history. If merging is requested, <b>--ff</b> is the default
unless merging an annotated (and possibly signed) tag that
is not stored in its natural place in the <b>refs/tags/</b>
hierarchy, in which case <b>--no-ff</b> is assumed.</p>

<p style="margin-left:14%; margin-top: 1em">With
<b>--ff</b>, when possible resolve the merge as a
fast-forward (only update the branch pointer to match the
merged branch; do not create a merge commit). When not
possible (when the merged-in history is not a descendant of
the current history), create a merge commit.</p>

<p style="margin-left:14%; margin-top: 1em">With
<b>--no-ff</b>, create a merge commit in all cases, even
when the merge could instead be resolved as a
fast-forward.</p>


<p style="margin-left:9%; margin-top: 1em">-S[&lt;keyid&gt;],
--gpg-sign[=&lt;keyid&gt;], --no-gpg-sign</p>

<p style="margin-left:14%;">GPG-sign the resulting merge
commit. The <b>keyid</b> argument is optional and defaults
to the committer identity; if specified, it must be stuck to
the option without a space. <b>--no-gpg-sign</b> is useful
to countermand both <b>commit.gpgSign</b> configuration
variable, and earlier <b>--gpg-sign</b>.</p>


<p style="margin-left:9%; margin-top: 1em">--log[=&lt;n&gt;],
--no-log</p>

<p style="margin-left:14%;">In addition to branch names,
populate the log message with one-line descriptions from at
most &lt;n&gt; actual commits that are being merged. See
also <b>git-fmt-merge-msg</b>(1). Only useful when
merging.</p>

<p style="margin-left:14%; margin-top: 1em">With --no-log
do not list one-line descriptions from the actual commits
being merged.</p>


<p style="margin-left:9%; margin-top: 1em"><b>--signoff</b>,
<b>--no-signoff</b></p>

<p style="margin-left:14%;">Add a <b>Signed-off-by</b>
trailer by the committer at the end of the commit log
message. The meaning of a signoff depends on the project to
which you&rsquo;re committing. For example, it may certify
that the committer has the rights to submit the work under
the project&rsquo;s license or agrees to some contributor
representation, such as a Developer Certificate of Origin.
(See
<b><font color="#0000FF">https://developercertificate.org</font></b>
<font color="#000000">for the one used by the Linux kernel
and Git projects.) Consult the documentation or leadership
of the project to which you&rsquo;re contributing to
understand how the signoffs are used in that
project.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">The
<b>--no-signoff</b> option can be used to countermand an
earlier <b>--signoff</b> option on the command
line.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--stat,
-n, --no-stat</font></p>

<p style="margin-left:14%;"><font color="#000000">Show a
diffstat at the end of the merge. The diffstat is also
controlled by the configuration option
merge.stat.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">With
-n or --no-stat do not show a diffstat at the end of the
merge.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--squash,
--no-squash</font></p>

<p style="margin-left:14%;"><font color="#000000">Produce
the working tree and index state as if a real merge happened
(except for the merge information), but do not actually make
a commit, move the <b>HEAD</b>, or record
<b>$GIT_DIR/MERGE_HEAD</b> (to cause the next <b>git
commit</b> command to create a merge commit). This allows
you to create a single commit on top of the current branch
whose effect is the same as merging another branch (or more
in case of an octopus).</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">With
--no-squash perform the merge and commit the result. This
option can be used to override --squash.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">With
--squash, --commit is not allowed, and will fail.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Only
useful when merging.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--[no-]verify</font></p>

<p style="margin-left:14%;"><font color="#000000">By
default, the pre-merge and commit-msg hooks are run. When
<b>--no-verify</b> is given, these are bypassed. See also
<b>githooks</b>(5). Only useful when merging.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">-s
&lt;strategy&gt;, --strategy=&lt;strategy&gt;</font></p>

<p style="margin-left:14%;"><font color="#000000">Use the
given merge strategy; can be supplied more than once to
specify them in the order they should be tried. If there is
no <b>-s</b> option, a built-in list of strategies is used
instead (<b>ort</b> when merging a single head,
<b>octopus</b> otherwise).</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">-X
&lt;option&gt;, --strategy-option=&lt;option&gt;</font></p>

<p style="margin-left:14%;"><font color="#000000">Pass
merge strategy specific option through to the merge
strategy.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--verify-signatures,
--no-verify-signatures</font></p>

<p style="margin-left:14%;"><font color="#000000">Verify
that the tip commit of the side branch being merged is
signed with a valid key, i.e. a key that has a valid uid: in
the default trust model, this means the signing key has been
signed by a trusted key. If the tip commit of the side
branch is not signed with a valid key, the merge is
aborted.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Only
useful when merging.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--summary,
--no-summary</font></p>

<p style="margin-left:14%;"><font color="#000000">Synonyms
to --stat and --no-stat; these are deprecated and will be
removed in the future.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--autostash,
--no-autostash</font></p>


<p style="margin-left:14%;"><font color="#000000">Automatically
create a temporary stash entry before the operation begins,
record it in the ref <b>MERGE_AUTOSTASH</b> and apply it
after the operation ends. This means that you can run the
operation on a dirty worktree. However, use with care: the
final stash application after a successful merge might
result in non-trivial conflicts.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--allow-unrelated-histories</font></p>

<p style="margin-left:14%;"><font color="#000000">By
default, <b>git merge</b> command refuses to merge histories
that do not share a common ancestor. This option can be used
to override this safety when merging histories of two
projects that started their lives independently. As that is
a very rare occasion, no configuration variable to enable
this by default exists and will not be added.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Only
useful when merging.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">-r,
--rebase[=(false|true|merges|interactive)]</font></p>

<p style="margin-left:14%;"><font color="#000000">When
true, rebase the current branch on top of the upstream
branch after fetching. If there is a remote-tracking branch
corresponding to the upstream branch and the upstream branch
was rebased since last fetched, the rebase uses that
information to avoid rebasing non-local changes.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">When
set to <b>merges</b>, rebase using <b>git rebase
--rebase-merges</b> so that the local merge commits are
included in the rebase (see <b>git-rebase</b>(1) for
details).</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">When
false, merge the upstream branch into the current
branch.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">When
<b>interactive</b>, enable the interactive mode of
rebase.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">See
<b>pull.rebase</b>,
<b>branch.</b><i>&lt;name&gt;</i><b>.rebase</b> and
<b>branch.autoSetupRebase</b> in <b>git-config</b>(1) if you
want to make <b>git pull</b> always use <b>--rebase</b>
instead of merging.</font></p>


<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><b><big>Note</big></b>
<br>
This is a potentially <i>dangerous</i> mode of operation. It
rewrites history, which does not bode well when you
published that history already. Do <b>not</b> use this
option unless you have read <b>git-rebase</b>(1)
carefully.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--no-rebase</font></p>

<p style="margin-left:14%;"><font color="#000000">This is
shorthand for --rebase=false.</font></p>

<h3>Options related to fetching
<a name="Options related to fetching"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--[no-]all</font></p>

<p style="margin-left:14%;"><font color="#000000">Fetch all
remotes, except for the ones that has the
<b>remote.</b><i>&lt;name&gt;</i><b>.skipFetchAll</b>
configuration variable set. This overrides the configuration
variable fetch.all&lsquo;.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">-a,
--append</font></p>

<p style="margin-left:14%;"><font color="#000000">Append
ref names and object names of fetched refs to the existing
contents of <b>.git/FETCH_HEAD</b>. Without this option old
data in <b>.git/FETCH_HEAD</b> will be
overwritten.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--atomic</font></p>

<p style="margin-left:14%;"><font color="#000000">Use an
atomic transaction to update local refs. Either all refs are
updated, or on error, no refs are updated.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--depth=&lt;depth&gt;</font></p>

<p style="margin-left:14%;"><font color="#000000">Limit
fetching to the specified number of commits from the tip of
each remote branch history. If fetching to a <i>shallow</i>
repository created by <b>git clone</b> with
<b>--depth=</b><i>&lt;depth&gt;</i> option (see
<b>git-clone</b>(1)), deepen or shorten the history to the
specified number of commits. Tags for the deepened commits
are not fetched.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--deepen=&lt;depth&gt;</font></p>

<p style="margin-left:14%;"><font color="#000000">Similar
to --depth, except it specifies the number of commits from
the current shallow boundary instead of from the tip of each
remote branch history.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--shallow-since=&lt;date&gt;</font></p>

<p style="margin-left:14%;"><font color="#000000">Deepen or
shorten the history of a shallow repository to include all
reachable commits after &lt;date&gt;.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--shallow-exclude=&lt;ref&gt;</font></p>

<p style="margin-left:14%;"><font color="#000000">Deepen or
shorten the history of a shallow repository to exclude
commits reachable from a specified remote branch or tag.
This option can be specified multiple times.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--unshallow</font></p>

<p style="margin-left:14%;"><font color="#000000">If the
source repository is complete, convert a shallow repository
to a complete one, removing all the limitations imposed by
shallow repositories.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">If
the source repository is shallow, fetch as much as possible
so that the current repository has the same history as the
source repository.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--update-shallow</font></p>

<p style="margin-left:14%;"><font color="#000000">By
default when fetching from a shallow repository, <b>git
fetch</b> refuses refs that require updating .git/shallow.
This option updates .git/shallow and accepts such
refs.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--negotiation-tip=&lt;commit|glob&gt;</font></p>

<p style="margin-left:14%;"><font color="#000000">By
default, Git will report, to the server, commits reachable
from all local refs to find common commits in an attempt to
reduce the size of the to-be-received packfile. If
specified, Git will only report commits reachable from the
given tips. This is useful to speed up fetches when the user
knows which local ref is likely to have commits in common
with the upstream ref being fetched.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">This
option may be specified more than once; if so, Git will
report commits reachable from any of the given
commits.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">The
argument to this option may be a glob on ref names, a ref,
or the (possibly abbreviated) SHA-1 of a commit. Specifying
a glob is equivalent to specifying this option multiple
times, one for each matching ref name.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">See
also the <b>fetch.negotiationAlgorithm</b> and
<b>push.negotiate</b> configuration variables documented in
<b>git-config</b>(1), and the <b>--negotiate-only</b> option
below.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--negotiate-only</font></p>

<p style="margin-left:14%;"><font color="#000000">Do not
fetch anything from the server, and instead print the
ancestors of the provided <b>--negotiation-tip=</b>*
arguments, which we have in common with the
server.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">This
is incompatible with
<b>--recurse-submodules=</b>[<b>yes</b>|<b>on-demand</b>].
Internally this is used to implement the
<b>push.negotiate</b> option, see
<b>git-config</b>(1).</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--dry-run</font></p>

<p style="margin-left:14%;"><font color="#000000">Show what
would be done, without making any changes.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--porcelain</font></p>

<p style="margin-left:14%;"><font color="#000000">Print the
output to standard output in an easy-to-parse format for
scripts. See section OUTPUT in <b>git-fetch</b>(1) for
details.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">This
is incompatible with
<b>--recurse-submodules=</b>[<b>yes</b>|<b>on-demand</b>]
and takes precedence over the <b>fetch.output</b> config
option.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">-f,
--force</font></p>

<p style="margin-left:14%;"><font color="#000000">When
<i>git fetch</i> is used with
<i>&lt;src&gt;</i><b>:</b><i>&lt;dst&gt;</i> refspec, it may
refuse to update the local branch as discussed in the
<i>&lt;refspec&gt;</i> part of the <b>git-fetch</b>(1)
documentation. This option overrides that check.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">-k,
--keep</font></p>

<p style="margin-left:14%;"><font color="#000000">Keep
downloaded pack.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--prefetch</font></p>

<p style="margin-left:14%;"><font color="#000000">Modify
the configured refspec to place all refs into the
<b>refs/prefetch/</b> namespace. See the <b>prefetch</b>
task in <b>git-maintenance</b>(1).</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">-p,
--prune</font></p>

<p style="margin-left:14%;"><font color="#000000">Before
fetching, remove any remote-tracking references that no
longer exist on the remote. Tags are not subject to pruning
if they are fetched only because of the default tag
auto-following or due to a --tags option. However, if tags
are fetched due to an explicit refspec (either on the
command line or in the remote configuration, for example if
the remote was cloned with the --mirror option), then they
are also subject to pruning. Supplying <b>--prune-tags</b>
is a shorthand for providing the tag refspec.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--no-tags</font></p>

<p style="margin-left:14%;"><font color="#000000">By
default, tags that point at objects that are downloaded from
the remote repository are fetched and stored locally. This
option disables this automatic tag following. The default
behavior for a remote may be specified with the
remote.&lt;name&gt;.tagOpt setting. See
<b>git-config</b>(1).</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--refmap=&lt;refspec&gt;</font></p>

<p style="margin-left:14%;"><font color="#000000">When
fetching refs listed on the command line, use the specified
refspec (can be given more than once) to map the refs to
remote-tracking branches, instead of the values of
<b>remote.</b>*.fetch configuration variables for the remote
repository. Providing an empty <i>&lt;refspec&gt;</i> to the
<b>--refmap</b> option causes Git to ignore the configured
refspecs and rely entirely on the refspecs supplied as
command-line arguments. See section on &quot;Configured
Remote-tracking Branches&quot; for details.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">-t,
--tags</font></p>

<p style="margin-left:14%;"><font color="#000000">Fetch all
tags from the remote (i.e., fetch remote tags
<b>refs/tags/</b>* into local tags with the same name), in
addition to whatever else would otherwise be fetched. Using
this option alone does not subject tags to pruning, even if
--prune is used (though tags may be pruned anyway if they
are also the destination of an explicit refspec; see
<b>--prune</b>).</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">-j,
--jobs=&lt;n&gt;</font></p>

<p style="margin-left:14%;"><font color="#000000">Number of
parallel children to be used for all forms of
fetching.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">If
the <b>--multiple</b> option was specified, the different
remotes will be fetched in parallel. If multiple submodules
are fetched, they will be fetched in parallel. To control
them independently, use the config settings
<b>fetch.parallel</b> and <b>submodule.fetchJobs</b> (see
<b>git-config</b>(1)).</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Typically,
parallel recursive and multi-remote fetches will be faster.
By default fetches are performed sequentially, not in
parallel.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--set-upstream</font></p>

<p style="margin-left:14%;"><font color="#000000">If the
remote is fetched successfully, add upstream (tracking)
reference, used by argument-less <b>git-pull</b>(1) and
other commands. For more information, see
<b>branch.</b><i>&lt;name&gt;</i><b>.merge</b> and
<b>branch.</b><i>&lt;name&gt;</i><b>.remote</b> in
<b>git-config</b>(1).</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--upload-pack
&lt;upload-pack&gt;</font></p>

<p style="margin-left:14%;"><font color="#000000">When
given, and the repository to fetch from is handled by <i>git
fetch-pack</i>, <b>--exec=</b><i>&lt;upload-pack&gt;</i> is
passed to the command to specify non-default path for the
command run on the other end.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--progress</font></p>

<p style="margin-left:14%;"><font color="#000000">Progress
status is reported on the standard error stream by default
when it is attached to a terminal, unless -q is specified.
This flag forces progress status even if the standard error
stream is not directed to a terminal.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">-o
&lt;option&gt;, --server-option=&lt;option&gt;</font></p>

<p style="margin-left:14%;"><font color="#000000">Transmit
the given string to the server when communicating using
protocol version 2. The given string must not contain a NUL
or LF character. The server&rsquo;s handling of server
options, including unknown ones, is server-specific. When
multiple <b>--server-option=</b><i>&lt;option&gt;</i> are
given, they are all sent to the other side in the order
listed on the command line. When no
<b>--server-option=</b><i>&lt;option&gt;</i> is given from
the command line, the values of configuration variable
<b>remote.</b><i>&lt;name&gt;</i><b>.serverOption</b> are
used instead.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--show-forced-updates</font></p>

<p style="margin-left:14%;"><font color="#000000">By
default, git checks if a branch is force-updated during
fetch. This can be disabled through fetch.showForcedUpdates,
but the --show-forced-updates option guarantees this check
occurs. See <b>git-config</b>(1).</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">--no-show-forced-updates</font></p>

<p style="margin-left:14%;"><font color="#000000">By
default, git checks if a branch is force-updated during
fetch. Pass --no-show-forced-updates or set
fetch.showForcedUpdates to false to skip this check for
performance reasons. If used during <i>git-pull</i> the
--ff-only option will still check for forced updates before
attempting a fast-forward update. See
<b>git-config</b>(1).</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">-4,
--ipv4</font></p>

<p style="margin-left:14%;"><font color="#000000">Use IPv4
addresses only, ignoring IPv6 addresses.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">-6,
--ipv6</font></p>

<p style="margin-left:14%;"><font color="#000000">Use IPv6
addresses only, ignoring IPv4 addresses.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">&lt;repository&gt;</font></p>

<p style="margin-left:14%;"><font color="#000000">The
&quot;remote&quot; repository that is the source of a fetch
or pull operation. This parameter can be either a URL (see
the section GIT URLS below) or the name of a remote (see the
section REMOTES below).</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">&lt;refspec&gt;</font></p>


<p style="margin-left:14%;"><font color="#000000">Specifies
which refs to fetch and which local refs to update. When no
&lt;refspec&gt;s appear on the command line, the refs to
fetch are read from
<b>remote.</b><i>&lt;repository&gt;</i><b>.fetch</b>
variables instead (see the section &quot;CONFIGURED
REMOTE-TRACKING BRANCHES&quot; in
<b>git-fetch</b>(1)).</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">The
format of a &lt;refspec&gt; parameter is an optional plus
<b>+</b>, followed by the source &lt;src&gt;, followed by a
colon <b>:</b>, followed by the destination &lt;dst&gt;. The
colon can be omitted when &lt;dst&gt; is empty. &lt;src&gt;
is typically a ref, or a glob pattern with a single * that
is used to match a set of refs, but it can also be a fully
spelled hex object name.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">A
&lt;refspec&gt; may contain a * in its &lt;src&gt; to
indicate a simple pattern match. Such a refspec functions
like a glob that matches any ref with the pattern. A pattern
&lt;refspec&gt; must have one and only one * in both the
&lt;src&gt; and &lt;dst&gt;. It will map refs to the
destination by replacing the * with the contents matched
from the source.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">If
a refspec is prefixed by <b>&#710;</b>, it will be
interpreted as a negative refspec. Rather than specifying
which refs to fetch or which local refs to update, such a
refspec will instead specify refs to exclude. A ref will be
considered to match if it matches at least one positive
refspec, and does not match any negative refspec. Negative
refspecs can be useful to restrict the scope of a pattern
refspec so that it will not include specific refs. Negative
refspecs can themselves be pattern refspecs. However, they
may only contain a &lt;src&gt; and do not specify a
&lt;dst&gt;. Fully spelled out hex object names are also not
supported.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><b>tag</b>
<i>&lt;tag&gt;</i> means the same as
<b>refs/tags/</b><i>&lt;tag&gt;</i><b>:refs/tags/</b><i>&lt;tag&gt;</i>;
it requests fetching everything up to the given
tag.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">The
remote ref that matches &lt;src&gt; is fetched, and if
&lt;dst&gt; is not an empty string, an attempt is made to
update the local ref that matches it.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Whether
that update is allowed without <b>--force</b> depends on the
ref namespace it&rsquo;s being fetched to, the type of
object being fetched, and whether the update is considered
to be a fast-forward. Generally, the same rules apply for
fetching as when pushing, see the <i>&lt;refspec&gt;</i>...
section of <b>git-push</b>(1) for what those are. Exceptions
to those rules particular to <i>git fetch</i> are noted
below.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Until
Git version 2.20, and unlike when pushing with
<b>git-push</b>(1), any updates to <b>refs/tags/</b>* would
be accepted without <b>+</b> in the refspec (or
<b>--force</b>). When fetching, we promiscuously considered
all tag updates from a remote to be forced fetches. Since
Git version 2.20, fetching to update <b>refs/tags/</b>*
works the same way as when pushing. I.e. any updates will be
rejected without <b>+</b> in the refspec (or
<b>--force</b>).</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Unlike
when pushing with <b>git-push</b>(1), any updates outside of
<b>refs/</b>{tags,heads}/* will be accepted without <b>+</b>
in the refspec (or <b>--force</b>), whether that&rsquo;s
swapping e.g. a tree object for a blob, or a commit for
another commit that doesn&rsquo;t have the previous commit
as an ancestor etc.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Unlike
when pushing with <b>git-push</b>(1), there is no
configuration which&rsquo;ll amend these rules, and nothing
like a <b>pre-fetch</b> hook analogous to the
<b>pre-receive</b> hook.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">As
with pushing with <b>git-push</b>(1), all of the rules
described above about what&rsquo;s not allowed as an update
can be overridden by adding an optional leading <b>+</b> to
a refspec (or using the <b>--force</b> command line option).
The only exception to this is that no amount of forcing will
make the <b>refs/heads/</b>* namespace accept a non-commit
object.</font></p>


<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><b><big>Note</big></b>
<br>
When the remote branch you want to fetch is known to be
rewound and rebased regularly, it is expected that its new
tip will not be a descendant of its previous tip (as stored
in your remote-tracking branch the last time you fetched).
You would want to use the <b>+</b> sign to indicate
non-fast-forward updates will be needed for such branches.
There is no way to determine or declare that a branch will
be made available in a repository with this behavior; the
pulling user simply must know this is the expected usage
pattern for a branch.</font></p>


<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><b><big>Note</big></b>
<br>
There is a difference between listing multiple
&lt;refspec&gt; directly on <i>git pull</i> command line and
having multiple
<b>remote.</b><i>&lt;repository&gt;</i><b>.fetch</b> entries
in your configuration for a &lt;repository&gt; and running a
<i>git pull</i> command without any explicit &lt;refspec&gt;
parameters. &lt;refspec&gt;s listed explicitly on the
command line are always merged into the current branch after
fetching. In other words, if you list more than one remote
ref, <i>git pull</i> will create an Octopus merge. On the
other hand, if you do not list any explicit &lt;refspec&gt;
parameter on the command line, <i>git pull</i> will fetch
all the &lt;refspec&gt;s it finds in the
<b>remote.</b><i>&lt;repository&gt;</i><b>.fetch</b>
configuration and merge only the first &lt;refspec&gt; found
into the current branch. This is because making an Octopus
from remote refs is rarely done, while keeping track of
multiple remote heads in one-go by fetching more than one is
often useful.</font></p>

<h2>GIT URLS
<a name="GIT URLS"></a>
</h2>



<p style="margin-left:9%; margin-top: 1em"><font color="#000000">In
general, URLs contain information about the transport
protocol, the address of the remote server, and the path to
the repository. Depending on the transport protocol, some of
this information may be absent.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">Git
supports ssh, git, http, and https protocols (in addition,
ftp and ftps can be used for fetching, but this is
inefficient and deprecated; do not use them).</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
native transport (i.e. <b>git://</b> URL) does no
authentication and should be used with caution on unsecured
networks.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
following syntaxes may be used with them:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">&bull;
<b>ssh://</b>[<i>&lt;user&gt;</i><b>@</b>]<i>&lt;host&gt;</i>[<b>:</b><i>&lt;port&gt;</i>]<b>/</b><i>&lt;path-to-git-repo&gt;</i></font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">&bull;
<b>git://</b><i>&lt;host&gt;</i>[<b>:</b><i>&lt;port&gt;</i>]<b>/</b><i>&lt;path-to-git-repo&gt;</i></font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">&bull;
<b>http</b>[<b>s</b>]<b>://</b><i>&lt;host&gt;</i>[<b>:</b><i>&lt;port&gt;</i>]<b>/</b><i>&lt;path-to-git-repo&gt;</i></font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">&bull;
<b>ftp</b>[<b>s</b>]<b>://</b><i>&lt;host&gt;</i>[<b>:</b><i>&lt;port&gt;</i>]<b>/</b><i>&lt;path-to-git-repo&gt;</i></font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">An
alternative scp-like syntax may also be used with the ssh
protocol:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">&bull;
[<i>&lt;user&gt;</i><b>@</b>]<i>&lt;host&gt;</i><b>:/</b><i>&lt;path-to-git-repo&gt;</i></font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">This
syntax is only recognized if there are no slashes before the
first colon. This helps differentiate a local path that
contains a colon. For example the local path <b>foo:bar</b>
could be specified as an absolute path or <b>./foo:bar</b>
to avoid being misinterpreted as an ssh url.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
ssh and git protocols additionally support
<b>&#732;</b><i>&lt;username&gt;</i> expansion:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">&bull;
<b>ssh://</b>[<i>&lt;user&gt;</i><b>@</b>]<i>&lt;host&gt;</i>[<b>:</b><i>&lt;port&gt;</i>]<b>/&#732;</b><i>&lt;user&gt;</i><b>/</b><i>&lt;path-to-git-repo&gt;</i></font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">&bull;
<b>git://</b><i>&lt;host&gt;</i>[<b>:</b><i>&lt;port&gt;</i>]<b>/&#732;</b><i>&lt;user&gt;</i><b>/</b><i>&lt;path-to-git-repo&gt;</i></font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">&bull;
[<i>&lt;user&gt;</i><b>@</b>]<i>&lt;host&gt;</i><b>:&#732;</b><i>&lt;user&gt;</i><b>/</b><i>&lt;path-to-git-repo&gt;</i></font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">For
local repositories, also supported by Git natively, the
following syntaxes may be used:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">&bull;
<b>/path/to/repo.git/</b></font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">&bull;
<b>file:///path/to/repo.git/</b></font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">These
two syntaxes are mostly equivalent, except when cloning,
when the former implies <b>--local</b> option. See
<b>git-clone</b>(1) for details.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>git
clone</b>, <b>git fetch</b> and <b>git pull</b>, but not
<b>git push</b>, will also accept a suitable bundle file.
See <b>git-bundle</b>(1).</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">When
Git doesn&rsquo;t know how to handle a certain transport
protocol, it attempts to use the
<b>remote-</b><i>&lt;transport&gt;</i> remote helper, if one
exists. To explicitly request a remote helper, the following
syntax may be used:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">&bull;
<i>&lt;transport&gt;</i><b>::</b><i>&lt;address&gt;</i></font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">where
<i>&lt;address&gt;</i> may be a path, a server and path, or
an arbitrary URL-like string recognized by the specific
remote helper being invoked. See <b>gitremote-helpers</b>(7)
for details.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">If
there are a large number of similarly-named remote
repositories and you want to use a different format for them
(such that the URLs you use will be rewritten into URLs that
work), you can create a configuration section of the
form:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">[url
&quot;<i>&lt;actual-url-base&gt;</i>&quot;] <br>
insteadOf = <i>&lt;other-url-base&gt;</i></font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">For
example, with this:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">[url
&quot;git://git.host.xz/&quot;] <br>
insteadOf = host.xz:/path/to/ <br>
insteadOf = work:</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">a
URL like &quot;work:repo.git&quot; or like
&quot;host.xz:/path/to/repo.git&quot; will be rewritten in
any context that takes a URL to be
&quot;git://git.host.xz/repo.git&quot;.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">If
you want to rewrite URLs for push only, you can create a
configuration section of the form:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">[url
&quot;<i>&lt;actual-url-base&gt;</i>&quot;] <br>
pushInsteadOf = <i>&lt;other-url-base&gt;</i></font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">For
example, with this:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">[url
&quot;ssh://example.org/&quot;] <br>
pushInsteadOf = git://example.org/</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">a
URL like &quot;git://example.org/path/to/repo.git&quot; will
be rewritten to
&quot;ssh://example.org/path/to/repo.git&quot; for pushes,
but pulls will still use the original URL.</font></p>

<h2>REMOTES
<a name="REMOTES"></a>
</h2>



<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
name of one of the following can be used instead of a URL as
<i>&lt;repository&gt;</i> argument:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">&bull;
a remote in the Git configuration file:
<b>$GIT_DIR/config</b>,</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">&bull;
a file in the <b>$GIT_DIR/remotes</b> directory,
or</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">&bull;
a file in the <b>$GIT_DIR/branches</b> directory.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">All
of these also allow you to omit the refspec from the command
line because they each contain a refspec which git will use
by default.</font></p>

<h3>Named remote in configuration file
<a name="Named remote in configuration file"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><font color="#000000">You
can choose to provide the name of a remote which you had
previously configured using <b>git-remote</b>(1),
<b>git-config</b>(1) or even by a manual edit to the
<b>$GIT_DIR/config</b> file. The URL of this remote will be
used to access the repository. The refspec of this remote
will be used by default when you do not provide a refspec on
the command line. The entry in the config file would appear
like this:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">[remote
&quot;&lt;name&gt;&quot;] <br>
url = &lt;URL&gt; <br>
pushurl = &lt;pushurl&gt; <br>
push = &lt;refspec&gt; <br>
fetch = &lt;refspec&gt;</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
<i>&lt;pushurl&gt;</i> is used for pushes only. It is
optional and defaults to <i>&lt;URL&gt;</i>. Pushing to a
remote affects all defined pushurls or all defined urls if
no pushurls are defined. Fetch, however, will only fetch
from the first defined url if multiple urls are
defined.</font></p>

<h3>Named file in $GIT_DIR/remotes
<a name="Named file in $GIT_DIR/remotes"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><font color="#000000">You
can choose to provide the name of a file in
<b>$GIT_DIR/remotes</b>. The URL in this file will be used
to access the repository. The refspec in this file will be
used as default when you do not provide a refspec on the
command line. This file should have the following
format:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">URL:
one of the above URL formats <br>
Push: &lt;refspec&gt; <br>
Pull: &lt;refspec&gt;</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>Push:</b>
lines are used by <i>git push</i> and <b>Pull:</b> lines are
used by <i>git pull</i> and <i>git fetch</i>. Multiple
<b>Push:</b> and <b>Pull:</b> lines may be specified for
additional branch mappings.</font></p>

<h3>Named file in $GIT_DIR/branches
<a name="Named file in $GIT_DIR/branches"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><font color="#000000">You
can choose to provide the name of a file in
<b>$GIT_DIR/branches</b>. The URL in this file will be used
to access the repository. This file should have the
following format:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">&lt;URL&gt;#&lt;head&gt;</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><i>&lt;URL&gt;</i>
is required; #<i>&lt;head&gt;</i> is optional.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">Depending
on the operation, git will use one of the following
refspecs, if you don&rsquo;t provide one on the command
line. <i>&lt;branch&gt;</i> is the name of this file in
<b>$GIT_DIR/branches</b> and <i>&lt;head&gt;</i> defaults to
<b>master</b>.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">git
fetch uses:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">refs/heads/&lt;head&gt;:refs/heads/&lt;branch&gt;</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">git
push uses:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">HEAD:refs/heads/&lt;head&gt;</font></p>

<h2>MERGE STRATEGIES
<a name="MERGE STRATEGIES"></a>
</h2>



<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
merge mechanism (<b>git merge</b> and <b>git pull</b>
commands) allows the backend <i>merge strategies</i> to be
chosen with <b>-s</b> option. Some strategies can also take
their own options, which can be passed by giving
<b>-X</b><i>&lt;option&gt;</i> arguments to <b>git merge</b>
and/or <b>git pull</b>.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">ort</font></p>

<p style="margin-left:14%;"><font color="#000000">This is
the default merge strategy when pulling or merging one
branch. This strategy can only resolve two heads using a
3-way merge algorithm. When there is more than one common
ancestor that can be used for 3-way merge, it creates a
merged tree of the common ancestors and uses that as the
reference tree for the 3-way merge. This has been reported
to result in fewer merge conflicts without causing mismerges
by tests done on actual merge commits taken from Linux 2.6
kernel development history. Additionally this strategy can
detect and handle merges involving renames. It does not make
use of detected copies. The name for this algorithm is an
acronym (&quot;Ostensibly Recursive&rsquo;s Twin&quot;) and
came from the fact that it was written as a replacement for
the previous default algorithm, <b>recursive</b>.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">In
the case where the path is a submodule, if the submodule
commit used on one side of the merge is a descendant of the
submodule commit used on the other side of the merge, Git
attempts to fast-forward to the descendant. Otherwise, Git
will treat this case as a conflict, suggesting as a
resolution a submodule commit that is descendant of the
conflicting ones, if one exists.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">The
<i>ort</i> strategy can take the following
options:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">ours</font></p>

<p style="margin-left:19%;"><font color="#000000">This
option forces conflicting hunks to be auto-resolved cleanly
by favoring <i>our</i> version. Changes from the other tree
that do not conflict with our side are reflected in the
merge result. For a binary file, the entire contents are
taken from our side.</font></p>


<p style="margin-left:19%; margin-top: 1em"><font color="#000000">This
should not be confused with the <i>ours</i> merge strategy,
which does not even look at what the other tree contains at
all. It discards everything the other tree did, declaring
<i>our</i> history contains all that happened in
it.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">theirs</font></p>

<p style="margin-left:19%;"><font color="#000000">This is
the opposite of <i>ours</i>; note that, unlike <i>ours</i>,
there is no <i>theirs</i> merge strategy to confuse this
merge option with.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">ignore-space-change,
ignore-all-space, ignore-space-at-eol,
ignore-cr-at-eol</font></p>

<p style="margin-left:19%;"><font color="#000000">Treats
lines with the indicated type of whitespace change as
unchanged for the sake of a three-way merge. Whitespace
changes mixed with other changes to a line are not ignored.
See also <b>git-diff</b>(1) <b>-b</b>, <b>-w</b>,
<b>--ignore-space-at-eol</b>, and
<b>--ignore-cr-at-eol</b>.</font></p>


<p style="margin-left:24%; margin-top: 1em"><font color="#000000">&bull;
If <i>their</i> version only introduces whitespace changes
to a line, <i>our</i> version is used;</font></p>


<p style="margin-left:24%; margin-top: 1em"><font color="#000000">&bull;
If <i>our</i> version introduces whitespace changes but
<i>their</i> version includes a substantial change,
<i>their</i> version is used;</font></p>


<p style="margin-left:24%; margin-top: 1em"><font color="#000000">&bull;
Otherwise, the merge proceeds in the usual way.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">renormalize</font></p>

<p style="margin-left:19%;"><font color="#000000">This runs
a virtual check-out and check-in of all three stages of any
file which needs a three-way merge. This option is meant to
be used when merging branches with different clean filters
or end-of-line normalization rules. See &quot;Merging
branches with differing checkin/checkout attributes&quot; in
<b>gitattributes</b>(5) for details.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">no-renormalize</font></p>

<p style="margin-left:19%;"><font color="#000000">Disables
the <b>renormalize</b> option. This overrides the
<b>merge.renormalize</b> configuration variable.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">find-renames[=&lt;n&gt;]</font></p>

<p style="margin-left:19%;"><font color="#000000">Turn on
rename detection, optionally setting the similarity
threshold. This is the default. This overrides the
<i>merge.renames</i> configuration variable. See also
<b>git-diff</b>(1) <b>--find-renames</b>.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">rename-threshold=&lt;n&gt;</font></p>


<p style="margin-left:19%;"><font color="#000000">Deprecated
synonym for <b>find-renames=</b><i>&lt;n&gt;</i>.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">subtree[=&lt;path&gt;]</font></p>

<p style="margin-left:19%;"><font color="#000000">This
option is a more advanced form of <i>subtree</i> strategy,
where the strategy makes a guess on how two trees must be
shifted to match with each other when merging. Instead, the
specified path is prefixed (or stripped from the beginning)
to make the shape of two trees to match.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">recursive</font></p>

<p style="margin-left:14%;"><font color="#000000">This can
only resolve two heads using a 3-way merge algorithm. When
there is more than one common ancestor that can be used for
3-way merge, it creates a merged tree of the common
ancestors and uses that as the reference tree for the 3-way
merge. This has been reported to result in fewer merge
conflicts without causing mismerges by tests done on actual
merge commits taken from Linux 2.6 kernel development
history. Additionally this can detect and handle merges
involving renames. It does not make use of detected copies.
This was the default strategy for resolving two heads from
Git v0.99.9k until v2.33.0.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">For
a path that is a submodule, the same caution as <i>ort</i>
applies to this strategy.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">The
<i>recursive</i> strategy takes the same options as
<i>ort</i>. However, there are three additional options that
<i>ort</i> ignores (not documented above) that are
potentially useful with the <i>recursive</i>
strategy:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">patience</font></p>


<p style="margin-left:19%;"><font color="#000000">Deprecated
synonym for <b>diff-algorithm=patience</b>.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">diff-algorithm=[patience|minimal|histogram|myers]</font></p>

<p style="margin-left:19%;"><font color="#000000">Use a
different diff algorithm while merging, which can help avoid
mismerges that occur due to unimportant matching lines (such
as braces from distinct functions). See also
<b>git-diff</b>(1) <b>--diff-algorithm</b>. Note that
<b>ort</b> specifically uses
<b>diff-algorithm=histogram</b>, while <b>recursive</b>
defaults to the <b>diff.algorithm</b> config
setting.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">no-renames</font></p>

<p style="margin-left:19%;"><font color="#000000">Turn off
rename detection. This overrides the <b>merge.renames</b>
configuration variable. See also <b>git-diff</b>(1)
<b>--no-renames</b>.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">resolve</font></p>

<p style="margin-left:14%;"><font color="#000000">This can
only resolve two heads (i.e. the current branch and another
branch you pulled from) using a 3-way merge algorithm. It
tries to carefully detect criss-cross merge ambiguities. It
does not handle renames.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">octopus</font></p>

<p style="margin-left:14%;"><font color="#000000">This
resolves cases with more than two heads, but refuses to do a
complex merge that needs manual resolution. It is primarily
meant to be used for bundling topic branch heads together.
This is the default merge strategy when pulling or merging
more than one branch.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">ours</font></p>

<p style="margin-left:14%;"><font color="#000000">This
resolves any number of heads, but the resulting tree of the
merge is always that of the current branch head, effectively
ignoring all changes from all other branches. It is meant to
be used to supersede old development history of side
branches. Note that this is different from the -Xours option
to the <i>recursive</i> merge strategy.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">subtree</font></p>

<p style="margin-left:14%;"><font color="#000000">This is a
modified <b>ort</b> strategy. When merging trees A and B, if
B corresponds to a subtree of A, B is first adjusted to
match the tree structure of A, instead of reading the trees
at the same level. This adjustment is also done to the
common ancestor tree.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">With
the strategies that use 3-way merge (including the default,
<i>ort</i>), if a change is made on both branches, but later
reverted on one of the branches, that change will be present
in the merged result; some people find this behavior
confusing. It occurs because only the heads and the merge
base are considered when performing a merge, not the
individual commits. The merge algorithm therefore considers
the reverted change as no change at all, and substitutes the
changed version instead.</font></p>

<h2>DEFAULT BEHAVIOUR
<a name="DEFAULT BEHAVIOUR"></a>
</h2>



<p style="margin-left:9%; margin-top: 1em"><font color="#000000">Often
people use <b>git pull</b> without giving any parameter.
Traditionally, this has been equivalent to saying <b>git
pull origin</b>. However, when configuration
<b>branch.</b><i>&lt;name&gt;</i><b>.remote</b> is present
while on branch <i>&lt;name&gt;</i>, that value is used
instead of <b>origin</b>.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">In
order to determine what URL to use to fetch from, the value
of the configuration
<b>remote.</b><i>&lt;origin&gt;</i><b>.url</b> is consulted
and if there is not any such variable, the value on the
<b>URL:</b> line in
<b>$GIT_DIR/remotes/</b><i>&lt;origin&gt;</i> is
used.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">In
order to determine what remote branches to fetch (and
optionally store in the remote-tracking branches) when the
command is run without any refspec parameters on the command
line, values of the configuration variable
<b>remote.</b><i>&lt;origin&gt;</i><b>.fetch</b> are
consulted, and if there aren&rsquo;t any,
<b>$GIT_DIR/remotes/</b><i>&lt;origin&gt;</i> is consulted
and its <b>Pull:</b> lines are used. In addition to the
refspec formats described in the OPTIONS section, you can
have a globbing refspec that looks like this:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">refs/heads/*:refs/remotes/origin/*</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">A
globbing refspec must have a non-empty RHS (i.e. must store
what were fetched in remote-tracking branches), and its LHS
and RHS must end with <b>/</b>*. The above specifies that
all remote branches are tracked using remote-tracking
branches in <b>refs/remotes/origin/</b> hierarchy under the
same name.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
rule to determine which remote branch to merge after
fetching is a bit involved, in order not to break backward
compatibility.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">If
explicit refspecs were given on the command line of <b>git
pull</b>, they are all merged.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">When
no refspec was given on the command line, then <b>git
pull</b> uses the refspec from the configuration or
<b>$GIT_DIR/remotes/</b><i>&lt;origin&gt;</i>. In such
cases, the following rules apply:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">1.
If <b>branch.</b><i>&lt;name&gt;</i><b>.merge</b>
configuration for the current branch <i>&lt;name&gt;</i>
exists, that is the name of the branch at the remote site
that is merged.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">2.
If the refspec is a globbing one, nothing is
merged.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">3.
Otherwise the remote branch of the first refspec is
merged.</font></p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>



<p style="margin-left:14%; margin-top: 1em"><font color="#000000">&bull;
Update the remote-tracking branches for the repository you
cloned from, then merge one of them into your current
branch:</font></p>


<p style="margin-left:19%; margin-top: 1em"><font color="#000000">$
git pull <br>
$ git pull origin</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Normally
the branch merged in is the HEAD of the remote repository,
but the choice is determined by the
branch.&lt;name&gt;.remote and branch.&lt;name&gt;.merge
options; see <b>git-config</b>(1) for details.</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">&bull;
Merge into the current branch the remote branch
<b>next</b>:</font></p>


<p style="margin-left:19%; margin-top: 1em"><font color="#000000">$
git pull origin next</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">This
leaves a copy of <b>next</b> temporarily in FETCH_HEAD, and
updates the remote-tracking branch <b>origin/next</b>. The
same can be done by invoking fetch and merge:</font></p>


<p style="margin-left:19%; margin-top: 1em"><font color="#000000">$
git fetch origin <br>
$ git merge origin/next</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">If
you tried a pull which resulted in complex conflicts and
would want to start over, you can recover with <i>git
reset</i>.</font></p>

<h2>SECURITY
<a name="SECURITY"></a>
</h2>



<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
fetch and push protocols are not designed to prevent one
side from stealing data from the other repository that was
not intended to be shared. If you have private data that you
need to protect from a malicious peer, your best option is
to store it in another repository. This applies to both
clients and servers. In particular, namespaces on a server
are not effective for read access control; you should only
grant read access to a namespace to clients that you would
trust with read access to the entire repository.</font></p>


<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
known attack vectors are as follows:</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">1.
The victim sends &quot;have&quot; lines advertising the IDs
of objects it has that are not explicitly intended to be
shared but can be used to optimize the transfer if the peer
also has them. The attacker chooses an object ID X to steal
and sends a ref to X, but isn&rsquo;t required to send the
content of X because the victim already has it. Now the
victim believes that the attacker has X, and it sends the
content of X back to the attacker later. (This attack is
most straightforward for a client to perform on a server, by
creating a ref to X in the namespace the client has access
to and then fetching it. The most likely way for a server to
perform it on a client is to &quot;merge&quot; X into a
public branch and hope that the user does additional work on
this branch and pushes it back to the server without
noticing the merge.)</font></p>


<p style="margin-left:14%; margin-top: 1em"><font color="#000000">2.
As in #1, the attacker chooses an object ID X to steal. The
victim sends an object Y that the attacker already has, and
the attacker falsely claims to have X and not Y, so the
victim sends Y as a delta against X. The delta reveals
regions of X that are similar to Y to the
attacker.</font></p>

<h2>BUGS
<a name="BUGS"></a>
</h2>



<p style="margin-left:9%; margin-top: 1em"><font color="#000000">Using
--recurse-submodules can only fetch new commits in already
checked out submodules right now. When e.g. upstream added a
new submodule in the just fetched commits of the
superproject the submodule itself cannot be fetched, making
it impossible to check out that submodule later without
having to do a fetch again. This is expected to be fixed in
a future Git version.</font></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>git-fetch</b>(1),
<b>git-merge</b>(1), <b>git-config</b>(1)</font></p>

<h2>GIT
<a name="GIT"></a>
</h2>



<p style="margin-left:9%; margin-top: 1em"><font color="#000000">Part
of the <b>git</b>(1) suite</font></p>
<hr>
</body>
</html>
