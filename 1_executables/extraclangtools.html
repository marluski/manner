<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Mon Apr  7 17:23:31 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>EXTRACLANGTOOLS</title>

</head>
<body>

<h1 align="center">EXTRACLANGTOOLS</h1>

<a href="#NAME">NAME</a><br>
<a href="#EXTRA CLANG TOOLS 19.1.7 RELEASE NOTES">EXTRA CLANG TOOLS 19.1.7 RELEASE NOTES</a><br>
<a href="#Introduction">Introduction</a><br>
<a href="#What's New in Extra Clang Tools 19.1.7?">What's New in Extra Clang Tools 19.1.7?</a><br>
<a href="#Major New Features">Major New Features</a><br>
<a href="#Improvements to clangd">Improvements to clangd</a><br>
<a href="#Inlay hints">Inlay hints</a><br>
<a href="#Diagnostics">Diagnostics</a><br>
<a href="#Semantic Highlighting">Semantic Highlighting</a><br>
<a href="#Compile flags">Compile flags</a><br>
<a href="#Hover">Hover</a><br>
<a href="#Code completion">Code completion</a><br>
<a href="#Code actions">Code actions</a><br>
<a href="#Signature help">Signature help</a><br>
<a href="#Cross-references">Cross-references</a><br>
<a href="#Document outline">Document outline</a><br>
<a href="#Clang-tidy integration">Clang-tidy integration</a><br>
<a href="#Objective-C">Objective-C</a><br>
<a href="#Miscellaneous">Miscellaneous</a><br>
<a href="#Improvements to clang-doc">Improvements to clang-doc</a><br>
<a href="#Improvements to clang-query">Improvements to clang-query</a><br>
<a href="#Improvements to clang-rename">Improvements to clang-rename</a><br>
<a href="#Improvements to clang-tidy">Improvements to clang-tidy</a><br>
<a href="#New checks">New checks</a><br>
<a href="#New check aliases">New check aliases</a><br>
<a href="#Changes in existing checks">Changes in existing checks</a><br>
<a href="#Removed checks">Removed checks</a><br>
<a href="#Miscellaneous">Miscellaneous</a><br>
<a href="#Improvements to include-fixer">Improvements to include-fixer</a><br>
<a href="#Improvements to clang-include-fixer">Improvements to clang-include-fixer</a><br>
<a href="#Improvements to modularize">Improvements to modularize</a><br>
<a href="#Improvements to pp-trace">Improvements to pp-trace</a><br>
<a href="#Clang-tidy Visual Studio plugin">Clang-tidy Visual Studio plugin</a><br>
<a href="#CLANG-TIDY">CLANG-TIDY</a><br>
<a href="#Contents">Contents</a><br>
<a href="#Clang-Tidy Checks">Clang-Tidy Checks</a><br>
<a href="#abseil-cleanup-ctad">abseil-cleanup-ctad</a><br>
<a href="#abseil-duration-addition">abseil-duration-addition</a><br>
<a href="#abseil-duration-comparison">abseil-duration-comparison</a><br>
<a href="#abseil-duration-conversion-cast">abseil-duration-conversion-cast</a><br>
<a href="#abseil-duration-division">abseil-duration-division</a><br>
<a href="#abseil-duration-factory-float">abseil-duration-factory-float</a><br>
<a href="#abseil-duration-factory-scale">abseil-duration-factory-scale</a><br>
<a href="#abseil-duration-subtraction">abseil-duration-subtraction</a><br>
<a href="#abseil-duration-unnecessary-conversion">abseil-duration-unnecessary-conversion</a><br>
<a href="#abseil-faster-strsplit-delimiter">abseil-faster-strsplit-delimiter</a><br>
<a href="#abseil-no-internal-dependencies">abseil-no-internal-dependencies</a><br>
<a href="#abseil-no-namespace">abseil-no-namespace</a><br>
<a href="#abseil-redundant-strcat-calls">abseil-redundant-strcat-calls</a><br>
<a href="#abseil-str-cat-append">abseil-str-cat-append</a><br>
<a href="#abseil-string-find-startswith">abseil-string-find-startswith</a><br>
<a href="#Options">Options</a><br>
<a href="#abseil-string-find-str-contains">abseil-string-find-str-contains</a><br>
<a href="#Options">Options</a><br>
<a href="#abseil-time-comparison">abseil-time-comparison</a><br>
<a href="#abseil-time-subtraction">abseil-time-subtraction</a><br>
<a href="#abseil-upgrade-duration-conversions">abseil-upgrade-duration-conversions</a><br>
<a href="#altera-id-dependent-backward-branch">altera-id-dependent-backward-branch</a><br>
<a href="#altera-kernel-name-restriction">altera-kernel-name-restriction</a><br>
<a href="#altera-single-work-item-barrier">altera-single-work-item-barrier</a><br>
<a href="#Options">Options</a><br>
<a href="#altera-struct-pack-align">altera-struct-pack-align</a><br>
<a href="#altera-unroll-loops">altera-unroll-loops</a><br>
<a href="#Options">Options</a><br>
<a href="#android-cloexec-accept">android-cloexec-accept</a><br>
<a href="#android-cloexec-accept4">android-cloexec-accept4</a><br>
<a href="#android-cloexec-creat">android-cloexec-creat</a><br>
<a href="#android-cloexec-dup">android-cloexec-dup</a><br>
<a href="#android-cloexec-epoll-create">android-cloexec-epoll-create</a><br>
<a href="#android-cloexec-epoll-create1">android-cloexec-epoll-create1</a><br>
<a href="#android-cloexec-fopen">android-cloexec-fopen</a><br>
<a href="#android-cloexec-inotify-init">android-cloexec-inotify-init</a><br>
<a href="#android-cloexec-inotify-init1">android-cloexec-inotify-init1</a><br>
<a href="#android-cloexec-memfd-create">android-cloexec-memfd-create</a><br>
<a href="#android-cloexec-open">android-cloexec-open</a><br>
<a href="#android-cloexec-pipe">android-cloexec-pipe</a><br>
<a href="#android-cloexec-pipe2">android-cloexec-pipe2</a><br>
<a href="#android-cloexec-socket">android-cloexec-socket</a><br>
<a href="#android-comparison-in-temp-failure-retry">android-comparison-in-temp-failure-retry</a><br>
<a href="#Options">Options</a><br>
<a href="#boost-use-ranges">boost-use-ranges</a><br>
<a href="#Example">Example</a><br>
<a href="#Supported algorithms">Supported algorithms</a><br>
<a href="#Reverse Iteration">Reverse Iteration</a><br>
<a href="#Options">Options</a><br>
<a href="#boost-use-to-string">boost-use-to-string</a><br>
<a href="#bugprone-argument-comment">bugprone-argument-comment</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-assert-side-effect">bugprone-assert-side-effect</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-assignment-in-if-condition">bugprone-assignment-in-if-condition</a><br>
<a href="#bugprone-bad-signal-to-kill-thread">bugprone-bad-signal-to-kill-thread</a><br>
<a href="#bugprone-bool-pointer-implicit-conversion">bugprone-bool-pointer-implicit-conversion</a><br>
<a href="#bugprone-branch-clone">bugprone-branch-clone</a><br>
<a href="#bugprone-casting-through-void">bugprone-casting-through-void</a><br>
<a href="#bugprone-chained-comparison">bugprone-chained-comparison</a><br>
<a href="#bugprone-compare-pointer-to-member-virtual-function">bugprone-compare-pointer-to-member-virtual-function</a><br>
<a href="#Limitations">Limitations</a><br>
<a href="#bugprone-copy-constructor-init">bugprone-copy-constructor-init</a><br>
<a href="#bugprone-crtp-constructor-accessibility">bugprone-crtp-constructor-accessibility</a><br>
<a href="#bugprone-dangling-handle">bugprone-dangling-handle</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-dynamic-static-initializers">bugprone-dynamic-static-initializers</a><br>
<a href="#bugprone-easily-swappable-parameters">bugprone-easily-swappable-parameters</a><br>
<a href="#Options">Options</a><br>
<a href="#Extension/relaxation options">Extension/relaxation options</a><br>
<a href="#Filtering options">Filtering options</a><br>
<a href="#Limitations">Limitations</a><br>
<a href="#bugprone-empty-catch">bugprone-empty-catch</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-exception-escape">bugprone-exception-escape</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-fold-init-type">bugprone-fold-init-type</a><br>
<a href="#bugprone-forward-declaration-namespace">bugprone-forward-declaration-namespace</a><br>
<a href="#bugprone-forwarding-reference-overload">bugprone-forwarding-reference-overload</a><br>
<a href="#Background">Background</a><br>
<a href="#bugprone-implicit-widening-of-multiplication-result">bugprone-implicit-widening-of-multiplication-result</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-inaccurate-erase">bugprone-inaccurate-erase</a><br>
<a href="#bugprone-inc-dec-in-conditions">bugprone-inc-dec-in-conditions</a><br>
<a href="#bugprone-incorrect-enable-if">bugprone-incorrect-enable-if</a><br>
<a href="#bugprone-incorrect-roundings">bugprone-incorrect-roundings</a><br>
<a href="#bugprone-infinite-loop">bugprone-infinite-loop</a><br>
<a href="#bugprone-integer-division">bugprone-integer-division</a><br>
<a href="#bugprone-lambda-function-name">bugprone-lambda-function-name</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-macro-parentheses">bugprone-macro-parentheses</a><br>
<a href="#bugprone-macro-repeated-side-effects">bugprone-macro-repeated-side-effects</a><br>
<a href="#bugprone-misplaced-operator-in-strlen-in-alloc">bugprone-misplaced-operator-in-strlen-in-alloc</a><br>
<a href="#bugprone-misplaced-pointer-arithmetic-in-alloc">bugprone-misplaced-pointer-arithmetic-in-alloc</a><br>
<a href="#bugprone-misplaced-widening-cast">bugprone-misplaced-widening-cast</a><br>
<a href="#Implicit casts">Implicit casts</a><br>
<a href="#Floating point">Floating point</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-move-forwarding-reference">bugprone-move-forwarding-reference</a><br>
<a href="#Background">Background</a><br>
<a href="#bugprone-multi-level-implicit-pointer-conversion">bugprone-multi-level-implicit-pointer-conversion</a><br>
<a href="#bugprone-multiple-new-in-one-expression">bugprone-multiple-new-in-one-expression</a><br>
<a href="#bugprone-multiple-statement-macro">bugprone-multiple-statement-macro</a><br>
<a href="#bugprone-narrowing-conversions">bugprone-narrowing-conversions</a><br>
<a href="#bugprone-no-escape">bugprone-no-escape</a><br>
<a href="#bugprone-non-zero-enum-to-bool-conversion">bugprone-non-zero-enum-to-bool-conversion</a><br>
<a href="#Example">Example</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-not-null-terminated-result">bugprone-not-null-terminated-result</a><br>
<a href="#Transformation rules of 'memcpy()'">Transformation rules of 'memcpy()'</a><br>
<a href="#Rewrite based on the destination array">Rewrite based on the destination array</a><br>
<a href="#Rewrite based on the length of the source string">Rewrite based on the length of the source string</a><br>
<a href="#Transformations with 'strlen()' or equal length of this expression">Transformations with 'strlen()' or equal length of this expression</a><br>
<a href="#Memory handler functions">Memory handler functions</a><br>
<a href="#String handler functions">String handler functions</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-optional-value-conversion">bugprone-optional-value-conversion</a><br>
<a href="#Options:">Options:</a><br>
<a href="#bugprone-parent-virtual-call">bugprone-parent-virtual-call</a><br>
<a href="#bugprone-pointer-arithmetic-on-polymorphic-object">bugprone-pointer-arithmetic-on-polymorphic-object</a><br>
<a href="#Options">Options</a><br>
<a href="#References">References</a><br>
<a href="#bugprone-posix-return">bugprone-posix-return</a><br>
<a href="#bugprone-redundant-branch-condition">bugprone-redundant-branch-condition</a><br>
<a href="#Known limitations">Known limitations</a><br>
<a href="#bugprone-reserved-identifier">bugprone-reserved-identifier</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-return-const-ref-from-parameter">bugprone-return-const-ref-from-parameter</a><br>
<a href="#Example">Example</a><br>
<a href="#bugprone-shared-ptr-array-mismatch">bugprone-shared-ptr-array-mismatch</a><br>
<a href="#bugprone-signal-handler">bugprone-signal-handler</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-signed-char-misuse">bugprone-signed-char-misuse</a><br>
<a href="#bugprone-sizeof-container">bugprone-sizeof-container</a><br>
<a href="#bugprone-sizeof-expression">bugprone-sizeof-expression</a><br>
<a href="#Suspicious usage of 'sizeof(K)'">Suspicious usage of 'sizeof(K)'</a><br>
<a href="#Suspicious usage of 'sizeof(expr)'">Suspicious usage of 'sizeof(expr)'</a><br>
<a href="#Suspicious usage of 'sizeof(this)'">Suspicious usage of 'sizeof(this)'</a><br>
<a href="#Suspicious usage of 'sizeof(char*)'">Suspicious usage of 'sizeof(char*)'</a><br>
<a href="#Suspicious usage of 'sizeof(A*)'">Suspicious usage of 'sizeof(A*)'</a><br>
<a href="#Suspicious usage of 'sizeof(...)/sizeof(...)'">Suspicious usage of 'sizeof(...)/sizeof(...)'</a><br>
<a href="#Suspicious 'sizeof' by 'sizeof' expression">Suspicious 'sizeof' by 'sizeof' expression</a><br>
<a href="#Suspicious usage of 'sizeof(sizeof(...))'">Suspicious usage of 'sizeof(sizeof(...))'</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-spuriously-wake-up-functions">bugprone-spuriously-wake-up-functions</a><br>
<a href="#bugprone-standalone-empty">bugprone-standalone-empty</a><br>
<a href="#bugprone-string-constructor">bugprone-string-constructor</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-string-integer-assignment">bugprone-string-integer-assignment</a><br>
<a href="#bugprone-string-literal-with-embedded-nul">bugprone-string-literal-with-embedded-nul</a><br>
<a href="#Invalid escaping">Invalid escaping</a><br>
<a href="#Truncated literal">Truncated literal</a><br>
<a href="#bugprone-stringview-nullptr">bugprone-stringview-nullptr</a><br>
<a href="#bugprone-suspicious-enum-usage">bugprone-suspicious-enum-usage</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-suspicious-include">bugprone-suspicious-include</a><br>
<a href="#bugprone-suspicious-memory-comparison">bugprone-suspicious-memory-comparison</a><br>
<a href="#bugprone-suspicious-memset-usage">bugprone-suspicious-memset-usage</a><br>
<a href="#bugprone-suspicious-missing-comma">bugprone-suspicious-missing-comma</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-suspicious-realloc-usage">bugprone-suspicious-realloc-usage</a><br>
<a href="#bugprone-suspicious-semicolon">bugprone-suspicious-semicolon</a><br>
<a href="#bugprone-suspicious-string-compare">bugprone-suspicious-string-compare</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-suspicious-stringview-data-usage">bugprone-suspicious-stringview-data-usage</a><br>
<a href="#bugprone-swapped-arguments">bugprone-swapped-arguments</a><br>
<a href="#bugprone-switch-missing-default-case">bugprone-switch-missing-default-case</a><br>
<a href="#bugprone-terminating-continue">bugprone-terminating-continue</a><br>
<a href="#bugprone-throw-keyword-missing">bugprone-throw-keyword-missing</a><br>
<a href="#bugprone-too-small-loop-variable">bugprone-too-small-loop-variable</a><br>
<a href="#bugprone-unchecked-optional-access">bugprone-unchecked-optional-access</a><br>
<a href="#Unsafe access patterns">Unsafe access patterns</a><br>
<a href="#Access the value without checking if it exists">Access the value without checking if it exists</a><br>
<a href="#Access the value in the wrong branch">Access the value in the wrong branch</a><br>
<a href="#Assume a function result to be stable">Assume a function result to be stable</a><br>
<a href="#Rely on invariants of uncommon APIs">Rely on invariants of uncommon APIs</a><br>
<a href="#Check if a value exists, then pass the optional to another function">Check if a value exists, then pass the optional to another function</a><br>
<a href="#Safe access patterns">Safe access patterns</a><br>
<a href="#Check if a value exists, then access the value">Check if a value exists, then access the value</a><br>
<a href="#Check if a value exists, then access the value from a copy">Check if a value exists, then access the value from a copy</a><br>
<a href="#Ensure that a value exists using common macros">Ensure that a value exists using common macros</a><br>
<a href="#Ensure that a value exists, then access the value in a correlated branch">Ensure that a value exists, then access the value in a correlated branch</a><br>
<a href="#Stabilize function results">Stabilize function results</a><br>
<a href="#Do not rely on uncommon-API invariants">Do not rely on uncommon-API invariants</a><br>
<a href="#Do not rely on caller-performed checks">Do not rely on caller-performed checks</a><br>
<a href="#Additional notes">Additional notes</a><br>
<a href="#Aliases created via using declarations">Aliases created via using declarations</a><br>
<a href="#Lambdas">Lambdas</a><br>
<a href="#Access with operator*() vs. value()">Access with operator*() vs. value()</a><br>
<a href="#bugprone-undefined-memory-manipulation">bugprone-undefined-memory-manipulation</a><br>
<a href="#bugprone-undelegated-constructor">bugprone-undelegated-constructor</a><br>
<a href="#bugprone-unhandled-exception-at-new">bugprone-unhandled-exception-at-new</a><br>
<a href="#bugprone-unhandled-self-assignment">bugprone-unhandled-self-assignment</a><br>
<a href="#bugprone-unique-ptr-array-mismatch">bugprone-unique-ptr-array-mismatch</a><br>
<a href="#bugprone-unsafe-functions">bugprone-unsafe-functions</a><br>
<a href="#Unsafe functions">Unsafe functions</a><br>
<a href="#Options">Options</a><br>
<a href="#Examples">Examples</a><br>
<a href="#bugprone-unused-local-non-trivial-variable">bugprone-unused-local-non-trivial-variable</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-unused-raii">bugprone-unused-raii</a><br>
<a href="#bugprone-unused-return-value">bugprone-unused-return-value</a><br>
<a href="#Options">Options</a><br>
<a href="#bugprone-use-after-move">bugprone-use-after-move</a><br>
<a href="#Silencing erroneous warnings">Silencing erroneous warnings</a><br>
<a href="#Unsequenced moves, uses, and reinitializations">Unsequenced moves, uses, and reinitializations</a><br>
<a href="#Move">Move</a><br>
<a href="#Use">Use</a><br>
<a href="#Reinitialization">Reinitialization</a><br>
<a href="#bugprone-virtual-near-miss">bugprone-virtual-near-miss</a><br>
<a href="#cert-con36-c">cert-con36-c</a><br>
<a href="#cert-con54-cpp">cert-con54-cpp</a><br>
<a href="#cert-ctr56-cpp">cert-ctr56-cpp</a><br>
<a href="#cert-dcl03-c">cert-dcl03-c</a><br>
<a href="#cert-dcl16-c">cert-dcl16-c</a><br>
<a href="#cert-dcl37-c">cert-dcl37-c</a><br>
<a href="#cert-dcl50-cpp">cert-dcl50-cpp</a><br>
<a href="#cert-dcl51-cpp">cert-dcl51-cpp</a><br>
<a href="#cert-dcl54-cpp">cert-dcl54-cpp</a><br>
<a href="#cert-dcl58-cpp">cert-dcl58-cpp</a><br>
<a href="#cert-dcl59-cpp">cert-dcl59-cpp</a><br>
<a href="#cert-env33-c">cert-env33-c</a><br>
<a href="#cert-err09-cpp">cert-err09-cpp</a><br>
<a href="#cert-err33-c">cert-err33-c</a><br>
<a href="#cert-err34-c">cert-err34-c</a><br>
<a href="#cert-err52-cpp">cert-err52-cpp</a><br>
<a href="#cert-err58-cpp">cert-err58-cpp</a><br>
<a href="#cert-err60-cpp">cert-err60-cpp</a><br>
<a href="#cert-err61-cpp">cert-err61-cpp</a><br>
<a href="#cert-exp42-c">cert-exp42-c</a><br>
<a href="#cert-fio38-c">cert-fio38-c</a><br>
<a href="#cert-flp30-c">cert-flp30-c</a><br>
<a href="#cert-flp37-c">cert-flp37-c</a><br>
<a href="#cert-int09-c">cert-int09-c</a><br>
<a href="#cert-mem57-cpp">cert-mem57-cpp</a><br>
<a href="#cert-msc24-c">cert-msc24-c</a><br>
<a href="#cert-msc30-c">cert-msc30-c</a><br>
<a href="#cert-msc32-c">cert-msc32-c</a><br>
<a href="#cert-msc33-c">cert-msc33-c</a><br>
<a href="#cert-msc50-cpp">cert-msc50-cpp</a><br>
<a href="#cert-msc51-cpp">cert-msc51-cpp</a><br>
<a href="#Options">Options</a><br>
<a href="#cert-msc54-cpp">cert-msc54-cpp</a><br>
<a href="#cert-oop11-cpp">cert-oop11-cpp</a><br>
<a href="#cert-oop54-cpp">cert-oop54-cpp</a><br>
<a href="#cert-oop57-cpp">cert-oop57-cpp</a><br>
<a href="#Options">Options</a><br>
<a href="#cert-oop58-cpp">cert-oop58-cpp</a><br>
<a href="#cert-pos44-c">cert-pos44-c</a><br>
<a href="#cert-pos47-c">cert-pos47-c</a><br>
<a href="#cert-sig30-c">cert-sig30-c</a><br>
<a href="#cert-str34-c">cert-str34-c</a><br>
<a href="#clang-analyzer-core.BitwiseShift">clang-analyzer-core.BitwiseShift</a><br>
<a href="#clang-analyzer-core.CallAndMessage">clang-analyzer-core.CallAndMessage</a><br>
<a href="#clang-analyzer-core.DivideZero">clang-analyzer-core.DivideZero</a><br>
<a href="#clang-analyzer-core.NonNullParamChecker">clang-analyzer-core.NonNullParamChecker</a><br>
<a href="#clang-analyzer-core.NullDereference">clang-analyzer-core.NullDereference</a><br>
<a href="#clang-analyzer-core.StackAddressEscape">clang-analyzer-core.StackAddressEscape</a><br>
<a href="#clang-analyzer-core.UndefinedBinaryOperatorResult">clang-analyzer-core.UndefinedBinaryOperatorResult</a><br>
<a href="#clang-analyzer-core.VLASize">clang-analyzer-core.VLASize</a><br>
<a href="#clang-analyzer-core.uninitialized.ArraySubscript">clang-analyzer-core.uninitialized.ArraySubscript</a><br>
<a href="#clang-analyzer-core.uninitialized.Assign">clang-analyzer-core.uninitialized.Assign</a><br>
<a href="#clang-analyzer-core.uninitialized.Branch">clang-analyzer-core.uninitialized.Branch</a><br>
<a href="#clang-analyzer-core.uninitialized.CapturedBlockVariable">clang-analyzer-core.uninitialized.CapturedBlockVariable</a><br>
<a href="#clang-analyzer-core.uninitialized.NewArraySize">clang-analyzer-core.uninitialized.NewArraySize</a><br>
<a href="#clang-analyzer-core.uninitialized.UndefReturn">clang-analyzer-core.uninitialized.UndefReturn</a><br>
<a href="#clang-analyzer-cplusplus.ArrayDelete">clang-analyzer-cplusplus.ArrayDelete</a><br>
<a href="#clang-analyzer-cplusplus.InnerPointer">clang-analyzer-cplusplus.InnerPointer</a><br>
<a href="#clang-analyzer-cplusplus.Move">clang-analyzer-cplusplus.Move</a><br>
<a href="#clang-analyzer-cplusplus.NewDelete">clang-analyzer-cplusplus.NewDelete</a><br>
<a href="#clang-analyzer-cplusplus.NewDeleteLeaks">clang-analyzer-cplusplus.NewDeleteLeaks</a><br>
<a href="#clang-analyzer-cplusplus.PlacementNew">clang-analyzer-cplusplus.PlacementNew</a><br>
<a href="#clang-analyzer-cplusplus.PureVirtualCall">clang-analyzer-cplusplus.PureVirtualCall</a><br>
<a href="#clang-analyzer-cplusplus.StringChecker">clang-analyzer-cplusplus.StringChecker</a><br>
<a href="#clang-analyzer-deadcode.DeadStores">clang-analyzer-deadcode.DeadStores</a><br>
<a href="#clang-analyzer-fuchsia.HandleChecker">clang-analyzer-fuchsia.HandleChecker</a><br>
<a href="#clang-analyzer-nullability.NullPassedToNonnull">clang-analyzer-nullability.NullPassedToNonnull</a><br>
<a href="#clang-analyzer-nullability.NullReturnedFromNonnull">clang-analyzer-nullability.NullReturnedFromNonnull</a><br>
<a href="#clang-analyzer-nullability.NullableDereferenced">clang-analyzer-nullability.NullableDereferenced</a><br>
<a href="#clang-analyzer-nullability.NullablePassedToNonnull">clang-analyzer-nullability.NullablePassedToNonnull</a><br>
<a href="#clang-analyzer-nullability.NullableReturnedFromNonnull">clang-analyzer-nullability.NullableReturnedFromNonnull</a><br>
<a href="#clang-analyzer-optin.core.EnumCastOutOfRange">clang-analyzer-optin.core.EnumCastOutOfRange</a><br>
<a href="#clang-analyzer-optin.cplusplus.UninitializedObject">clang-analyzer-optin.cplusplus.UninitializedObject</a><br>
<a href="#clang-analyzer-optin.cplusplus.VirtualCall">clang-analyzer-optin.cplusplus.VirtualCall</a><br>
<a href="#clang-analyzer-optin.mpi.MPI-Checker">clang-analyzer-optin.mpi.MPI-Checker</a><br>
<a href="#clang-analyzer-optin.osx.OSObjectCStyleCast">clang-analyzer-optin.osx.OSObjectCStyleCast</a><br>
<a href="#clang-analyzer-optin.osx.cocoa.localizability.EmptyLocalizationContextChecker">clang-analyzer-optin.osx.cocoa.localizability.EmptyLocalizationContextChecker</a><br>
<a href="#clang-analyzer-optin.osx.cocoa.localizability.NonLocalizedStringChecker">clang-analyzer-optin.osx.cocoa.localizability.NonLocalizedStringChecker</a><br>
<a href="#clang-analyzer-optin.performance.GCDAntipattern">clang-analyzer-optin.performance.GCDAntipattern</a><br>
<a href="#clang-analyzer-optin.performance.Padding">clang-analyzer-optin.performance.Padding</a><br>
<a href="#clang-analyzer-optin.portability.UnixAPI">clang-analyzer-optin.portability.UnixAPI</a><br>
<a href="#clang-analyzer-optin.taint.TaintedAlloc">clang-analyzer-optin.taint.TaintedAlloc</a><br>
<a href="#clang-analyzer-osx.API">clang-analyzer-osx.API</a><br>
<a href="#clang-analyzer-osx.MIG">clang-analyzer-osx.MIG</a><br>
<a href="#clang-analyzer-osx.NumberObjectConversion">clang-analyzer-osx.NumberObjectConversion</a><br>
<a href="#clang-analyzer-osx.OSObjectRetainCount">clang-analyzer-osx.OSObjectRetainCount</a><br>
<a href="#clang-analyzer-osx.ObjCProperty">clang-analyzer-osx.ObjCProperty</a><br>
<a href="#clang-analyzer-osx.SecKeychainAPI">clang-analyzer-osx.SecKeychainAPI</a><br>
<a href="#clang-analyzer-osx.cocoa.AtSync">clang-analyzer-osx.cocoa.AtSync</a><br>
<a href="#clang-analyzer-osx.cocoa.AutoreleaseWrite">clang-analyzer-osx.cocoa.AutoreleaseWrite</a><br>
<a href="#clang-analyzer-osx.cocoa.ClassRelease">clang-analyzer-osx.cocoa.ClassRelease</a><br>
<a href="#clang-analyzer-osx.cocoa.Dealloc">clang-analyzer-osx.cocoa.Dealloc</a><br>
<a href="#clang-analyzer-osx.cocoa.IncompatibleMethodTypes">clang-analyzer-osx.cocoa.IncompatibleMethodTypes</a><br>
<a href="#clang-analyzer-osx.cocoa.Loops">clang-analyzer-osx.cocoa.Loops</a><br>
<a href="#clang-analyzer-osx.cocoa.MissingSuperCall">clang-analyzer-osx.cocoa.MissingSuperCall</a><br>
<a href="#clang-analyzer-osx.cocoa.NSAutoreleasePool">clang-analyzer-osx.cocoa.NSAutoreleasePool</a><br>
<a href="#clang-analyzer-osx.cocoa.NSError">clang-analyzer-osx.cocoa.NSError</a><br>
<a href="#clang-analyzer-osx.cocoa.NilArg">clang-analyzer-osx.cocoa.NilArg</a><br>
<a href="#clang-analyzer-osx.cocoa.NonNilReturnValue">clang-analyzer-osx.cocoa.NonNilReturnValue</a><br>
<a href="#clang-analyzer-osx.cocoa.ObjCGenerics">clang-analyzer-osx.cocoa.ObjCGenerics</a><br>
<a href="#clang-analyzer-osx.cocoa.RetainCount">clang-analyzer-osx.cocoa.RetainCount</a><br>
<a href="#clang-analyzer-osx.cocoa.RunLoopAutoreleaseLeak">clang-analyzer-osx.cocoa.RunLoopAutoreleaseLeak</a><br>
<a href="#clang-analyzer-osx.cocoa.SelfInit">clang-analyzer-osx.cocoa.SelfInit</a><br>
<a href="#clang-analyzer-osx.cocoa.SuperDealloc">clang-analyzer-osx.cocoa.SuperDealloc</a><br>
<a href="#clang-analyzer-osx.cocoa.UnusedIvars">clang-analyzer-osx.cocoa.UnusedIvars</a><br>
<a href="#clang-analyzer-osx.cocoa.VariadicMethodTypes">clang-analyzer-osx.cocoa.VariadicMethodTypes</a><br>
<a href="#clang-analyzer-osx.coreFoundation.CFError">clang-analyzer-osx.coreFoundation.CFError</a><br>
<a href="#clang-analyzer-osx.coreFoundation.CFNumber">clang-analyzer-osx.coreFoundation.CFNumber</a><br>
<a href="#clang-analyzer-osx.coreFoundation.CFRetainRelease">clang-analyzer-osx.coreFoundation.CFRetainRelease</a><br>
<a href="#clang-analyzer-osx.coreFoundation.containers.OutOfBounds">clang-analyzer-osx.coreFoundation.containers.OutOfBounds</a><br>
<a href="#clang-analyzer-osx.coreFoundation.containers.PointerSizedValues">clang-analyzer-osx.coreFoundation.containers.PointerSizedValues</a><br>
<a href="#clang-analyzer-security.FloatLoopCounter">clang-analyzer-security.FloatLoopCounter</a><br>
<a href="#clang-analyzer-security.PutenvStackArray">clang-analyzer-security.PutenvStackArray</a><br>
<a href="#clang-analyzer-security.SetgidSetuidOrder">clang-analyzer-security.SetgidSetuidOrder</a><br>
<a href="#clang-analyzer-security.cert.env.InvalidPtr">clang-analyzer-security.cert.env.InvalidPtr</a><br>
<a href="#clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling">clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling</a><br>
<a href="#clang-analyzer-security.insecureAPI.UncheckedReturn">clang-analyzer-security.insecureAPI.UncheckedReturn</a><br>
<a href="#clang-analyzer-security.insecureAPI.bcmp">clang-analyzer-security.insecureAPI.bcmp</a><br>
<a href="#clang-analyzer-security.insecureAPI.bcopy">clang-analyzer-security.insecureAPI.bcopy</a><br>
<a href="#clang-analyzer-security.insecureAPI.bzero">clang-analyzer-security.insecureAPI.bzero</a><br>
<a href="#clang-analyzer-security.insecureAPI.decodeValueOfObjCType">clang-analyzer-security.insecureAPI.decodeValueOfObjCType</a><br>
<a href="#clang-analyzer-security.insecureAPI.getpw">clang-analyzer-security.insecureAPI.getpw</a><br>
<a href="#clang-analyzer-security.insecureAPI.gets">clang-analyzer-security.insecureAPI.gets</a><br>
<a href="#clang-analyzer-security.insecureAPI.mkstemp">clang-analyzer-security.insecureAPI.mkstemp</a><br>
<a href="#clang-analyzer-security.insecureAPI.mktemp">clang-analyzer-security.insecureAPI.mktemp</a><br>
<a href="#clang-analyzer-security.insecureAPI.rand">clang-analyzer-security.insecureAPI.rand</a><br>
<a href="#clang-analyzer-security.insecureAPI.strcpy">clang-analyzer-security.insecureAPI.strcpy</a><br>
<a href="#clang-analyzer-security.insecureAPI.vfork">clang-analyzer-security.insecureAPI.vfork</a><br>
<a href="#clang-analyzer-unix.API">clang-analyzer-unix.API</a><br>
<a href="#clang-analyzer-unix.BlockInCriticalSection">clang-analyzer-unix.BlockInCriticalSection</a><br>
<a href="#clang-analyzer-unix.Errno">clang-analyzer-unix.Errno</a><br>
<a href="#clang-analyzer-unix.Malloc">clang-analyzer-unix.Malloc</a><br>
<a href="#clang-analyzer-unix.MallocSizeof">clang-analyzer-unix.MallocSizeof</a><br>
<a href="#clang-analyzer-unix.MismatchedDeallocator">clang-analyzer-unix.MismatchedDeallocator</a><br>
<a href="#clang-analyzer-unix.StdCLibraryFunctions">clang-analyzer-unix.StdCLibraryFunctions</a><br>
<a href="#clang-analyzer-unix.Stream">clang-analyzer-unix.Stream</a><br>
<a href="#clang-analyzer-unix.Vfork">clang-analyzer-unix.Vfork</a><br>
<a href="#clang-analyzer-unix.cstring.BadSizeArg">clang-analyzer-unix.cstring.BadSizeArg</a><br>
<a href="#clang-analyzer-unix.cstring.NullArg">clang-analyzer-unix.cstring.NullArg</a><br>
<a href="#clang-analyzer-valist.CopyToSelf">clang-analyzer-valist.CopyToSelf</a><br>
<a href="#clang-analyzer-valist.Uninitialized">clang-analyzer-valist.Uninitialized</a><br>
<a href="#clang-analyzer-valist.Unterminated">clang-analyzer-valist.Unterminated</a><br>
<a href="#clang-analyzer-webkit.NoUncountedMemberChecker">clang-analyzer-webkit.NoUncountedMemberChecker</a><br>
<a href="#clang-analyzer-webkit.RefCntblBaseVirtualDtor">clang-analyzer-webkit.RefCntblBaseVirtualDtor</a><br>
<a href="#clang-analyzer-webkit.UncountedLambdaCapturesChecker">clang-analyzer-webkit.UncountedLambdaCapturesChecker</a><br>
<a href="#concurrency-mt-unsafe">concurrency-mt-unsafe</a><br>
<a href="#concurrency-thread-canceltype-asynchronous">concurrency-thread-canceltype-asynchronous</a><br>
<a href="#cppcoreguidelines-avoid-c-arrays">cppcoreguidelines-avoid-c-arrays</a><br>
<a href="#cppcoreguidelines-avoid-capturing-lambda-coroutines">cppcoreguidelines-avoid-capturing-lambda-coroutines</a><br>
<a href="#cppcoreguidelines-avoid-const-or-ref-data-members">cppcoreguidelines-avoid-const-or-ref-data-members</a><br>
<a href="#cppcoreguidelines-avoid-do-while">cppcoreguidelines-avoid-do-while</a><br>
<a href="#Options">Options</a><br>
<a href="#cppcoreguidelines-avoid-goto">cppcoreguidelines-avoid-goto</a><br>
<a href="#cppcoreguidelines-avoid-magic-numbers">cppcoreguidelines-avoid-magic-numbers</a><br>
<a href="#cppcoreguidelines-avoid-non-const-global-variables">cppcoreguidelines-avoid-non-const-global-variables</a><br>
<a href="#Options">Options</a><br>
<a href="#cppcoreguidelines-avoid-reference-coroutine-parameters">cppcoreguidelines-avoid-reference-coroutine-parameters</a><br>
<a href="#cppcoreguidelines-c-copy-assignment-signature">cppcoreguidelines-c-copy-assignment-signature</a><br>
<a href="#cppcoreguidelines-explicit-virtual-functions">cppcoreguidelines-explicit-virtual-functions</a><br>
<a href="#cppcoreguidelines-init-variables">cppcoreguidelines-init-variables</a><br>
<a href="#Options">Options</a><br>
<a href="#cppcoreguidelines-interfaces-global-init">cppcoreguidelines-interfaces-global-init</a><br>
<a href="#cppcoreguidelines-macro-to-enum">cppcoreguidelines-macro-to-enum</a><br>
<a href="#cppcoreguidelines-macro-usage">cppcoreguidelines-macro-usage</a><br>
<a href="#Options">Options</a><br>
<a href="#cppcoreguidelines-misleading-capture-default-by-value">cppcoreguidelines-misleading-capture-default-by-value</a><br>
<a href="#cppcoreguidelines-missing-std-forward">cppcoreguidelines-missing-std-forward</a><br>
<a href="#cppcoreguidelines-narrowing-conversions">cppcoreguidelines-narrowing-conversions</a><br>
<a href="#Options">Options</a><br>
<a href="#FAQ">FAQ</a><br>
<a href="#cppcoreguidelines-no-malloc">cppcoreguidelines-no-malloc</a><br>
<a href="#Options">Options</a><br>
<a href="#cppcoreguidelines-no-suspend-with-lock">cppcoreguidelines-no-suspend-with-lock</a><br>
<a href="#cppcoreguidelines-noexcept-destructor">cppcoreguidelines-noexcept-destructor</a><br>
<a href="#cppcoreguidelines-noexcept-move-operations">cppcoreguidelines-noexcept-move-operations</a><br>
<a href="#cppcoreguidelines-noexcept-swap">cppcoreguidelines-noexcept-swap</a><br>
<a href="#cppcoreguidelines-non-private-member-variables-in-classes">cppcoreguidelines-non-private-member-variables-in-classes</a><br>
<a href="#cppcoreguidelines-owning-memory">cppcoreguidelines-owning-memory</a><br>
<a href="#Options">Options</a><br>
<a href="#Limitations">Limitations</a><br>
<a href="#cppcoreguidelines-prefer-member-initializer">cppcoreguidelines-prefer-member-initializer</a><br>
<a href="#Example 1">Example 1</a><br>
<a href="#Example 2">Example 2</a><br>
<a href="#cppcoreguidelines-pro-bounds-array-to-pointer-decay">cppcoreguidelines-pro-bounds-array-to-pointer-decay</a><br>
<a href="#cppcoreguidelines-pro-bounds-constant-array-index">cppcoreguidelines-pro-bounds-constant-array-index</a><br>
<a href="#Options">Options</a><br>
<a href="#cppcoreguidelines-pro-bounds-pointer-arithmetic">cppcoreguidelines-pro-bounds-pointer-arithmetic</a><br>
<a href="#cppcoreguidelines-pro-type-const-cast">cppcoreguidelines-pro-type-const-cast</a><br>
<a href="#Options">Options</a><br>
<a href="#cppcoreguidelines-pro-type-cstyle-cast">cppcoreguidelines-pro-type-cstyle-cast</a><br>
<a href="#cppcoreguidelines-pro-type-member-init">cppcoreguidelines-pro-type-member-init</a><br>
<a href="#Options">Options</a><br>
<a href="#cppcoreguidelines-pro-type-reinterpret-cast">cppcoreguidelines-pro-type-reinterpret-cast</a><br>
<a href="#cppcoreguidelines-pro-type-static-cast-downcast">cppcoreguidelines-pro-type-static-cast-downcast</a><br>
<a href="#Options">Options</a><br>
<a href="#cppcoreguidelines-pro-type-union-access">cppcoreguidelines-pro-type-union-access</a><br>
<a href="#cppcoreguidelines-pro-type-vararg">cppcoreguidelines-pro-type-vararg</a><br>
<a href="#cppcoreguidelines-rvalue-reference-param-not-moved">cppcoreguidelines-rvalue-reference-param-not-moved</a><br>
<a href="#Options">Options</a><br>
<a href="#cppcoreguidelines-slicing">cppcoreguidelines-slicing</a><br>
<a href="#cppcoreguidelines-special-member-functions">cppcoreguidelines-special-member-functions</a><br>
<a href="#Options">Options</a><br>
<a href="#cppcoreguidelines-use-default-member-init">cppcoreguidelines-use-default-member-init</a><br>
<a href="#cppcoreguidelines-virtual-class-destructor">cppcoreguidelines-virtual-class-destructor</a><br>
<a href="#Example">Example</a><br>
<a href="#darwin-avoid-spinlock">darwin-avoid-spinlock</a><br>
<a href="#darwin-dispatch-once-nonstatic">darwin-dispatch-once-nonstatic</a><br>
<a href="#fuchsia-default-arguments-calls">fuchsia-default-arguments-calls</a><br>
<a href="#fuchsia-default-arguments-declarations">fuchsia-default-arguments-declarations</a><br>
<a href="#fuchsia-header-anon-namespaces">fuchsia-header-anon-namespaces</a><br>
<a href="#fuchsia-multiple-inheritance">fuchsia-multiple-inheritance</a><br>
<a href="#fuchsia-overloaded-operator">fuchsia-overloaded-operator</a><br>
<a href="#fuchsia-statically-constructed-objects">fuchsia-statically-constructed-objects</a><br>
<a href="#fuchsia-trailing-return">fuchsia-trailing-return</a><br>
<a href="#fuchsia-virtual-inheritance">fuchsia-virtual-inheritance</a><br>
<a href="#google-build-explicit-make-pair">google-build-explicit-make-pair</a><br>
<a href="#google-build-namespaces">google-build-namespaces</a><br>
<a href="#google-build-using-namespace">google-build-using-namespace</a><br>
<a href="#google-default-arguments">google-default-arguments</a><br>
<a href="#google-explicit-constructor">google-explicit-constructor</a><br>
<a href="#google-global-names-in-headers">google-global-names-in-headers</a><br>
<a href="#google-objc-avoid-nsobject-new">google-objc-avoid-nsobject-new</a><br>
<a href="#google-objc-avoid-throwing-exception">google-objc-avoid-throwing-exception</a><br>
<a href="#google-objc-function-naming">google-objc-function-naming</a><br>
<a href="#google-objc-global-variable-declaration">google-objc-global-variable-declaration</a><br>
<a href="#google-readability-avoid-underscore-in-googletest-name">google-readability-avoid-underscore-in-googletest-name</a><br>
<a href="#google-readability-braces-around-statements">google-readability-braces-around-statements</a><br>
<a href="#google-readability-casting">google-readability-casting</a><br>
<a href="#google-readability-function-size">google-readability-function-size</a><br>
<a href="#google-readability-namespace-comments">google-readability-namespace-comments</a><br>
<a href="#google-readability-todo">google-readability-todo</a><br>
<a href="#google-runtime-int">google-runtime-int</a><br>
<a href="#Options">Options</a><br>
<a href="#google-runtime-operator">google-runtime-operator</a><br>
<a href="#google-upgrade-googletest-case">google-upgrade-googletest-case</a><br>
<a href="#hicpp-avoid-c-arrays">hicpp-avoid-c-arrays</a><br>
<a href="#hicpp-avoid-goto">hicpp-avoid-goto</a><br>
<a href="#hicpp-braces-around-statements">hicpp-braces-around-statements</a><br>
<a href="#hicpp-deprecated-headers">hicpp-deprecated-headers</a><br>
<a href="#hicpp-exception-baseclass">hicpp-exception-baseclass</a><br>
<a href="#hicpp-explicit-conversions">hicpp-explicit-conversions</a><br>
<a href="#hicpp-function-size">hicpp-function-size</a><br>
<a href="#hicpp-ignored-remove-result">hicpp-ignored-remove-result</a><br>
<a href="#Options">Options</a><br>
<a href="#hicpp-invalid-access-moved">hicpp-invalid-access-moved</a><br>
<a href="#hicpp-member-init">hicpp-member-init</a><br>
<a href="#hicpp-move-const-arg">hicpp-move-const-arg</a><br>
<a href="#hicpp-multiway-paths-covered">hicpp-multiway-paths-covered</a><br>
<a href="#Options">Options</a><br>
<a href="#hicpp-named-parameter">hicpp-named-parameter</a><br>
<a href="#hicpp-new-delete-operators">hicpp-new-delete-operators</a><br>
<a href="#hicpp-no-array-decay">hicpp-no-array-decay</a><br>
<a href="#hicpp-no-assembler">hicpp-no-assembler</a><br>
<a href="#hicpp-no-malloc">hicpp-no-malloc</a><br>
<a href="#hicpp-noexcept-move">hicpp-noexcept-move</a><br>
<a href="#hicpp-signed-bitwise">hicpp-signed-bitwise</a><br>
<a href="#Options">Options</a><br>
<a href="#hicpp-special-member-functions">hicpp-special-member-functions</a><br>
<a href="#hicpp-static-assert">hicpp-static-assert</a><br>
<a href="#hicpp-undelegated-constructor">hicpp-undelegated-constructor</a><br>
<a href="#hicpp-uppercase-literal-suffix">hicpp-uppercase-literal-suffix</a><br>
<a href="#hicpp-use-auto">hicpp-use-auto</a><br>
<a href="#hicpp-use-emplace">hicpp-use-emplace</a><br>
<a href="#hicpp-use-equals-default">hicpp-use-equals-default</a><br>
<a href="#hicpp-use-equals-delete">hicpp-use-equals-delete</a><br>
<a href="#hicpp-use-noexcept">hicpp-use-noexcept</a><br>
<a href="#hicpp-use-nullptr">hicpp-use-nullptr</a><br>
<a href="#hicpp-use-override">hicpp-use-override</a><br>
<a href="#hicpp-vararg">hicpp-vararg</a><br>
<a href="#linuxkernel-must-check-errs">linuxkernel-must-check-errs</a><br>
<a href="#llvm-else-after-return">llvm-else-after-return</a><br>
<a href="#llvm-header-guard">llvm-header-guard</a><br>
<a href="#llvm-include-order">llvm-include-order</a><br>
<a href="#llvm-namespace-comment">llvm-namespace-comment</a><br>
<a href="#Options">Options</a><br>
<a href="#llvm-prefer-isa-or-dyn-cast-in-conditionals">llvm-prefer-isa-or-dyn-cast-in-conditionals</a><br>
<a href="#llvm-prefer-register-over-unsigned">llvm-prefer-register-over-unsigned</a><br>
<a href="#llvm-qualified-auto">llvm-qualified-auto</a><br>
<a href="#llvm-twine-local">llvm-twine-local</a><br>
<a href="#llvmlibc-callee-namespace">llvmlibc-callee-namespace</a><br>
<a href="#llvmlibc-implementation-in-namespace">llvmlibc-implementation-in-namespace</a><br>
<a href="#llvmlibc-inline-function-decl">llvmlibc-inline-function-decl</a><br>
<a href="#llvmlibc-restrict-system-libc-headers">llvmlibc-restrict-system-libc-headers</a><br>
<a href="#Options">Options</a><br>
<a href="#misc-confusable-identifiers">misc-confusable-identifiers</a><br>
<a href="#misc-const-correctness">misc-const-correctness</a><br>
<a href="#Known Limitations">Known Limitations</a><br>
<a href="#Options">Options</a><br>
<a href="#misc-coroutine-hostile-raii">misc-coroutine-hostile-raii</a><br>
<a href="#Options">Options</a><br>
<a href="#misc-definitions-in-headers">misc-definitions-in-headers</a><br>
<a href="#misc-header-include-cycle">misc-header-include-cycle</a><br>
<a href="#Options">Options</a><br>
<a href="#misc-include-cleaner">misc-include-cleaner</a><br>
<a href="#Options">Options</a><br>
<a href="#misc-misleading-bidirectional">misc-misleading-bidirectional</a><br>
<a href="#misc-misleading-identifier">misc-misleading-identifier</a><br>
<a href="#misc-misplaced-const">misc-misplaced-const</a><br>
<a href="#misc-new-delete-overloads">misc-new-delete-overloads</a><br>
<a href="#misc-no-recursion">misc-no-recursion</a><br>
<a href="#misc-non-copyable-objects">misc-non-copyable-objects</a><br>
<a href="#misc-non-private-member-variables-in-classes">misc-non-private-member-variables-in-classes</a><br>
<a href="#Options">Options</a><br>
<a href="#misc-redundant-expression">misc-redundant-expression</a><br>
<a href="#misc-static-assert">misc-static-assert</a><br>
<a href="#misc-throw-by-value-catch-by-reference">misc-throw-by-value-catch-by-reference</a><br>
<a href="#Options">Options</a><br>
<a href="#misc-unconventional-assign-operator">misc-unconventional-assign-operator</a><br>
<a href="#misc-uniqueptr-reset-release">misc-uniqueptr-reset-release</a><br>
<a href="#Options">Options</a><br>
<a href="#misc-unused-alias-decls">misc-unused-alias-decls</a><br>
<a href="#misc-unused-parameters">misc-unused-parameters</a><br>
<a href="#Options">Options</a><br>
<a href="#misc-unused-using-decls">misc-unused-using-decls</a><br>
<a href="#misc-use-anonymous-namespace">misc-use-anonymous-namespace</a><br>
<a href="#misc-use-internal-linkage">misc-use-internal-linkage</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-avoid-bind">modernize-avoid-bind</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-avoid-c-arrays">modernize-avoid-c-arrays</a><br>
<a href="#modernize-concat-nested-namespaces">modernize-concat-nested-namespaces</a><br>
<a href="#modernize-deprecated-headers">modernize-deprecated-headers</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-deprecated-ios-base-aliases">modernize-deprecated-ios-base-aliases</a><br>
<a href="#modernize-loop-convert">modernize-loop-convert</a><br>
<a href="#MinConfidence option">MinConfidence option</a><br>
<a href="#risky">risky</a><br>
<a href="#reasonable (Default)">reasonable (Default)</a><br>
<a href="#safe">safe</a><br>
<a href="#Example">Example</a><br>
<a href="#Reverse Iterator Support">Reverse Iterator Support</a><br>
<a href="#Limitations">Limitations</a><br>
<a href="#Comments inside loop headers">Comments inside loop headers</a><br>
<a href="#Range-based loops evaluate end() only once">Range-based loops evaluate end() only once</a><br>
<a href="#Overloaded operator-&gt;() with side effects">Overloaded operator-&gt;() with side effects</a><br>
<a href="#Pointers and references to containers">Pointers and references to containers</a><br>
<a href="#OpenMP">OpenMP</a><br>
<a href="#modernize-macro-to-enum">modernize-macro-to-enum</a><br>
<a href="#modernize-make-shared">modernize-make-shared</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-make-unique">modernize-make-unique</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-min-max-use-initializer-list">modernize-min-max-use-initializer-list</a><br>
<a href="#Performance Considerations">Performance Considerations</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-pass-by-value">modernize-pass-by-value</a><br>
<a href="#Pass-by-value in constructors">Pass-by-value in constructors</a><br>
<a href="#Known limitations">Known limitations</a><br>
<a href="#Note about delayed template parsing">Note about delayed template parsing</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-raw-string-literal">modernize-raw-string-literal</a><br>
<a href="#modernize-redundant-void-arg">modernize-redundant-void-arg</a><br>
<a href="#modernize-replace-auto-ptr">modernize-replace-auto-ptr</a><br>
<a href="#Known Limitations">Known Limitations</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-replace-disallow-copy-and-assign-macro">modernize-replace-disallow-copy-and-assign-macro</a><br>
<a href="#Known Limitations">Known Limitations</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-replace-random-shuffle">modernize-replace-random-shuffle</a><br>
<a href="#modernize-return-braced-init-list">modernize-return-braced-init-list</a><br>
<a href="#modernize-shrink-to-fit">modernize-shrink-to-fit</a><br>
<a href="#modernize-type-traits">modernize-type-traits</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-unary-static-assert">modernize-unary-static-assert</a><br>
<a href="#modernize-use-auto">modernize-use-auto</a><br>
<a href="#Iterators">Iterators</a><br>
<a href="#New expressions">New expressions</a><br>
<a href="#Cast expressions">Cast expressions</a><br>
<a href="#Known Limitations">Known Limitations</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-use-bool-literals">modernize-use-bool-literals</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-use-constraints">modernize-use-constraints</a><br>
<a href="#modernize-use-default">modernize-use-default</a><br>
<a href="#modernize-use-default-member-init">modernize-use-default-member-init</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-use-designated-initializers">modernize-use-designated-initializers</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-use-emplace">modernize-use-emplace</a><br>
<a href="#Options">Options</a><br>
<a href="#Example">Example</a><br>
<a href="#modernize-use-equals-default">modernize-use-equals-default</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-use-equals-delete">modernize-use-equals-delete</a><br>
<a href="#modernize-use-nodiscard">modernize-use-nodiscard</a><br>
<a href="#Example">Example</a><br>
<a href="#Options">Options</a><br>
<a href="#Example">Example</a><br>
<a href="#modernize-use-noexcept">modernize-use-noexcept</a><br>
<a href="#Example">Example</a><br>
<a href="#Options">Options</a><br>
<a href="#Example">Example</a><br>
<a href="#Example">Example</a><br>
<a href="#modernize-use-nullptr">modernize-use-nullptr</a><br>
<a href="#Example">Example</a><br>
<a href="#Options">Options</a><br>
<a href="#Example">Example</a><br>
<a href="#modernize-use-override">modernize-use-override</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-use-ranges">modernize-use-ranges</a><br>
<a href="#Example">Example</a><br>
<a href="#Supported algorithms">Supported algorithms</a><br>
<a href="#Reverse Iteration">Reverse Iteration</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-use-starts-ends-with">modernize-use-starts-ends-with</a><br>
<a href="#modernize-use-std-format">modernize-use-std-format</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-use-std-numbers">modernize-use-std-numbers</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-use-std-print">modernize-use-std-print</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-use-trailing-return-type">modernize-use-trailing-return-type</a><br>
<a href="#Example">Example</a><br>
<a href="#Known Limitations">Known Limitations</a><br>
<a href="#modernize-use-transparent-functors">modernize-use-transparent-functors</a><br>
<a href="#Options">Options</a><br>
<a href="#modernize-use-uncaught-exceptions">modernize-use-uncaught-exceptions</a><br>
<a href="#modernize-use-using">modernize-use-using</a><br>
<a href="#Options">Options</a><br>
<a href="#mpi-buffer-deref">mpi-buffer-deref</a><br>
<a href="#mpi-type-mismatch">mpi-type-mismatch</a><br>
<a href="#objc-assert-equals">objc-assert-equals</a><br>
<a href="#objc-avoid-nserror-init">objc-avoid-nserror-init</a><br>
<a href="#objc-dealloc-in-category">objc-dealloc-in-category</a><br>
<a href="#objc-forbidden-subclassing">objc-forbidden-subclassing</a><br>
<a href="#Options">Options</a><br>
<a href="#objc-missing-hash">objc-missing-hash</a><br>
<a href="#objc-nsdate-formatter">objc-nsdate-formatter</a><br>
<a href="#objc-nsinvocation-argument-lifetime">objc-nsinvocation-argument-lifetime</a><br>
<a href="#objc-property-declaration">objc-property-declaration</a><br>
<a href="#objc-super-self">objc-super-self</a><br>
<a href="#openmp-exception-escape">openmp-exception-escape</a><br>
<a href="#Options">Options</a><br>
<a href="#openmp-use-default-none">openmp-use-default-none</a><br>
<a href="#Example">Example</a><br>
<a href="#performance-avoid-endl">performance-avoid-endl</a><br>
<a href="#performance-enum-size">performance-enum-size</a><br>
<a href="#Options">Options</a><br>
<a href="#performance-faster-string-find">performance-faster-string-find</a><br>
<a href="#Options">Options</a><br>
<a href="#performance-for-range-copy">performance-for-range-copy</a><br>
<a href="#Options">Options</a><br>
<a href="#performance-implicit-cast-in-loop">performance-implicit-cast-in-loop</a><br>
<a href="#performance-implicit-conversion-in-loop">performance-implicit-conversion-in-loop</a><br>
<a href="#performance-inefficient-algorithm">performance-inefficient-algorithm</a><br>
<a href="#performance-inefficient-string-concatenation">performance-inefficient-string-concatenation</a><br>
<a href="#Options">Options</a><br>
<a href="#performance-inefficient-vector-operation">performance-inefficient-vector-operation</a><br>
<a href="#Options">Options</a><br>
<a href="#performance-move-const-arg">performance-move-const-arg</a><br>
<a href="#Options">Options</a><br>
<a href="#performance-move-constructor-init">performance-move-constructor-init</a><br>
<a href="#performance-no-automatic-move">performance-no-automatic-move</a><br>
<a href="#Semantics">Semantics</a><br>
<a href="#-Wreturn-std-move">-Wreturn-std-move</a><br>
<a href="#performance-no-int-to-ptr">performance-no-int-to-ptr</a><br>
<a href="#performance-noexcept-destructor">performance-noexcept-destructor</a><br>
<a href="#performance-noexcept-move-constructor">performance-noexcept-move-constructor</a><br>
<a href="#performance-noexcept-swap">performance-noexcept-swap</a><br>
<a href="#performance-trivially-destructible">performance-trivially-destructible</a><br>
<a href="#performance-type-promotion-in-math-fn">performance-type-promotion-in-math-fn</a><br>
<a href="#performance-unnecessary-copy-initialization">performance-unnecessary-copy-initialization</a><br>
<a href="#Options">Options</a><br>
<a href="#performance-unnecessary-value-param">performance-unnecessary-value-param</a><br>
<a href="#Options">Options</a><br>
<a href="#portability-restrict-system-includes">portability-restrict-system-includes</a><br>
<a href="#Options">Options</a><br>
<a href="#portability-simd-intrinsics">portability-simd-intrinsics</a><br>
<a href="#Options">Options</a><br>
<a href="#portability-std-allocator-const">portability-std-allocator-const</a><br>
<a href="#readability-avoid-const-params-in-decls">readability-avoid-const-params-in-decls</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-avoid-nested-conditional-operator">readability-avoid-nested-conditional-operator</a><br>
<a href="#readability-avoid-return-with-void-value">readability-avoid-return-with-void-value</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-avoid-unconditional-preprocessor-if">readability-avoid-unconditional-preprocessor-if</a><br>
<a href="#readability-braces-around-statements">readability-braces-around-statements</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-const-return-type">readability-const-return-type</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-container-contains">readability-container-contains</a><br>
<a href="#readability-container-data-pointer">readability-container-data-pointer</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-container-size-empty">readability-container-size-empty</a><br>
<a href="#readability-convert-member-functions-to-static">readability-convert-member-functions-to-static</a><br>
<a href="#readability-delete-null-pointer">readability-delete-null-pointer</a><br>
<a href="#readability-duplicate-include">readability-duplicate-include</a><br>
<a href="#readability-else-after-return">readability-else-after-return</a><br>
<a href="#Options">Options</a><br>
<a href="#LLVM alias">LLVM alias</a><br>
<a href="#readability-enum-initial-value">readability-enum-initial-value</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-function-cognitive-complexity">readability-function-cognitive-complexity</a><br>
<a href="#Options">Options</a><br>
<a href="#Building blocks">Building blocks</a><br>
<a href="#Increment">Increment</a><br>
<a href="#Nesting level">Nesting level</a><br>
<a href="#Nesting increment">Nesting increment</a><br>
<a href="#Examples">Examples</a><br>
<a href="#Limitations">Limitations</a><br>
<a href="#readability-function-size">readability-function-size</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-identifier-length">readability-identifier-length</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-identifier-naming">readability-identifier-naming</a><br>
<a href="#Options">Options</a><br>
<a href="#The default mapping table of Hungarian Notation">The default mapping table of Hungarian Notation</a><br>
<a href="#Options for Hungarian Notation">Options for Hungarian Notation</a><br>
<a href="#readability-implicit-bool-cast">readability-implicit-bool-cast</a><br>
<a href="#readability-implicit-bool-conversion">readability-implicit-bool-conversion</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-inconsistent-declaration-parameter-name">readability-inconsistent-declaration-parameter-name</a><br>
<a href="#readability-isolate-declaration">readability-isolate-declaration</a><br>
<a href="#Limitations">Limitations</a><br>
<a href="#readability-magic-numbers">readability-magic-numbers</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-make-member-function-const">readability-make-member-function-const</a><br>
<a href="#readability-math-missing-parentheses">readability-math-missing-parentheses</a><br>
<a href="#readability-misleading-indentation">readability-misleading-indentation</a><br>
<a href="#Limitations">Limitations</a><br>
<a href="#readability-misplaced-array-index">readability-misplaced-array-index</a><br>
<a href="#readability-named-parameter">readability-named-parameter</a><br>
<a href="#readability-non-const-parameter">readability-non-const-parameter</a><br>
<a href="#readability-operators-representation">readability-operators-representation</a><br>
<a href="#Token Representation Mapping Table">Token Representation Mapping Table</a><br>
<a href="#Example">Example</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-qualified-auto">readability-qualified-auto</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-redundant-access-specifiers">readability-redundant-access-specifiers</a><br>
<a href="#Example">Example</a><br>
<a href="#Options">Options</a><br>
<a href="#Example">Example</a><br>
<a href="#readability-redundant-casting">readability-redundant-casting</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-redundant-control-flow">readability-redundant-control-flow</a><br>
<a href="#readability-redundant-declaration">readability-redundant-declaration</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-redundant-function-ptr-dereference">readability-redundant-function-ptr-dereference</a><br>
<a href="#readability-redundant-inline-specifier">readability-redundant-inline-specifier</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-redundant-member-init">readability-redundant-member-init</a><br>
<a href="#Example">Example</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-redundant-preprocessor">readability-redundant-preprocessor</a><br>
<a href="#readability-redundant-smartptr-get">readability-redundant-smartptr-get</a><br>
<a href="#readability-redundant-string-cstr">readability-redundant-string-cstr</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-redundant-string-init">readability-redundant-string-init</a><br>
<a href="#Examples">Examples</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-reference-to-constructed-temporary">readability-reference-to-constructed-temporary</a><br>
<a href="#readability-simplify-boolean-expr">readability-simplify-boolean-expr</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-simplify-subscript-expr">readability-simplify-subscript-expr</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-static-accessed-through-instance">readability-static-accessed-through-instance</a><br>
<a href="#readability-static-definition-in-anonymous-namespace">readability-static-definition-in-anonymous-namespace</a><br>
<a href="#readability-string-compare">readability-string-compare</a><br>
<a href="#Example">Example</a><br>
<a href="#Options">Options</a><br>
<a href="#Example">Example</a><br>
<a href="#readability-suspicious-call-argument">readability-suspicious-call-argument</a><br>
<a href="#Heuristics">Heuristics</a><br>
<a href="#Equality">Equality</a><br>
<a href="#Abbreviation">Abbreviation</a><br>
<a href="#Prefix">Prefix</a><br>
<a href="#Suffix">Suffix</a><br>
<a href="#Substring">Substring</a><br>
<a href="#Levenshtein distance (as Levenshtein)">Levenshtein distance (as Levenshtein)</a><br>
<a href="#Jaro--Winkler distance (as JaroWinkler)">Jaro--Winkler distance (as JaroWinkler)</a><br>
<a href="#S&oslash;rensen--Dice coefficient (as Dice)">S&oslash;rensen--Dice coefficient (as Dice)</a><br>
<a href="#Options">Options</a><br>
<a href="#Name synthesis">Name synthesis</a><br>
<a href="#readability-uniqueptr-delete-release">readability-uniqueptr-delete-release</a><br>
<a href="#Options">Options</a><br>
<a href="#readability-uppercase-literal-suffix">readability-uppercase-literal-suffix</a><br>
<a href="#Options">Options</a><br>
<a href="#Example">Example</a><br>
<a href="#readability-use-anyofallof">readability-use-anyofallof</a><br>
<a href="#readability-use-std-min-max">readability-use-std-min-max</a><br>
<a href="#zircon-temporary-objects">zircon-temporary-objects</a><br>
<a href="#Options">Options</a><br>
<a href="#Check aliases">Check aliases</a><br>
<a href="#Clang-tidy IDE/Editor Integrations">Clang-tidy IDE/Editor Integrations</a><br>
<a href="#Getting Involved">Getting Involved</a><br>
<a href="#Choosing the Right Place for your Check">Choosing the Right Place for your Check</a><br>
<a href="#Preparing your Workspace">Preparing your Workspace</a><br>
<a href="#The Directory Structure">The Directory Structure</a><br>
<a href="#Writing a clang-tidy Check">Writing a clang-tidy Check</a><br>
<a href="#Check development tips">Check development tips</a><br>
<a href="#Guide to useful documentation">Guide to useful documentation</a><br>
<a href="#Using the Transformer library">Using the Transformer library</a><br>
<a href="#Developing your check incrementally">Developing your check incrementally</a><br>
<a href="#Creating private matchers">Creating private matchers</a><br>
<a href="#Unit testing helper code">Unit testing helper code</a><br>
<a href="#Making your check robust">Making your check robust</a><br>
<a href="#Documenting your check">Documenting your check</a><br>
<a href="#Registering your Check">Registering your Check</a><br>
<a href="#Configuring Checks">Configuring Checks</a><br>
<a href="#Testing Checks">Testing Checks</a><br>
<a href="#Out-of-tree check plugins">Out-of-tree check plugins</a><br>
<a href="#Running clang-tidy on LLVM">Running clang-tidy on LLVM</a><br>
<a href="#On checks profiling">On checks profiling</a><br>
<a href="#Using clang-tidy">Using clang-tidy</a><br>
<a href="#Suppressing Undesired Diagnostics">Suppressing Undesired Diagnostics</a><br>
<a href="#CLANG-INCLUDE-FIXER">CLANG-INCLUDE-FIXER</a><br>
<a href="#Contents">Contents</a><br>
<a href="#Setup">Setup</a><br>
<a href="#Creating a Symbol Index From a Compilation Database">Creating a Symbol Index From a Compilation Database</a><br>
<a href="#Integrate with Vim">Integrate with Vim</a><br>
<a href="#Integrate with Emacs">Integrate with Emacs</a><br>
<a href="#How it Works">How it Works</a><br>
<a href="#MODULARIZE USER&rsquo;S MANUAL">MODULARIZE USER&rsquo;S MANUAL</a><br>
<a href="#Modularize Usage">Modularize Usage</a><br>
<a href="#Modularize Command Line Options">Modularize Command Line Options</a><br>
<a href="#Getting Started">Getting Started</a><br>
<a href="#What Modularize Checks">What Modularize Checks</a><br>
<a href="#Module Map Coverage Check">Module Map Coverage Check</a><br>
<a href="#Module Map Generation">Module Map Generation</a><br>
<a href="#PP-TRACE USER&rsquo;S MANUAL">PP-TRACE USER&rsquo;S MANUAL</a><br>
<a href="#pp-trace Usage">pp-trace Usage</a><br>
<a href="#Command Line Format">Command Line Format</a><br>
<a href="#Command Line Options">Command Line Options</a><br>
<a href="#pp-trace Output Format">pp-trace Output Format</a><br>
<a href="#Callback Details">Callback Details</a><br>
<a href="#FileChanged Callback">FileChanged Callback</a><br>
<a href="#FileSkipped Callback">FileSkipped Callback</a><br>
<a href="#InclusionDirective Callback">InclusionDirective Callback</a><br>
<a href="#moduleImport Callback">moduleImport Callback</a><br>
<a href="#EndOfMainFile Callback">EndOfMainFile Callback</a><br>
<a href="#Ident Callback">Ident Callback</a><br>
<a href="#PragmaDirective Callback">PragmaDirective Callback</a><br>
<a href="#PragmaComment Callback">PragmaComment Callback</a><br>
<a href="#PragmaDetectMismatch Callback">PragmaDetectMismatch Callback</a><br>
<a href="#PragmaDebug Callback">PragmaDebug Callback</a><br>
<a href="#PragmaMessage Callback">PragmaMessage Callback</a><br>
<a href="#PragmaDiagnosticPush Callback">PragmaDiagnosticPush Callback</a><br>
<a href="#PragmaDiagnosticPop Callback">PragmaDiagnosticPop Callback</a><br>
<a href="#PragmaDiagnostic Callback">PragmaDiagnostic Callback</a><br>
<a href="#PragmaOpenCLExtension Callback">PragmaOpenCLExtension Callback</a><br>
<a href="#PragmaWarning Callback">PragmaWarning Callback</a><br>
<a href="#PragmaWarningPush Callback">PragmaWarningPush Callback</a><br>
<a href="#PragmaWarningPop Callback">PragmaWarningPop Callback</a><br>
<a href="#MacroExpands Callback">MacroExpands Callback</a><br>
<a href="#MacroDefined Callback">MacroDefined Callback</a><br>
<a href="#MacroUndefined Callback">MacroUndefined Callback</a><br>
<a href="#Defined Callback">Defined Callback</a><br>
<a href="#SourceRangeSkipped Callback">SourceRangeSkipped Callback</a><br>
<a href="#If Callback">If Callback</a><br>
<a href="#Elif Callback">Elif Callback</a><br>
<a href="#Ifdef Callback">Ifdef Callback</a><br>
<a href="#Ifndef Callback">Ifndef Callback</a><br>
<a href="#Else Callback">Else Callback</a><br>
<a href="#Endif Callback">Endif Callback</a><br>
<a href="#Building pp-trace">Building pp-trace</a><br>
<a href="#CLANG-RENAME">CLANG-RENAME</a><br>
<a href="#Contents">Contents</a><br>
<a href="#Using Clang-Rename">Using Clang-Rename</a><br>
<a href="#Vim Integration">Vim Integration</a><br>
<a href="#Emacs Integration">Emacs Integration</a><br>
<a href="#CLANG-DOC">CLANG-DOC</a><br>
<a href="#Contents">Contents</a><br>
<a href="#Use">Use</a><br>
<a href="#Output">Output</a><br>
<a href="#Configuration">Configuration</a><br>
<a href="#Options">Options</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">extraclangtools
- Extra Clang Tools Documentation</p>

<p style="margin-left:9%; margin-top: 1em">Welcome to the
clang-tools-extra project which contains extra tools built
using Clang's tooling APIs.</p>

<h2>EXTRA CLANG TOOLS 19.1.7 RELEASE NOTES
<a name="EXTRA CLANG TOOLS 19.1.7 RELEASE NOTES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="50%">


<p style="margin-top: 1em"><i>Introduction</i></p></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="50%">


<p><i>What's New in Extra Clang Tools 19.1.7?</i></p></td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:12%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%"></td>
<td width="1%"></td>
<td width="28%">


<p style="margin-top: 1em"><i>Major New Features</i></p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="28%">


<p><i>Improvements to clangd</i></p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:14%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%"></td>
<td width="2%"></td>
<td width="28%">


<p style="margin-top: 1em"><i>Inlay hints</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><i>Diagnostics</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><i>Semantic Highlighting</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><i>Compile flags</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><i>Hover</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><i>Code completion</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><i>Code actions</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><i>Signature help</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><i>Cross-references</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><i>Document outline</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><i>Clang-tidy integration</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><i>Objective-C</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><i>Miscellaneous</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%"></td>
<td width="55%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><i>Improvements
to clang-doc</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="36%">


<p style="margin-top: 1em"><i>Improvements to
clang-query</i></p> </td>
<td width="50%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="36%">


<p><i>Improvements to clang-rename</i></p></td>
<td width="50%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="36%">


<p><i>Improvements to clang-tidy</i></p></td>
<td width="50%">
</td></tr>
</table>

<p style="margin-left:14%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%"></td>
<td width="2%"></td>
<td width="33%">


<p style="margin-top: 1em"><i>New checks</i></p></td>
<td width="50%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="33%">


<p><i>New check aliases</i></p></td>
<td width="50%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="33%">


<p><i>Changes in existing checks</i></p></td>
<td width="50%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="33%">


<p><i>Removed checks</i></p></td>
<td width="50%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="33%">


<p><i>Miscellaneous</i></p></td>
<td width="50%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="33%"></td>
<td width="50%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><i>Improvements
to include-fixer</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p style="margin-top: 1em"><i>Improvements to
clang-include-fixer</i></p> </td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p><i>Improvements to modularize</i></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p><i>Improvements to pp-trace</i></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p><i>Clang-tidy Visual Studio plugin</i></p></td>
<td width="41%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Written by the
<i>LLVM Team</i></p>

<h3>Introduction
<a name="Introduction"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This document
contains the release notes for the Extra Clang Tools, part
of the Clang release 19.1.7. Here we describe the status of
the Extra Clang Tools in some detail, including major
improvements from the previous release and new feature work.
All LLVM releases may be downloaded from the <i>LLVM
releases web site</i>.</p>

<p style="margin-left:9%; margin-top: 1em">For more
information about Clang or LLVM, including information about
the latest release, please see the <i>Clang Web Site</i> or
the <i>LLVM Web Site</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Note that if you
are reading this file from a Git checkout or the main Clang
web page, this document applies to the <i>next</i> release,
not the current one. To see the release notes for a specific
release, please see the <i>releases page</i>.</p>

<h3>What's New in Extra Clang Tools 19.1.7?
<a name="What's New in Extra Clang Tools 19.1.7?"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Some of the
major new features and improvements to Extra Clang Tools are
listed here. Generic improvements to Extra Clang Tools as a
whole or to its underlying infrastructure are described
first, followed by tool-specific sections.</p>

<h3>Major New Features
<a name="Major New Features"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">...</p>

<h3>Improvements to clangd
<a name="Improvements to clangd"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Introduced exmperimental support
for C++20 Modules. The experimental support can be enabled
by <i>-experimental-modules-support</i> option. It is in an
early development stage and may not perform efficiently in
real-world scenarios.</p></td></tr>
</table>

<h3>Inlay hints
<a name="Inlay hints"></a>
</h3>


<h3>Diagnostics
<a name="Diagnostics"></a>
</h3>


<h3>Semantic Highlighting
<a name="Semantic Highlighting"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Improved semantic token coverage
in some edge cases, e.g. IndirectFieldDecl</p></td></tr>
</table>

<h3>Compile flags
<a name="Compile flags"></a>
</h3>


<h3>Hover
<a name="Hover"></a>
</h3>


<h3>Code completion
<a name="Code completion"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="90%">
</td></tr>
</table>


<p style="margin-left:12%; margin-top: 1em"><b>--function-arg-placeholders=0
is now respected for variable template <br>
argument lists</b></p>

<p style="margin-left:21%;">as well</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Macro proposals now use the completion item kind
<b>Constant</b> (for object-like macros) or <b>Function</b>
(for function-style macros) even for proposals coming from
the index</p></td></tr>
</table>

<h3>Code actions
<a name="Code actions"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">The &quot;extract variable&quot;
tweak is no longer offered for the initializer expression of
a declaration</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>The tweak for turning unscoped into scoped enums now
removes redundant prefixes from the enum values.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Support &quot;move function body out-of-line&quot; in
non-header files as well</p></td></tr>
</table>

<h3>Signature help
<a name="Signature help"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Signature help now shows
function argument names for calls through pointers to
functions in struct fields</p></td></tr>
</table>

<h3>Cross-references
<a name="Cross-references"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="66%">


<p style="margin-top: 1em">Improve go-to-definition for
some concept references</p></td>
<td width="22%">
</td></tr>
</table>

<h3>Document outline
<a name="Document outline"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Improved precision of document
outline information for symbols whose definitions involve
macro expansions</p></td></tr>
</table>

<h3>Clang-tidy integration
<a name="Clang-tidy integration"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">The quick fix for clang-tidy's
<b>readability-identifier-naming</b> diagnostic is now
hooked to invoke <b>textDocument/rename</b>, renaming the
identifier across the whole project rather than just the
translation unit of the diagnostic</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p><b>misc-const-correctness</b> can now be enabled with
<b>FastCheckFilter: None</b> (previously clangd would force
it off unconditionally due to its run time)</p></td></tr>
</table>

<h3>Objective-C
<a name="Objective-C"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="59%">


<p style="margin-top: 1em">Added support for renaming
Objective-C methods</p></td>
<td width="29%">
</td></tr>
</table>

<h3>Miscellaneous
<a name="Miscellaneous"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Worked around a clang-format bug
that caused memory exhaustion when opening some large
<b>.h</b> files due to the formatter's language guessing
heuristic (#GH85703)</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Various other stability improvements, e.g. crash
fixes</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Added a boolean option <i>AnalyzeAngledIncludes</i> to
<i>Includes</i> config section, which allows to enable
unused includes detection for all angled
(&quot;system&quot;) headers. At this moment umbrella
headers are not supported, so enabling this option may
result in false-positives.</p></td></tr>
</table>

<h3>Improvements to clang-doc
<a name="Improvements to clang-doc"></a>
</h3>


<h3>Improvements to clang-query
<a name="Improvements to clang-query"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Added the <i>file</i> command to
dynamically load a list of commands and matchers from an
external file, allowing the cost of reading the compilation
database and building the AST to be imposed just once for
faster prototyping.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Removed support for <b>enable output srcloc</b>. Fixes
#GH82591</p> </td></tr>
</table>

<h3>Improvements to clang-rename
<a name="Improvements to clang-rename"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The improvements
are...</p>

<h3>Improvements to clang-tidy
<a name="Improvements to clang-tidy"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Improved
<b>run-clang-tidy.py</b> script. Added argument
<i>-source-filter</i> to filter source files from the
compilation database, via a RegEx. In a similar fashion to
what <i>-header-filter</i> does for header files. Added
progress indicator with a number of processed files and the
runtime of each invocation after completion.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <b>check_clang_tidy.py</b> script. Added
argument <i>-export-fixes</i> to aid in clang-tidy and test
development.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Fixed bug where big values for unsigned check options
overflowed into negative values when being printed with
<i>--dump-config</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Fixed <i>--verify-config</i> option not properly parsing
checks when using the literal operator in the
<i>.clang-tidy</i> config.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Added argument <i>--exclude-header-filter</i> and config
option <i>ExcludeHeaderFilterRegex</i> to exclude headers
from analysis via a RegEx.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Added argument <i>--allow-no-checks</i> to suppress
&quot;no checks enabled&quot; error when disabling all of
the checks by <i>--checks='-*'</i>.</p></td></tr>
</table>

<h3>New checks
<a name="New checks"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="34%">


<p style="margin-top: 1em">New <i>boost-use-ranges</i>
check.</p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Detects calls
to standard library iterator algorithms that could be
replaced with a Boost ranges version instead.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="64%">


<p style="margin-top: 1em">New
<i>bugprone-crtp-constructor-accessibility</i> check.</p></td>
<td width="24%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Detects
error-prone Curiously Recurring Template Pattern usage, when
the CRTP can be constructed outside itself and the derived
class.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="76%">


<p style="margin-top: 1em">New
<i>bugprone-pointer-arithmetic-on-polymorphic-object</i>
check.</p> </td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Finds pointer
arithmetic performed on classes that contain a virtual
function.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="65%">


<p style="margin-top: 1em">New
<i>bugprone-return-const-ref-from-parameter</i> check.</p></td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Detects return
statements that return a constant reference parameter as
constant reference. This may cause use-after-free errors if
the caller uses xvalues as arguments.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="66%">


<p style="margin-top: 1em">New
<i>bugprone-suspicious-stringview-data-usage</i> check.</p></td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Identifies
suspicious usages of <b>std::string_view::data()</b> that
could lead to reading out-of-bounds data due to inadequate
or incorrect string null termination.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="46%">


<p style="margin-top: 1em">New
<i>misc-use-internal-linkage</i> check.</p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Detects
variables and functions that can be marked as static or
moved into an anonymous namespace to enforce internal
linkage.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="62%">


<p style="margin-top: 1em">New
<i>modernize-min-max-use-initializer-list</i> check.</p></td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Replaces nested
<b>std::min</b> and <b>std::max</b> calls with an
initializer list where applicable.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="61%">


<p style="margin-top: 1em">New
<i>modernize-use-designated-initializers</i> check.</p></td>
<td width="27%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Finds
initializer lists for aggregate types that could be written
as designated initializers instead.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="39%">


<p style="margin-top: 1em">New <i>modernize-use-ranges</i>
check.</p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Detects calls
to standard library iterator algorithms that could be
replaced with a ranges version instead.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="44%">


<p style="margin-top: 1em">New
<i>modernize-use-std-format</i> check.</p></td>
<td width="44%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Converts calls
to <b>absl::StrFormat</b>, or other functions via
configuration options, to C++20's <b>std::format</b>, or
another function via a configuration option, modifying the
format string appropriately and removing now-unnecessary
calls to <b>std::string::c_str()</b> and
<b>std::string::data()</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p style="margin-top: 1em">New
<i>readability-enum-initial-value</i> check.</p></td>
<td width="36%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Enforces
consistent style for enumerators' initialization, covering
three styles: none, first only, or all initialized
explicitly.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="60%">


<p style="margin-top: 1em">New
<i>readability-math-missing-parentheses</i> check.</p></td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Check for
missing parentheses in mathematical expressions that involve
operators of different priorities.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p style="margin-top: 1em">New
<i>readability-use-std-min-max</i> check.</p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Replaces
certain conditional statements with equivalent calls to
<b>std::min</b> or <b>std::max</b>.</p>

<h3>New check aliases
<a name="New check aliases"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">New alias <i>cert-ctr56-cpp</i>
to <i>bugprone-pointer-arithmetic-on-polymorphic-object</i>
was added.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>New alias <i>cert-int09-c</i> to
<i>readability-enum-initial-value</i> was added.</p></td></tr>
</table>

<h3>Changes in existing checks
<a name="Changes in existing checks"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Improved
<i>bugprone-assert-side-effect</i> check by detecting side
effect from calling a method with non-const reference
parameters.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>bugprone-assignment-in-if-condition</i>
check by ignoring assignments in the C++20 <b>requires</b>
clause.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>bugprone-casting-through-void</i> check by
ignoring casts where source is already a <b>void`</b>
pointer, making middle <b>void</b> pointer casts
bug-free.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>bugprone-exception-escape</i> check to
correctly detect exception handler of type <b>CV void *</b>
as catching all <b>CV</b> compatible pointer types.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>bugprone-forwarding-reference-overload</i>
check to ignore deleted constructors which won't hide other
overloads.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved
<i>bugprone-implicit-widening-of-multiplication-result</i>
check by adding an option to ignore constant expressions of
signed integer types that fit in the source expression
type.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>bugprone-inc-dec-in-conditions</i> check to
ignore code within unevaluated contexts, such as
<b>decltype</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>bugprone-lambda-function-name</i> check by
ignoring <b>__func__</b> macro in lambda captures,
initializers of default parameters and nested function
declarations.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved
<i>bugprone-multi-level-implicit-pointer-conversion</i>
check by ignoring implicit pointer conversions that are part
of a cast expression.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved
<i>bugprone-non-zero-enum-to-bool-conversion</i> check by
eliminating false positives resulting from direct usage of
bitwise operators within parentheses.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>bugprone-optional-value-conversion</i> check
by eliminating false positives resulting from use of
optionals in unevaluated context.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>bugprone-sizeof-expression</i> check by
clarifying the diagnostics, eliminating some false positives
and adding a new (off-by-default) option
<i>WarnOnSizeOfPointer</i> that reports all
<b>sizeof(pointer)</b> expressions (except for a few that
are idiomatic).</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>bugprone-suspicious-include</i> check by
replacing the local options <i>HeaderFileExtensions</i> and
<i>ImplementationFileExtensions</i> by the global options of
the same name.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>bugprone-too-small-loop-variable</i> check
by incorporating better support for <b>const</b> loop
boundaries.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved
<i>bugprone-unused-local-non-trivial-variable</i> check by
ignoring local variable with <b>[maybe_unused]</b>
attribute.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>bugprone-unused-return-value</i> check by
updating the parameter <i>CheckedFunctions</i> to support
regexp, avoiding false positive for function with the same
prefix as the default argument, e.g. <b>std::unique_ptr</b>
and <b>std::unique</b>, avoiding false positive for
assignment operator overloading.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>bugprone-use-after-move</i> check to also
handle calls to <b>std::forward</b>. Fixed sequencing of
designated initializers. Fixed sequencing of callees: In
C++17 and later, the callee of a function is guaranteed to
be sequenced before the arguments, so don't warn if the use
happens in the callee and the move happens in one of the
arguments.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved
<i>cppcoreguidelines-avoid-non-const-global-variables</i>
check with a new option <i>AllowInternalLinkage</i> to
disable the warning for variables with internal linkage.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>cppcoreguidelines-macro-usage</i> check by
ignoring macro with hash preprocessing token.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>cppcoreguidelines-missing-std-forward</i>
check by no longer giving false positives for deleted
functions, by fixing false negatives when only a few
parameters are forwarded and by ignoring parameters without
a name (unused arguments).</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>cppcoreguidelines-owning-memory</i> check to
properly handle return type in lambdas and in nested
functions.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved
<i>cppcoreguidelines-prefer-member-initializer</i> check by
removing enforcement of rule <i>C.48</i>, which was
deprecated since <b>clang-tidy</b> 17. This rule is now
covered by <i>cppcoreguidelines-use-default-member-init</i>.
Fixed incorrect hints when using list-initialization.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved
<i>cppcoreguidelines-special-member-functions</i> check with
a new option <i>AllowImplicitlyDeletedCopyOrMove</i>, which
removes the requirement for explicit copy or move special
member functions when they are already implicitly
deleted.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>google-build-namespaces</i> check by
replacing the local option <i>HeaderFileExtensions</i> by
the global option of the same name.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>google-explicit-constructor</i> check to
better handle C++20 <i>explicit(bool)</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>google-global-names-in-headers</i> check by
replacing the local option <i>HeaderFileExtensions</i> by
the global option of the same name.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>google-runtime-int</i> check performance
through optimizations.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>hicpp-signed-bitwise</i> check by ignoring
false positives involving positive integer literals behind
implicit casts when <i>IgnorePositiveIntegerLiterals</i> is
enabled.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>hicpp-ignored-remove-result</i> check by
ignoring other functions with same prefixes as the target
specific functions.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>linuxkernel-must-check-errs</i> check
documentation to consistently use the check's proper
name.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>llvm-header-guard</i> check by replacing the
local option <i>HeaderFileExtensions</i> by the global
option of the same name.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>misc-const-correctness</i> check by avoiding
infinite recursion for recursive functions with forwarding
reference parameters and reference variables which refer to
themselves. Also adapted the check to work with
function-try-blocks.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>misc-definitions-in-headers</i> check by
replacing the local option <i>HeaderFileExtensions</i> by
the global option of the same name. Additionally, the option
<i>UseHeaderFileExtensions</i> is removed, so that the check
uses the <i>HeaderFileExtensions</i> option
unconditionally.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>misc-header-include-cycle</i> check by
avoiding crash for self include cycles.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>misc-unused-using-decls</i> check by
replacing the local option <i>HeaderFileExtensions</i> by
the global option of the same name.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>misc-use-anonymous-namespace</i> check by
replacing the local option <i>HeaderFileExtensions</i> by
the global option of the same name.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>modernize-avoid-c-arrays</i> check by
introducing the new <i>AllowStringArrays</i> option,
enabling the exclusion of array types with deduced length
initialized from string literals.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>modernize-loop-convert</i> check by ensuring
that fix-its don't remove parentheses used in <b>sizeof</b>
calls when they have array index accesses as arguments.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>modernize-use-constraints</i> check by
fixing a crash that occurred in some scenarios and excluding
system headers from analysis.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>modernize-use-nullptr</i> check to include
support for C23, which also has introduced the
<b>nullptr</b> keyword.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>modernize-use-override</i> check to also
remove any trailing whitespace when deleting the
<b>virtual</b> keyword.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>modernize-use-starts-ends-with</i> check to
also handle calls to <b>compare</b> method.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>modernize-use-std-print</i> check to not
crash if the format string parameter of the function to be
replaced is not of the expected type.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>modernize-use-using</i> check by adding
support for detection of typedefs declared on function
level.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>performance-inefficient-vector-operation</i>
fixing false negatives caused by different variable
definition type and variable initial value type in loop
initialization expression.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>performance-move-const-arg</i> check by
ignoring <b>std::move()</b> calls when their target is used
as an rvalue.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved
<i>performance-unnecessary-copy-initialization</i> check by
detecting more cases of constant access. In particular,
pointers can be analyzed, so the check now handles the
common patterns <i>const auto e = (*vector_ptr)[i]</i> and
<i>const auto e = vector_ptr-&gt;at(i);</i>. Calls to
mutable function where there exists a <i>const</i> overload
are also handled. Fix crash in the case of a non-member
operator call.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>performance-unnecessary-value-param</i>
check detecting more cases for template functions including
lambdas with <b>auto</b>. E.g., <b>std::sort(a.begin(),
a.end(), [](auto x, auto y) { return a &gt; b; });</b> will
be detected for expensive to copy types. Fixed false
positives for dependent call expressions.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>readability-avoid-return-with-void-value</i>
check by adding fix-its.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>readability-const-return-type</i> check to
eliminate false positives when returning types with const
not at the top level.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>readability-container-size-empty</i> check
to prevent false positives when utilizing <b>size</b> or
<b>length</b> methods that accept parameter. Fixed crash
when facing template user defined literals.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>readability-duplicate-include</i> check by
excluding include directives that form the filename using
macro.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>readability-else-after-return</i> check to
ignore <i>if consteval</i> statements, for which the
<i>else</i> branch must not be removed.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>readability-identifier-naming</i> check in
<i>GetConfigPerFile</i> mode by resolving symbolic links to
header files. Fixed handling of Hungarian Prefix when
configured to <i>LowerCase</i>. Added support for renaming
designated initializers. Added support for renaming macro
arguments. Fixed renaming conflicts arising from out-of-line
member function template definitions.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>readability-implicit-bool-conversion</i>
check to provide valid fix suggestions for
<b>static_cast</b> without a preceding space and fixed
problem with duplicate parentheses in double implicit casts.
Corrected the fix suggestions for C23 and later by using
C-style casts instead of <b>static_cast</b>. Fixed false
positives in C++20 spaceship operator by ignoring casts in
implicit and defaulted functions.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>readability-non-const-parameter</i> check to
not crash when redeclaration have fewer parameters than
expected.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>readability-redundant-inline-specifier</i>
check to properly emit warnings for static data member with
an in-class initializer.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>readability-redundant-member-init</i> check
to avoid false-positives when type of the member does not
match the type of the initializer.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved
<i>readability-static-accessed-through-instance</i> check to
support calls to overloaded operators as base expression and
provide fixes to expressions with side-effects.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>readability-simplify-boolean-expr</i> check
to avoid to emit warning for macro when IgnoreMacro option
is enabled and improve messages when auto-fix does not
work.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved
<i>readability-static-definition-in-anonymous-namespace</i>
check by resolving fix-it overlaps in template code by
disregarding implicit instances.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Improved <i>readability-string-compare</i> check to also
detect usages of <b>std::string_view::compare</b>. Added a
<i>StringLikeClasses</i> option to detect usages of
<b>compare</b> method in custom string-like classes.</p></td></tr>
</table>

<h3>Removed checks
<a name="Removed checks"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Removed <i>cert-dcl21-cpp</i>,
which was deprecated since <b>clang-tidy</b> 17, since the
rule DCL21-CPP has been removed from the CERT
guidelines.</p> </td></tr>
</table>

<h3>Miscellaneous
<a name="Miscellaneous"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Fixed incorrect formatting in
<b>clang-apply-replacements</b> when no <i>--format</i>
option is specified. Now <b>clang-apply-replacements</b>
applies formatting only with the option.</p></td></tr>
</table>

<h3>Improvements to include-fixer
<a name="Improvements to include-fixer"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The improvements
are...</p>

<h3>Improvements to clang-include-fixer
<a name="Improvements to clang-include-fixer"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The improvements
are...</p>

<h3>Improvements to modularize
<a name="Improvements to modularize"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The improvements
are...</p>

<h3>Improvements to pp-trace
<a name="Improvements to pp-trace"></a>
</h3>


<h3>Clang-tidy Visual Studio plugin
<a name="Clang-tidy Visual Studio plugin"></a>
</h3>


<h2>CLANG-TIDY
<a name="CLANG-TIDY"></a>
</h2>


<h3>Contents
<a name="Contents"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p style="margin-top: 1em"><i>Clang-Tidy</i></p></td>
<td width="76%">
</td></tr>
</table>

<p style="margin-left:12%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%"></td>
<td width="1%"></td>
<td width="42%">


<p style="margin-top: 1em"><i>Using clang-tidy</i></p></td>
<td width="44%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="42%">


<p><i>Suppressing Undesired Diagnostics</i></p></td>
<td width="44%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">See also:</p>

<h3>Clang-Tidy Checks
<a name="Clang-Tidy Checks"></a>
</h3>


<h3>abseil-cleanup-ctad
<a name="abseil-cleanup-ctad"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Suggests
switching the initialization pattern of <b>absl::Cleanup</b>
instances from the factory function to class template
argument deduction (CTAD), in C++17 and higher.</p>

<p style="margin-left:13%; margin-top: 1em">auto c1 =
absl::MakeCleanup([] {});</p>

<p style="margin-left:13%; margin-top: 1em">const auto c2 =
absl::MakeCleanup(std::function&lt;void()&gt;([] {}));</p>

<p style="margin-left:9%; margin-top: 1em">becomes</p>

<p style="margin-left:13%; margin-top: 1em">absl::Cleanup
c1 = [] {};</p>

<p style="margin-left:13%; margin-top: 1em">const
absl::Cleanup c2 = std::function&lt;void()&gt;([] {});</p>

<h3>abseil-duration-addition
<a name="abseil-duration-addition"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for cases
where addition should be performed in the <b>absl::Time</b>
domain. When adding two values, and one is known to be an
<b>absl::Time</b>, we can infer that the other should be
interpreted as an <b>absl::Duration</b> of a similar scale,
and make that inference explicit.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Addition in the integer domain <br>
int x; <br>
absl::Time t; <br>
int result = absl::ToUnixSeconds(t) + x;</p>

<p style="margin-left:13%; margin-top: 1em">// Suggestion -
Addition in the absl::Time domain <br>
int result = absl::ToUnixSeconds(t + absl::Seconds(x));</p>

<h3>abseil-duration-comparison
<a name="abseil-duration-comparison"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for
comparisons which should be in the <b>absl::Duration</b>
domain instead of the floating point or integer domains.</p>

<p style="margin-left:9%; margin-top: 1em">N.B.: In cases
where a <b>Duration</b> was being converted to an integer
and then compared against a floating-point value, truncation
during the <b>Duration</b> conversion might yield a
different result. In practice this is very rare, and still
indicates a bug which should be fixed.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Comparison in the floating point domain <br>
double x; <br>
absl::Duration d; <br>
if (x &lt; absl::ToDoubleSeconds(d)) ...</p>

<p style="margin-left:13%; margin-top: 1em">// Suggested -
Compare in the absl::Duration domain instead <br>
if (absl::Seconds(x) &lt; d) ...</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Comparison in the integer domain <br>
int x; <br>
absl::Duration d; <br>
if (x &lt; absl::ToInt64Microseconds(d)) ...</p>

<p style="margin-left:13%; margin-top: 1em">// Suggested -
Compare in the absl::Duration domain instead <br>
if (absl::Microseconds(x) &lt; d) ...</p>

<h3>abseil-duration-conversion-cast
<a name="abseil-duration-conversion-cast"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for casts
of <b>absl::Duration</b> conversion functions, and
recommends the right conversion function instead.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Cast from a double to an integer <br>
absl::Duration d; <br>
int i =
static_cast&lt;int&gt;(absl::ToDoubleSeconds(d));</p>

<p style="margin-left:13%; margin-top: 1em">// Suggested -
Use the integer conversion function directly. <br>
int i = absl::ToInt64Seconds(d);</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Cast from a double to an integer <br>
absl::Duration d; <br>
double x =
static_cast&lt;double&gt;(absl::ToInt64Seconds(d));</p>

<p style="margin-left:13%; margin-top: 1em">// Suggested -
Use the integer conversion function directly. <br>
double x = absl::ToDoubleSeconds(d);</p>

<p style="margin-left:9%; margin-top: 1em">Note: In the
second example, the suggested fix could yield a different
result, as the conversion to integer could truncate. In
practice, this is very rare, and you should use
<b>absl::Trunc</b> to perform this operation explicitly
instead.</p>

<h3>abseil-duration-division
<a name="abseil-duration-division"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>absl::Duration</b>
arithmetic works like it does with integers. That means that
division of two <b>absl::Duration</b> objects returns an
<b>int64</b> with any fractional component truncated toward
0. See <i>this link</i> for more information on arithmetic
with <b>absl::Duration</b>.</p>

<p style="margin-left:9%; margin-top: 1em">For example:</p>

<p style="margin-left:13%; margin-top: 1em">absl::Duration
d = absl::Seconds(3.5); <br>
int64 sec1 = d / absl::Seconds(1); // Truncates toward 0.
<br>
int64 sec2 = absl::ToInt64Seconds(d); // Equivalent to
division. <br>
assert(sec1 == 3 &amp;&amp; sec2 == 3);</p>

<p style="margin-left:13%; margin-top: 1em">double dsec = d
/ absl::Seconds(1); // WRONG: Still truncates toward 0. <br>
assert(dsec == 3.0);</p>

<p style="margin-left:9%; margin-top: 1em">If you want
floating-point division, you should use either the
<b>absl::FDivDuration()</b> function, or one of the unit
conversion functions such as <b>absl::ToDoubleSeconds()</b>.
For example:</p>

<p style="margin-left:13%; margin-top: 1em">absl::Duration
d = absl::Seconds(3.5); <br>
double dsec1 = absl::FDivDuration(d, absl::Seconds(1)); //
GOOD: No truncation. <br>
double dsec2 = absl::ToDoubleSeconds(d); // GOOD: No
truncation. <br>
assert(dsec1 == 3.5 &amp;&amp; dsec2 == 3.5);</p>

<p style="margin-left:9%; margin-top: 1em">This check looks
for uses of <b>absl::Duration</b> division that is done in a
floating-point context, and recommends the use of a function
that returns a floating-point value.</p>

<h3>abseil-duration-factory-float
<a name="abseil-duration-factory-float"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for cases
where the floating-point overloads of various
<b>absl::Duration</b> factory functions are called when the
more-efficient integer versions could be used instead.</p>

<p style="margin-left:9%; margin-top: 1em">This check will
not suggest fixes for literals which contain fractional
floating point values or non-literals. It will suggest
removing superfluous casts.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Providing a floating-point literal. <br>
absl::Duration d = absl::Seconds(10.0);</p>

<p style="margin-left:13%; margin-top: 1em">// Suggested -
Use an integer instead. <br>
absl::Duration d = absl::Seconds(10);</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Explicitly casting to a floating-point type. <br>
absl::Duration d =
absl::Seconds(static_cast&lt;double&gt;(10));</p>

<p style="margin-left:13%; margin-top: 1em">// Suggested -
Remove the explicit cast <br>
absl::Duration d = absl::Seconds(10);</p>

<h3>abseil-duration-factory-scale
<a name="abseil-duration-factory-scale"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for cases
where arguments to <b>absl::Duration</b> factory functions
are scaled internally and could be changed to a different
factory function. This check also looks for arguments with a
zero value and suggests using <b>absl::ZeroDuration()</b>
instead.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Internal multiplication. <br>
int x; <br>
absl::Duration d = absl::Seconds(60 * x);</p>

<p style="margin-left:13%; margin-top: 1em">// Suggested -
Use absl::Minutes instead. <br>
absl::Duration d = absl::Minutes(x);</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Internal division. <br>
int y; <br>
absl::Duration d = absl::Milliseconds(y / 1000.);</p>

<p style="margin-left:13%; margin-top: 1em">// Suggested -
Use absl:::Seconds instead. <br>
absl::Duration d = absl::Seconds(y);</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Zero-value argument. <br>
absl::Duration d = absl::Hours(0);</p>

<p style="margin-left:13%; margin-top: 1em">// Suggested =
Use absl::ZeroDuration instead <br>
absl::Duration d = absl::ZeroDuration();</p>

<h3>abseil-duration-subtraction
<a name="abseil-duration-subtraction"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for cases
where subtraction should be performed in the
<b>absl::Duration</b> domain. When subtracting two values,
and the first one is known to be a conversion from
<b>absl::Duration</b>, we can infer that the second should
also be interpreted as an <b>absl::Duration</b>, and make
that inference explicit.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Subtraction in the double domain <br>
double x; <br>
absl::Duration d; <br>
double result = absl::ToDoubleSeconds(d) - x;</p>

<p style="margin-left:13%; margin-top: 1em">// Suggestion -
Subtraction in the absl::Duration domain instead <br>
double result = absl::ToDoubleSeconds(d -
absl::Seconds(x));</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Subtraction of two Durations in the double domain <br>
absl::Duration d1, d2; <br>
double result = absl::ToDoubleSeconds(d1) -
absl::ToDoubleSeconds(d2);</p>

<p style="margin-left:13%; margin-top: 1em">// Suggestion -
Subtraction in the absl::Duration domain instead <br>
double result = absl::ToDoubleSeconds(d1 - d2);</p>

<p style="margin-left:9%; margin-top: 1em">Note: As with
other <b>clang-tidy</b> checks, it is possible that multiple
fixes may overlap (as in the case of nested expressions), so
not all occurrences can be transformed in one run. In
particular, this may occur for nested subtraction
expressions. Running <b>clang-tidy</b> multiple times will
find and fix these overlaps.</p>

<h3>abseil-duration-unnecessary-conversion
<a name="abseil-duration-unnecessary-conversion"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds and fixes
cases where <b>absl::Duration</b> values are being converted
to numeric types and back again.</p>

<p style="margin-left:9%; margin-top: 1em">Floating-point
examples:</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Conversion to double and back again <br>
absl::Duration d1; <br>
absl::Duration d2 =
absl::Seconds(absl::ToDoubleSeconds(d1));</p>

<p style="margin-left:13%; margin-top: 1em">// Suggestion -
Remove unnecessary conversions <br>
absl::Duration d2 = d1;</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Division to convert to double and back again <br>
absl::Duration d2 = absl::Seconds(absl::FDivDuration(d1,
absl::Seconds(1)));</p>

<p style="margin-left:13%; margin-top: 1em">// Suggestion -
Remove division and conversion <br>
absl::Duration d2 = d1;</p>

<p style="margin-left:9%; margin-top: 1em">Integer
examples:</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Conversion to integer and back again <br>
absl::Duration d1; <br>
absl::Duration d2 = absl::Hours(absl::ToInt64Hours(d1));</p>

<p style="margin-left:13%; margin-top: 1em">// Suggestion -
Remove unnecessary conversions <br>
absl::Duration d2 = d1;</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Integer division followed by conversion <br>
absl::Duration d2 = absl::Seconds(d1 /
absl::Seconds(1));</p>

<p style="margin-left:13%; margin-top: 1em">// Suggestion -
Remove division and conversion <br>
absl::Duration d2 = d1;</p>

<p style="margin-left:9%; margin-top: 1em">Unwrapping
scalar operations:</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Multiplication by a scalar <br>
absl::Duration d1; <br>
absl::Duration d2 = absl::Seconds(absl::ToInt64Seconds(d1) *
2);</p>

<p style="margin-left:13%; margin-top: 1em">// Suggestion -
Remove unnecessary conversion <br>
absl::Duration d2 = d1 * 2;</p>

<p style="margin-left:9%; margin-top: 1em">Note: Converting
to an integer and back to an <b>absl::Duration</b> might be
a truncating operation if the value is not aligned to the
scale of conversion. In the rare case where this is the
intended result, callers should use <b>absl::Trunc</b> to
truncate explicitly.</p>

<h3>abseil-faster-strsplit-delimiter
<a name="abseil-faster-strsplit-delimiter"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds instances
of <b>absl::StrSplit()</b> or <b>absl::MaxSplits()</b> where
the delimiter is a single character string literal and
replaces with a character. The check will offer a suggestion
to change the string literal into a character. It will also
catch code using <b>absl::ByAnyChar()</b> for just a single
character and will transform that into a single character as
well.</p>

<p style="margin-left:9%; margin-top: 1em">These changes
will give the same result, but using characters rather than
single character string literals is more efficient and
readable.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
the argument is a string literal. <br>
for (auto piece : absl::StrSplit(str, &quot;B&quot;)) {</p>

<p style="margin-left:13%; margin-top: 1em">// Suggested -
the argument is a character, which causes the more efficient
<br>
// overload of absl::StrSplit() to be used. <br>
for (auto piece : absl::StrSplit(str, 'B')) {</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
the argument is a string literal inside absl::ByAnyChar
call. <br>
for (auto piece : absl::StrSplit(str,
absl::ByAnyChar(&quot;B&quot;))) {</p>

<p style="margin-left:13%; margin-top: 1em">// Suggested -
the argument is a character, which causes the more efficient
<br>
// overload of absl::StrSplit() to be used and we do not
need absl::ByAnyChar <br>
// anymore. <br>
for (auto piece : absl::StrSplit(str, 'B')) {</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
the argument is a string literal inside absl::MaxSplits
call. <br>
for (auto piece : absl::StrSplit(str,
absl::MaxSplits(&quot;B&quot;, 1))) {</p>

<p style="margin-left:13%; margin-top: 1em">// Suggested -
the argument is a character, which causes the more efficient
<br>
// overload of absl::StrSplit() to be used. <br>
for (auto piece : absl::StrSplit(str, absl::MaxSplits('B',
1))) {</p>

<h3>abseil-no-internal-dependencies
<a name="abseil-no-internal-dependencies"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns if code
using Abseil depends on internal details. If something is in
a namespace that includes the word &quot;internal&quot;,
code is not allowed to depend upon it because it's an
implementation detail. They cannot friend it, include it,
you mention it or refer to it in any way. Doing so violates
Abseil's compatibility guidelines and may result in
breakage. See <i>https://abseil.io/about/compatibility</i>
for more information.</p>

<p style="margin-left:9%; margin-top: 1em">The following
cases will result in warnings:</p>


<p style="margin-left:13%; margin-top: 1em">absl::strings_internal::foo();
<br>
// warning triggered on this line <br>
class foo { <br>
friend struct absl::container_internal::faa; <br>
// warning triggered on this line <br>
}; <br>
absl::memory_internal::MakeUniqueResult(); <br>
// warning triggered on this line</p>

<h3>abseil-no-namespace
<a name="abseil-no-namespace"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Ensures code
does not open <b>namespace absl</b> as that violates
Abseil's compatibility guidelines. Code should not open
<b>namespace absl</b> as that conflicts with Abseil's
compatibility guidelines and may result in breakage.</p>

<p style="margin-left:9%; margin-top: 1em">Any code that
uses:</p>

<p style="margin-left:13%; margin-top: 1em">namespace absl
{ <br>
... <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">will be prompted
with a warning.</p>

<p style="margin-left:9%; margin-top: 1em">See <i>the full
Abseil compatibility guidelines</i> for more
information.</p>

<h3>abseil-redundant-strcat-calls
<a name="abseil-redundant-strcat-calls"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Suggests removal
of unnecessary calls to <b>absl::StrCat</b> when the result
is being passed to another call to <b>absl::StrCat</b> or
<b>absl::StrAppend</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The extra calls
cause unnecessary temporary strings to be constructed.
Removing them makes the code smaller and faster.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">std::string s =
absl::StrCat(&quot;A&quot;, absl::StrCat(&quot;B&quot;,
absl::StrCat(&quot;C&quot;, &quot;D&quot;))); <br>
//before</p>

<p style="margin-left:13%; margin-top: 1em">std::string s =
absl::StrCat(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;,
&quot;D&quot;); <br>
//after</p>


<p style="margin-left:13%; margin-top: 1em">absl::StrAppend(&amp;s,
absl::StrCat(&quot;E&quot;, &quot;F&quot;, &quot;G&quot;));
<br>
//before</p>


<p style="margin-left:13%; margin-top: 1em">absl::StrAppend(&amp;s,
&quot;E&quot;, &quot;F&quot;, &quot;G&quot;); <br>
//after</p>

<h3>abseil-str-cat-append
<a name="abseil-str-cat-append"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Flags uses of
<b>absl::StrCat()</b> to append to a <b>std::string</b>.
Suggests <b>absl::StrAppend()</b> should be used
instead.</p>

<p style="margin-left:9%; margin-top: 1em">The extra calls
cause unnecessary temporary strings to be constructed.
Removing them makes the code smaller and faster.</p>

<p style="margin-left:13%; margin-top: 1em">a =
absl::StrCat(a, b); // Use absl::StrAppend(&amp;a, b)
instead.</p>

<p style="margin-left:9%; margin-top: 1em">Does not
diagnose cases where <b>absl::StrCat()</b> is used as a
template argument for a functor.</p>

<h3>abseil-string-find-startswith
<a name="abseil-string-find-startswith"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks whether a
<b>std::string::find()</b> or <b>std::string::rfind()</b>
(and corresponding <b>std::string_view</b> methods) result
is compared with 0, and suggests replacing with
<b>absl::StartsWith()</b>. This is both a readability and
performance issue.</p>


<p style="margin-left:9%; margin-top: 1em"><b>starts_with</b>
was added as a built-in function on those types in C++20. If
available, prefer enabling
<i>modernize-use-starts-ends-with</i> instead of this
check.</p>

<p style="margin-left:13%; margin-top: 1em">string s =
&quot;...&quot;; <br>
if (s.find(&quot;Hello World&quot;) == 0) { /* do something
*/ } <br>
if (s.rfind(&quot;Hello World&quot;, 0) == 0) { /* do
something */ }</p>

<p style="margin-left:9%; margin-top: 1em">becomes</p>

<p style="margin-left:13%; margin-top: 1em">string s =
&quot;...&quot;; <br>
if (absl::StartsWith(s, &quot;Hello World&quot;)) { /* do
something */ } <br>
if (absl::StartsWith(s, &quot;Hello World&quot;)) { /* do
something */ }</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>StringLikeClasses</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
names of string-like classes. By default both
<b>std::basic_string</b> and <b>std::basic_string_view</b>
are considered. The list of methods to be considered is
fixed.</p>

<p style="margin-left:9%;"><b>IncludeStyle</b></p>

<p style="margin-left:18%;">A string specifying which
include-style is used, <i>llvm</i> or <i>google</i>. Default
is <i>llvm</i>.</p>


<p style="margin-left:9%;"><b>AbseilStringsMatchHeader</b></p>

<p style="margin-left:18%;">The location of Abseil's
<b>strings/match.h</b>. Defaults to
<b>absl/strings/match.h</b>.</p>

<h3>abseil-string-find-str-contains
<a name="abseil-string-find-str-contains"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
<b>s.find(...) == string::npos</b> comparisons (for various
string-like types) and suggests replacing with
<b>absl::StrContains()</b>.</p>

<p style="margin-left:9%; margin-top: 1em">This improves
readability and reduces the likelihood of accidentally
mixing <b>find()</b> and <b>npos</b> from different
string-like types.</p>

<p style="margin-left:9%; margin-top: 1em">By default,
&quot;string-like types&quot; includes
<b>::std::basic_string</b>, <b>::std::basic_string_view</b>,
and <b>::absl::string_view</b>. See the StringLikeClasses
option to change this.</p>

<p style="margin-left:13%; margin-top: 1em">std::string s =
&quot;...&quot;; <br>
if (s.find(&quot;Hello World&quot;) == std::string::npos) {
/* do something */ }</p>


<p style="margin-left:13%; margin-top: 1em">absl::string_view
a = &quot;...&quot;; <br>
if (absl::string_view::npos != a.find(&quot;Hello
World&quot;)) { /* do something */ }</p>

<p style="margin-left:9%; margin-top: 1em">becomes</p>

<p style="margin-left:13%; margin-top: 1em">std::string s =
&quot;...&quot;; <br>
if (!absl::StrContains(s, &quot;Hello World&quot;)) { /* do
something */ }</p>


<p style="margin-left:13%; margin-top: 1em">absl::string_view
a = &quot;...&quot;; <br>
if (absl::StrContains(a, &quot;Hello World&quot;)) { /* do
something */ }</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>StringLikeClasses</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
names of string-like classes. By default includes
<b>::std::basic_string</b>, <b>::std::basic_string_view</b>,
and <b>::absl::string_view</b>.</p>

<p style="margin-left:9%;"><b>IncludeStyle</b></p>

<p style="margin-left:18%;">A string specifying which
include-style is used, <i>llvm</i> or <i>google</i>. Default
is <i>llvm</i>.</p>


<p style="margin-left:9%;"><b>AbseilStringsMatchHeader</b></p>

<p style="margin-left:18%;">The location of Abseil's
<b>strings/match.h</b>. Defaults to
<b>absl/strings/match.h</b>.</p>

<h3>abseil-time-comparison
<a name="abseil-time-comparison"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Prefer
comparisons in the <b>absl::Time</b> domain instead of the
integer domain.</p>

<p style="margin-left:9%; margin-top: 1em">N.B.: In cases
where an <b>absl::Time</b> is being converted to an integer,
alignment may occur. If the comparison depends on this
alignment, doing the comparison in the <b>absl::Time</b>
domain may yield a different result. In practice this is
very rare, and still indicates a bug which should be
fixed.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Comparison in the integer domain <br>
int x; <br>
absl::Time t; <br>
if (x &lt; absl::ToUnixSeconds(t)) ...</p>

<p style="margin-left:13%; margin-top: 1em">// Suggested -
Compare in the absl::Time domain instead <br>
if (absl::FromUnixSeconds(x) &lt; t) ...</p>

<h3>abseil-time-subtraction
<a name="abseil-time-subtraction"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds and fixes
<b>absl::Time</b> subtraction expressions to do subtraction
in the Time domain instead of the numeric domain.</p>

<p style="margin-left:9%; margin-top: 1em">There are two
cases of Time subtraction in which deduce additional type
information:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>When the result is an <b>absl::Duration</b> and the
first argument is an <b>absl::Time</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>When the second argument is a <b>absl::Time</b>.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">In the first
case, we must know the result of the operation, since
without that the second operand could be either an
<b>absl::Time</b> or an <b>absl::Duration</b>. In the second
case, the first operand <i>must</i> be an <b>absl::Time</b>,
because subtracting an <b>absl::Time</b> from an
<b>absl::Duration</b> is not defined.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">int x; <br>
absl::Time t;</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
absl::Duration result and first operand is an absl::Time.
<br>
absl::Duration d = absl::Seconds(absl::ToUnixSeconds(t) -
x);</p>

<p style="margin-left:13%; margin-top: 1em">// Suggestion -
Perform subtraction in the Time domain instead. <br>
absl::Duration d = t - absl::FromUnixSeconds(x);</p>

<p style="margin-left:13%; margin-top: 1em">// Original -
Second operand is an absl::Time. <br>
int i = x - absl::ToUnixSeconds(t);</p>

<p style="margin-left:13%; margin-top: 1em">// Suggestion -
Perform subtraction in the Time domain instead. <br>
int i = absl::ToInt64Seconds(absl::FromUnixSeconds(x) -
t);</p>

<h3>abseil-upgrade-duration-conversions
<a name="abseil-upgrade-duration-conversions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds calls to
<b>absl::Duration</b> arithmetic operators and factories
whose argument needs an explicit cast to continue compiling
after upcoming API changes.</p>

<p style="margin-left:9%; margin-top: 1em">The operators
<b>*=</b>, <b>/=</b>, <b>*</b>, and <b>/</b> for
<b>absl::Duration</b> currently accept an argument of class
type that is convertible to an arithmetic type. Such a call
currently converts the value to an <b>int64_t</b>, even in a
case such as <b>std::atomic&lt;float&gt;</b> that would
result in lossy conversion.</p>

<p style="margin-left:9%; margin-top: 1em">Additionally,
the <b>absl::Duration</b> factory functions
(<b>absl::Hours</b>, <b>absl::Minutes</b>, etc) currently
accept an <b>int64_t</b> or a floating-point type. Similar
to the arithmetic operators, calls with an argument of class
type that is convertible to an arithmetic type go through
the <b>int64_t</b> path.</p>

<p style="margin-left:9%; margin-top: 1em">These operators
and factories will be changed to only accept arithmetic
types to prevent unintended behavior. After these changes
are released, passing an argument of class type will no
longer compile, even if the type is implicitly convertible
to an arithmetic type.</p>

<p style="margin-left:9%; margin-top: 1em">Here are example
fixes created by this check:</p>


<p style="margin-left:13%; margin-top: 1em">std::atomic&lt;int&gt;
a; <br>
absl::Duration d = absl::Milliseconds(a); <br>
d *= a;</p>

<p style="margin-left:9%; margin-top: 1em">becomes</p>


<p style="margin-left:13%; margin-top: 1em">std::atomic&lt;int&gt;
a; <br>
absl::Duration d =
absl::Milliseconds(static_cast&lt;int64_t&gt;(a)); <br>
d *= static_cast&lt;int64_t&gt;(a);</p>

<p style="margin-left:9%; margin-top: 1em">Note that this
check always adds a cast to <b>int64_t</b> in order to
preserve the current behavior of user code. It is possible
that this uncovers unintended behavior due to types
implicitly convertible to a floating-point type.</p>

<h3>altera-id-dependent-backward-branch
<a name="altera-id-dependent-backward-branch"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
ID-dependent variables and fields that are used within
loops. This causes branches to occur inside the loops, and
thus leads to performance degradation.</p>

<p style="margin-left:13%; margin-top: 1em">// The
following code will produce a warning because this
ID-dependent <br>
// variable is used in a loop condition statement. <br>
int ThreadID = get_local_id(0);</p>

<p style="margin-left:13%; margin-top: 1em">// The
following loop will produce a warning because the loop
condition <br>
// statement depends on an ID-dependent variable. <br>
for (int i = 0; i &lt; ThreadID; ++i) { <br>
std::cout &lt;&lt; i &lt;&lt; std::endl; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// The
following loop will not produce a warning, because the
ID-dependent <br>
// variable is not used in the loop condition statement.
<br>
for (int i = 0; i &lt; 100; ++i) { <br>
std::cout &lt;&lt; ThreadID &lt;&lt; std::endl; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Based on the
<i>Altera SDK for OpenCL: Best Practices Guide</i>.</p>

<h3>altera-kernel-name-restriction
<a name="altera-kernel-name-restriction"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds kernel
files and include directives whose filename is
<i>kernel.cl</i>, <i>Verilog.cl</i>, or <i>VHDL.cl</i>. The
check is case insensitive.</p>

<p style="margin-left:9%; margin-top: 1em">Such kernel file
names cause the offline compiler to generate intermediate
design files that have the same names as certain internal
files, which leads to a compilation error.</p>

<p style="margin-left:9%; margin-top: 1em">Based on the
<i>Guidelines for Naming the Kernel</i> section in the
<i>Intel FPGA SDK for OpenCL Pro Edition: Programming
Guide</i>.</p>

<h3>altera-single-work-item-barrier
<a name="altera-single-work-item-barrier"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds OpenCL
kernel functions that call a barrier function but do not
call an ID function (<b>get_local_id</b>,
<b>get_local_id</b>, <b>get_group_id</b>, or
<b>get_local_linear_id</b>).</p>

<p style="margin-left:9%; margin-top: 1em">These kernels
may be viable single work-item kernels, but will be forced
to execute as NDRange kernels if using a newer version of
the Altera Offline Compiler (&gt;= v17.01).</p>

<p style="margin-left:9%; margin-top: 1em">If using an
older version of the Altera Offline Compiler, these kernel
functions will be treated as single work-item kernels, which
could be inefficient or lead to errors if NDRange semantics
were intended.</p>

<p style="margin-left:9%; margin-top: 1em">Based on the
<i>Altera SDK for OpenCL: Best Practices Guide</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">// error:
function calls barrier but does not call an ID function.
<br>
void __kernel barrier_no_id(__global int * foo, int size) {
<br>
for (int i = 0; i &lt; 100; i++) { <br>
foo[i] += 5; <br>
} <br>
barrier(CLK_GLOBAL_MEM_FENCE); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// ok: function
calls barrier and an ID function. <br>
void __kernel barrier_with_id(__global int * foo, int size)
{ <br>
for (int i = 0; i &lt; 100; i++) { <br>
int tid = get_global_id(0); <br>
foo[tid] += 5; <br>
} <br>
barrier(CLK_GLOBAL_MEM_FENCE); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// ok with AOC
Version 17.01: the reqd_work_group_size turns this into <br>
// an NDRange. <br>
__attribute__((reqd_work_group_size(2,2,2))) <br>
void __kernel barrier_with_id(__global int * foo, int size)
{ <br>
for (int i = 0; i &lt; 100; i++) { <br>
foo[tid] += 5; <br>
} <br>
barrier(CLK_GLOBAL_MEM_FENCE); <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>AOCVersion</b></p>

<p style="margin-left:18%;">Defines the version of the
Altera Offline Compiler. Defaults to <b>1600</b>
(corresponding to version 16.00).</p>

<h3>altera-struct-pack-align
<a name="altera-struct-pack-align"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds structs
that are inefficiently packed or aligned, and recommends
packing and/or aligning of said structs as needed.</p>

<p style="margin-left:9%; margin-top: 1em">Structs that are
not packed take up more space than they should, and
accessing structs that are not well aligned is
inefficient.</p>

<p style="margin-left:9%; margin-top: 1em">Fix-its are
provided to fix both of these issues by inserting and/or
amending relevant struct attributes.</p>

<p style="margin-left:9%; margin-top: 1em">Based on the
<i>Altera SDK for OpenCL: Best Practices Guide</i>.</p>

<p style="margin-left:13%; margin-top: 1em">// The
following struct is originally aligned to 4 bytes, and thus
takes up <br>
// 12 bytes of memory instead of 10. Packing the struct will
make it use <br>
// only 10 bytes of memory, and aligning it to 16 bytes will
make it <br>
// efficient to access. <br>
struct example { <br>
char a; // 1 byte <br>
double b; // 8 bytes <br>
char c; // 1 byte <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">// The
following struct is arranged in such a way that packing is
not needed. <br>
// However, it is aligned to 4 bytes instead of 8, and thus
needs to be <br>
// explicitly aligned. <br>
struct implicitly_packed_example { <br>
char a; // 1 byte <br>
char b; // 1 byte <br>
char c; // 1 byte <br>
char d; // 1 byte <br>
int e; // 4 bytes <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">// The
following struct is explicitly aligned and packed. <br>
struct good_example { <br>
char a; // 1 byte <br>
double b; // 8 bytes <br>
char c; // 1 byte <br>
} __attribute__((packed)) __attribute__((aligned(16));</p>

<p style="margin-left:13%; margin-top: 1em">// Explicitly
aligning a struct to the wrong value will result in a
warning. <br>
// The following example should be aligned to 16 bytes, not
32. <br>
struct badly_aligned_example { <br>
char a; // 1 byte <br>
double b; // 8 bytes <br>
char c; // 1 byte <br>
} __attribute__((packed)) __attribute__((aligned(32)));</p>

<h3>altera-unroll-loops
<a name="altera-unroll-loops"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds inner
loops that have not been unrolled, as well as fully unrolled
loops with unknown loop bounds or a large number of
iterations.</p>

<p style="margin-left:9%; margin-top: 1em">Unrolling inner
loops could improve the performance of OpenCL kernels.
However, if they have unknown loop bounds or a large number
of iterations, they cannot be fully unrolled, and should be
partially unrolled.</p>

<p style="margin-left:9%; margin-top: 1em">Notes:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>This check is unable to determine the number of
iterations in a <b>while</b> or <b>do..while</b> loop; hence
if such a loop is fully unrolled, a note is emitted advising
the user to partially unroll instead.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>In <b>for</b> loops, our check only works with simple
arithmetic increments ( <b>+</b>, <b>-</b>, <b>*</b>,
<b>/</b>). For all other increments, partial unrolling is
advised.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Depending on the exit condition, the calculations for
determining if the number of iterations is large may be off
by 1. This should not be an issue since the cut-off is
generally arbitrary.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Based on the
<i>Altera SDK for OpenCL: Best Practices Guide</i>.</p>

<p style="margin-left:13%; margin-top: 1em">for (int i = 0;
i &lt; 10; i++) { // ok: outer loops should not be unrolled
<br>
int j = 0; <br>
do { // warning: this inner do..while loop should be
unrolled <br>
j++; <br>
} while (j &lt; 15);</p>

<p style="margin-left:13%; margin-top: 1em">int k = 0; <br>
#pragma unroll <br>
while (k &lt; 20) { // ok: this inner loop is already
unrolled <br>
k++; <br>
} <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int A[1000];
<br>
#pragma unroll <br>
// warning: this loop is large and should be partially
unrolled <br>
for (int a : A) { <br>
printf(&quot;%d&quot;, a); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">#pragma unroll
5 <br>
// ok: this loop is large, but is partially unrolled <br>
for (int a : A) { <br>
printf(&quot;%d&quot;, a); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">#pragma unroll
<br>
// warning: this loop is large and should be partially
unrolled <br>
for (int i = 0; i &lt; 1000; ++i) { <br>
printf(&quot;%d&quot;, i); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">#pragma unroll
5 <br>
// ok: this loop is large, but is partially unrolled <br>
for (int i = 0; i &lt; 1000; ++i) { <br>
printf(&quot;%d&quot;, i); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">#pragma unroll
<br>
// warning: &lt;&lt; operator not supported, recommend
partial unrolling <br>
for (int i = 0; i &lt; 1000; i&lt;&lt;1) { <br>
printf(&quot;%d&quot;, i); <br>
}</p>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;int&gt;
someVector (100, 0); <br>
int i = 0; <br>
#pragma unroll <br>
// note: loop may be large, recommend partial unrolling <br>
while (i &lt; someVector.size()) { <br>
someVector[i]++; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">#pragma unroll
<br>
// note: loop may be large, recommend partial unrolling <br>
while (true) { <br>
printf(&quot;In loop&quot;); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">#pragma unroll
5 <br>
// ok: loop may be large, but is partially unrolled <br>
while (i &lt; someVector.size()) { <br>
someVector[i]++; <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>MaxLoopIterations</b></p>

<p style="margin-left:18%;">Defines the maximum number of
loop iterations that a fully unrolled loop can have. By
default, it is set to <i>100</i>.</p>

<p style="margin-left:18%; margin-top: 1em">In practice,
this refers to the integer value of the upper bound within
the loop statement's condition expression.</p>

<h3>android-cloexec-accept
<a name="android-cloexec-accept"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The usage of
<b>accept()</b> is not recommended, it's better to use
<b>accept4()</b>. Without this flag, an opened sensitive
file descriptor would remain open across a fork+exec to a
lower-privileged SELinux domain.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">accept(sockfd,
addr, addrlen);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>


<p style="margin-left:13%; margin-top: 1em">accept4(sockfd,
addr, addrlen, SOCK_CLOEXEC);</p>

<h3>android-cloexec-accept4
<a name="android-cloexec-accept4"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>accept4()</b>
should include <b>SOCK_CLOEXEC</b> in its type argument to
avoid the file descriptor leakage. Without this flag, an
opened sensitive file would remain open across a fork+exec
to a lower-privileged SELinux domain.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>


<p style="margin-left:13%; margin-top: 1em">accept4(sockfd,
addr, addrlen, SOCK_NONBLOCK);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>


<p style="margin-left:13%; margin-top: 1em">accept4(sockfd,
addr, addrlen, SOCK_NONBLOCK | SOCK_CLOEXEC);</p>

<h3>android-cloexec-creat
<a name="android-cloexec-creat"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The usage of
<b>creat()</b> is not recommended, it's better to use
<b>open()</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">int fd =
creat(path, mode);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">int fd =
open(path, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC,
mode);</p>

<h3>android-cloexec-dup
<a name="android-cloexec-dup"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The usage of
<b>dup()</b> is not recommended, it's better to use
<b>fcntl()</b>, which can set the close-on-exec flag.
Otherwise, an opened sensitive file would remain open across
a fork+exec to a lower-privileged SELinux domain.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">int fd =
dup(oldfd);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">int fd =
fcntl(oldfd, F_DUPFD_CLOEXEC);</p>

<h3>android-cloexec-epoll-create
<a name="android-cloexec-epoll-create"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The usage of
<b>epoll_create()</b> is not recommended, it's better to use
<b>epoll_create1()</b>, which allows close-on-exec.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>


<p style="margin-left:13%; margin-top: 1em">epoll_create(size);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>


<p style="margin-left:13%; margin-top: 1em">epoll_create1(EPOLL_CLOEXEC);</p>

<h3>android-cloexec-epoll-create1
<a name="android-cloexec-epoll-create1"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>epoll_create1()</b>
should include <b>EPOLL_CLOEXEC</b> in its type argument to
avoid the file descriptor leakage. Without this flag, an
opened sensitive file would remain open across a fork+exec
to a lower-privileged SELinux domain.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>


<p style="margin-left:13%; margin-top: 1em">epoll_create1(0);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>


<p style="margin-left:13%; margin-top: 1em">epoll_create1(EPOLL_CLOEXEC);</p>

<h3>android-cloexec-fopen
<a name="android-cloexec-fopen"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>fopen()</b>
should include <b>e</b> in their mode string; so <b>re</b>
would be valid. This is equivalent to having set
<b>FD_CLOEXEC on</b> that descriptor.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>


<p style="margin-left:13%; margin-top: 1em">fopen(&quot;fn&quot;,
&quot;r&quot;);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>


<p style="margin-left:13%; margin-top: 1em">fopen(&quot;fn&quot;,
&quot;re&quot;);</p>

<h3>android-cloexec-inotify-init
<a name="android-cloexec-inotify-init"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The usage of
<b>inotify_init()</b> is not recommended, it's better to use
<b>inotify_init1()</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>


<p style="margin-left:13%; margin-top: 1em">inotify_init();</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>


<p style="margin-left:13%; margin-top: 1em">inotify_init1(IN_CLOEXEC);</p>

<h3>android-cloexec-inotify-init1
<a name="android-cloexec-inotify-init1"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>inotify_init1()</b>
should include <b>IN_CLOEXEC</b> in its type argument to
avoid the file descriptor leakage. Without this flag, an
opened sensitive file would remain open across a fork+exec
to a lower-privileged SELinux domain.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>


<p style="margin-left:13%; margin-top: 1em">inotify_init1(IN_NONBLOCK);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>


<p style="margin-left:13%; margin-top: 1em">inotify_init1(IN_NONBLOCK
| IN_CLOEXEC);</p>

<h3>android-cloexec-memfd-create
<a name="android-cloexec-memfd-create"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>memfd_create()</b>
should include <b>MFD_CLOEXEC</b> in its type argument to
avoid the file descriptor leakage. Without this flag, an
opened sensitive file would remain open across a fork+exec
to a lower-privileged SELinux domain.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>


<p style="margin-left:13%; margin-top: 1em">memfd_create(name,
MFD_ALLOW_SEALING);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>


<p style="margin-left:13%; margin-top: 1em">memfd_create(name,
MFD_ALLOW_SEALING | MFD_CLOEXEC);</p>

<h3>android-cloexec-open
<a name="android-cloexec-open"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">A common source
of security bugs is code that opens a file without using the
<b>O_CLOEXEC</b> flag. Without that flag, an opened
sensitive file would remain open across a fork+exec to a
lower-privileged SELinux domain, leaking that sensitive
data. Open-like functions including <b>open()</b>,
<b>openat()</b>, and <b>open64()</b> should include
<b>O_CLOEXEC</b> in their flags argument.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>


<p style="margin-left:13%; margin-top: 1em">open(&quot;filename&quot;,
O_RDWR); <br>
open64(&quot;filename&quot;, O_RDWR); <br>
openat(0, &quot;filename&quot;, O_RDWR);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>


<p style="margin-left:13%; margin-top: 1em">open(&quot;filename&quot;,
O_RDWR | O_CLOEXEC); <br>
open64(&quot;filename&quot;, O_RDWR | O_CLOEXEC); <br>
openat(0, &quot;filename&quot;, O_RDWR | O_CLOEXEC);</p>

<h3>android-cloexec-pipe
<a name="android-cloexec-pipe"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
detects usage of <b>pipe()</b>. Using <b>pipe()</b> is not
recommended, <b>pipe2()</b> is the suggested replacement.
The check also adds the O_CLOEXEC flag that marks the file
descriptor to be closed in child processes. Without this
flag a sensitive file descriptor can be leaked to a child
process, potentially into a lower-privileged SELinux
domain.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>


<p style="margin-left:13%; margin-top: 1em">pipe(pipefd);</p>

<p style="margin-left:9%; margin-top: 1em">Suggested
replacement:</p>

<p style="margin-left:13%; margin-top: 1em">pipe2(pipefd,
O_CLOEXEC);</p>

<h3>android-cloexec-pipe2
<a name="android-cloexec-pipe2"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
ensures that pipe2() is called with the O_CLOEXEC flag. The
check also adds the O_CLOEXEC flag that marks the file
descriptor to be closed in child processes. Without this
flag a sensitive file descriptor can be leaked to a child
process, potentially into a lower-privileged SELinux
domain.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">pipe2(pipefd,
O_NONBLOCK);</p>

<p style="margin-left:9%; margin-top: 1em">Suggested
replacement:</p>

<p style="margin-left:13%; margin-top: 1em">pipe2(pipefd,
O_NONBLOCK | O_CLOEXEC);</p>

<h3>android-cloexec-socket
<a name="android-cloexec-socket"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>socket()</b>
should include <b>SOCK_CLOEXEC</b> in its type argument to
avoid the file descriptor leakage. Without this flag, an
opened sensitive file would remain open across a fork+exec
to a lower-privileged SELinux domain.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">socket(domain,
type, SOCK_STREAM);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">socket(domain,
type, SOCK_STREAM | SOCK_CLOEXEC);</p>

<h3>android-comparison-in-temp-failure-retry
<a name="android-comparison-in-temp-failure-retry"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Diagnoses
comparisons that appear to be incorrectly placed in the
argument to the <b>TEMP_FAILURE_RETRY</b> macro. Having such
a use is incorrect in the vast majority of cases, and will
often silently defeat the purpose of the
<b>TEMP_FAILURE_RETRY</b> macro.</p>

<p style="margin-left:9%; margin-top: 1em">For context,
<b>TEMP_FAILURE_RETRY</b> is <i>a convenience macro</i>
provided by both glibc and Bionic. Its purpose is to
repeatedly run a syscall until it either succeeds, or fails
for reasons other than being interrupted.</p>

<p style="margin-left:9%; margin-top: 1em">Example buggy
usage looks like:</p>

<p style="margin-left:13%; margin-top: 1em">char cs[1];
<br>
while (TEMP_FAILURE_RETRY(read(STDIN_FILENO, cs, sizeof(cs))
!= 0)) { <br>
// Do something with cs. <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Because
TEMP_FAILURE_RETRY will check for whether the result <i>of
the comparison</i> is <b>-1</b>, and retry if so.</p>

<p style="margin-left:9%; margin-top: 1em">If you encounter
this, the fix is simple: lift the comparison out of the
<b>TEMP_FAILURE_RETRY</b> argument, like so:</p>

<p style="margin-left:13%; margin-top: 1em">char cs[1];
<br>
while (TEMP_FAILURE_RETRY(read(STDIN_FILENO, cs,
sizeof(cs))) != 0) { <br>
// Do something with cs. <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>RetryMacros</b></p>

<p style="margin-left:18%;">A comma-separated list of the
names of retry macros to be checked.</p>

<h3>boost-use-ranges
<a name="boost-use-ranges"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects calls to
standard library iterator algorithms that could be replaced
with a Boost ranges version instead.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">auto Iter1 =
std::find(Items.begin(), Items.end(), 0); <br>
auto AreSame = std::equal(Items1.cbegin(), Items1.cend(),
std::begin(Items2), <br>
std::end(Items2));</p>

<p style="margin-left:9%; margin-top: 1em">Transforms
to:</p>

<p style="margin-left:13%; margin-top: 1em">auto Iter1 =
boost::range::find(Items, 0); <br>
auto AreSame = boost::range::equal(Items1, Items2);</p>

<h3>Supported algorithms
<a name="Supported algorithms"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Calls to the
following std library algorithms are checked:</p>


<p style="margin-left:9%; margin-top: 1em"><b>std::accumulate</b>,
<b>std::adjacent_difference</b>, <b>std::adjacent_find</b>,
<b>std::all_of</b>, <b>std::any_of</b>,
<b>std::binary_search</b>, <b>std::copy_backward</b>,
<b>std::copy_if</b>, <b>std::copy</b>, <b>std::count_if</b>,
<b>std::count</b>, <b>std::equal_range</b>,
<b>std::equal</b>, <b>std::fill</b>, <b>std::find_end</b>,
<b>std::find_first_of</b>, <b>std::find_if_not</b>,
<b>std::find_if</b>, <b>std::find</b>, <b>std::for_each</b>,
<b>std::generate</b>, <b>std::includes</b>,
<b>std::iota</b>, <b>std::is_partitioned</b>,
<b>std::is_permutation</b>, <b>std::is_sorted_until</b>,
<b>std::is_sorted</b>, <b>std::lexicographical_compare</b>,
<b>std::lower_bound</b>, <b>std::make_heap</b>,
<b>std::max_element</b>, <b>std::merge</b>,
<b>std::min_element</b>, <b>std::mismatch</b>,
<b>std::next_permutation</b>, <b>std::none_of</b>,
<b>std::parital_sum</b>, <b>std::partial_sort_copy</b>,
<b>std::partition_copy</b>, <b>std::partition_point</b>,
<b>std::partition</b>, <b>std::pop_heap</b>,
<b>std::prev_permutation</b>, <b>std::push_heap</b>,
<b>std::random_shuffle</b>, <b>std::reduce</b>,
<b>std::remove_copy_if</b>, <b>std::remove_copy</b>,
<b>std::remove_if</b>, <b>std::remove</b>,
<b>std::replace_copy_if</b>, <b>std::replace_copy</b>,
<b>std::replace_if</b>, <b>std::replace</b>,
<b>std::reverse_copy</b>, <b>std::reverse</b>,
<b>std::search</b>, <b>std::set_difference</b>,
<b>std::set_intersection</b>,
<b>std::set_symmetric_difference</b>, <b>std::set_union</b>,
<b>std::sort_heap</b>, <b>std::sort</b>,
<b>std::stable_partition</b>, <b>std::stable_sort</b>,
<b>std::transform</b>, <b>std::unique_copy</b>,
<b>std::unique</b>, <b>std::upper_bound</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The check will
also look for the following functions from the
<b>boost::algorithm</b> namespace:</p>


<p style="margin-left:9%; margin-top: 1em"><b>all_of_equal</b>,
<b>any_of_equal</b>, <b>any_of</b>,
<b>apply_permutation</b>, <b>apply_reverse_permutation</b>,
<b>clamp_range</b>, <b>copy_if_until</b>,
<b>copy_if_while</b>, <b>copy_if</b>, <b>copy_until</b>,
<b>copy_while</b>, <b>find_backward</b>,
<b>find_if_backward</b>, <b>find_if_not_backward</b>,
<b>find_if_not</b>, <b>find_not_backward</b>,
<b>hex_lower</b>, <b>hex</b>, <b>iota</b>, <b>all_of</b>,
<b>is_decreasing</b>, <b>is_increasing</b>,
<b>is_palindrome</b>, <b>is_partitioned_until</b>,
<b>is_partitioned</b>, <b>is_permutation</b>,
<b>is_sorted_until</b>, <b>is_sorted</b>,
<b>is_strictly_decreasing</b>,
<b>is_strictly_increasing</b>, <b>none_of_equal</b>,
<b>none_of</b>, <b>one_of_equal</b>, <b>one_of</b>,
<b>partition_copy</b>, <b>partition_point</b>,
<b>reduce</b>, <b>unhex</b>.</p>

<h3>Reverse Iteration
<a name="Reverse Iteration"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">If calls are
made using reverse iterators on containers, The code will be
fixed using the <b>boost::adaptors::reverse</b> adaptor.</p>

<p style="margin-left:13%; margin-top: 1em">auto AreSame =
std::equal(Items1.rbegin(), Items1.rend(), <br>
std::crbegin(Items2), std::crend(Items2));</p>

<p style="margin-left:9%; margin-top: 1em">Transforms
to:</p>

<p style="margin-left:13%; margin-top: 1em">auto AreSame =
boost::range::equal(boost::adaptors::reverse(Items1), <br>
boost::adaptors::reverse(Items2));</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IncludeStyle</b></p>

<p style="margin-left:18%;">A string specifying which
include-style is used, <i>llvm</i> or <i>google</i>. Default
is <i>llvm</i>.</p>

<p style="margin-left:9%;"><b>IncludeBoostSystem</b></p>

<p style="margin-left:18%;">If <i>true</i> (default value)
the boost headers are included as system headers with angle
brackets (<i>#include &lt;boost.hpp&gt;</i>), otherwise
quotes are used (<i>#include &quot;boost.hpp&quot;</i>).</p>

<p style="margin-left:9%;"><b>UseReversePipe</b></p>

<p style="margin-left:18%;">When <i>true</i> (default
<i>false</i>), fixes which involve reverse ranges will use
the pipe adaptor syntax instead of the function syntax.</p>


<p style="margin-left:22%; margin-top: 1em">std::find(Items.rbegin(),
Items.rend(), 0);</p>

<p style="margin-left:18%; margin-top: 1em">Transforms
to:</p>


<p style="margin-left:22%; margin-top: 1em">boost::range::find(Items
| boost::adaptors::reversed, 0);</p>

<h3>boost-use-to-string
<a name="boost-use-to-string"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check finds
conversion from integer type like <b>int</b> to
<b>std::string</b> or <b>std::wstring</b> using
<b>boost::lexical_cast</b>, and replace it with calls to
<b>std::to_string</b> and <b>std::to_wstring</b>.</p>

<p style="margin-left:9%; margin-top: 1em">It doesn't
replace conversion from floating points despite the
<b>to_string</b> overloads, because it would change the
behavior.</p>

<p style="margin-left:13%; margin-top: 1em">auto str =
boost::lexical_cast&lt;std::string&gt;(42); <br>
auto wstr =
boost::lexical_cast&lt;std::wstring&gt;(2137LL);</p>

<p style="margin-left:13%; margin-top: 1em">// Will be
changed to <br>
auto str = std::to_string(42); <br>
auto wstr = std::to_wstring(2137LL);</p>

<h3>bugprone-argument-comment
<a name="bugprone-argument-comment"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks that
argument comments match parameter names.</p>

<p style="margin-left:9%; margin-top: 1em">The check
understands argument comments in the form
<b>/*parameter_name=*/</b> that are placed right before the
argument.</p>

<p style="margin-left:13%; margin-top: 1em">void f(bool
foo);</p>

<p style="margin-left:13%; margin-top: 1em">...</p>


<p style="margin-left:13%; margin-top: 1em">f(/*bar=*/true);
<br>
// warning: argument name 'bar' in comment does not match
parameter name 'foo'</p>

<p style="margin-left:9%; margin-top: 1em">The check tries
to detect typos and suggest automated fixes for them.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>StrictMode</b></p>

<p style="margin-left:18%;">When <i>false</i> (default
value), the check will ignore leading and trailing
underscores and case when comparing names -- otherwise they
are taken into account.</p>

<p style="margin-left:9%;"><b>IgnoreSingleArgument</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will ignore the single argument.</p>

<p style="margin-left:9%;"><b>CommentBoolLiterals</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will add argument comments in the format
<b>/*ParameterName=*/</b> right before the boolean literal
argument.</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(bool
TurnKey, bool PressButton);</p>

<p style="margin-left:13%; margin-top: 1em">foo(true,
false);</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(bool
TurnKey, bool PressButton);</p>


<p style="margin-left:13%; margin-top: 1em">foo(/*TurnKey=*/true,
/*PressButton=*/false);</p>


<p style="margin-left:9%;"><b>CommentIntegerLiterals</b></p>

<p style="margin-left:18%;">When true, the check will add
argument comments in the format <b>/*ParameterName=*/</b>
right before the integer literal argument.</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(int
MeaningOfLife);</p>

<p style="margin-left:13%; margin-top: 1em">foo(42);</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(int
MeaningOfLife);</p>


<p style="margin-left:13%; margin-top: 1em">foo(/*MeaningOfLife=*/42);</p>

<p style="margin-left:9%;"><b>CommentFloatLiterals</b></p>

<p style="margin-left:18%;">When true, the check will add
argument comments in the format <b>/*ParameterName=*/</b>
right before the float/double literal argument.</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(float
Pi);</p>


<p style="margin-left:13%; margin-top: 1em">foo(3.14159);</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(float
Pi);</p>


<p style="margin-left:13%; margin-top: 1em">foo(/*Pi=*/3.14159);</p>


<p style="margin-left:9%;"><b>CommentStringLiterals</b></p>

<p style="margin-left:18%;">When true, the check will add
argument comments in the format <b>/*ParameterName=*/</b>
right before the string literal argument.</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(const
char *String); <br>
void foo(const wchar_t *WideString);</p>


<p style="margin-left:13%; margin-top: 1em">foo(&quot;Hello
World&quot;); <br>
foo(L&quot;Hello World&quot;);</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(const
char *String); <br>
void foo(const wchar_t *WideString);</p>


<p style="margin-left:13%; margin-top: 1em">foo(/*String=*/&quot;Hello
World&quot;); <br>
foo(/*WideString=*/L&quot;Hello World&quot;);</p>


<p style="margin-left:9%;"><b>CommentCharacterLiterals</b></p>

<p style="margin-left:18%;">When true, the check will add
argument comments in the format <b>/*ParameterName=*/</b>
right before the character literal argument.</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(char
*Character);</p>

<p style="margin-left:13%; margin-top: 1em">foo('A');</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(char
*Character);</p>


<p style="margin-left:13%; margin-top: 1em">foo(/*Character=*/'A');</p>


<p style="margin-left:9%;"><b>CommentUserDefinedLiterals</b></p>

<p style="margin-left:18%;">When true, the check will add
argument comments in the format <b>/*ParameterName=*/</b>
right before the user defined literal argument.</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(double
Distance);</p>

<p style="margin-left:13%; margin-top: 1em">double
operator&quot;&quot; _km(long double);</p>


<p style="margin-left:13%; margin-top: 1em">foo(402.0_km);</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(double
Distance);</p>

<p style="margin-left:13%; margin-top: 1em">double
operator&quot;&quot; _km(long double);</p>


<p style="margin-left:13%; margin-top: 1em">foo(/*Distance=*/402.0_km);</p>

<p style="margin-left:9%;"><b>CommentNullPtrs</b></p>

<p style="margin-left:18%;">When true, the check will add
argument comments in the format <b>/*ParameterName=*/</b>
right before the nullptr literal argument.</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(A*
Value);</p>


<p style="margin-left:13%; margin-top: 1em">foo(nullptr);</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(A*
Value);</p>


<p style="margin-left:13%; margin-top: 1em">foo(/*Value=*/nullptr);</p>

<h3>bugprone-assert-side-effect
<a name="bugprone-assert-side-effect"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
<b>assert()</b> with side effect.</p>

<p style="margin-left:9%; margin-top: 1em">The condition of
<b>assert()</b> is evaluated only in debug builds so a
condition with side effect can cause different behavior in
debug / release builds.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>AssertMacros</b></p>

<p style="margin-left:18%;">A comma-separated list of the
names of assert macros to be checked.</p>

<p style="margin-left:9%;"><b>CheckFunctionCalls</b></p>

<p style="margin-left:18%;">Whether to treat non-const
member and non-member functions as they produce side
effects. Disabled by default because it can increase the
number of false positive warnings.</p>

<p style="margin-left:9%;"><b>IgnoredFunctions</b></p>

<p style="margin-left:18%;">A semicolon-separated list of
the names of functions or methods to be considered as not
having side-effects. Regular expressions are accepted, e.g.
<i>[Rr]ef(erence)?$</i> matches every type with suffix
<i>Ref</i>, <i>ref</i>, <i>Reference</i> and
<i>reference</i>. The default is empty. If a name in the
list contains the sequence <i>::</i> it is matched against
the qualified typename (i.e. <i>namespace::Type</i>,
otherwise it is matched against only the type name (i.e.
<i>Type</i>).</p>

<h3>bugprone-assignment-in-if-condition
<a name="bugprone-assignment-in-if-condition"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
assignments within conditions of <i>if</i> statements. Such
assignments are bug-prone because they may have been
intended as equality tests.</p>

<p style="margin-left:9%; margin-top: 1em">This check finds
all assignments within <i>if</i> conditions, including ones
that are not flagged by <i>-Wparentheses</i> due to an extra
set of parentheses, and including assignments that call an
overloaded <i>operator=()</i>. The identified assignments
violate <i>BARR group &quot;Rule 8.2.c&quot;</i>.</p>

<p style="margin-left:13%; margin-top: 1em">int f = 3; <br>
if(f = 4) { // This is identified by both `Wparentheses` and
this check - should it have been: `if (f == 4)` ? <br>
f = f + 1; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">if((f == 5) ||
(f = 6)) { // the assignment here `(f = 6)` is identified by
this check, but not by `-Wparentheses`. Should it have been
`(f == 6)` ? <br>
f = f + 2; <br>
}</p>

<h3>bugprone-bad-signal-to-kill-thread
<a name="bugprone-bad-signal-to-kill-thread"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
<b>pthread_kill</b> function calls when a thread is
terminated by raising <b>SIGTERM</b> signal and the signal
kills the entire process, not just the individual thread.
Use any signal except <b>SIGTERM</b>.</p>


<p style="margin-left:13%; margin-top: 1em">pthread_kill(thread,
SIGTERM);</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C Coding Standard rule <i>POS44-C.
Do not use signals to terminate threads</i>.</p>


<p style="margin-left:9%; margin-top: 1em"><i>cert-pos44-c</i>
redirects here as an alias of this check.</p>

<h3>bugprone-bool-pointer-implicit-conversion
<a name="bugprone-bool-pointer-implicit-conversion"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for
conditions based on implicit conversion from a <b>bool</b>
pointer to <b>bool</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">bool *p; <br>
if (p) { <br>
// Never used in a pointer-specific way. <br>
}</p>

<h3>bugprone-branch-clone
<a name="bugprone-branch-clone"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for
repeated branches in <b>if/else if/else</b> chains,
consecutive repeated branches in <b>switch</b> statements
and identical true and false branches in conditional
operators.</p>

<p style="margin-left:13%; margin-top: 1em">if
(test_value(x)) { <br>
y++; <br>
do_something(x, y); <br>
} else { <br>
y++; <br>
do_something(x, y); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In this simple
example (which could arise e.g. as a copy-paste error) the
<b>then</b> and <b>else</b> branches are identical and the
code is equivalent the following shorter and cleaner
code:</p>

<p style="margin-left:13%; margin-top: 1em">test_value(x);
// can be omitted unless it has side effects <br>
y++; <br>
do_something(x, y);</p>

<p style="margin-left:9%; margin-top: 1em">If this is the
intended behavior, then there is no reason to use a
conditional statement; otherwise the issue can be solved by
fixing the branch that is handled incorrectly.</p>

<p style="margin-left:9%; margin-top: 1em">The check also
detects repeated branches in longer <b>if/else if/else</b>
chains where it would be even harder to notice the
problem.</p>

<p style="margin-left:9%; margin-top: 1em">In <b>switch</b>
statements the check only reports repeated branches when
they are consecutive, because it is relatively common that
the <b>case:</b> labels have some natural ordering and
rearranging them would decrease the readability of the code.
For example:</p>

<p style="margin-left:13%; margin-top: 1em">switch (ch) {
<br>
case 'a': <br>
return 10; <br>
case 'A': <br>
return 10; <br>
case 'b': <br>
return 11; <br>
case 'B': <br>
return 11; <br>
default: <br>
return 10; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Here the check
reports that the <b>'a'</b> and <b>'A'</b> branches are
identical (and that the <b>'b'</b> and <b>'B'</b> branches
are also identical), but does not report that the
<b>default:</b> branch is also identical to the first two
branches. If this is indeed the correct behavior, then it
could be implemented as:</p>

<p style="margin-left:13%; margin-top: 1em">switch (ch) {
<br>
case 'a': <br>
case 'A': <br>
return 10; <br>
case 'b': <br>
case 'B': <br>
return 11; <br>
default: <br>
return 10; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Here the check
does not warn for the repeated <b>return 10;</b>, which is
good if we want to preserve that <b>'a'</b> is before
<b>'b'</b> and <b>default:</b> is the last branch.</p>

<p style="margin-left:9%; margin-top: 1em">Switch cases
marked with the <b>[[fallthrough]]</b> attribute are
ignored.</p>

<p style="margin-left:9%; margin-top: 1em">Finally, the
check also examines conditional operators and reports code
like:</p>

<p style="margin-left:13%; margin-top: 1em">return
test_value(x) ? x : x;</p>

<p style="margin-left:9%; margin-top: 1em">Unlike if
statements, the check does not detect chains of conditional
operators.</p>

<p style="margin-left:9%; margin-top: 1em">Note: This check
also reports situations where branches become identical only
after preprocessing.</p>

<h3>bugprone-casting-through-void
<a name="bugprone-casting-through-void"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects unsafe
or redundant two-step casting operations involving
<b>void*</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Two-step type
conversions via <b>void*</b> are discouraged for several
reasons.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>They obscure code and impede its understandability,
complicating maintenance.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>These conversions bypass valuable compiler support,
erasing warnings related to pointer alignment. It may
violate strict aliasing rule and leading to undefined
behavior.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>In scenarios involving multiple inheritance, ambiguity
and unexpected outcomes can arise due to the loss of type
information, posing runtime issues.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">In summary,
avoiding two-step type conversions through <b>void*</b>
ensures clearer code, maintains essential compiler warnings,
and prevents ambiguity and potential runtime errors,
particularly in complex inheritance scenarios.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">using
IntegerPointer = int *; <br>
double *ptr;</p>


<p style="margin-left:13%; margin-top: 1em">static_cast&lt;IntegerPointer&gt;(static_cast&lt;void
*&gt;(ptr)); // WRONG <br>

reinterpret_cast&lt;IntegerPointer&gt;(reinterpret_cast&lt;void
*&gt;(ptr)); // WRONG <br>
(IntegerPointer)(void *)ptr; // WRONG <br>
IntegerPointer(static_cast&lt;void *&gt;(ptr)); // WRONG</p>

<h3>bugprone-chained-comparison
<a name="bugprone-chained-comparison"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check detects
chained comparison operators that can lead to unintended
behavior or logical errors.</p>

<p style="margin-left:9%; margin-top: 1em">Chained
comparisons are expressions that use multiple comparison
operators to compare three or more values. For example, the
expression <b>a &lt; b &lt; c</b> compares the values of
<b>a</b>, <b>b</b>, and <b>c</b>. However, this expression
does not evaluate as <b>(a &lt; b) &amp;&amp; (b &lt;
c)</b>, which is probably what the developer intended.
Instead, it evaluates as <b>(a &lt; b) &lt; c</b>, which may
produce unintended results, especially when the types of
<b>a</b>, <b>b</b>, and <b>c</b> are different.</p>

<p style="margin-left:9%; margin-top: 1em">To avoid such
errors, the check will issue a warning when a chained
comparison operator is detected, suggesting to use
parentheses to specify the order of evaluation or to use a
logical operator to separate comparison expressions.</p>

<p style="margin-left:9%; margin-top: 1em">Consider the
following examples:</p>

<p style="margin-left:13%; margin-top: 1em">int a = 2, b =
6, c = 4; <br>
if (a &lt; b &lt; c) { <br>
// This block will be executed <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In this example,
the developer intended to check if <b>a</b> is less than
<b>b</b> and <b>b</b> is less than <b>c</b>. However, the
expression <b>a &lt; b &lt; c</b> is equivalent to <b>(a
&lt; b) &lt; c</b>. Since <b>a &lt; b</b> is <b>true</b>,
the expression <b>(a &lt; b) &lt; c</b> is evaluated as <b>1
&lt; c</b>, which is equivalent to <b>true &lt; c</b> and is
invalid in this case as <b>b &lt; c</b> is <b>false</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Even that above
issue could be detected as comparison of <b>int</b> to
<b>bool</b>, there is more dangerous example:</p>

<p style="margin-left:13%; margin-top: 1em">bool a = false,
b = false, c = true; <br>
if (a == b == c) { <br>
// This block will be executed <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In this example,
the developer intended to check if <b>a</b>, <b>b</b>, and
<b>c</b> are all equal. However, the expression <b>a == b ==
c</b> is evaluated as <b>(a == b) == c</b>. Since <b>a ==
b</b> is true, the expression <b>(a == b) == c</b> is
evaluated as <b>true == c</b>, which is equivalent to
<b>true == true</b>. This comparison yields <b>true</b>,
even though <b>a</b> and <b>b</b> are <b>false</b>, and are
not equal to <b>c</b>.</p>

<p style="margin-left:9%; margin-top: 1em">To avoid this
issue, the developer can use a logical operator to separate
the comparison expressions, like this:</p>

<p style="margin-left:13%; margin-top: 1em">if (a == b
&amp;&amp; b == c) { <br>
// This block will not be executed <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Alternatively,
use of parentheses in the comparison expressions can make
the developer's intention more explicit and help avoid
misunderstanding.</p>

<p style="margin-left:13%; margin-top: 1em">if ((a == b) ==
c) { <br>
// This block will be executed <br>
}</p>

<h3>bugprone-compare-pointer-to-member-virtual-function
<a name="bugprone-compare-pointer-to-member-virtual-function"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects
unspecified behavior about equality comparison between
pointer to member virtual function and anything other than
null-pointer-constant.</p>

<p style="margin-left:13%; margin-top: 1em">struct A { <br>
void f1(); <br>
void f2(); <br>
virtual void f3(); <br>
virtual void f4();</p>

<p style="margin-left:13%; margin-top: 1em">void g1(int);
<br>
};</p>

<p style="margin-left:13%; margin-top: 1em">void fn() {
<br>
bool r1 = (&amp;A::f1 == &amp;A::f2); // ok <br>
bool r2 = (&amp;A::f1 == &amp;A::f3); // bugprone <br>
bool r3 = (&amp;A::f1 != &amp;A::f3); // bugprone <br>
bool r4 = (&amp;A::f3 == nullptr); // ok <br>
bool r5 = (&amp;A::f3 == &amp;A::f4); // bugprone</p>

<p style="margin-left:13%; margin-top: 1em">void (A::*v1)()
= &amp;A::f3; <br>
bool r6 = (v1 == &amp;A::f1); // bugprone <br>
bool r6 = (v1 == nullptr); // ok</p>

<p style="margin-left:13%; margin-top: 1em">void (A::*v2)()
= &amp;A::f2; <br>
bool r7 = (v2 == &amp;A::f1); // false positive, but
potential risk if assigning other value to v2.</p>

<p style="margin-left:13%; margin-top: 1em">void
(A::*v3)(int) = &amp;A::g1; <br>
bool r8 = (v3 == &amp;A::g1); // ok, no virtual function
match void(A::*)(int) signature. <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Provide warnings
on equality comparisons involve pointers to member virtual
function or variables which is potential pointer to member
virtual function and any entity other than a null-pointer
constant.</p>

<p style="margin-left:9%; margin-top: 1em">In certain
compilers, virtual function addresses are not conventional
pointers but instead consist of offsets and indexes within a
virtual function table (vtable). Consequently, these
pointers may vary between base and derived classes, leading
to unpredictable behavior when compared directly. This issue
becomes particularly challenging when dealing with pointers
to pure virtual functions, as they may not even have a valid
address, further complicating comparisons.</p>

<p style="margin-left:9%; margin-top: 1em">Instead, it is
recommended to utilize the <b>typeid</b> operator or other
appropriate mechanisms for comparing objects to ensure
robust and predictable behavior in your codebase. By heeding
this detection and adopting a more reliable comparison
method, you can mitigate potential issues related to
unspecified behavior, especially when dealing with pointers
to member virtual functions or pure virtual functions,
thereby improving the overall stability and maintainability
of your code. In scenarios involving pointers to member
virtual functions, it's only advisable to employ
<b>nullptr</b> for comparisons.</p>

<h3>Limitations
<a name="Limitations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Does not analyze
values stored in a variable. For variable, only analyze all
virtual methods in the same <b>class</b> or <b>struct</b>
and diagnose when assigning a pointer to member virtual
function to this variable is possible.</p>

<h3>bugprone-copy-constructor-init
<a name="bugprone-copy-constructor-init"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds copy
constructors where the constructor doesn't call the copy
constructor of the base class.</p>

<p style="margin-left:13%; margin-top: 1em">class Copyable
{ <br>
public: <br>
Copyable() = default; <br>
Copyable(const Copyable &amp;) = default;</p>

<p style="margin-left:13%; margin-top: 1em">int
memberToBeCopied = 0; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">class X2 :
public Copyable { <br>
X2(const X2 &amp;other) {} // Copyable(other) is missing
<br>
};</p>

<p style="margin-left:9%; margin-top: 1em">Also finds copy
constructors where the constructor of the base class don't
have parameter.</p>

<p style="margin-left:13%; margin-top: 1em">class X3 :
public Copyable { <br>
X3(const X3 &amp;other) : Copyable() {} // other is missing
<br>
};</p>

<p style="margin-left:9%; margin-top: 1em">Failure to
properly initialize base class sub-objects during copy
construction can result in undefined behavior, crashes, data
corruption, or other unexpected outcomes. The check ensures
that the copy constructor of a derived class properly calls
the copy constructor of the base class, helping to prevent
bugs and improve code quality.</p>


<p style="margin-left:9%; margin-top: 1em">Limitations:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">It won't generate warnings for
empty classes, as there are no class members (including base
class sub-objects) to worry about.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>It won't generate warnings for base classes that have
copy constructor private or deleted.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>It won't generate warnings for base classes that are
initialized using other non-default constructor, as this
could be intentional.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">The check also
suggests a fix-its in some cases.</p>

<h3>bugprone-crtp-constructor-accessibility
<a name="bugprone-crtp-constructor-accessibility"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects
error-prone Curiously Recurring Template Pattern usage, when
the CRTP can be constructed outside itself and the derived
class.</p>

<p style="margin-left:9%; margin-top: 1em">The CRTP is an
idiom, in which a class derives from a template class, where
itself is the template argument. It should be ensured that
if a class is intended to be a base class in this idiom, it
can only be instantiated if the derived class is it's
template argument.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T&gt; class CRTP { <br>
private: <br>
CRTP() = default; <br>
friend T; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">class Derived :
CRTP&lt;Derived&gt; {};</p>

<p style="margin-left:9%; margin-top: 1em">Below can be
seen some common mistakes that will allow the breaking of
the idiom.</p>

<p style="margin-left:9%; margin-top: 1em">If the
constructor of a class intended to be used in a CRTP is
public, then it allows users to construct that class on its
own.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T&gt; class CRTP { <br>
public: <br>
CRTP() = default; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">class Good :
CRTP&lt;Good&gt; {}; <br>
Good GoodInstance;</p>


<p style="margin-left:13%; margin-top: 1em">CRTP&lt;int&gt;
BadInstance;</p>

<p style="margin-left:9%; margin-top: 1em">If the
constructor is protected, the possibility of an accidental
instantiation is prevented, however it can fade an error,
when a different class is used as the template parameter
instead of the derived one.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T&gt; class CRTP { <br>
protected: <br>
CRTP() = default; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">class Good :
CRTP&lt;Good&gt; {}; <br>
Good GoodInstance;</p>

<p style="margin-left:13%; margin-top: 1em">class Bad :
CRTP&lt;Good&gt; {}; <br>
Bad BadInstance;</p>

<p style="margin-left:9%; margin-top: 1em">To ensure that
no accidental instantiation happens, the best practice is to
make the constructor private and declare the derived class
as friend. Note that as a tradeoff, this also gives the
derived class access to every other private members of the
CRTP.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T&gt; class CRTP { <br>
CRTP() = default; <br>
friend T; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">class Good :
CRTP&lt;Good&gt; {}; <br>
Good GoodInstance;</p>

<p style="margin-left:13%; margin-top: 1em">class Bad :
CRTP&lt;Good&gt; {}; <br>
Bad CompileTimeError;</p>


<p style="margin-left:13%; margin-top: 1em">CRTP&lt;int&gt;
AlsoCompileTimeError;</p>


<p style="margin-left:9%; margin-top: 1em">Limitations:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">The check is not supported below
C++11</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>The check does not handle when the derived class is
passed as a variadic template argument</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Accessible functions that can construct the CRTP, like
factory functions are not checked</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">The check also
suggests a fix-its in some cases.</p>

<h3>bugprone-dangling-handle
<a name="bugprone-dangling-handle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detect dangling
references in value handles like <b>std::string_view</b>.
These dangling references can be a result of constructing
handles from temporary values, where the temporary is
destroyed soon after the handle is created.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">string_view
View = string(); // View will dangle. <br>
string A; <br>
View = A + &quot;A&quot;; // still dangle.</p>


<p style="margin-left:13%; margin-top: 1em">vector&lt;string_view&gt;
V; <br>
V.push_back(string()); // V[0] is dangling. <br>
V.resize(3, string()); // V[1] and V[2] will also
dangle.</p>

<p style="margin-left:13%; margin-top: 1em">string_view f()
{ <br>
// All these return values will dangle. <br>
return string(); <br>
string S; <br>
return S; <br>
char Array[10]{}; <br>
return Array; <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>HandleClasses</b></p>

<p style="margin-left:18%;">A semicolon-separated list of
class names that should be treated as handles. By default
only <b>std::basic_string_view</b> and
<b>std::experimental::basic_string_view</b> are
considered.</p>

<h3>bugprone-dynamic-static-initializers
<a name="bugprone-dynamic-static-initializers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds instances
of static variables that are dynamically initialized in
header files.</p>

<p style="margin-left:9%; margin-top: 1em">This can pose
problems in certain multithreaded contexts. For example,
when disabling compiler generated synchronization
instructions for static variables initialized at runtime
(e.g. by <b>-fno-threadsafe-statics</b>), even if a
particular project takes the necessary precautions to
prevent race conditions during initialization by providing
their own synchronization, header files included from other
projects may not. Therefore, such a check is helpful for
ensuring that disabling compiler generated synchronization
for static variable initialization will not cause
problems.</p>

<p style="margin-left:9%; margin-top: 1em">Consider the
following code:</p>

<p style="margin-left:13%; margin-top: 1em">int foo() {
<br>
static int k = bar(); <br>
return k; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">When
synchronization of static initialization is disabled, if two
threads both call <i>foo</i> for the first time, there is
the possibility that <i>k</i> will be double initialized,
creating a race condition.</p>

<h3>bugprone-easily-swappable-parameters
<a name="bugprone-easily-swappable-parameters"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds function
definitions where parameters of convertible types follow
each other directly, making call sites prone to calling the
function with swapped (or badly ordered) arguments.</p>

<p style="margin-left:13%; margin-top: 1em">void
drawPoint(int X, int Y) { /* ... */ } <br>
FILE *open(const char *Dir, const char *Name, Flags Mode) {
/* ... */ }</p>

<p style="margin-left:9%; margin-top: 1em">A potential call
like <b>drawPoint(-2, 5)</b> or
<b>openPath(&quot;a.txt&quot;, &quot;tmp&quot;, Read)</b> is
perfectly legal from the language's perspective, but might
not be what the developer of the function intended.</p>

<p style="margin-left:9%; margin-top: 1em">More elaborate
and type-safe constructs, such as opaque typedefs or strong
types should be used instead, to prevent a mistaken order of
arguments.</p>

<p style="margin-left:13%; margin-top: 1em">struct Coord2D
{ int X; int Y; }; <br>
void drawPoint(const Coord2D Pos) { /* ... */ }</p>

<p style="margin-left:13%; margin-top: 1em">FILE
*open(const Path &amp;Dir, const Filename &amp;Name, Flags
Mode) { /* ... */ }</p>

<p style="margin-left:9%; margin-top: 1em">Due to the
potentially elaborate refactoring and API-breaking that is
necessary to strengthen the type safety of a project, no
automatic fix-its are offered.</p>

<h3>Options
<a name="Options"></a>
</h3>


<h3>Extension/relaxation options
<a name="Extension/relaxation options"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Relaxation (or
extension) options can be used to broaden the scope of the
analysis and fine-tune the enabling of more mixes between
types. Some mixes may depend on coding style or preference
specific to a project, however, it should be noted that
enabling <i>all</i> of these relaxations model the way of
mixing at call sites the most. These options are expected to
make the check report for more functions, and report longer
mixable ranges. <b><br>
QualifiersMix</b></p>

<p style="margin-left:18%;">Whether to consider parameters
of some <i>cvr-qualified</i> <b>T</b> and a differently
<i>cvr-qualified</i> <b>T</b> (i.e. <b>T</b> and <b>const
T</b>, <b>const T</b> and <b>volatile T</b>, etc.) mixable
between one another. If <i>false</i>, the check will
consider differently qualified types unmixable. <i>True</i>
turns the warnings on. Defaults to <i>false</i>.</p>

<p style="margin-left:18%; margin-top: 1em">The following
example produces a diagnostic only if <i>QualifiersMix</i>
is enabled:</p>

<p style="margin-left:22%; margin-top: 1em">void
*memcpy(const void *Destination, void *Source, std::size_t
N) { /* ... */ }</p>


<p style="margin-left:9%;"><b>ModelImplicitConversions</b></p>

<p style="margin-left:18%;">Whether to consider parameters
of type <b>T</b> and <b>U</b> mixable if there exists an
implicit conversion from <b>T</b> to <b>U</b> and <b>U</b>
to <b>T</b>. If <i>false</i>, the check will not consider
implicitly convertible types for mixability. <i>True</i>
turns warnings for implicit conversions on. Defaults to
<i>true</i>.</p>

<p style="margin-left:18%; margin-top: 1em">The following
examples produce a diagnostic only if
<i>ModelImplicitConversions</i> is enabled:</p>

<p style="margin-left:22%; margin-top: 1em">void fun(int
Int, double Double) { /* ... */ } <br>
void compare(const char *CharBuf, std::string String) { /*
... */ }</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Changing the qualifiers of an
expression's type (e.g. from <b>int</b> to <b>const int</b>)
is defined as an <i>implicit conversion</i> in the C++
Standard. However, the check separates this decision-making
on the mixability of differently qualified types based on
whether <i>QualifiersMix</i> was enabled.</p>

<p style="margin-left:22%; margin-top: 1em">For example,
the following code snippet will only produce a diagnostic if
<b>both</b> <i>QualifiersMix</i> and
<i>ModelImplicitConversions</i> are enabled:</p>

<p style="margin-left:27%; margin-top: 1em">void fun2(int
Int, const double Double) { /* ... */ }</p>

<h3>Filtering options
<a name="Filtering options"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Filtering
options can be used to lessen the size of the diagnostics
emitted by the checker, whether the aim is to ignore certain
constructs or dampen the noisiness. <b><br>
MinimumLength</b></p>

<p style="margin-left:18%;">The minimum length required
from an adjacent parameter sequence to be diagnosed.
Defaults to <i>2</i>. Might be any positive integer greater
or equal to <i>2</i>. If <i>0</i> or <i>1</i> is given, the
default value <i>2</i> will be used instead.</p>

<p style="margin-left:18%; margin-top: 1em">For example, if
<i>3</i> is specified, the examples above will not be
matched.</p>


<p style="margin-left:9%;"><b>IgnoredParameterNames</b></p>

<p style="margin-left:18%;">The list of parameter
<b>names</b> that should never be considered part of a
swappable adjacent parameter sequence. The value is a
<i>;</i>-separated list of names. To ignore unnamed
parameters, add <i>&quot;&quot;</i> to the list verbatim
(not the empty string, but the two quotes, potentially
escaped!). <b>This option is case-sensitive!</b></p>

<p style="margin-left:18%; margin-top: 1em">By default, the
following parameter names, and their Uppercase-initial
variants are ignored: <i>&quot;&quot;</i> (unnamed
parameters), <i>iterator</i>, <i>begin</i>, <i>end</i>,
<i>first</i>, <i>last</i>, <i>lhs</i>, <i>rhs</i>.</p>


<p style="margin-left:9%;"><b>IgnoredParameterTypeSuffixes</b></p>

<p style="margin-left:18%;">The list of parameter <b>type
name suffixes</b> that should never be considered part of a
swappable adjacent parameter sequence. Parameters which
type, as written in the source code, end with an element of
this option will be ignored. The value is a
<i>;</i>-separated list of names. <b>This option is
case-sensitive!</b></p>

<p style="margin-left:18%; margin-top: 1em">By default, the
following, and their lowercase-initial variants are ignored:
<i>bool</i>, <i>It</i>, <i>Iterator</i>, <i>InputIt</i>,
<i>ForwardIt</i>, <i>BidirIt</i>, <i>RandomIt</i>,
<i>random_iterator</i>, <i>ReverseIt</i>,
<i>reverse_iterator</i>, <i>reverse_const_iterator</i>,
<i>RandomIt</i>, <i>random_iterator</i>, <i>ReverseIt</i>,
<i>reverse_iterator</i>, <i>reverse_const_iterator</i>,
<i>Const_Iterator</i>, <i>ConstIterator</i>,
<i>const_reverse_iterator</i>, <i>ConstReverseIterator</i>.
In addition, <i>_Bool</i> (but not <i>_bool</i>) is also
part of the default value.</p>


<p style="margin-left:9%;"><b>SuppressParametersUsedTogether</b></p>

<p style="margin-left:18%;">Suppresses diagnostics about
parameters that are used together or in a similar fashion
inside the function's body. Defaults to <i>true</i>.
Specifying <i>false</i> will turn off the heuristics.</p>

<p style="margin-left:18%; margin-top: 1em">Currently, the
following heuristics are implemented which will suppress the
warning about the parameter pair involved:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>The parameters are used in the same expression, e.g.
<b>f(a, b)</b> or <b>a &lt; b</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>The parameters are further passed to the same function
to the same parameter of that function, of the same
overload. E.g. <b>f(a, 1)</b> and <b>f(b, 2)</b> to some
<b>f(T, int)</b>.</p></td></tr>
</table>


<p style="margin-left:21%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:24%;">The check does not perform
path-sensitive analysis, and as such, &quot;same
function&quot; in this context means the same function
declaration. If the same member function of a type on two
distinct instances are called with the parameters, it will
still be regarded as &quot;same function&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p style="margin-top: 1em">The same member field is
accessed, or member method is called of the two parameters,
e.g. <b>a.foo()</b> and <b>b.foo()</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>Separate <b>return</b> statements return either of the
parameters on different code paths.</p></td></tr>
</table>


<p style="margin-left:9%;"><b>NamePrefixSuffixSilenceDissimilarityTreshold</b></p>

<p style="margin-left:18%;">The number of characters two
parameter names might be different on <i>either</i> the head
or the tail end with the rest of the name the same so that
the warning about the two parameters are silenced. Defaults
to <i>1</i>. Might be any positive integer. If <i>0</i>, the
filtering heuristic based on the parameters' names is turned
off.</p>

<p style="margin-left:18%; margin-top: 1em">This option can
be used to silence warnings about parameters where the
naming scheme indicates that the order of those parameters
do not matter.</p>

<p style="margin-left:18%; margin-top: 1em">For example,
the parameters <b>LHS</b> and <b>RHS</b> are 1-dissimilar
suffixes of each other: <b>L</b> and <b>R</b> is the
different character, while <b>HS</b> is the common suffix.
Similarly, parameters <b>text1, text2, text3</b> are
1-dissimilar prefixes of each other, with the numbers at the
end being the dissimilar part. If the value is at least
<i>1</i>, such cases will not be reported.</p>

<h3>Limitations
<a name="Limitations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>This check is
designed to check function signatures!</b></p>

<p style="margin-left:9%; margin-top: 1em">The check does
not investigate functions that are generated by the compiler
in a context that is only determined from a call site. These
cases include variadic functions, functions in C code that
do not have an argument list, and C++ template
instantiations. Most of these cases, which are otherwise
swappable from a caller's standpoint, have no way of getting
&quot;fixed&quot; at the definition point. In the case of
C++ templates, only primary template definitions and
explicit specializations are matched and analyzed.</p>

<p style="margin-left:9%; margin-top: 1em">None of the
following cases produce a diagnostic:</p>

<p style="margin-left:13%; margin-top: 1em">int
printf(const char *Format, ...) { /* ... */ } <br>
int someOldCFunction() { /* ... */ }</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T, typename U&gt; <br>
int add(T X, U Y) { return X + Y };</p>

<p style="margin-left:13%; margin-top: 1em">void
theseAreNotWarnedAbout() { <br>
printf(&quot;%d %d\n&quot;, 1, 2); // Two ints passed, they
could be swapped. <br>
someOldCFunction(1, 2, 3); // Similarly, multiple ints
passed.</p>

<p style="margin-left:13%; margin-top: 1em">add(1, 2); //
Instantiates 'add&lt;int, int&gt;', but that's not a
user-defined function. <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Due to the
limitation above, parameters which type are further
dependent upon template instantiations to <i>prove</i> that
they mix with another parameter's is not diagnosed.</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T&gt; <br>
struct Vector { <br>
typedef T element_type; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">// Diagnosed:
Explicit instantiation was done by the user, we can prove it
<br>
// is the same type. <br>
void instantiated(int A, Vector&lt;int&gt;::element_type B)
{ /* ... */ }</p>

<p style="margin-left:13%; margin-top: 1em">// Diagnosed:
The two parameter types are exactly the same. <br>
template &lt;typename T&gt; <br>
void exact(typename Vector&lt;T&gt;::element_type A, <br>
typename Vector&lt;T&gt;::element_type B) { /* ... */ }</p>

<p style="margin-left:13%; margin-top: 1em">// Skipped: The
two parameters are both 'T' but we cannot prove this <br>
// without actually instantiating. <br>
template &lt;typename T&gt; <br>
void falseNegative(T A, typename
Vector&lt;T&gt;::element_type B) { /* ... */ }</p>

<p style="margin-left:9%; margin-top: 1em">In the context
of <i>implicit conversions</i> (when
<i>ModelImplicitConversions</i> is enabled), the modelling
performed by the check warns if the parameters are swappable
and the swapped order matches implicit conversions. It does
not model whether there exists an unrelated third type from
which <i>both</i> parameters can be given in a function
call. This means that in the following example, even while
<b>strs()</b> clearly carries the possibility to be called
with swapped arguments (as long as the arguments are string
literals), will not be warned about.</p>

<p style="margin-left:13%; margin-top: 1em">struct String {
<br>
String(const char *Buf); <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">struct
StringView { <br>
StringView(const char *Buf); <br>
operator const char *() const; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">// Skipped:
Directly swapping expressions of the two type cannot mix.
<br>
// (Note: StringView -&gt; const char * -&gt; String would
be **two** <br>
// user-defined conversions, which is disallowed by the
language.) <br>
void strs(String Str, StringView SV) { /* ... */ }</p>

<p style="margin-left:13%; margin-top: 1em">// Diagnosed:
StringView implicitly converts to and from a buffer. <br>
void cStr(StringView SV, const char *Buf() { /* ... */ }</p>

<h3>bugprone-empty-catch
<a name="bugprone-empty-catch"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects and
suggests addressing issues with empty catch statements.</p>

<p style="margin-left:13%; margin-top: 1em">try { <br>
// Some code that can throw an exception <br>
} catch(const std::exception&amp;) { <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Having empty
catch statements in a codebase can be a serious problem that
developers should be aware of. Catch statements are used to
handle exceptions that are thrown during program execution.
When an exception is thrown, the program jumps to the
nearest catch statement that matches the type of the
exception.</p>

<p style="margin-left:9%; margin-top: 1em">Empty catch
statements, also known as &quot;swallowing&quot; exceptions,
catch the exception but do nothing with it. This means that
the exception is not handled properly, and the program
continues to run as if nothing happened. This can lead to
several issues, such as:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p><i>Hidden Bugs</i>: If an exception is caught and
ignored, it can lead to hidden bugs that are difficult to
diagnose and fix. The root cause of the problem may not be
apparent, and the program may continue to behave in
unexpected ways.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p><i>Security Issues</i>: Ignoring exceptions can lead to
security issues, such as buffer overflows or null pointer
dereferences. Hackers can exploit these vulnerabilities to
gain access to sensitive data or execute malicious code.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p><i>Poor Code Quality</i>: Empty catch statements can
indicate poor code quality and a lack of attention to
detail. This can make the codebase difficult to maintain and
update, leading to longer development cycles and increased
costs.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p><i>Unreliable Code</i>: Code that ignores exceptions is
often unreliable and can lead to unpredictable behavior.
This can cause frustration for users and erode trust in the
software.</p> </td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">To avoid these
issues, developers should always handle exceptions properly.
This means either fixing the underlying issue that caused
the exception or propagating the exception up the call stack
to a higher-level handler. If an exception is not important,
it should still be logged or reported in some way so that it
can be tracked and addressed later.</p>

<p style="margin-left:9%; margin-top: 1em">If the exception
is something that can be handled locally, then it should be
handled within the catch block. This could involve logging
the exception or taking other appropriate action to ensure
that the exception is not ignored.</p>

<p style="margin-left:9%; margin-top: 1em">Here is an
example:</p>

<p style="margin-left:13%; margin-top: 1em">try { <br>
// Some code that can throw an exception <br>
} catch (const std::exception&amp; ex) { <br>
// Properly handle the exception, e.g.: <br>
std::cerr &lt;&lt; &quot;Exception caught: &quot; &lt;&lt;
ex.what() &lt;&lt; std::endl; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">If the exception
cannot be handled locally and needs to be propagated up the
call stack, it should be re-thrown or new exception should
be thrown.</p>

<p style="margin-left:9%; margin-top: 1em">Here is an
example:</p>

<p style="margin-left:13%; margin-top: 1em">try { <br>
// Some code that can throw an exception <br>
} catch (const std::exception&amp; ex) { <br>
// Re-throw the exception <br>
throw; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In some cases,
catching the exception at this level may not be necessary,
and it may be appropriate to let the exception propagate up
the call stack. This can be done simply by not using
<b>try/catch</b> block.</p>

<p style="margin-left:9%; margin-top: 1em">Here is an
example:</p>

<p style="margin-left:13%; margin-top: 1em">void function()
{ <br>
// Some code that can throw an exception <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
callerFunction() { <br>
try { <br>
function(); <br>
} catch (const std::exception&amp; ex) { <br>
// Handling exception on higher level <br>
std::cerr &lt;&lt; &quot;Exception caught: &quot; &lt;&lt;
ex.what() &lt;&lt; std::endl; <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Other potential
solution to avoid empty catch statements is to modify the
code to avoid throwing the exception in the first place.
This can be achieved by using a different API, checking for
error conditions beforehand, or handling errors in a
different way that does not involve exceptions. By
eliminating the need for try-catch blocks, the code becomes
simpler and less error-prone.</p>

<p style="margin-left:9%; margin-top: 1em">Here is an
example:</p>

<p style="margin-left:13%; margin-top: 1em">// Old code:
<br>
try { <br>
mapContainer[&quot;Key&quot;].callFunction(); <br>
} catch(const std::out_of_range&amp;) { <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// New code
<br>
if (auto it = mapContainer.find(&quot;Key&quot;); it !=
mapContainer.end()) { <br>
it-&gt;second.callFunction(); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In conclusion,
empty catch statements are a bad practice that can lead to
hidden bugs, security issues, poor code quality, and
unreliable code. By handling exceptions properly, developers
can ensure that their code is robust, secure, and
maintainable.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreCatchWithKeywords</b></p>

<p style="margin-left:18%;">This option can be used to
ignore specific catch statements containing certain
keywords. If a <b>catch</b> statement body contains
(case-insensitive) any of the keywords listed in this
semicolon-separated option, then the catch will be ignored,
and no warning will be raised. Default value:
<i>@TODO;@FIXME</i>.</p>


<p style="margin-left:9%;"><b>AllowEmptyCatchForExceptions</b></p>

<p style="margin-left:18%;">This option can be used to
ignore empty catch statements for specific exception types.
By default, the check will raise a warning if an empty catch
statement is detected, regardless of the type of exception
being caught. However, in certain situations, such as when a
developer wants to intentionally ignore certain exceptions
or handle them in a different way, it may be desirable to
allow empty catch statements for specific exception types.
To configure this option, a semicolon-separated list of
exception type names should be provided. If an exception
type name in the list is caught in an empty catch statement,
no warning will be raised. Default value: empty string.</p>

<h3>bugprone-exception-escape
<a name="bugprone-exception-escape"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds functions
which may throw an exception directly or indirectly, but
they should not. The functions which should not throw
exceptions are the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p>Destructors</p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p>Move constructors</p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p>Move assignment operators</p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p>The <b>main()</b> functions</p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p><b>swap()</b> functions</p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p><b>iter_swap()</b> functions</p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p><b>iter_move()</b> functions</p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p>Functions marked with <b>throw()</b> or
<b>noexcept</b></p> </td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p>Other functions given as option</p></td>
<td width="36%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">A destructor
throwing an exception may result in undefined behavior,
resource leaks or unexpected termination of the program.
Throwing move constructor or move assignment also may result
in undefined behavior or resource leak. The <b>swap()</b>
operations expected to be non throwing most of the cases and
they are always possible to implement in a non throwing way.
Non throwing <b>swap()</b> operations are also used to
create move operations. A throwing <b>main()</b> function
also results in unexpected termination.</p>

<p style="margin-left:9%; margin-top: 1em">Functions
declared explicitly with <b>noexcept(false)</b> or
<b>throw(exception)</b> will be excluded from the analysis,
as even though it is not recommended for functions like
<b>swap()</b>, <b>main()</b>, move constructors, move
assignment operators and destructors, it is a clear
indication of the developer's intention and should be
respected.</p>

<p style="margin-left:9%; margin-top: 1em">WARNING! This
check may be expensive on large source files.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>FunctionsThatShouldNotThrow</b></p>

<p style="margin-left:18%;">Comma separated list containing
function names which should not throw. An example value for
this parameter can be <b>WinMain</b> which adds function
<b>WinMain()</b> in the Windows API to the list of the
functions which should not throw. Default value is an empty
string.</p>

<p style="margin-left:9%;"><b>IgnoredExceptions</b></p>

<p style="margin-left:18%;">Comma separated list containing
type names which are not counted as thrown exceptions in the
check. Default value is an empty string.</p>

<h3>bugprone-fold-init-type
<a name="bugprone-fold-init-type"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check flags
type mismatches in <i>folds</i> like <b>std::accumulate</b>
that might result in loss of precision.
<b>std::accumulate</b> folds an input range into an initial
value using the type of the latter, with <b>operator+</b> by
default. This can cause loss of precision through:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Truncation: The following code uses a floating point
range and an int initial value, so truncation will happen at
every application of <b>operator+</b> and the result will be
<i>0</i>, which might not be what the user expected.</p></td></tr>
</table>

<p style="margin-left:13%; margin-top: 1em">auto a = {0.5f,
0.5f, 0.5f, 0.5f}; <br>
return std::accumulate(std::begin(a), std::end(a), 0);</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="56%">


<p style="margin-top: 1em">Overflow: The following code
also returns <i>0</i>.</p></td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:13%; margin-top: 1em">auto a =
{65536LL * 65536 * 65536}; <br>
return std::accumulate(std::begin(a), std::end(a), 0);</p>

<h3>bugprone-forward-declaration-namespace
<a name="bugprone-forward-declaration-namespace"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks if an
unused forward declaration is in a wrong namespace.</p>

<p style="margin-left:9%; margin-top: 1em">The check
inspects all unused forward declarations and checks if there
is any declaration/definition with the same name existing,
which could indicate that the forward declaration is in a
potentially wrong namespace.</p>

<p style="margin-left:13%; margin-top: 1em">namespace na {
struct A; } <br>
namespace nb { struct A {}; } <br>
nb::A a; <br>
// warning : no definition found for 'A', but a definition
with the same name <br>
// 'A' found in another namespace 'nb::'</p>

<p style="margin-left:9%; margin-top: 1em">This check can
only generate warnings, but it can't suggest a fix at this
point.</p>

<h3>bugprone-forwarding-reference-overload
<a name="bugprone-forwarding-reference-overload"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check looks
for perfect forwarding constructors that can hide copy or
move constructors. If a non const lvalue reference is passed
to the constructor, the forwarding reference parameter will
be a better match than the const reference parameter of the
copy constructor, so the perfect forwarding constructor will
be called, which can be confusing. For detailed description
of this issue see: Scott Meyers, Effective Modern C++, Item
26.</p>

<p style="margin-left:9%; margin-top: 1em">Consider the
following example:</p>

<p style="margin-left:13%; margin-top: 1em">class Person {
<br>
public: <br>
// C1: perfect forwarding ctor <br>
template&lt;typename T&gt; <br>
explicit Person(T&amp;&amp; n) {}</p>

<p style="margin-left:13%; margin-top: 1em">// C2: perfect
forwarding ctor with parameter default value <br>
template&lt;typename T&gt; <br>
explicit Person(T&amp;&amp; n, int x = 1) {}</p>

<p style="margin-left:13%; margin-top: 1em">// C3: perfect
forwarding ctor guarded with enable_if <br>
template&lt;typename T, typename X =
enable_if_t&lt;is_special&lt;T&gt;, void&gt;&gt; <br>
explicit Person(T&amp;&amp; n) {}</p>

<p style="margin-left:13%; margin-top: 1em">// C4: variadic
perfect forwarding ctor guarded with enable_if <br>
template&lt;typename... A, <br>
enable_if_t&lt;is_constructible_v&lt;tuple&lt;string,
int&gt;, A&amp;&amp;...&gt;, int&gt; = 0&gt; <br>
explicit Person(A&amp;&amp;... a) {}</p>

<p style="margin-left:13%; margin-top: 1em">// C5: perfect
forwarding ctor guarded with requires expression <br>
template&lt;typename T&gt; <br>
requires requires { is_special&lt;T&gt;; } <br>
explicit Person(T&amp;&amp; n) {}</p>

<p style="margin-left:13%; margin-top: 1em">// C6: perfect
forwarding ctor guarded with concept requirement <br>
template&lt;Special T&gt; <br>
explicit Person(T&amp;&amp; n) {}</p>

<p style="margin-left:13%; margin-top: 1em">// (possibly
compiler generated) copy ctor <br>
Person(const Person&amp; rhs); <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">The check warns
for constructors C1 and C2, because those can hide copy and
move constructors. We suppress warnings if the copy and the
move constructors are both disabled (deleted or private),
because there is nothing the perfect forwarding constructor
could hide in this case. We also suppress warnings for
constructors like C3-C6 that are guarded with an
<b>enable_if</b> or a concept, assuming the programmer was
aware of the possible hiding.</p>

<h3>Background
<a name="Background"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">For deciding
whether a constructor is guarded with enable_if, we consider
the types of the constructor parameters, the default values
of template type parameters and the types of non-type
template parameters with a default literal value. If any
part of these types is <b>std::enable_if</b> or
<b>std::enable_if_t</b>, we assume the constructor is
guarded.</p>

<h3>bugprone-implicit-widening-of-multiplication-result
<a name="bugprone-implicit-widening-of-multiplication-result"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check
diagnoses instances where a result of a multiplication is
implicitly widened, and suggests (with fix-it) to either
silence the code by making widening explicit, or to perform
the multiplication in a wider type, to avoid the widening
afterwards.</p>

<p style="margin-left:9%; margin-top: 1em">This is mainly
useful when operating on very large buffers. For example,
consider:</p>

<p style="margin-left:13%; margin-top: 1em">void
zeroinit(char* base, unsigned width, unsigned height) { <br>
for(unsigned row = 0; row != height; ++row) { <br>
for(unsigned col = 0; col != width; ++col) { <br>
char* ptr = base + row * width + col; <br>
*ptr = 0; <br>
} <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">This is fine in
general, but if <b>width * height</b> overflows, you end up
wrapping back to the beginning of <b>base</b> instead of
processing the entire requested buffer.</p>

<p style="margin-left:9%; margin-top: 1em">Indeed, this
only matters for pretty large buffers (4GB+), but that can
happen very easily for example in image processing, where
for that to happen you &quot;only&quot; need a &#732;269MPix
image.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>UseCXXStaticCastsInCppSources</b></p>

<p style="margin-left:18%;">When suggesting fix-its for C++
code, should C++-style <b>static_cast&lt;&gt;()</b>'s be
suggested, or C-style casts. Defaults to <b>true</b>.</p>


<p style="margin-left:9%;"><b>UseCXXHeadersInCppSources</b></p>

<p style="margin-left:18%;">When suggesting to include the
appropriate header in C++ code, should
<b>&lt;cstddef&gt;</b> header be suggested, or
<b>&lt;stddef.h&gt;</b>. Defaults to <b>true</b>.</p>


<p style="margin-left:9%;"><b>IgnoreConstantIntExpr</b></p>

<p style="margin-left:18%;">If the multiplication operands
are compile-time constants (like literals or are
<b>constexpr</b>) and fit within the source expression type,
do not emit a diagnostic or suggested fix. Only considers
expressions where the source expression is a signed integer
type. Defaults to <b>false</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">long mul(int a,
int b) { <br>
return a * b; // warning: performing an implicit widening
conversion to type 'long' of a multiplication performed in
type 'int' <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">char*
ptr_add(char *base, int a, int b) { <br>
return base + a * b; // warning: result of multiplication in
type 'int' is used as a pointer offset after an implicit
widening conversion to type 'ssize_t' <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">char
ptr_subscript(char *base, int a, int b) { <br>
return base[a * b]; // warning: result of multiplication in
type 'int' is used as a pointer offset after an implicit
widening conversion to type 'ssize_t' <br>
}</p>

<h3>bugprone-inaccurate-erase
<a name="bugprone-inaccurate-erase"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for
inaccurate use of the <b>erase()</b> method.</p>

<p style="margin-left:9%; margin-top: 1em">Algorithms like
<b>remove()</b> do not actually remove any element from the
container but return an iterator to the first redundant
element at the end of the container. These redundant
elements must be removed using the <b>erase()</b> method.
This check warns when not all of the elements will be
removed due to using an inappropriate overload.</p>

<p style="margin-left:9%; margin-top: 1em">For example, the
following code erases only one element:</p>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;int&gt;
xs; <br>
... <br>
xs.erase(std::remove(xs.begin(), xs.end(), 10));</p>

<p style="margin-left:9%; margin-top: 1em">Call the
two-argument overload of <b>erase()</b> to remove the
subrange:</p>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;int&gt;
xs; <br>
... <br>
xs.erase(std::remove(xs.begin(), xs.end(), 10),
xs.end());</p>

<h3>bugprone-inc-dec-in-conditions
<a name="bugprone-inc-dec-in-conditions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects when a
variable is both incremented/decremented and referenced
inside a complex condition and suggests moving them outside
to avoid ambiguity in the variable's value.</p>

<p style="margin-left:9%; margin-top: 1em">When a variable
is modified and also used in a complex condition, it can
lead to unexpected behavior. The side-effect of changing the
variable's value within the condition can make the code
difficult to reason about. Additionally, the developer's
intended timing for the modification of the variable may not
be clear, leading to misunderstandings and errors. This can
be particularly problematic when the condition involves
logical operators like <b>&amp;&amp;</b> and <b>||</b>,
where the order of evaluation can further complicate the
situation.</p>

<p style="margin-left:9%; margin-top: 1em">Consider the
following example:</p>

<p style="margin-left:13%; margin-top: 1em">int i = 0; <br>
// ... <br>
if (i++ &lt; 5 &amp;&amp; i &gt; 0) { <br>
// do something <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In this example,
the result of the expression may not be what the developer
intended. The original intention of the developer could be
to increment <b>i</b> after the entire condition is
evaluated, but in reality, i will be incremented before <b>i
&gt; 0</b> is executed. This can lead to unexpected behavior
and bugs in the code. To fix this issue, the developer
should separate the increment operation from the condition
and perform it separately. For example, they can increment
<b>i</b> in a separate statement before or after the
condition is evaluated. This ensures that the value of
<b>i</b> is predictable and consistent throughout the
code.</p>

<p style="margin-left:13%; margin-top: 1em">int i = 0; <br>
// ... <br>
i++; <br>
if (i &lt;= 5 &amp;&amp; i &gt; 0) { <br>
// do something <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Another common
issue occurs when multiple increments or decrements are
performed on the same variable inside a complex condition.
For example:</p>

<p style="margin-left:13%; margin-top: 1em">int i = 4; <br>
// ... <br>
if (i++ &lt; 5 || --i &gt; 2) { <br>
// do something <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">There is a
potential issue with this code due to the order of
evaluation in C++. The <b>||</b> operator used in the
condition statement guarantees that if the first operand
evaluates to <b>true</b>, the second operand will not be
evaluated. This means that if <b>i</b> were initially
<b>4</b>, the first operand <b>i &lt; 5</b> would evaluate
to <b>true</b> and the second operand <b>i &gt; 2</b> would
not be evaluated. As a result, the decrement operation
<b>--i</b> would not be executed and <b>i</b> would hold
value <b>5</b>, which may not be the intended behavior for
the developer.</p>

<p style="margin-left:9%; margin-top: 1em">To avoid this
potential issue, the both increment and decrement operation
on <b>i</b> should be moved outside the condition
statement.</p>

<h3>bugprone-incorrect-enable-if
<a name="bugprone-incorrect-enable-if"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects
incorrect usages of <b>std::enable_if</b> that don't name
the nested <b>type</b> type.</p>

<p style="margin-left:9%; margin-top: 1em">In C++11
introduced <b>std::enable_if</b> as a convenient way to
leverage SFINAE. One form of using <b>std::enable_if</b> is
to declare an unnamed template type parameter with a default
type equal to <b>typename
std::enable_if&lt;condition&gt;::type</b>. If the author
forgets to name the nested type <b>type</b>, then the code
will always consider the candidate template even if the
condition is not met.</p>

<p style="margin-left:9%; margin-top: 1em">Below are some
examples of code using <b>std::enable_if</b> correctly and
incorrect examples that this check flags.</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T, typename = typename
std::enable_if&lt;T::some_trait&gt;::type&gt; <br>
void valid_usage() { ... }</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T, typename =
std::enable_if_t&lt;T::some_trait&gt;&gt; <br>
void valid_usage_with_trait_helpers() { ... }</p>

<p style="margin-left:13%; margin-top: 1em">// The below
code is not a correct application of SFINAE. Even if <br>
// T::some_trait is not true, the function will still be
considered in the <br>
// set of function candidates. It can either incorrectly
select the function <br>
// when it should not be a candidates, and/or lead to hard
compile errors <br>
// if the body of the template does not compile if the
condition is not <br>
// satisfied. <br>
template &lt;typename T, typename =
std::enable_if&lt;T::some_trait&gt;&gt; <br>
void invalid_usage() { ... }</p>

<p style="margin-left:13%; margin-top: 1em">// The tool
suggests the following replacement for 'invalid_usage': <br>
template &lt;typename T, typename = typename
std::enable_if&lt;T::some_trait&gt;::type&gt; <br>
void fixed_invalid_usage() { ... }</p>

<p style="margin-left:9%; margin-top: 1em">C++14 introduced
the trait helper <b>std::enable_if_t</b> which reduces the
likelihood of this error. C++20 introduces constraints,
which generally supersede the use of <b>std::enable_if</b>.
See <i>modernize-type-traits</i> for another tool that will
replace <b>std::enable_if</b> with <b>std::enable_if_t</b>,
and see <i>modernize-use-constraints</i> for another tool
that replaces <b>std::enable_if</b> with C++20 constraints.
Consider these newer mechanisms where possible.</p>

<h3>bugprone-incorrect-roundings
<a name="bugprone-incorrect-roundings"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks the usage
of patterns known to produce incorrect rounding. Programmers
often use:</p>


<p style="margin-left:13%; margin-top: 1em">(int)(double_expression
+ 0.5)</p>

<p style="margin-left:9%; margin-top: 1em">to round the
double expression to an integer. The problem with this:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="87%">


<p>It is unnecessarily slow.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="87%">


<p>It is incorrect. The number 0.499999975 (smallest
representable float number below 0.5) rounds to 1.0. Even
worse behavior for negative numbers where both -0.5f and
-1.4f both round to 0.0.</p></td></tr>
</table>

<h3>bugprone-infinite-loop
<a name="bugprone-infinite-loop"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds obvious
infinite loops (loops where the condition variable is not
changed at all).</p>

<p style="margin-left:9%; margin-top: 1em">Finding infinite
loops is well-known to be impossible (halting problem).
However, it is possible to detect some obvious infinite
loops, for example, if the loop condition is not changed.
This check detects such loops. A loop is considered infinite
if it does not have any loop exit statement (<b>break</b>,
<b>continue</b>, <b>goto</b>, <b>return</b>, <b>throw</b> or
a call to a function called as <b>[[noreturn]]</b>) and all
of the following conditions hold for every variable in the
condition:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="50%">


<p style="margin-top: 1em">It is a local variable.</p></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="50%">


<p>It has no reference or pointer aliases.</p></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="50%">


<p>It is not a structure or class member.</p></td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Furthermore, the
condition must not contain a function call to consider the
loop infinite since functions may return different values
for different calls.</p>

<p style="margin-left:9%; margin-top: 1em">For example, the
following loop is considered infinite <i>i</i> is not
changed in the body:</p>

<p style="margin-left:13%; margin-top: 1em">int i = 0, j =
0; <br>
while (i &lt; 10) { <br>
++j; <br>
}</p>

<h3>bugprone-integer-division
<a name="bugprone-integer-division"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds cases
where integer division in a floating point context is likely
to cause unintended loss of precision.</p>

<p style="margin-left:9%; margin-top: 1em">No reports are
made if divisions are part of the following expressions:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="70%">


<p style="margin-top: 1em">operands of operators expecting
integral or bool types,</p></td>
<td width="18%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="70%">


<p>call expressions of integral or bool types, and</p></td>
<td width="18%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="70%">


<p>explicit cast expressions to integral or bool types,</p></td>
<td width="18%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">as these are
interpreted as signs of deliberateness from the
programmer.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">float
floatFunc(float); <br>
int intFunc(int); <br>
double d; <br>
int i = 42;</p>

<p style="margin-left:13%; margin-top: 1em">// Warn,
floating-point values expected. <br>
d = 32 * 8 / (2 + i); <br>
d = 8 * floatFunc(1 + 7 / 2); <br>
d = i / (1 &lt;&lt; 4);</p>

<p style="margin-left:13%; margin-top: 1em">// OK, no
integer division. <br>
d = 32 * 8.0 / (2 + i); <br>
d = 8 * floatFunc(1 + 7.0 / 2); <br>
d = (double)i / (1 &lt;&lt; 4);</p>

<p style="margin-left:13%; margin-top: 1em">// OK, there
are signs of deliberateness. <br>
d = 1 &lt;&lt; (i / 2); <br>
d = 9 + intFunc(6 * i / 32); <br>
d = (int)(i / 32) - 8;</p>

<h3>bugprone-lambda-function-name
<a name="bugprone-lambda-function-name"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for
attempts to get the name of a function from within a lambda
expression. The name of a lambda is always something like
<b>operator()</b>, which is almost never what was
intended.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">void
FancyFunction() { <br>
[] { printf(&quot;Called from %s\n&quot;, __func__); }();
<br>
[] { printf(&quot;Now called from %s\n&quot;, __FUNCTION__);
}(); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Output:</p>

<p style="margin-left:13%; margin-top: 1em">Called from
operator() <br>
Now called from operator()</p>

<p style="margin-left:9%; margin-top: 1em">Likely intended
output:</p>

<p style="margin-left:13%; margin-top: 1em">Called from
FancyFunction <br>
Now called from FancyFunction</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">The value <i>true</i> specifies
that attempting to get the name of a function from within a
macro should not be diagnosed. The default value is
<i>false</i>.</p>

<h3>bugprone-macro-parentheses
<a name="bugprone-macro-parentheses"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds macros
that can have unexpected behavior due to missing
parentheses.</p>

<p style="margin-left:9%; margin-top: 1em">Macros are
expanded by the preprocessor as-is. As a result, there can
be unexpected behavior; operators may be evaluated in
unexpected order and unary operators may become binary
operators, etc.</p>

<p style="margin-left:9%; margin-top: 1em">When the
replacement list has an expression, it is recommended to
surround it with parentheses. This ensures that the macro
result is evaluated completely before it is used.</p>

<p style="margin-left:9%; margin-top: 1em">It is also
recommended to surround macro arguments in the replacement
list with parentheses. This ensures that the argument value
is calculated properly.</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C Coding Standard rule <i>PRE20-C.
Macro replacement lists should be parenthesized.</i></p>

<h3>bugprone-macro-repeated-side-effects
<a name="bugprone-macro-repeated-side-effects"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for
repeated argument with side effects in macros.</p>

<h3>bugprone-misplaced-operator-in-strlen-in-alloc
<a name="bugprone-misplaced-operator-in-strlen-in-alloc"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds cases
where <b>1</b> is added to the string in the argument to
<b>strlen()</b>, <b>strnlen()</b>, <b>strnlen_s()</b>,
<b>wcslen()</b>, <b>wcsnlen()</b>, and <b>wcsnlen_s()</b>
instead of the result and the value is used as an argument
to a memory allocation function (<b>malloc()</b>,
<b>calloc()</b>, <b>realloc()</b>, <b>alloca()</b>) or the
<b>new[]</b> operator in <i>C++</i>. The check detects error
cases even if one of these functions (except the
<b>new[]</b> operator) is called by a constant function
pointer. Cases where <b>1</b> is added both to the parameter
and the result of the <b>strlen()</b>-like function are
ignored, as are cases where the whole addition is surrounded
by extra parentheses.</p>

<p style="margin-left:9%; margin-top: 1em"><i>C</i> example
code:</p>

<p style="margin-left:13%; margin-top: 1em">void
bad_malloc(char *str) { <br>
char *c = (char*) malloc(strlen(str + 1)); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The suggested
fix is to add <b>1</b> to the return value of
<b>strlen()</b> and not to its argument. In the example
above the fix would be</p>

<p style="margin-left:13%; margin-top: 1em">char *c =
(char*) malloc(strlen(str) + 1);</p>

<p style="margin-left:9%; margin-top: 1em"><i>C++</i>
example code:</p>

<p style="margin-left:13%; margin-top: 1em">void
bad_new(char *str) { <br>
char *c = new char[strlen(str + 1)]; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">As in the
<i>C</i> code with the <b>malloc()</b> function, the
suggested fix is to add <b>1</b> to the return value of
<b>strlen()</b> and not to its argument. In the example
above the fix would be</p>

<p style="margin-left:13%; margin-top: 1em">char *c = new
char[strlen(str) + 1];</p>

<p style="margin-left:9%; margin-top: 1em">Example for
silencing the diagnostic:</p>

<p style="margin-left:13%; margin-top: 1em">void
bad_malloc(char *str) { <br>
char *c = (char*) malloc(strlen((str + 1))); <br>
}</p>

<h3>bugprone-misplaced-pointer-arithmetic-in-alloc
<a name="bugprone-misplaced-pointer-arithmetic-in-alloc"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds cases
where an integer expression is added to or subtracted from
the result of a memory allocation function (<b>malloc()</b>,
<b>calloc()</b>, <b>realloc()</b>, <b>alloca()</b>) instead
of its argument. The check detects error cases even if one
of these functions is called by a constant function
pointer.</p>

<p style="margin-left:9%; margin-top: 1em">Example
code:</p>

<p style="margin-left:13%; margin-top: 1em">void
bad_malloc(int n) { <br>
char *p = (char*) malloc(n) + 10; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The suggested
fix is to add the integer expression to the argument of
<b>malloc</b> and not to its result. In the example above
the fix would be</p>

<p style="margin-left:13%; margin-top: 1em">char *p =
(char*) malloc(n + 10);</p>

<h3>bugprone-misplaced-widening-cast
<a name="bugprone-misplaced-widening-cast"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check will
warn when there is a cast of a calculation result to a
bigger type. If the intention of the cast is to avoid loss
of precision then the cast is misplaced, and there can be
loss of precision. Otherwise the cast is ineffective.</p>

<p style="margin-left:9%; margin-top: 1em">Example
code:</p>

<p style="margin-left:13%; margin-top: 1em">long f(int x) {
<br>
return (long)(x * 1000); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The result <b>x
* 1000</b> is first calculated using <b>int</b> precision.
If the result exceeds <b>int</b> precision there is loss of
precision. Then the result is casted to <b>long</b>.</p>

<p style="margin-left:9%; margin-top: 1em">If there is no
loss of precision then the cast can be removed or you can
explicitly cast to <b>int</b> instead.</p>

<p style="margin-left:9%; margin-top: 1em">If you want to
avoid loss of precision then put the cast in a proper
location, for instance:</p>

<p style="margin-left:13%; margin-top: 1em">long f(int x) {
<br>
return (long)x * 1000; <br>
}</p>

<h3>Implicit casts
<a name="Implicit casts"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Forgetting to
place the cast at all is at least as dangerous and at least
as common as misplacing it. If <i>CheckImplicitCasts</i> is
enabled the check also detects these cases, for
instance:</p>

<p style="margin-left:13%; margin-top: 1em">long f(int x) {
<br>
return x * 1000; <br>
}</p>

<h3>Floating point
<a name="Floating point"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Currently
warnings are only written for integer conversion. No warning
is written for this code:</p>

<p style="margin-left:13%; margin-top: 1em">double f(float
x) { <br>
return (double)(x * 10.0f); <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>CheckImplicitCasts</b></p>

<p style="margin-left:18%;">If <i>true</i>, enables
detection of implicit casts. Default is <i>false</i>.</p>

<h3>bugprone-move-forwarding-reference
<a name="bugprone-move-forwarding-reference"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns if
<b>std::move</b> is called on a forwarding reference, for
example:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T&gt; <br>
void foo(T&amp;&amp; t) { <br>
bar(std::move(t)); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em"><i>Forwarding
references</i> should typically be passed to
<b>std::forward</b> instead of <b>std::move</b>, and this is
the fix that will be suggested.</p>

<p style="margin-left:9%; margin-top: 1em">(A forwarding
reference is an rvalue reference of a type that is a deduced
function template argument.)</p>

<p style="margin-left:9%; margin-top: 1em">In this example,
the suggested fix would be</p>


<p style="margin-left:13%; margin-top: 1em">bar(std::forward&lt;T&gt;(t));</p>

<h3>Background
<a name="Background"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Code like the
example above is sometimes written with the expectation that
<b>T&amp;&amp;</b> will always end up being an rvalue
reference, no matter what type is deduced for <b>T</b>, and
that it is therefore not possible to pass an lvalue to
<b>foo()</b>. However, this is not true. Consider this
example:</p>

<p style="margin-left:13%; margin-top: 1em">std::string s =
&quot;Hello, world&quot;; <br>
foo(s);</p>

<p style="margin-left:9%; margin-top: 1em">This code
compiles and, after the call to <b>foo()</b>, <b>s</b> is
left in an indeterminate state because it has been moved
from. This may be surprising to the caller of <b>foo()</b>
because no <b>std::move</b> was used when calling
<b>foo()</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The reason for
this behavior lies in the special rule for template argument
deduction on function templates like <b>foo()</b> -- i.e. on
function templates that take an rvalue reference argument of
a type that is a deduced function template argument. (See
section [temp.deduct.call]/3 in the C++11 standard.)</p>

<p style="margin-left:9%; margin-top: 1em">If <b>foo()</b>
is called on an lvalue (as in the example above), then
<b>T</b> is deduced to be an lvalue reference. In the
example, <b>T</b> is deduced to be <b>std::string &amp;</b>.
The type of the argument <b>t</b> therefore becomes
<b>std::string&amp; &amp;&amp;</b>; by the reference
collapsing rules, this collapses to
<b>std::string&amp;</b>.</p>

<p style="margin-left:9%; margin-top: 1em">This means that
the <b>foo(s)</b> call passes <b>s</b> as an lvalue
reference, and <b>foo()</b> ends up moving <b>s</b> and
thereby placing it into an indeterminate state.</p>

<h3>bugprone-multi-level-implicit-pointer-conversion
<a name="bugprone-multi-level-implicit-pointer-conversion"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects implicit
conversions between pointers of different levels of
indirection.</p>

<p style="margin-left:9%; margin-top: 1em">Conversions
between pointer types of different levels of indirection can
be dangerous and may lead to undefined behavior,
particularly if the converted pointer is later cast to a
type with a different level of indirection. For example,
converting a pointer to a pointer to an <b>int</b>
(<b>int**</b>) to a <b>void*</b> can result in the loss of
information about the original level of indirection, which
can cause problems when attempting to use the converted
pointer. If the converted pointer is later cast to a type
with a different level of indirection and dereferenced, it
may lead to access violations, memory corruption, or other
undefined behavior.</p>

<p style="margin-left:9%; margin-top: 1em">Consider the
following example:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(void*
ptr);</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
int x = 42; <br>
int* ptr = &amp;x; <br>
int** ptr_ptr = &amp;ptr; <br>
foo(ptr_ptr); // warning will trigger here <br>
return 0; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In this example,
<b>foo()</b> is called with <b>ptr_ptr</b> as its argument.
However, <b>ptr_ptr</b> is a <b>int**</b> pointer, while
<b>foo()</b> expects a <b>void*</b> pointer. This results in
an implicit pointer level conversion, which could cause
issues if <b>foo()</b> dereferences the pointer assuming
it's a <b>int*</b> pointer.</p>

<p style="margin-left:9%; margin-top: 1em">Using an
explicit cast is a recommended solution to prevent issues
caused by implicit pointer level conversion, as it allows
the developer to explicitly state their intention and show
their reasoning for the type conversion. Additionally, it is
recommended that developers thoroughly check and verify the
safety of the conversion before using an explicit cast. This
extra level of caution can help catch potential issues early
on in the development process, improving the overall
reliability and maintainability of the code.</p>

<h3>bugprone-multiple-new-in-one-expression
<a name="bugprone-multiple-new-in-one-expression"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds multiple
<b>new</b> operator calls in a single expression, where the
allocated memory by the first <b>new</b> may leak if the
second allocation fails and throws exception.</p>

<p style="margin-left:9%; margin-top: 1em">C++ does often
not specify the exact order of evaluation of the operands of
an operator or arguments of a function. Therefore if a first
allocation succeeds and a second fails, in an exception
handler it is not possible to tell which allocation has
failed and free the memory. Even if the order is fixed the
result of a first <b>new</b> may be stored in a temporary
location that is not reachable at the time when a second
allocation fails. It is best to avoid any expression that
contains more than one <b>operator new</b> call, if
exception handling is used to check for allocation
errors.</p>

<p style="margin-left:9%; margin-top: 1em">Different rules
apply for are the short-circuit operators <b>||</b> and
<b>&amp;&amp;</b> and the <b>,</b> operator, where
evaluation of one side must be completed before the other
starts. Expressions of a list-initialization (initialization
or construction using <b>{</b> and <b>}</b> characters) are
evaluated in fixed order. Similarly, condition of a <b>?</b>
operator is evaluated before the branches are evaluated.</p>

<p style="margin-left:9%; margin-top: 1em">The check
reports warning if two <b>new</b> calls appear in one
expression at different sides of an operator, or if
<b>new</b> calls appear in different arguments of a function
call (that can be an object construction with <b>()</b>
syntax). These <b>new</b> calls can be nested at any level.
For any warning to be emitted the <b>new</b> calls should be
in a code block where exception handling is used with catch
for <b>std::bad_alloc</b> or <b>std::exception</b>. At
<b>||</b>, <b>&amp;&amp;</b>, <b>,</b>, <b>?</b> (condition
and one branch) operators no warning is emitted. No warning
is emitted if both of the memory allocations are not
assigned to a variable or not passed directly to a function.
The reason is that in this case the memory may be
intentionally not freed or the allocated objects can be
self-destructing objects.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">struct A { <br>
int Var; <br>
}; <br>
struct B { <br>
B(); <br>
B(A *); <br>
int Var; <br>
}; <br>
struct C { <br>
int *X1; <br>
int *X2; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">void f(A *, B
*); <br>
int f1(A *); <br>
int f1(B *); <br>
bool f2(A *);</p>

<p style="margin-left:13%; margin-top: 1em">void foo() {
<br>
A *PtrA; <br>
B *PtrB; <br>
try { <br>
// Allocation of 'B'/'A' may fail after memory for 'A'/'B'
was allocated. <br>
f(new A, new B); // warning: memory allocation may leak if
an other allocation is sequenced after it and throws an
exception; order of these allocations is undefined</p>

<p style="margin-left:13%; margin-top: 1em">// List
(aggregate) initialization is used. <br>
C C1{new int, new int}; // no warning</p>

<p style="margin-left:13%; margin-top: 1em">// Allocation
of 'B'/'A' may fail after memory for 'A'/'B' was allocated
but not yet passed to function 'f1'. <br>
int X = f1(new A) + f1(new B); // warning: memory allocation
may leak if an other allocation is sequenced after it and
throws an exception; order of these allocations is
undefined</p>

<p style="margin-left:13%; margin-top: 1em">// Allocation
of 'B' may fail after memory for 'A' was allocated. <br>
// From C++17 on memory for 'B' is allocated first but still
may leak if allocation of 'A' fails. <br>
PtrB = new B(new A); // warning: memory allocation may leak
if an other allocation is sequenced after it and throws an
exception</p>

<p style="margin-left:13%; margin-top: 1em">// 'new A' and
'new B' may be performed in any order. <br>
// 'new B'/'new A' may fail after memory for 'A'/'B' was
allocated but not assigned to 'PtrA'/'PtrB'. <br>
(PtrA = new A)-&gt;Var = (PtrB = new B)-&gt;Var; // warning:
memory allocation may leak if an other allocation is
sequenced after it and throws an exception; order of these
allocations is undefined</p>

<p style="margin-left:13%; margin-top: 1em">// Evaluation
of 'f2(new A)' must be finished before 'f1(new B)' starts.
<br>
// If 'new B' fails the allocated memory for 'A' is
supposedly handled correctly because function 'f2' could
take the ownership. <br>
bool Z = f2(new A) || f1(new B); // no warning</p>

<p style="margin-left:13%; margin-top: 1em">X = (f2(new A)
? f1(new A) : f1(new B)); // no warning</p>

<p style="margin-left:13%; margin-top: 1em">// No warning
if the result of both allocations is not passed to a
function <br>
// or stored in a variable. <br>
(new A)-&gt;Var = (new B)-&gt;Var; // no warning</p>

<p style="margin-left:13%; margin-top: 1em">// No warning
if at least one non-throwing allocation is used. <br>
f(new(std::nothrow) A, new B); // no warning <br>
} catch(std::bad_alloc) { <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// No warning
if the allocation is outside a try block (or no catch
handler exists for std::bad_alloc). <br>
// (The fact if exceptions can escape from 'foo' is not
taken into account.) <br>
f(new A, new B); // no warning <br>
}</p>

<h3>bugprone-multiple-statement-macro
<a name="bugprone-multiple-statement-macro"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detect multiple
statement macros that are used in unbraced conditionals.
Only the first statement of the macro will be inside the
conditional and the other ones will be executed
unconditionally.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">#define
INCREMENT_TWO(x, y) (x)++; (y)++ <br>
if (do_increment) <br>
INCREMENT_TWO(a, b); // (b)++ will be executed
unconditionally.</p>

<h3>bugprone-narrowing-conversions
<a name="bugprone-narrowing-conversions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
bugprone-narrowing-conversions check is an alias, please see
<i>cppcoreguidelines-narrowing-conversions</i> for more
information.</p>

<h3>bugprone-no-escape
<a name="bugprone-no-escape"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds pointers
with the <b>noescape</b> attribute that are captured by an
asynchronously-executed block. The block arguments in
<b>dispatch_async()</b> and <b>dispatch_after()</b> are
guaranteed to escape, so it is an error if a pointer with
the <b>noescape</b> attribute is captured by one of these
blocks.</p>

<p style="margin-left:9%; margin-top: 1em">The following is
an example of an invalid use of the <b>noescape</b>
attribute.</p>

<p style="margin-left:18%; margin-top: 1em">void
foo(__attribute__((noescape)) int *p) { <br>
dispatch_async(queue, &#710;{ <br>
*p = 123; <br>
}); <br>
});</p>

<h3>bugprone-non-zero-enum-to-bool-conversion
<a name="bugprone-non-zero-enum-to-bool-conversion"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detect implicit
and explicit casts of <b>enum</b> type into <b>bool</b>
where <b>enum</b> type doesn't have a zero-value enumerator.
If the <b>enum</b> is used only to hold values equal to its
enumerators, then conversion to <b>bool</b> will always
result in <b>true</b> value. This can lead to unnecessary
code that reduces readability and maintainability and can
result in bugs.</p>

<p style="margin-left:9%; margin-top: 1em">May produce
false positives if the <b>enum</b> is used to store other
values (used as a bit-mask or zero-initialized on purpose).
To deal with them, <b>// NOLINT</b> or casting first to the
underlying type before casting to <b>bool</b> can be
used.</p>

<p style="margin-left:9%; margin-top: 1em">It is important
to note that this check will not generate warnings if the
definition of the enumeration type is not available.
Additionally, C++11 enumeration classes are supported by
this check.</p>

<p style="margin-left:9%; margin-top: 1em">Overall, this
check serves to improve code quality and readability by
identifying and flagging instances where implicit or
explicit casts from enumeration types to boolean could cause
potential issues.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">enum EStatus {
<br>
OK = 1, <br>
NOT_OK, <br>
UNKNOWN <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">void
process(EStatus status) { <br>
if (!status) { <br>
// this true-branch won't be executed <br>
return; <br>
} <br>
// proceed with &quot;valid data&quot; <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>EnumIgnoreList</b></p>

<p style="margin-left:18%;">Option is used to ignore
certain enum types when checking for implicit/explicit casts
to bool. It accepts a semicolon-separated list of (fully
qualified) enum type names or regular expressions that match
the enum type names. The default value is an empty string,
which means no enums will be ignored.</p>

<h3>bugprone-not-null-terminated-result
<a name="bugprone-not-null-terminated-result"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds function
calls where it is possible to cause a not null-terminated
result. Usually the proper length of a string is
<b>strlen(src) + 1</b> or equal length of this expression,
because the null terminator needs an extra space. Without
the null terminator it can result in undefined behavior when
the string is read.</p>

<p style="margin-left:9%; margin-top: 1em">The following
and their respective <b>wchar_t</b> based functions are
checked:</p>

<p style="margin-left:9%; margin-top: 1em"><b>memcpy</b>,
<b>memcpy_s</b>, <b>memchr</b>, <b>memmove</b>,
<b>memmove_s</b>, <b>strerror_s</b>, <b>strncmp</b>,
<b>strxfrm</b></p>

<p style="margin-left:9%; margin-top: 1em">The following is
a real-world example where the programmer forgot to increase
the passed third argument, which is <b>size_t length</b>.
That is why the length of the allocated memory is not enough
to hold the null terminator.</p>

<p style="margin-left:13%; margin-top: 1em">static char
*stringCpy(const std::string &amp;str) { <br>
char *result = reinterpret_cast&lt;char
*&gt;(malloc(str.size())); <br>
memcpy(result, str.data(), str.size()); <br>
return result; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In addition to
issuing warnings, fix-it rewrites all the necessary code. It
also tries to adjust the capacity of the destination
array:</p>

<p style="margin-left:13%; margin-top: 1em">static char
*stringCpy(const std::string &amp;str) { <br>
char *result = reinterpret_cast&lt;char
*&gt;(malloc(str.size() + 1)); <br>
strcpy(result, str.data()); <br>
return result; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Note: It cannot
guarantee to rewrite every of the path-sensitive memory
allocations.</p>

<h3>Transformation rules of 'memcpy()'
<a name="Transformation rules of 'memcpy()'"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">It is possible
to rewrite the <b>memcpy()</b> and <b>memcpy_s()</b> calls
as the following four functions: <b>strcpy()</b>,
<b>strncpy()</b>, <b>strcpy_s()</b>, <b>strncpy_s()</b>,
where the latter two are the safer versions of the former
two. It rewrites the <b>wchar_t</b> based memory handler
functions respectively.</p>

<h3>Rewrite based on the destination array
<a name="Rewrite based on the destination array"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">If copy to the destination array
cannot overflow [1] the new function should be the older
copy function (ending with <b>cpy</b>), because it is more
efficient than the safe version.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>If copy to the destination array can overflow [1] and
<i>WantToUseSafeFunctions</i> is set to <i>true</i> and it
is possible to obtain the capacity of the destination array
then the new function could be the safe version (ending with
<b>cpy_s</b>).</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>If the new function is could be safe version and C++
files are analyzed and the destination array is plain
<b>char</b>/<b>wchar_t</b> without <b>un/signed</b> then the
length of the destination array can be omitted.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>If the new function is could be safe version and the
destination array is <b>un/signed</b> it needs to be casted
to plain <b>char *</b>/<b>wchar_t *</b>.</p></td></tr>
</table>

<p style="margin-left:9%;"><b>[1] It is possible to
overflow:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>If the capacity of the destination array is unknown.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>If the given length is equal to the destination array's
capacity.</p> </td></tr>
</table>

<h3>Rewrite based on the length of the source string
<a name="Rewrite based on the length of the source string"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">If the given length is
<b>strlen(source)</b> or equal length of this expression
then the new function should be the older copy function
(ending with <b>cpy</b>), as it is more efficient than the
safe version (ending with <b>cpy_s</b>).</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Otherwise we assume that the programmer wanted to copy
'N' characters, so the new function is <b>ncpy</b>-like
which copies 'N' characters.</p></td></tr>
</table>

<h3>Transformations with 'strlen()' or equal length of this expression
<a name="Transformations with 'strlen()' or equal length of this expression"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">It transforms
the <b>wchar_t</b> based memory and string handler functions
respectively (where only <b>strerror_s</b> does not have
<b>wchar_t</b> based alias).</p>

<h3>Memory handler functions
<a name="Memory handler functions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>memcpy</b>
Please visit the <i>Transformation rules of 'memcpy()'</i>
section.</p>

<p style="margin-left:9%; margin-top: 1em"><b>memchr</b>
Usually there is a C-style cast and it is needed to be
removed, because the new function <b>strchr</b>'s return
type is correct. The given length is going to be
removed.</p>

<p style="margin-left:9%; margin-top: 1em"><b>memmove</b>
If safe functions are available the new function is
<b>memmove_s</b>, which has a new second argument which is
the length of the destination array, it is adjusted, and the
length of the source string is incremented by one. If safe
functions are not available the given length is incremented
by one.</p>


<p style="margin-left:9%; margin-top: 1em"><b>memmove_s</b>
The given length is incremented by one.</p>

<h3>String handler functions
<a name="String handler functions"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>strerror_s</b>
The given length is incremented by one.</p>

<p style="margin-left:9%; margin-top: 1em"><b>strncmp</b>
If the third argument is the first or the second argument's
<b>length + 1</b> it has to be truncated without the <b>+
1</b> operation.</p>

<p style="margin-left:9%; margin-top: 1em"><b>strxfrm</b>
The given length is incremented by one.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>WantToUseSafeFunctions</b></p>

<p style="margin-left:18%;">The value <i>true</i> specifies
that the target environment is considered to implement '_s'
suffixed memory and string handler functions which are safer
than older versions (e.g. 'memcpy_s()'). The default value
is <i>true</i>.</p>

<h3>bugprone-optional-value-conversion
<a name="bugprone-optional-value-conversion"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects
potentially unintentional and redundant conversions where a
value is extracted from an optional-like type and then used
to create a new instance of the same optional-like type.</p>

<p style="margin-left:9%; margin-top: 1em">These
conversions might be the result of developer oversight,
leftovers from code refactoring, or other situations that
could lead to unintended exceptions or cases where the
resulting optional is always initialized, which might be
unexpected behavior.</p>

<p style="margin-left:9%; margin-top: 1em">To illustrate,
consider the following problematic code snippet:</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;optional&gt;</p>

<p style="margin-left:13%; margin-top: 1em">void
print(std::optional&lt;int&gt;);</p>

<p style="margin-left:13%; margin-top: 1em">int main() <br>
{ <br>
std::optional&lt;int&gt; opt; <br>
// ...</p>

<p style="margin-left:13%; margin-top: 1em">//
Unintentional conversion from std::optional&lt;int&gt; to
int and back to <br>
// std::optional&lt;int&gt;: <br>
print(opt.value());</p>

<p style="margin-left:13%; margin-top: 1em">// ... <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">A better
approach would be to directly pass <b>opt</b> to the
<b>print</b> function without extracting its value:</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;optional&gt;</p>

<p style="margin-left:13%; margin-top: 1em">void
print(std::optional&lt;int&gt;);</p>

<p style="margin-left:13%; margin-top: 1em">int main() <br>
{ <br>
std::optional&lt;int&gt; opt; <br>
// ...</p>

<p style="margin-left:13%; margin-top: 1em">// Proposed
code: Directly pass the std::optional&lt;int&gt; to the
print <br>
// function. <br>
print(opt);</p>

<p style="margin-left:13%; margin-top: 1em">// ... <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">By passing
<b>opt</b> directly to the print function, unnecessary
conversions are avoided, and potential unintended behavior
or exceptions are minimized.</p>

<p style="margin-left:9%; margin-top: 1em">Value extraction
using <b>operator *</b> is matched by default. The support
for non-standard optional types such as
<b>boost::optional</b> or <b>absl::optional</b> may be
limited.</p>

<h3>Options:
<a name="Options:"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>OptionalTypes</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
(fully qualified) optional type names or regular expressions
that match the optional types. Default value is
<i>::std::optional;::absl::optional;::boost::optional</i>.</p>

<p style="margin-left:9%;"><b>ValueMethods</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
(fully qualified) method names or regular expressions that
match the methods. Default value is
<i>::value$;::get$</i>.</p>

<h3>bugprone-parent-virtual-call
<a name="bugprone-parent-virtual-call"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects and
fixes calls to grand-...parent virtual methods instead of
calls to overridden parent's virtual methods.</p>

<p style="margin-left:13%; margin-top: 1em">struct A { <br>
int virtual foo() {...} <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">struct B:
public A { <br>
int foo() override {...} <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">struct C:
public B { <br>
int foo() override { A::foo(); } <br>
// &#710;&#710;&#710;&#710;&#710;&#710;&#710;&#710; <br>
// warning: qualified name A::foo refers to a member
overridden in subclass; did you mean 'B'?
[bugprone-parent-virtual-call] <br>
};</p>

<h3>bugprone-pointer-arithmetic-on-polymorphic-object
<a name="bugprone-pointer-arithmetic-on-polymorphic-object"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds pointer
arithmetic performed on classes that contain a virtual
function.</p>

<p style="margin-left:9%; margin-top: 1em">Pointer
arithmetic on polymorphic objects where the pointer's static
type is different from its dynamic type is undefined
behavior, as the two types could have different sizes, and
thus the vtable pointer could point to an invalid
address.</p>

<p style="margin-left:9%; margin-top: 1em">Finding pointers
where the static type contains a virtual member function is
a good heuristic, as the pointer is likely to point to a
different, derived object.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">struct Base {
<br>
virtual void &#732;Base(); <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">struct Derived
: public Base {};</p>

<p style="margin-left:13%; margin-top: 1em">void foo() {
<br>
Base *b = new Derived[10];</p>

<p style="margin-left:13%; margin-top: 1em">b += 1; <br>
// warning: pointer arithmetic on class that declares a
virtual function can <br>
// result in undefined behavior if the dynamic type differs
from the <br>
// pointer type</p>

<p style="margin-left:13%; margin-top: 1em">delete[]
static_cast&lt;Derived*&gt;(b); <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreInheritedVirtualFunctions</b></p>

<p style="margin-left:18%;">When <i>true</i>, objects that
only inherit a virtual function are not checked. Classes
that do not declare a new virtual function are excluded by
default, as they make up the majority of false positives.
Default: <i>false</i>.</p>

<p style="margin-left:22%; margin-top: 1em">void bar() {
<br>
Base *b = new Base[10]; <br>
b += 1; // warning, as Base declares a virtual
destructor</p>

<p style="margin-left:22%; margin-top: 1em">delete[] b;</p>

<p style="margin-left:22%; margin-top: 1em">Derived *d =
new Derived[10]; // Derived overrides the destructor, and
<br>
// declares no other virtual functions <br>
d += 1; // warning only if IgnoreVirtualDeclarationsOnly is
set to false</p>

<p style="margin-left:22%; margin-top: 1em">delete[] d;
<br>
}</p>

<h3>References
<a name="References"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the SEI Cert rule <i>CTR56-CPP. Do not use
pointer arithmetic on polymorphic objects</i>.</p>

<h3>bugprone-posix-return
<a name="bugprone-posix-return"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks if any
calls to <b>pthread_*</b> or <b>posix_*</b> functions
(except <b>posix_openpt</b>) expect negative return values.
These functions return either <b>0</b> on success or an
<b>errno</b> on failure, which is positive only.</p>

<p style="margin-left:9%; margin-top: 1em">Example buggy
usage looks like:</p>

<p style="margin-left:13%; margin-top: 1em">if
(posix_fadvise(...) &lt; 0) {</p>

<p style="margin-left:9%; margin-top: 1em">This will never
happen as the return value is always non-negative. A simple
fix could be:</p>

<p style="margin-left:13%; margin-top: 1em">if
(posix_fadvise(...) &gt; 0) {</p>

<h3>bugprone-redundant-branch-condition
<a name="bugprone-redundant-branch-condition"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds condition
variables in nested <b>if</b> statements that were also
checked in the outer <b>if</b> statement and were not
changed.</p>

<p style="margin-left:9%; margin-top: 1em">Simple
example:</p>

<p style="margin-left:13%; margin-top: 1em">bool onFire =
isBurning(); <br>
if (onFire) { <br>
if (onFire) <br>
scream(); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Here
<i>onFire</i> is checked both in the outer <b>if</b> and the
inner <b>if</b> statement without a possible change between
the two checks. The check warns for this code and suggests
removal of the second checking of variable
<i>onFire</i>.</p>

<p style="margin-left:9%; margin-top: 1em">The checker also
detects redundant condition checks if the condition variable
is an operand of a logical &quot;and&quot;
(<b>&amp;&amp;</b>) or a logical &quot;or&quot; (<b>||</b>)
operator:</p>

<p style="margin-left:13%; margin-top: 1em">bool onFire =
isBurning(); <br>
if (onFire) { <br>
if (onFire &amp;&amp; peopleInTheBuilding &gt; 0) <br>
scream(); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">bool onFire =
isBurning(); <br>
if (onFire) { <br>
if (onFire || isCollapsing()) <br>
scream(); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In the first
case (logical &quot;and&quot;) the suggested fix is to
remove the redundant condition variable and keep the other
side of the <b>&amp;&amp;</b>. In the second case (logical
&quot;or&quot;) the whole <b>if</b> is removed similarly to
the simple case on the top.</p>

<p style="margin-left:9%; margin-top: 1em">The condition of
the outer <b>if</b> statement may also be a logical
&quot;and&quot; (<b>&amp;&amp;</b>) expression:</p>

<p style="margin-left:13%; margin-top: 1em">bool onFire =
isBurning(); <br>
if (onFire &amp;&amp; fireFighters &lt; 10) { <br>
if (someOtherCondition()) { <br>
if (onFire) <br>
scream(); <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The error is
also detected if both the outer statement is a logical
&quot;and&quot; (<b>&amp;&amp;</b>) and the inner statement
is a logical &quot;and&quot; (<b>&amp;&amp;</b>) or
&quot;or&quot; (<b>||</b>). The inner <b>if</b> statement
does not have to be a direct descendant of the outer
one.</p>

<p style="margin-left:9%; margin-top: 1em">No error is
detected if the condition variable may have been changed
between the two checks:</p>

<p style="margin-left:13%; margin-top: 1em">bool onFire =
isBurning(); <br>
if (onFire) { <br>
tryToExtinguish(onFire); <br>
if (onFire &amp;&amp; peopleInTheBuilding &gt; 0) <br>
scream(); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Every possible
change is considered, thus if the condition variable is not
a local variable of the function, it is a volatile or it has
an alias (pointer or reference) then no warning is
issued.</p>

<h3>Known limitations
<a name="Known limitations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The <b>else</b>
branch is not checked currently for negated condition
variable:</p>

<p style="margin-left:13%; margin-top: 1em">bool onFire =
isBurning(); <br>
if (onFire) { <br>
scream(); <br>
} else { <br>
if (!onFire) { <br>
continueWork(); <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The checker
currently only detects redundant checking of single
condition variables. More complex expressions are not
checked:</p>

<p style="margin-left:13%; margin-top: 1em">if
(peopleInTheBuilding == 1) { <br>
if (peopleInTheBuilding == 1) { <br>
doSomething(); <br>
} <br>
}</p>

<h3>bugprone-reserved-identifier
<a name="bugprone-reserved-identifier"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>cert-dcl37-c</i>
and <i>cert-dcl51-cpp</i> redirect here as an alias for this
check.</p>

<p style="margin-left:9%; margin-top: 1em">Checks for
usages of identifiers reserved for use by the
implementation.</p>

<p style="margin-left:9%; margin-top: 1em">The C and C++
standards both reserve the following names for such use:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>identifiers that begin with an underscore followed by an
uppercase letter;</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>identifiers in the global namespace that begin with an
underscore.</p> </td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">The C standard
additionally reserves names beginning with a double
underscore, while the C++ standard strengthens this to
reserve names with a double underscore occurring
anywhere.</p>

<p style="margin-left:9%; margin-top: 1em">Violating the
naming rules above results in undefined behavior.</p>

<p style="margin-left:13%; margin-top: 1em">namespace NS {
<br>
void __f(); // name is not allowed in user code <br>
using _Int = int; // same with this <br>
#define cool__macro // also this <br>
} <br>
int _g(); // disallowed in global namespace only</p>

<p style="margin-left:9%; margin-top: 1em">The check can
also be inverted, i.e. it can be configured to flag any
identifier that is _not_ a reserved identifier. This mode is
for use by e.g. standard library implementors, to ensure
they don't infringe on the user namespace.</p>

<p style="margin-left:9%; margin-top: 1em">This check does
not (yet) check for other reserved names, e.g. macro names
identical to language keywords, and names specifically
reserved by language standards, e.g. C++ 'zombie names' and
C future library directions.</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to CERT C Coding Standard rule <i>DCL37-C. Do
not declare or define a reserved identifier</i> as well as
its C++ counterpart, <i>DCL51-CPP. Do not declare or define
a reserved identifier</i>.</p>

<h3>Options
<a name="Options"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p style="margin-top: 1em"><b>Invert</b></p></td>
<td width="1%"></td>
<td width="82%">


<p style="margin-top: 1em">If <i>true</i>, inverts the
check, i.e. flags names that are not reserved. Default is
<i>false</i>.</p> </td></tr>
</table>

<p style="margin-left:9%;"><b>AllowedIdentifiers</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
regular expressions that the check ignores. Default is an
empty list.</p>

<h3>bugprone-return-const-ref-from-parameter
<a name="bugprone-return-const-ref-from-parameter"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects return
statements that return a constant reference parameter as
constant reference. This may cause use-after-free errors if
the caller uses xvalues as arguments.</p>

<p style="margin-left:9%; margin-top: 1em">In C++, constant
reference parameters can accept xvalues which will be
destructed after the call. When the function returns such a
parameter also as constant reference, then the returned
reference can be used after the object it refers to has been
destroyed.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">struct S { <br>
int v; <br>
S(int); <br>
&#732;S(); <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">const S
&amp;fn(const S &amp;a) { <br>
return a; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">const S&amp; s
= fn(S{1}); <br>
s.v; // use after free</p>

<h3>bugprone-shared-ptr-array-mismatch
<a name="bugprone-shared-ptr-array-mismatch"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
initializations of C++ shared pointers to non-array type
that are initialized with an array.</p>

<p style="margin-left:9%; margin-top: 1em">If a shared
pointer <b>std::shared_ptr&lt;T&gt;</b> is initialized with
a new-expression <b>new T[]</b> the memory is not
deallocated correctly. The pointer uses plain <b>delete</b>
in this case to deallocate the target memory. Instead a
<b>delete[]</b> call is needed. A
<b>std::shared_ptr&lt;T[]&gt;</b> calls the correct delete
operator.</p>

<p style="margin-left:9%; margin-top: 1em">The check offers
replacement of <b>shared_ptr&lt;T&gt;</b> to
<b>shared_ptr&lt;T[]&gt;</b> if it is used at a single
variable declaration (one variable in one statement).</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>


<p style="margin-left:13%; margin-top: 1em">std::shared_ptr&lt;Foo&gt;
x(new Foo[10]); // -&gt; std::shared_ptr&lt;Foo[]&gt; x(new
Foo[10]); <br>
// &#710; warning: shared pointer to non-array is
initialized with array [bugprone-shared-ptr-array-mismatch]
<br>
std::shared_ptr&lt;Foo&gt; x1(new Foo), x2(new Foo[10]); //
no replacement <br>
// &#710; warning: shared pointer to non-array is
initialized with array
[bugprone-shared-ptr-array-mismatch]</p>


<p style="margin-left:13%; margin-top: 1em">std::shared_ptr&lt;Foo&gt;
x3(new Foo[10], [](const Foo *ptr) { delete[] ptr; }); // no
warning</p>

<p style="margin-left:13%; margin-top: 1em">struct S { <br>
std::shared_ptr&lt;Foo&gt; x(new Foo[10]); // no replacement
in this case <br>
// &#710; warning: shared pointer to non-array is
initialized with array [bugprone-shared-ptr-array-mismatch]
<br>
};</p>

<p style="margin-left:9%; margin-top: 1em">This check
partially covers the CERT C++ Coding Standard rule -
<i>MEM51-CPP. Properly deallocate dynamically allocated
resources</i> However, only the <b>std::shared_ptr</b> case
is detected by this check.</p>

<h3>bugprone-signal-handler
<a name="bugprone-signal-handler"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds specific
constructs in signal handler functions that can cause
undefined behavior. The rules for what is allowed differ
between C++ language versions.</p>

<p style="margin-left:9%; margin-top: 1em">Checked signal
handler rules for C:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="73%">


<p>Calls to non-asynchronous-safe functions are not
allowed.</p> </td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Checked signal
handler rules for up to and including C++14:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Calls to non-asynchronous-safe
functions are not allowed.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>C++-specific code constructs are not allowed in signal
handlers. In other words, only the common subset of C and
C++ is allowed to be used.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Calls to functions with non-C linkage are not allowed
(including the signal handler itself).</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">The check is
disabled on C++17 and later.</p>


<p style="margin-left:9%; margin-top: 1em">Asynchronous-safety
is determined by comparing the function's name against a set
of known functions. In addition, the function must come from
a system header include and in a global namespace. The
(possible) arguments passed to the function are not checked.
Any function that cannot be determined to be
asynchronous-safe is assumed to be non-asynchronous-safe by
the check, including user functions for which only the
declaration is visible. Calls to user-defined functions with
visible definitions are checked recursively.</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements the CERT C Coding Standard rule <i>SIG30-C. Call
only asynchronous-safe functions within signal handlers</i>
and the rule - <i>MSC54-CPP. A signal handler must be a
plain old function</i>. It has the alias names
<b>cert-sig30-c</b> and <b>cert-msc54-cpp</b>.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>AsyncSafeFunctionSet</b></p>

<p style="margin-left:18%;">Selects which set of functions
is considered as asynchronous-safe (and therefore allowed in
signal handlers). It can be set to the following values:
<b><br>
minimal</b></p>

<p style="margin-left:27%;">Selects a minimal set that is
defined in the CERT SIG30-C rule. and includes functions
<b>abort()</b>, <b>_Exit()</b>, <b>quick_exit()</b> and
<b>signal()</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="6%">


<p><b>POSIX</b></p></td>
<td width="3%"></td>
<td width="73%">


<p>Selects a larger set of functions that is listed in
POSIX.1-2017 (see <i>this link</i> for more information).
The following functions are included: <b>_Exit</b>,
<b>_exit</b>, <b>abort</b>, <b>accept</b>, <b>access</b>,
<b>aio_error</b>, <b>aio_return</b>, <b>aio_suspend</b>,
<b>alarm</b>, <b>bind</b>, <b>cfgetispeed</b>,
<b>cfgetospeed</b>, <b>cfsetispeed</b>, <b>cfsetospeed</b>,
<b>chdir</b>, <b>chmod</b>, <b>chown</b>,
<b>clock_gettime</b>, <b>close</b>, <b>connect</b>,
<b>creat</b>, <b>dup</b>, <b>dup2</b>, <b>execl</b>,
<b>execle</b>, <b>execv</b>, <b>execve</b>,
<b>faccessat</b>, <b>fchdir</b>, <b>fchmod</b>,
<b>fchmodat</b>, <b>fchown</b>, <b>fchownat</b>,
<b>fcntl</b>, <b>fdatasync</b>, <b>fexecve</b>, <b>ffs</b>,
<b>fork</b>, <b>fstat</b>, <b>fstatat</b>, <b>fsync</b>,
<b>ftruncate</b>, <b>futimens</b>, <b>getegid</b>,
<b>geteuid</b>, <b>getgid</b>, <b>getgroups</b>,
<b>getpeername</b>, <b>getpgrp</b>, <b>getpid</b>,
<b>getppid</b>, <b>getsockname</b>, <b>getsockopt</b>,
<b>getuid</b>, <b>htonl</b>, <b>htons</b>, <b>kill</b>,
<b>link</b>, <b>linkat</b>, <b>listen</b>, <b>longjmp</b>,
<b>lseek</b>, <b>lstat</b>, <b>memccpy</b>, <b>memchr</b>,
<b>memcmp</b>, <b>memcpy</b>, <b>memmove</b>, <b>memset</b>,
<b>mkdir</b>, <b>mkdirat</b>, <b>mkfifo</b>,
<b>mkfifoat</b>, <b>mknod</b>, <b>mknodat</b>, <b>ntohl</b>,
<b>ntohs</b>, <b>open</b>, <b>openat</b>, <b>pause</b>,
<b>pipe</b>, <b>poll</b>, <b>posix_trace_event</b>,
<b>pselect</b>, <b>pthread_kill</b>, <b>pthread_self</b>,
<b>pthread_sigmask</b>, <b>quick_exit</b>, <b>raise</b>,
<b>read</b>, <b>readlink</b>, <b>readlinkat</b>,
<b>recv</b>, <b>recvfrom</b>, <b>recvmsg</b>, <b>rename</b>,
<b>renameat</b>, <b>rmdir</b>, <b>select</b>,
<b>sem_post</b>, <b>send</b>, <b>sendmsg</b>, <b>sendto</b>,
<b>setgid</b>, <b>setpgid</b>, <b>setsid</b>,
<b>setsockopt</b>, <b>setuid</b>, <b>shutdown</b>,
<b>sigaction</b>, <b>sigaddset</b>, <b>sigdelset</b>,
<b>sigemptyset</b>, <b>sigfillset</b>, <b>sigismember</b>,
<b>siglongjmp</b>, <b>signal</b>, <b>sigpause</b>,
<b>sigpending</b>, <b>sigprocmask</b>, <b>sigqueue</b>,
<b>sigset</b>, <b>sigsuspend</b>, <b>sleep</b>,
<b>sockatmark</b>, <b>socket</b>, <b>socketpair</b>,
<b>stat</b>, <b>stpcpy</b>, <b>stpncpy</b>, <b>strcat</b>,
<b>strchr</b>, <b>strcmp</b>, <b>strcpy</b>, <b>strcspn</b>,
<b>strlen</b>, <b>strncat</b>, <b>strncmp</b>,
<b>strncpy</b>, <b>strnlen</b>, <b>strpbrk</b>,
<b>strrchr</b>, <b>strspn</b>, <b>strstr</b>,
<b>strtok_r</b>, <b>symlink</b>, <b>symlinkat</b>,
<b>tcdrain</b>, <b>tcflow</b>, <b>tcflush</b>,
<b>tcgetattr</b>, <b>tcgetpgrp</b>, <b>tcsendbreak</b>,
<b>tcsetattr</b>, <b>tcsetpgrp</b>, <b>time</b>,
<b>timer_getoverrun</b>, <b>timer_gettime</b>,
<b>timer_settime</b>, <b>times</b>, <b>umask</b>,
<b>uname</b>, <b>unlink</b>, <b>unlinkat</b>, <b>utime</b>,
<b>utimensat</b>, <b>utimes</b>, <b>wait</b>,
<b>waitpid</b>, <b>wcpcpy</b>, <b>wcpncpy</b>,
<b>wcscat</b>, <b>wcschr</b>, <b>wcscmp</b>, <b>wcscpy</b>,
<b>wcscspn</b>, <b>wcslen</b>, <b>wcsncat</b>,
<b>wcsncmp</b>, <b>wcsncpy</b>, <b>wcsnlen</b>,
<b>wcspbrk</b>, <b>wcsrchr</b>, <b>wcsspn</b>,
<b>wcsstr</b>, <b>wcstok</b>, <b>wmemchr</b>,
<b>wmemcmp</b>, <b>wmemcpy</b>, <b>wmemmove</b>,
<b>wmemset</b>, <b>write</b></p></td></tr>
</table>

<p style="margin-left:27%; margin-top: 1em">The function
<b>quick_exit</b> is not included in the POSIX list but it
is included here in the set of safe functions.</p>

<p style="margin-left:18%; margin-top: 1em">The default
value is <b>POSIX</b>.</p>

<h3>bugprone-signed-char-misuse
<a name="bugprone-signed-char-misuse"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>cert-str34-c</i>
redirects here as an alias for this check. For the CERT
alias, the <i>DiagnoseSignedUnsignedCharComparisons</i>
option is set to <i>false</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Finds those
<b>signed char</b> -&gt; integer conversions which might
indicate a programming error. The basic problem with the
<b>signed char</b>, that it might store the non-ASCII
characters as negative values. This behavior can cause a
misunderstanding of the written code both when an explicit
and when an implicit conversion happens.</p>

<p style="margin-left:9%; margin-top: 1em">When the code
contains an explicit <b>signed char</b> -&gt; integer
conversion, the human programmer probably expects that the
converted value matches with the character code (a value
from [0..255]), however, the actual value is in [-128..127]
interval. To avoid this kind of misinterpretation, the
desired way of converting from a <b>signed char</b> to an
integer value is converting to <b>unsigned char</b> first,
which stores all the characters in the positive [0..255]
interval which matches the known character codes.</p>

<p style="margin-left:9%; margin-top: 1em">In case of
implicit conversion, the programmer might not actually be
aware that a conversion happened and char value is used as
an integer. There are some use cases when this unawareness
might lead to a functionally imperfect code. For example,
checking the equality of a <b>signed char</b> and an
<b>unsigned char</b> variable is something we should avoid
in C++ code. During this comparison, the two variables are
converted to integers which have different value ranges. For
<b>signed char</b>, the non-ASCII characters are stored as a
value in [-128..-1] interval, while the same characters are
stored in the [128..255] interval for an <b>unsigned
char</b>.</p>

<p style="margin-left:9%; margin-top: 1em">It depends on
the actual platform whether plain <b>char</b> is handled as
<b>signed char</b> by default and so it is caught by this
check or not. To change the default behavior you can use
<b>-funsigned-char</b> and <b>-fsigned-char</b> compilation
options.</p>

<p style="margin-left:9%; margin-top: 1em">Currently, this
check warns in the following cases: - <b>signed char</b> is
assigned to an integer variable - <b>signed char</b> and
<b>unsigned char</b> are compared with equality/inequality
operator - <b>signed char</b> is converted to an integer in
the array subscript</p>

<p style="margin-left:9%; margin-top: 1em">See also:
<i>STR34-C. Cast characters to unsigned char before
converting to larger integer sizes</i></p>

<p style="margin-left:9%; margin-top: 1em">A good example
from the CERT description when a <b>char</b> variable is
used to read from a file that might contain non-ASCII
characters. The problem comes up when the code uses the
<b>-1</b> integer value as EOF, while the 255 character code
is also stored as <b>-1</b> in two's complement form of char
type. See a simple example of this below. This code stops
not only when it reaches the end of the file, but also when
it gets a character with the 255 code.</p>

<p style="margin-left:13%; margin-top: 1em">#define EOF
(-1)</p>

<p style="margin-left:13%; margin-top: 1em">int read(void)
{ <br>
char CChar; <br>
int IChar = EOF;</p>

<p style="margin-left:13%; margin-top: 1em">if
(readChar(CChar)) { <br>
IChar = CChar; <br>
} <br>
return IChar; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">A proper way to
fix the code above is converting the <b>char</b> variable to
an <b>unsigned char</b> value first.</p>

<p style="margin-left:13%; margin-top: 1em">#define EOF
(-1)</p>

<p style="margin-left:13%; margin-top: 1em">int read(void)
{ <br>
char CChar; <br>
int IChar = EOF;</p>

<p style="margin-left:13%; margin-top: 1em">if
(readChar(CChar)) { <br>
IChar = static_cast&lt;unsigned char&gt;(CChar); <br>
} <br>
return IChar; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Another use case
is checking the equality of two <b>char</b> variables with
different signedness. Inside the non-ASCII value range this
comparison between a <b>signed char</b> and an <b>unsigned
char</b> always returns <b>false</b>.</p>

<p style="margin-left:13%; margin-top: 1em">bool
compare(signed char SChar, unsigned char USChar) { <br>
if (SChar == USChar) <br>
return true; <br>
return false; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The easiest way
to fix this kind of comparison is casting one of the
arguments, so both arguments will have the same type.</p>

<p style="margin-left:13%; margin-top: 1em">bool
compare(signed char SChar, unsigned char USChar) { <br>
if (static_cast&lt;unsigned char&gt;(SChar) == USChar) <br>
return true; <br>
return false; <br>
}</p>

<p style="margin-left:9%;"><b>CharTypdefsToIgnore</b></p>

<p style="margin-left:18%;">A semicolon-separated list of
typedef names. In this list, we can list typedefs for
<b>char</b> or <b>signed char</b>, which will be ignored by
the check. This is useful when a typedef introduces an
integer alias like <b>sal_Int8</b> or <b>int8_t</b>. In this
case, human misinterpretation is not an issue.</p>


<p style="margin-left:9%;"><b>DiagnoseSignedUnsignedCharComparisons</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will warn on <b>signed char</b>/<b>unsigned char</b>
comparisons, otherwise these comparisons are ignored. By
default, this option is set to <i>true</i>.</p>

<h3>bugprone-sizeof-container
<a name="bugprone-sizeof-container"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check finds
usages of <b>sizeof</b> on expressions of STL container
types. Most likely the user wanted to use <b>.size()</b>
instead.</p>

<p style="margin-left:9%; margin-top: 1em">All class/struct
types declared in namespace <b>std::</b> having a const
<b>size()</b> method are considered containers, with the
exception of <b>std::bitset</b> and <b>std::array</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">std::string s;
<br>
int a = 47 + sizeof(s); // warning: sizeof() doesn't return
the size of the container. Did you mean .size()?</p>

<p style="margin-left:13%; margin-top: 1em">int b =
sizeof(std::string); // no warning, probably intended.</p>

<p style="margin-left:13%; margin-top: 1em">std::string
array_of_strings[10]; <br>
int c = sizeof(array_of_strings) /
sizeof(array_of_strings[0]); // no warning, definitely
intended.</p>


<p style="margin-left:13%; margin-top: 1em">std::array&lt;int,
3&gt; std_array; <br>
int d = sizeof(std_array); // no warning, probably
intended.</p>

<h3>bugprone-sizeof-expression
<a name="bugprone-sizeof-expression"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check finds
usages of <b>sizeof</b> expressions which are most likely
errors.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>sizeof</b> operator yields the size (in bytes) of its
operand, which may be an expression or the parenthesized
name of a type. Misuse of this operator may be leading to
errors and possible software vulnerabilities.</p>

<h3>Suspicious usage of 'sizeof(K)'
<a name="Suspicious usage of 'sizeof(K)'"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">A common mistake
is to query the <b>sizeof</b> of an integer literal. This is
equivalent to query the size of its type (probably
<b>int</b>). The intent of the programmer was probably to
simply get the integer and not its size.</p>

<p style="margin-left:13%; margin-top: 1em">#define BUFLEN
42 <br>
char buf[BUFLEN]; <br>
memset(buf, 0, sizeof(BUFLEN)); // sizeof(42) ==&gt;
sizeof(int)</p>

<h3>Suspicious usage of 'sizeof(expr)'
<a name="Suspicious usage of 'sizeof(expr)'"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">In cases, where
there is an enum or integer to represent a type, a common
mistake is to query the <b>sizeof</b> on the integer or enum
that represents the type that should be used by
<b>sizeof</b>. This results in the size of the integer and
not of the type the integer represents:</p>

<p style="margin-left:13%; margin-top: 1em">enum data_type
{ <br>
FLOAT_TYPE, <br>
DOUBLE_TYPE <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">struct data {
<br>
data_type type; <br>
void* buffer; <br>
data_type get_type() { <br>
return type; <br>
} <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">void f(data d,
int numElements) { <br>
// should be sizeof(float) or sizeof(double), depending on
d.get_type() <br>
int numBytes = numElements * sizeof(d.get_type()); <br>
... <br>
}</p>

<h3>Suspicious usage of 'sizeof(this)'
<a name="Suspicious usage of 'sizeof(this)'"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The <b>this</b>
keyword is evaluated to a pointer to an object of a given
type. The expression <b>sizeof(this)</b> is returning the
size of a pointer. The programmer most likely wanted the
size of the object and not the size of the pointer.</p>

<p style="margin-left:13%; margin-top: 1em">class Point {
<br>
[...] <br>
size_t size() { return sizeof(this); } // should probably be
sizeof(*this) <br>
[...] <br>
};</p>

<h3>Suspicious usage of 'sizeof(char*)'
<a name="Suspicious usage of 'sizeof(char*)'"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">There is a
subtle difference between declaring a string literal with
<b>char* A = &quot;&quot;</b> and <b>char A[] =
&quot;&quot;</b>. The first case has the type <b>char*</b>
instead of the aggregate type <b>char[]</b>. Using
<b>sizeof</b> on an object declared with <b>char*</b> type
is returning the size of a pointer instead of the number of
characters (bytes) in the string literal.</p>

<p style="margin-left:13%; margin-top: 1em">const char*
kMessage = &quot;Hello World!&quot;; // const char
kMessage[] = &quot;...&quot;; <br>
void getMessage(char* buf) { <br>
memcpy(buf, kMessage, sizeof(kMessage)); // sizeof(char*)
<br>
}</p>

<h3>Suspicious usage of 'sizeof(A*)'
<a name="Suspicious usage of 'sizeof(A*)'"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">A common mistake
is to compute the size of a pointer instead of its pointee.
These cases may occur because of explicit cast or implicit
conversion.</p>

<p style="margin-left:13%; margin-top: 1em">int A[10]; <br>
memset(A, 0, sizeof(A + 0));</p>

<p style="margin-left:13%; margin-top: 1em">struct Point
point; <br>
memset(point, 0, sizeof(&amp;point));</p>

<h3>Suspicious usage of 'sizeof(...)/sizeof(...)'
<a name="Suspicious usage of 'sizeof(...)/sizeof(...)'"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Dividing
<b>sizeof</b> expressions is typically used to retrieve the
number of elements of an aggregate. This check warns on
incompatible or suspicious cases.</p>

<p style="margin-left:9%; margin-top: 1em">In the following
example, the entity has 10-bytes and is incompatible with
the type <b>int</b> which has 4 bytes.</p>

<p style="margin-left:13%; margin-top: 1em">char buf[] = {
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; // sizeof(buf) =&gt; 10 <br>
void getMessage(char* dst) { <br>
memcpy(dst, buf, sizeof(buf) / sizeof(int)); // sizeof(int)
=&gt; 4 [incompatible sizes] <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In the following
example, the expression <b>sizeof(Values)</b> is returning
the size of <b>char*</b>. One can easily be fooled by its
declaration, but in parameter declaration the size '10' is
ignored and the function is receiving a <b>char*</b>.</p>

<p style="margin-left:13%; margin-top: 1em">char
OrderedValues[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; <br>
return CompareArray(char Values[10]) { <br>
return memcmp(OrderedValues, Values, sizeof(Values)) == 0;
// sizeof(Values) ==&gt; sizeof(char*) [implicit cast to
char*] <br>
}</p>

<h3>Suspicious 'sizeof' by 'sizeof' expression
<a name="Suspicious 'sizeof' by 'sizeof' expression"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Multiplying
<b>sizeof</b> expressions typically makes no sense and is
probably a logic error. In the following example, the
programmer used <b>*</b> instead of <b>/</b>.</p>

<p style="margin-left:13%; margin-top: 1em">const char
kMessage[] = &quot;Hello World!&quot;; <br>
void getMessage(char* buf) { <br>
memcpy(buf, kMessage, sizeof(kMessage) * sizeof(char)); //
sizeof(kMessage) / sizeof(char) <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">This check may
trigger on code using the arraysize macro. The following
code is working correctly but should be simplified by using
only the <b>sizeof</b> operator.</p>

<p style="margin-left:13%; margin-top: 1em">extern Object
objects[100]; <br>
void InitializeObjects() { <br>
memset(objects, 0, arraysize(objects) * sizeof(Object)); //
sizeof(objects) <br>
}</p>

<h3>Suspicious usage of 'sizeof(sizeof(...))'
<a name="Suspicious usage of 'sizeof(sizeof(...))'"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Getting the
<b>sizeof</b> of a <b>sizeof</b> makes no sense and is
typically an error hidden through macros.</p>

<p style="margin-left:13%; margin-top: 1em">#define INT_SZ
sizeof(int) <br>
int buf[] = { 42 }; <br>
void getInt(int* dst) { <br>
memcpy(dst, buf, sizeof(INT_SZ)); // sizeof(sizeof(int)) is
suspicious. <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>WarnOnSizeOfConstant</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will warn on an expression like <b>sizeof(CONSTANT)</b>.
Default is <i>true</i>.</p>


<p style="margin-left:9%;"><b>WarnOnSizeOfIntegerExpression</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will warn on an expression like <b>sizeof(expr)</b> where
the expression results in an integer. Default is
<i>false</i>.</p>

<p style="margin-left:9%;"><b>WarnOnSizeOfThis</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will warn on an expression like <b>sizeof(this)</b>. Default
is <i>true</i>.</p>


<p style="margin-left:9%;"><b>WarnOnSizeOfCompareToConstant</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will warn on an expression like <b>sizeof(expr) &lt;= k</b>
for a suspicious constant <i>k</i> while <i>k</i> is
<i>0</i> or greater than <i>0x8000</i>. Default is
<i>true</i>.</p>


<p style="margin-left:9%;"><b>WarnOnSizeOfPointerToAggregate</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will warn when the argument of <b>sizeof</b> is either a
pointer-to-aggregate type, an expression returning a
pointer-to-aggregate value or an expression that returns a
pointer from an array-to-pointer conversion (that may be
implicit or explicit, for example <b>array + 2</b> or
<b>(int *)array</b>). Default is <i>true</i>.</p>

<p style="margin-left:9%;"><b>WarnOnSizeOfPointer</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will report all expressions where the argument of
<b>sizeof</b> is an expression that produces a pointer
(except for a few idiomatic expressions that are probably
intentional and correct). This detects occurrences of CWE
467. Default is <i>false</i>.</p>

<h3>bugprone-spuriously-wake-up-functions
<a name="bugprone-spuriously-wake-up-functions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
<b>cnd_wait</b>, <b>cnd_timedwait</b>, <b>wait</b>,
<b>wait_for</b>, or <b>wait_until</b> function calls when
the function is not invoked from a loop that checks whether
a condition predicate holds or the function has a condition
parameter.</p>

<p style="margin-left:13%; margin-top: 1em">if
(condition_predicate) { <br>
condition.wait(lk); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">if
(condition_predicate) { <br>
if (thrd_success != cnd_wait(&amp;condition, &amp;lock)) {
<br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard rule
<i>CON54-CPP. Wrap functions that can spuriously wake up in
a loop</i>. and CERT C Coding Standard rule <i>CON36-C. Wrap
functions that can spuriously wake up in a loop</i>.</p>

<h3>bugprone-standalone-empty
<a name="bugprone-standalone-empty"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns when
<b>empty()</b> is used on a range and the result is ignored.
Suggests <b>clear()</b> if it is an existing member
function.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>empty()</b> method on several common ranges returns a
Boolean indicating whether or not the range is empty, but is
often mistakenly interpreted as a way to clear the contents
of a range. Some ranges offer a <b>clear()</b> method for
this purpose. This check warns when a call to empty returns
a result that is ignored, and suggests replacing it with a
call to <b>clear()</b> if it is available as a member
function of the range.</p>

<p style="margin-left:9%; margin-top: 1em">For example, the
following code could be used to indicate whether a range is
empty or not, but the result is ignored:</p>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;int&gt;
v; <br>
... <br>
v.empty();</p>

<p style="margin-left:9%; margin-top: 1em">A call to
<b>clear()</b> would appropriately clear the contents of the
range:</p>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;int&gt;
v; <br>
... <br>
v.clear();</p>


<p style="margin-left:9%; margin-top: 1em">Limitations:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Doesn't warn if <b>empty()</b> is defined and used with
the ignore result in the class template definition (for
example in the library implementation). These error cases
can be caught with <b>[[nodiscard]]</b> attribute.</p></td></tr>
</table>

<h3>bugprone-string-constructor
<a name="bugprone-string-constructor"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds string
constructors that are suspicious and probably errors.</p>

<p style="margin-left:9%; margin-top: 1em">A common mistake
is to swap parameters to the 'fill' string-constructor.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">std::string
str('x', 50); // should be str(50, 'x')</p>

<p style="margin-left:9%; margin-top: 1em">Calling the
string-literal constructor with a length bigger than the
literal is suspicious and adds extra random characters to
the string.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>


<p style="margin-left:13%; margin-top: 1em">std::string(&quot;test&quot;,
200); // Will include random characters after
&quot;test&quot;. <br>
std::string_view(&quot;test&quot;, 200);</p>

<p style="margin-left:9%; margin-top: 1em">Creating an
empty string from constructors with parameters is considered
suspicious. The programmer should use the empty constructor
instead.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>


<p style="margin-left:13%; margin-top: 1em">std::string(&quot;test&quot;,
0); // Creation of an empty string. <br>
std::string_view(&quot;test&quot;, 0);</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>WarnOnLargeLength</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will warn on a string with a length greater than
<i>LargeLengthThreshold</i>. Default is <i>true</i>.</p>

<p style="margin-left:9%;"><b>LargeLengthThreshold</b></p>

<p style="margin-left:18%;">An integer specifying the large
length threshold. Default is <i>0x800000</i>.</p>

<p style="margin-left:9%;"><b>StringNames</b></p>

<p style="margin-left:18%;">Default is
<i>::std::basic_string;::std::basic_string_view</i>.</p>


<p style="margin-left:18%; margin-top: 1em">Semicolon-delimited
list of class names to apply this check to. By default
<i>::std::basic_string</i> applies to <b>std::string</b> and
<b>std::wstring</b>. Set to e.g.
<i>::std::basic_string;llvm::StringRef;QString</i> to
perform this check on custom classes.</p>

<h3>bugprone-string-integer-assignment
<a name="bugprone-string-integer-assignment"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check finds
assignments of an integer to
<b>std::basic_string&lt;CharT&gt;</b> (<b>std::string</b>,
<b>std::wstring</b>, etc.). The source of the problem is the
following assignment operator of
<b>std::basic_string&lt;CharT&gt;</b>:</p>


<p style="margin-left:13%; margin-top: 1em">basic_string&amp;
operator=( CharT ch );</p>

<p style="margin-left:9%; margin-top: 1em">Numeric types
can be implicitly casted to character types.</p>

<p style="margin-left:13%; margin-top: 1em">std::string s;
<br>
int x = 5965; <br>
s = 6; <br>
s = x;</p>

<p style="margin-left:9%; margin-top: 1em">Use the
appropriate conversion functions or character literals.</p>

<p style="margin-left:13%; margin-top: 1em">std::string s;
<br>
int x = 5965; <br>
s = '6'; <br>
s = std::to_string(x);</p>

<p style="margin-left:9%; margin-top: 1em">In order to
suppress false positives, use an explicit cast.</p>

<p style="margin-left:13%; margin-top: 1em">std::string s;
<br>
s = static_cast&lt;char&gt;(6);</p>

<h3>bugprone-string-literal-with-embedded-nul
<a name="bugprone-string-literal-with-embedded-nul"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
occurrences of string literal with embedded NUL character
and validates their usage.</p>

<h3>Invalid escaping
<a name="Invalid escaping"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Special
characters can be escaped within a string literal by using
their hexadecimal encoding like <b>\x42</b>. A common
mistake is to escape them like this <b>\0x42</b> where the
<b>\0</b> stands for the NUL character.</p>

<p style="margin-left:13%; margin-top: 1em">const char*
Example[] = &quot;Invalid character: \0x12 should be
\x12&quot;; <br>
const char* Bytes[] =
&quot;\x03\0x02\0x01\0x00\0xFF\0xFF\0xFF&quot;;</p>

<h3>Truncated literal
<a name="Truncated literal"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">String-like
classes can manipulate strings with embedded NUL as they are
keeping track of the bytes and the length. This is not the
case for a <b>char*</b> (NUL-terminated) string.</p>

<p style="margin-left:9%; margin-top: 1em">A common mistake
is to pass a string-literal with embedded NUL to a string
constructor expecting a NUL-terminated string. The bytes
after the first NUL character are truncated.</p>

<p style="margin-left:13%; margin-top: 1em">std::string
str(&quot;abc\0def&quot;); // &quot;def&quot; is truncated
<br>
str += &quot;\0&quot;; // This statement is doing nothing
<br>
if (str == &quot;\0abc&quot;) return; // This expression is
always true</p>

<h3>bugprone-stringview-nullptr
<a name="bugprone-stringview-nullptr"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for
various ways that the <b>const CharT*</b> constructor of
<b>std::basic_string_view</b> can be passed a null argument
and replaces them with the default constructor in most
cases. For the comparison operators, braced initializer list
does not compile so instead a call to <b>.empty()</b> or the
empty string literal are used, where appropriate.</p>

<p style="margin-left:9%; margin-top: 1em">This prevents
code from invoking behavior which is unconditionally
undefined. The single-argument <b>const CharT*</b>
constructor does not check for the null case before
dereferencing its input. The standard is slated to add an
explicitly-deleted overload to catch some of these cases:
wg21.link/p2166</p>

<p style="margin-left:9%; margin-top: 1em">To catch the
additional cases of <b>NULL</b> (which expands to
<b>__null</b>) and <b>0</b>, first run the
<b>modernize-use-nullptr</b> check to convert the callers to
<b>nullptr</b>.</p>


<p style="margin-left:13%; margin-top: 1em">std::string_view
sv = nullptr;</p>

<p style="margin-left:13%; margin-top: 1em">sv =
nullptr;</p>

<p style="margin-left:13%; margin-top: 1em">bool is_empty =
sv == nullptr; <br>
bool isnt_empty = sv != nullptr;</p>


<p style="margin-left:13%; margin-top: 1em">accepts_sv(nullptr);</p>


<p style="margin-left:13%; margin-top: 1em">accepts_sv({{}});
// A</p>


<p style="margin-left:13%; margin-top: 1em">accepts_sv({nullptr,
0}); // B</p>

<p style="margin-left:9%; margin-top: 1em">is translated
into...</p>


<p style="margin-left:13%; margin-top: 1em">std::string_view
sv = {};</p>

<p style="margin-left:13%; margin-top: 1em">sv = {};</p>

<p style="margin-left:13%; margin-top: 1em">bool is_empty =
sv.empty(); <br>
bool isnt_empty = !sv.empty();</p>


<p style="margin-left:13%; margin-top: 1em">accepts_sv(&quot;&quot;);</p>


<p style="margin-left:13%; margin-top: 1em">accepts_sv(&quot;&quot;);
// A</p>


<p style="margin-left:13%; margin-top: 1em">accepts_sv({nullptr,
0}); // B</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">The source pattern with
trailing comment &quot;A&quot; selects the <b>(const
CharT*)</b> constructor overload and then value-initializes
the pointer, causing a null dereference. It happens to not
include the <b>nullptr</b> literal, but it is still within
the scope of this ClangTidy check.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">The source pattern with
trailing comment &quot;B&quot; selects the <b>(const CharT*,
size_type)</b> constructor which is perfectly valid, since
the length argument is <b>0</b>. It is not changed by this
ClangTidy check.</p>

<h3>bugprone-suspicious-enum-usage
<a name="bugprone-suspicious-enum-usage"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The checker
detects various cases when an enum is probably misused (as a
bitmask ).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="87%">


<p>When &quot;ADD&quot; or &quot;bitwise OR&quot; is used
between two enum which come from different types and these
types value ranges are not disjoint.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">The following
cases will be investigated only using <i>StrictMode</i>. We
regard the enum as a (suspicious) bitmask if the three
conditions below are true at the same time:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">at most half of the elements of
the enum are non pow-of-2 numbers (because of short
enumerations)</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>there is another non pow-of-2 number than the enum
constant representing all choices (the result &quot;bitwise
OR&quot; operation of all enum elements)</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>enum type variable/enumconstant is used as an argument
of a <i>+</i> or &quot;bitwise OR &quot; operator</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">So whenever the
non pow-of-2 element is used as a bitmask element we
diagnose a misuse and give a warning.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="1%"></td>
<td width="87%">


<p style="margin-top: 1em">Investigating the right hand
side of <i>+=</i> and <i>|=</i> operator.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="87%">


<p>Check only the enum value side of a <i>|</i> and
<i>+</i> operator if one of them is not enum val.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>4.</p></td>
<td width="1%"></td>
<td width="87%">


<p>Check both side of <i>|</i> or <i>+</i> operator where
the enum values are from the same enum type.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">enum { A, B, C
}; <br>
enum { D, E, F = 5 }; <br>
enum { G = 10, H = 11, I = 12 };</p>

<p style="margin-left:13%; margin-top: 1em">unsigned flag;
<br>
flag = <br>
A | <br>
H; // OK, disjoint value intervals in the enum types
-&gt;probably good use. <br>
flag = B | F; // Warning, have common values so they are
probably misused.</p>

<p style="margin-left:13%; margin-top: 1em">// Case 2: <br>
enum Bitmask { <br>
A = 0, <br>
B = 1, <br>
C = 2, <br>
D = 4, <br>
E = 8, <br>
F = 16, <br>
G = 31 // OK, real bitmask. <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">enum
Almostbitmask { <br>
AA = 0, <br>
BB = 1, <br>
CC = 2, <br>
DD = 4, <br>
EE = 8, <br>
FF = 16, <br>
GG // Problem, forgot to initialize. <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">unsigned flag =
0; <br>
flag |= E; // OK. <br>
flag |= <br>
EE; // Warning at the decl, and note that it was used here
as a bitmask.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>StrictMode</b></p>

<p style="margin-left:18%;">Default value: 0. When non-null
the suspicious bitmask usage will be investigated
additionally to the different enum usage check.</p>

<h3>bugprone-suspicious-include
<a name="bugprone-suspicious-include"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check
detects various cases when an include refers to what appears
to be an implementation file, which often leads to
hard-to-track-down ODR violations.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">#include
&quot;Dinosaur.hpp&quot; // OK, .hpp files tend not to have
definitions. <br>
#include &quot;Pterodactyl.h&quot; // OK, .h files tend not
to have definitions. <br>
#include &quot;Velociraptor.cpp&quot; // Warning, filename
is suspicious. <br>
#include_next &lt;stdio.c&gt; // Warning, filename is
suspicious.</p>

<h3>bugprone-suspicious-memory-comparison
<a name="bugprone-suspicious-memory-comparison"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
potentially incorrect calls to <b>memcmp()</b> based on
properties of the arguments. The following cases are
covered:</p>

<p style="margin-left:9%; margin-top: 1em"><b>Case 1:
Non-standard-layout type</b></p>

<p style="margin-left:9%; margin-top: 1em">Comparing the
object representations of non-standard-layout objects may
not properly compare the value representations.</p>

<p style="margin-left:9%; margin-top: 1em"><b>Case 2: Types
with no unique object representation</b></p>

<p style="margin-left:9%; margin-top: 1em">Objects with the
same value may not have the same object representation. This
may be caused by padding or floating-point types.</p>

<p style="margin-left:9%; margin-top: 1em">See also:
<i>EXP42-C. Do not compare padding data</i> and <i>FLP37-C.
Do not use object representations to compare floating-point
values</i></p>

<p style="margin-left:9%; margin-top: 1em">This check is
also related to and partially overlaps the CERT C++ Coding
Standard rules <i>OOP57-CPP. Prefer special member functions
and overloaded operators to C Standard Library functions</i>
and <i>EXP62-CPP. Do not access the bits of an object
representation that are not part of the object's value
representation</i></p>


<p style="margin-left:9%; margin-top: 1em"><i>cert-exp42-c</i>
redirects here as an alias of this check.</p>

<h3>bugprone-suspicious-memset-usage
<a name="bugprone-suspicious-memset-usage"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check finds
<b>memset()</b> calls with potential mistakes in their
arguments. Considering the function as <b>void* memset(void*
destination, int fill_value, size_t byte_count)</b>, the
following cases are covered:</p>

<p style="margin-left:9%; margin-top: 1em"><b>Case 1: Fill
value is a character ``'0'``</b></p>

<p style="margin-left:9%; margin-top: 1em">Filling up a
memory area with ASCII code 48 characters is not customary,
possibly integer zeroes were intended instead. The check
offers a replacement of <b>'0'</b> with <b>0</b>. Memsetting
character pointers with <b>'0'</b> is allowed.</p>

<p style="margin-left:9%; margin-top: 1em"><b>Case 2: Fill
value is truncated</b></p>

<p style="margin-left:9%; margin-top: 1em">Memset converts
<b>fill_value</b> to <b>unsigned char</b> before using it.
If <b>fill_value</b> is out of unsigned character range, it
gets truncated and memory will not contain the desired
pattern.</p>

<p style="margin-left:9%; margin-top: 1em"><b>Case 3: Byte
count is zero</b></p>

<p style="margin-left:9%; margin-top: 1em">Calling memset
with a literal zero in its <b>byte_count</b> argument is
likely to be unintended and swapped with <b>fill_value</b>.
The check offers to swap these two arguments.</p>

<p style="margin-left:9%; margin-top: 1em">Corresponding
cpplint.py check name: <b>runtime/memset</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">void foo() {
<br>
int i[5] = {1, 2, 3, 4, 5}; <br>
int *ip = i; <br>
char c = '1'; <br>
char *cp = &amp;c; <br>
int v = 0;</p>

<p style="margin-left:13%; margin-top: 1em">// Case 1 <br>
memset(ip, '0', 1); // suspicious <br>
memset(cp, '0', 1); // OK</p>

<p style="margin-left:13%; margin-top: 1em">// Case 2 <br>
memset(ip, 0xabcd, 1); // fill value gets truncated <br>
memset(ip, 0x00, 1); // OK</p>

<p style="margin-left:13%; margin-top: 1em">// Case 3 <br>
memset(ip, sizeof(int), v); // zero length, potentially
swapped <br>
memset(ip, 0, 1); // OK <br>
}</p>

<h3>bugprone-suspicious-missing-comma
<a name="bugprone-suspicious-missing-comma"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">String literals
placed side-by-side are concatenated at translation phase 6
(after the preprocessor). This feature is used to represent
long string literal on multiple lines.</p>

<p style="margin-left:9%; margin-top: 1em">For instance,
the following declarations are equivalent:</p>

<p style="margin-left:13%; margin-top: 1em">const char* A[]
= &quot;This is a test&quot;; <br>
const char* B[] = &quot;This&quot; &quot; is a &quot;
&quot;test&quot;;</p>

<p style="margin-left:9%; margin-top: 1em">A common mistake
done by programmers is to forget a comma between two string
literals in an array initializer list.</p>

<p style="margin-left:13%; margin-top: 1em">const char*
Test[] = { <br>
&quot;line 1&quot;, <br>
&quot;line 2&quot; // Missing comma! <br>
&quot;line 3&quot;, <br>
&quot;line 4&quot;, <br>
&quot;line 5&quot; <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">The array
contains the string &quot;line 2line3&quot; at offset 1
(i.e. Test[1]). Clang won't generate warnings at compile
time.</p>

<p style="margin-left:9%; margin-top: 1em">This check may
warn incorrectly on cases like:</p>

<p style="margin-left:13%; margin-top: 1em">const char*
SupportedFormat[] = { <br>
&quot;Error %s&quot;, <br>
&quot;Code &quot; PRIu64, // May warn here. <br>
&quot;Warning %s&quot;, <br>
};</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>SizeThreshold</b></p>

<p style="margin-left:18%;">An unsigned integer specifying
the minimum size of a string literal to be considered by the
check. Default is <b>5U</b>.</p>

<p style="margin-left:9%;"><b>RatioThreshold</b></p>

<p style="margin-left:18%;">A string specifying the maximum
threshold ratio [0, 1.0] of suspicious string literals to be
considered. Default is <b>&quot;.2&quot;</b>.</p>


<p style="margin-left:9%;"><b>MaxConcatenatedTokens</b></p>

<p style="margin-left:18%;">An unsigned integer specifying
the maximum number of concatenated tokens. Default is
<b>5U</b>.</p>

<h3>bugprone-suspicious-realloc-usage
<a name="bugprone-suspicious-realloc-usage"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check finds
usages of <b>realloc</b> where the return value is assigned
to the same expression as passed to the first argument: <b>p
= realloc(p, size);</b> The problem with this construct is
that if <b>realloc</b> fails it returns a null pointer but
does not deallocate the original memory. If no other
variable is pointing to it, the original memory block is not
available any more for the program to use or free. In either
case <b>p = realloc(p, size);</b> indicates bad coding style
and can be replaced by <b>q = realloc(p, size);</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The pointer
expression (used at <b>realloc</b>) can be a variable or a
field member of a data structure, but can not contain
function calls or unresolved types.</p>

<p style="margin-left:9%; margin-top: 1em">In obvious cases
when the pointer used at realloc is assigned to another
variable before the <b>realloc</b> call, no warning is
emitted. This happens only if a simple expression in form of
<b>q = p</b> or <b>void *q = p</b> is found in the same
function where <b>p = realloc(p, ...)</b> is found. The
assignment has to be before the call to realloc (but
otherwise at any place) in the same function. This
suppression works only if <b>p</b> is a single variable.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">struct A { <br>
void *p; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">A
&amp;getA();</p>

<p style="margin-left:13%; margin-top: 1em">void foo(void
*p, A *a, int new_size) { <br>
p = realloc(p, new_size); // warning: 'p' may be set to null
if 'realloc' fails, which may result in a leak of the
original buffer <br>
a-&gt;p = realloc(a-&gt;p, new_size); // warning: 'a-&gt;p'
may be set to null if 'realloc' fails, which may result in a
leak of the original buffer <br>
getA().p = realloc(getA().p, new_size); // no warning <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void foo1(void
*p, int new_size) { <br>
void *p1 = p; <br>
p = realloc(p, new_size); // no warning <br>
}</p>

<h3>bugprone-suspicious-semicolon
<a name="bugprone-suspicious-semicolon"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds most
instances of stray semicolons that unexpectedly alter the
meaning of the code. More specifically, it looks for
<b>if</b>, <b>while</b>, <b>for</b> and <b>for-range</b>
statements whose body is a single semicolon, and then
analyzes the context of the code (e.g. indentation) in an
attempt to determine whether that is intentional.</p>

<p style="margin-left:13%; margin-top: 1em">if (x &lt; y);
<br>
{ <br>
x++; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Here the body of
the <b>if</b> statement consists of only the semicolon at
the end of the first line, and <i>x</i> will be incremented
regardless of the condition.</p>

<p style="margin-left:13%; margin-top: 1em">while ((line =
readLine(file)) != NULL); <br>
processLine(line);</p>

<p style="margin-left:9%; margin-top: 1em">As a result of
this code, <i>processLine()</i> will only be called once,
when the <b>while</b> loop with the empty body exits with
<i>line == NULL</i>. The indentation of the code indicates
the intention of the programmer.</p>

<p style="margin-left:13%; margin-top: 1em">if (x &gt;= y);
<br>
x -= y;</p>

<p style="margin-left:9%; margin-top: 1em">While the
indentation does not imply any nesting, there is simply no
valid reason to have an <i>if</i> statement with an empty
body (but it can make sense for a loop). So this check
issues a warning for the code above.</p>

<p style="margin-left:9%; margin-top: 1em">To solve the
issue remove the stray semicolon or in case the empty body
is intentional, reflect this using code indentation or put
the semicolon in a new line. For example:</p>

<p style="margin-left:13%; margin-top: 1em">while
(readWhitespace()); <br>
Token t = readNextToken();</p>

<p style="margin-left:9%; margin-top: 1em">Here the second
line is indented in a way that suggests that it is meant to
be the body of the <i>while</i> loop - whose body is in fact
empty, because of the semicolon at the end of the first
line.</p>

<p style="margin-left:9%; margin-top: 1em">Either remove
the indentation from the second line:</p>

<p style="margin-left:13%; margin-top: 1em">while
(readWhitespace()); <br>
Token t = readNextToken();</p>

<p style="margin-left:9%; margin-top: 1em">... or move the
semicolon from the end of the first line to a new line:</p>

<p style="margin-left:13%; margin-top: 1em">while
(readWhitespace()) <br>
;</p>

<p style="margin-left:13%; margin-top: 1em">Token t =
readNextToken();</p>

<p style="margin-left:9%; margin-top: 1em">In this case the
check will assume that you know what you are doing, and will
not raise a warning.</p>

<h3>bugprone-suspicious-string-compare
<a name="bugprone-suspicious-string-compare"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Find suspicious
usage of runtime string comparison functions. This check is
valid in C and C++.</p>

<p style="margin-left:9%; margin-top: 1em">Checks for calls
with implicit comparator and proposed to explicitly add
it.</p>

<p style="margin-left:13%; margin-top: 1em">if
(strcmp(...)) // Implicitly compare to zero <br>
if (!strcmp(...)) // Won't warn <br>
if (strcmp(...) != 0) // Won't warn</p>

<p style="margin-left:9%; margin-top: 1em">Checks that
compare function results (i.e., <b>strcmp</b>) are compared
to valid constant. The resulting value is</p>

<p style="margin-left:13%; margin-top: 1em">&lt; 0 when
lower than, <br>
&gt; 0 when greater than, <br>
== 0 when equals.</p>

<p style="margin-left:9%; margin-top: 1em">A common mistake
is to compare the result to <i>1</i> or <i>-1</i>.</p>

<p style="margin-left:13%; margin-top: 1em">if (strcmp(...)
== -1) // Incorrect usage of the returned value.</p>

<p style="margin-left:9%; margin-top: 1em">Additionally,
the check warns if the results value is implicitly cast to a
<i>suspicious</i> non-integer type. It's happening when the
returned value is used in a wrong context.</p>

<p style="margin-left:13%; margin-top: 1em">if (strcmp(...)
&lt; 0.) // Incorrect usage of the returned value.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>WarnOnImplicitComparison</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will warn on implicit comparison. <i>true</i> by
default.</p>


<p style="margin-left:9%;"><b>WarnOnLogicalNotComparison</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will warn on logical not comparison. <i>false</i> by
default.</p>


<p style="margin-left:9%;"><b>StringCompareLikeFunctions</b></p>

<p style="margin-left:18%;">A string specifying the
comma-separated names of the extra string comparison
functions. Default is an empty string. The check will detect
the following string comparison functions:
<i>__builtin_memcmp</i>, <i>__builtin_strcasecmp</i>,
<i>__builtin_strcmp</i>, <i>__builtin_strncasecmp</i>,
<i>__builtin_strncmp</i>, <i>_mbscmp</i>, <i>_mbscmp_l</i>,
<i>_mbsicmp</i>, <i>_mbsicmp_l</i>, <i>_mbsnbcmp</i>,
<i>_mbsnbcmp_l</i>, <i>_mbsnbicmp</i>, <i>_mbsnbicmp_l</i>,
<i>_mbsncmp</i>, <i>_mbsncmp_l</i>, <i>_mbsnicmp</i>,
<i>_mbsnicmp_l</i>, <i>_memicmp</i>, <i>_memicmp_l</i>,
<i>_stricmp</i>, <i>_stricmp_l</i>, <i>_strnicmp</i>,
<i>_strnicmp_l</i>, <i>_wcsicmp</i>, <i>_wcsicmp_l</i>,
<i>_wcsnicmp</i>, <i>_wcsnicmp_l</i>, <i>lstrcmp</i>,
<i>lstrcmpi</i>, <i>memcmp</i>, <i>memicmp</i>,
<i>strcasecmp</i>, <i>strcmp</i>, <i>strcmpi</i>,
<i>stricmp</i>, <i>strncasecmp</i>, <i>strncmp</i>,
<i>strnicmp</i>, <i>wcscasecmp</i>, <i>wcscmp</i>,
<i>wcsicmp</i>, <i>wcsncmp</i>, <i>wcsnicmp</i>,
<i>wmemcmp</i>.</p>

<h3>bugprone-suspicious-stringview-data-usage
<a name="bugprone-suspicious-stringview-data-usage"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Identifies
suspicious usages of <b>std::string_view::data()</b> that
could lead to reading out-of-bounds data due to inadequate
or incorrect string null termination.</p>

<p style="margin-left:9%; margin-top: 1em">It warns when
the result of <b>data()</b> is passed to a constructor or
function without also passing the corresponding result of
<b>size()</b> or <b>length()</b> member function. Such usage
can lead to unintended behavior, particularly when assuming
the data pointed to by <b>data()</b> is null-terminated.</p>

<p style="margin-left:9%; margin-top: 1em">The absence of a
<b>c_str()</b> method in <b>std::string_view</b> often leads
developers to use <b>data()</b> as a substitute, especially
when interfacing with C APIs that expect null-terminated
strings. However, since <b>data()</b> does not guarantee
null termination, this can result in unintended behavior if
the API relies on proper null termination for correct string
interpretation.</p>

<p style="margin-left:9%; margin-top: 1em">In today's
programming landscape, this scenario can occur when
implicitly converting an <b>std::string_view</b> to an
<b>std::string</b>. Since the constructor in
<b>std::string</b> designed for string-view-like objects is
<b>explicit</b>, attempting to pass an
<b>std::string_view</b> to a function expecting an
<b>std::string</b> will result in a compilation error. As a
workaround, developers may be tempted to utilize the
<b>.data()</b> method to achieve compilation, introducing
potential risks.</p>

<p style="margin-left:9%; margin-top: 1em">For
instance:</p>

<p style="margin-left:13%; margin-top: 1em">void
printString(const std::string&amp; str) { <br>
std::cout &lt;&lt; &quot;String: &quot; &lt;&lt; str
&lt;&lt; std::endl; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
something(std::string_view sv) { <br>
printString(sv.data()); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In this example,
directly passing <b>sv</b> to the <b>printString</b>
function would lead to a compilation error due to the
explicit nature of the <b>std::string</b> constructor.
Consequently, developers might opt for <b>sv.data()</b> to
resolve the compilation error, albeit introducing potential
hazards as discussed. <b><br>
StringViewTypes</b></p>

<p style="margin-left:18%;">Option allows users to specify
custom string view-like types for analysis. It accepts a
semicolon-separated list of type names or regular
expressions matching these types. Default value is:
<i>::std::basic_string_view;::llvm::StringRef</i>.</p>

<p style="margin-left:9%;"><b>AllowedCallees</b></p>

<p style="margin-left:18%;">Specifies methods, functions,
or classes where the result of <b>.data()</b> is passed to.
Allows to exclude such calls from the analysis. Accepts a
semicolon-separated list of names or regular expressions
matching these entities. Default value is: empty string.</p>

<h3>bugprone-swapped-arguments
<a name="bugprone-swapped-arguments"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
potentially swapped arguments by examining implicit
conversions. It analyzes the types of the arguments being
passed to a function and compares them to the expected types
of the corresponding parameters. If there is a mismatch or
an implicit conversion that indicates a potential swap, a
warning is raised.</p>

<p style="margin-left:13%; margin-top: 1em">void
printNumbers(int a, float b);</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
// Swapped arguments: float passed as int, int as float)
<br>
printNumbers(10.0f, 5); <br>
return 0; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Covers a wide
range of implicit conversions, including: - User-defined
conversions - Conversions from floating-point types to
boolean or integral types - Conversions from integral types
to boolean or floating-point types - Conversions from
boolean to integer types or floating-point types -
Conversions from (member) pointers to boolean</p>

<p style="margin-left:9%; margin-top: 1em">It is important
to note that for most argument swaps, the types need to
match exactly. However, there are exceptions to this rule.
Specifically, when the swapped argument is of integral type,
an exact match is not always necessary. Implicit casts from
other integral types are also accepted. Similarly, when
dealing with floating-point arguments, implicit casts
between different floating-point types are considered
acceptable.</p>

<p style="margin-left:9%; margin-top: 1em">To avoid
confusion, swaps where both swapped arguments are of
integral types or both are of floating-point types do not
trigger the warning. In such cases, it's assumed that the
developer intentionally used different integral or
floating-point types and does not raise a warning. This
approach prevents false positives and provides flexibility
in handling situations where varying integral or
floating-point types are intentionally utilized.</p>

<h3>bugprone-switch-missing-default-case
<a name="bugprone-switch-missing-default-case"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Ensures that
switch statements without default cases are flagged, focuses
only on covering cases with non-enums where the compiler may
not issue warnings.</p>

<p style="margin-left:9%; margin-top: 1em">Switch
statements without a default case can lead to unexpected
behavior and incomplete handling of all possible cases. When
a switch statement lacks a default case, if a value is
encountered that does not match any of the specified cases,
the program will continue execution without any defined
behavior or handling.</p>

<p style="margin-left:9%; margin-top: 1em">This check helps
identify switch statements that are missing a default case,
allowing developers to ensure that all possible cases are
handled properly. Adding a default case allows for graceful
handling of unexpected or unmatched values, reducing the
risk of program errors and unexpected behavior.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">// Example 1:
<br>
// warning: switching on non-enum value without default case
may not cover all cases <br>
switch (i) { <br>
case 0: <br>
break; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// Example 2:
<br>
enum E { eE1 }; <br>
E e = eE1; <br>
switch (e) { // no-warning <br>
case eE1: <br>
break; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// Example 3:
<br>
int i = 0; <br>
switch (i) { // no-warning <br>
case 0: <br>
break; <br>
default: <br>
break; <br>
}</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">Enum types are already covered
by compiler warnings (comes under -Wswitch) when a switch
statement does not handle all enum values. This check
focuses on non-enum types where the compiler warnings may
not be present.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>CppCoreGuideline
ES.79</i> provide guidelines on switch statements, including
the recommendation to always provide a default case.</p>

<h3>bugprone-terminating-continue
<a name="bugprone-terminating-continue"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects <b>do
while</b> loops with a condition always evaluating to false
that have a <b>continue</b> statement, as this
<b>continue</b> terminates the loop effectively.</p>

<p style="margin-left:13%; margin-top: 1em">void f() { <br>
do { <br>
// some code <br>
continue; // terminating continue <br>
// some other code <br>
} while(false);</p>

<h3>bugprone-throw-keyword-missing
<a name="bugprone-throw-keyword-missing"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns about a
potentially missing <b>throw</b> keyword. If a temporary
object is created, but the object's type derives from (or is
the same as) a class that has 'EXCEPTION', 'Exception' or
'exception' in its name, we can assume that the programmer's
intention was to throw that object.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">void f(int i) {
<br>
if (i &lt; 0) { <br>
// Exception is created but is not thrown. <br>
std::runtime_error(&quot;Unexpected argument&quot;); <br>
} <br>
}</p>

<h3>bugprone-too-small-loop-variable
<a name="bugprone-too-small-loop-variable"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects those
<b>for</b> loops that have a loop variable with a &quot;too
small&quot; type which means this type can't represent all
values which are part of the iteration range.</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
long size = 294967296l; <br>
for (short i = 0; i &lt; size; ++i) {} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">This <b>for</b>
loop is an infinite loop because the <b>short</b> type can't
represent all values in the <b>[0..size]</b> interval.</p>

<p style="margin-left:9%; margin-top: 1em">In a real use
case size means a container's size which depends on the user
input.</p>

<p style="margin-left:13%; margin-top: 1em">int
doSomething(const std::vector&amp; items) { <br>
for (short i = 0; i &lt; items.size(); ++i) {} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">This algorithm
works for a small amount of objects, but will lead to freeze
for a larger user input.</p>

<p style="margin-left:9%; margin-top: 1em">It's recommended
to enable the compiler warning
<i>-Wtautological-constant-out-of-range-compare</i> as well,
since check does not inspect compile-time constant loop
boundaries to avoid overlaps with the warning. <b><br>
MagnitudeBitsUpperLimit</b></p>

<p style="margin-left:18%;">Upper limit for the magnitude
bits of the loop variable. If it's set the check filters out
those catches in which the loop variable's type has more
magnitude bits as the specified upper limit. The default
value is 16. For example, if the user sets this option to 31
(bits), then a 32-bit <b>unsigned int</b> is ignored by the
check, however a 32-bit <b>int</b> is not (A 32-bit
<b>signed int</b> has 31 magnitude bits).</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
long size = 294967296l; <br>
for (unsigned i = 0; i &lt; size; ++i) {} // no warning with
MagnitudeBitsUpperLimit = 31 on a system where unsigned is
32-bit <br>
for (int i = 0; i &lt; size; ++i) {} // warning with
MagnitudeBitsUpperLimit = 31 on a system where int is 32-bit
<br>
}</p>

<h3>bugprone-unchecked-optional-access
<a name="bugprone-unchecked-optional-access"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><i>Note</i>:
This check uses a flow-sensitive static analysis to produce
its results. Therefore, it may be more resource intensive
(RAM, CPU) than the average clang-tidy check.</p>

<p style="margin-left:9%; margin-top: 1em">This check
identifies unsafe accesses to values contained in
<b>std::optional&lt;T&gt;</b>,
<b>absl::optional&lt;T&gt;</b>,
<b>base::Optional&lt;T&gt;</b>, or
<b>folly::Optional&lt;T&gt;</b> objects. Below we will refer
to all these types collectively as
<b>optional&lt;T&gt;</b>.</p>

<p style="margin-left:9%; margin-top: 1em">An access to the
value of an <b>optional&lt;T&gt;</b> occurs when one of its
<b>value</b>, <b>operator*</b>, or <b>operator-&gt;</b>
member functions is invoked. To align with common
misconceptions, the check considers these member functions
as equivalent, even though there are subtle differences
related to exceptions versus undefined behavior. See
<i>Additional notes</i>, below, for more information on this
topic.</p>

<p style="margin-left:9%; margin-top: 1em">An access to the
value of an <b>optional&lt;T&gt;</b> is considered safe if
and only if code in the local scope (for example, a function
body) ensures that the <b>optional&lt;T&gt;</b> has a value
in all possible execution paths that can reach the access.
That should happen either through an explicit check, using
the <b>optional&lt;T&gt;::has_value</b> member function, or
by constructing the <b>optional&lt;T&gt;</b> in a way that
shows that it unambiguously holds a value (e.g using
<b>std::make_optional</b> which always returns a populated
<b>std::optional&lt;T&gt;</b>).</p>

<p style="margin-left:9%; margin-top: 1em">Below we list
some examples, starting with unsafe optional access
patterns, followed by safe access patterns.</p>

<h3>Unsafe access patterns
<a name="Unsafe access patterns"></a>
</h3>


<h3>Access the value without checking if it exists
<a name="Access the value without checking if it exists"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check flags
accesses to the value that are not locally guarded by
existence check:</p>

<p style="margin-left:13%; margin-top: 1em">void
f(std::optional&lt;int&gt; opt) { <br>
use(*opt); // unsafe: it is unclear whether `opt` has a
value. <br>
}</p>

<h3>Access the value in the wrong branch
<a name="Access the value in the wrong branch"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check is
aware of the state of an optional object in different
branches of the code. For example:</p>

<p style="margin-left:13%; margin-top: 1em">void
f(std::optional&lt;int&gt; opt) { <br>
if (opt.has_value()) { <br>
} else { <br>
use(opt.value()); // unsafe: it is clear that `opt` does
*not* have a value. <br>
} <br>
}</p>

<h3>Assume a function result to be stable
<a name="Assume a function result to be stable"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check is
aware that function results might not be stable. That is,
consecutive calls to the same function might return
different values. For example:</p>

<p style="margin-left:13%; margin-top: 1em">void f(Foo foo)
{ <br>
if (foo.opt().has_value()) { <br>
use(*foo.opt()); // unsafe: it is unclear whether
`foo.opt()` has a value. <br>
} <br>
}</p>

<h3>Rely on invariants of uncommon APIs
<a name="Rely on invariants of uncommon APIs"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check is
unaware of invariants of uncommon APIs. For example:</p>

<p style="margin-left:13%; margin-top: 1em">void f(Foo foo)
{ <br>
if (foo.HasProperty(&quot;bar&quot;)) { <br>
use(*foo.GetProperty(&quot;bar&quot;)); // unsafe: it is
unclear whether `foo.GetProperty(&quot;bar&quot;)` has a
value. <br>
} <br>
}</p>

<h3>Check if a value exists, then pass the optional to another function
<a name="Check if a value exists, then pass the optional to another function"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check relies
on local reasoning. The check and value access must both
happen in the same function. An access is considered unsafe
even if the caller of the function performing the access
ensures that the optional has a value. For example:</p>

<p style="margin-left:13%; margin-top: 1em">void
g(std::optional&lt;int&gt; opt) { <br>
use(*opt); // unsafe: it is unclear whether `opt` has a
value. <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
f(std::optional&lt;int&gt; opt) { <br>
if (opt.has_value()) { <br>
g(opt); <br>
} <br>
}</p>

<h3>Safe access patterns
<a name="Safe access patterns"></a>
</h3>


<h3>Check if a value exists, then access the value
<a name="Check if a value exists, then access the value"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check
recognizes all straightforward ways for checking if a value
exists and accessing the value contained in an optional
object. For example:</p>

<p style="margin-left:13%; margin-top: 1em">void
f(std::optional&lt;int&gt; opt) { <br>
if (opt.has_value()) { <br>
use(*opt); <br>
} <br>
}</p>

<h3>Check if a value exists, then access the value from a copy
<a name="Check if a value exists, then access the value from a copy"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The criteria
that the check uses is semantic, not syntactic. It
recognizes when a copy of the optional object being accessed
is known to have a value. For example:</p>

<p style="margin-left:13%; margin-top: 1em">void
f(std::optional&lt;int&gt; opt1) { <br>
if (opt1.has_value()) { <br>
std::optional&lt;int&gt; opt2 = opt1; <br>
use(*opt2); <br>
} <br>
}</p>

<h3>Ensure that a value exists using common macros
<a name="Ensure that a value exists using common macros"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check is
aware of common macros like <b>CHECK</b> and <b>DCHECK</b>.
Those can be used to ensure that an optional object has a
value. For example:</p>

<p style="margin-left:13%; margin-top: 1em">void
f(std::optional&lt;int&gt; opt) { <br>
DCHECK(opt.has_value()); <br>
use(*opt); <br>
}</p>

<h3>Ensure that a value exists, then access the value in a correlated branch
<a name="Ensure that a value exists, then access the value in a correlated branch"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check is
aware of correlated branches in the code and can figure out
when an optional object is ensured to have a value on all
execution paths that lead to an access. For example:</p>

<p style="margin-left:13%; margin-top: 1em">void
f(std::optional&lt;int&gt; opt) { <br>
bool safe = false; <br>
if (opt.has_value() &amp;&amp; SomeOtherCondition()) { <br>
safe = true; <br>
} <br>
// ... more code... <br>
if (safe) { <br>
use(*opt); <br>
} <br>
}</p>

<h3>Stabilize function results
<a name="Stabilize function results"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Since function
results are not assumed to be stable across calls, it is
best to store the result of the function call in a local
variable and use that variable to access the value. For
example:</p>

<p style="margin-left:13%; margin-top: 1em">void f(Foo foo)
{ <br>
if (const auto&amp; foo_opt = foo.opt();
foo_opt.has_value()) { <br>
use(*foo_opt); <br>
} <br>
}</p>

<h3>Do not rely on uncommon-API invariants
<a name="Do not rely on uncommon-API invariants"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">When uncommon
APIs guarantee that an optional has contents, do not rely on
it -- instead, check explicitly that the optional object has
a value. For example:</p>

<p style="margin-left:13%; margin-top: 1em">void f(Foo foo)
{ <br>
if (const auto&amp; property =
foo.GetProperty(&quot;bar&quot;)) { <br>
use(*property); <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">instead of the
<i>HasProperty</i>, <i>GetProperty</i> pairing we saw
above.</p>

<h3>Do not rely on caller-performed checks
<a name="Do not rely on caller-performed checks"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">If you know that
all of a function's callers have checked that an optional
argument has a value, either change the function to take the
value directly or check the optional again in the local
scope of the callee. For example:</p>

<p style="margin-left:13%; margin-top: 1em">void g(int val)
{ <br>
use(val); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
f(std::optional&lt;int&gt; opt) { <br>
if (opt.has_value()) { <br>
g(*opt); <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">and</p>

<p style="margin-left:13%; margin-top: 1em">struct S { <br>
std::optional&lt;int&gt; opt; <br>
int x; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">void g(const S
&amp;s) { <br>
if (s.opt.has_value() &amp;&amp; s.x &gt; 10) { <br>
use(*s.opt); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void f(S s) {
<br>
if (s.opt.has_value()) { <br>
g(s); <br>
} <br>
}</p>

<h3>Additional notes
<a name="Additional notes"></a>
</h3>


<h3>Aliases created via using declarations
<a name="Aliases created via using declarations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check is
aware of aliases of optional types that are created via
<b>using</b> declarations. For example:</p>

<p style="margin-left:13%; margin-top: 1em">using
OptionalInt = std::optional&lt;int&gt;;</p>

<p style="margin-left:13%; margin-top: 1em">void
f(OptionalInt opt) { <br>
use(opt.value()); // unsafe: it is unclear whether `opt` has
a value. <br>
}</p>

<h3>Lambdas
<a name="Lambdas"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check does
not currently report unsafe optional accesses in lambdas. A
future version will expand the scope to lambdas, following
the rules outlined above. It is best to follow the same
principles when using optionals in lambdas.</p>

<h3>Access with operator*() vs. value()
<a name="Access with operator*() vs. value()"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Given that
<b>value()</b> has well-defined behavior (either throwing an
exception or terminating the program), why treat it the same
as <b>operator*()</b> which causes undefined behavior (UB)?
That is, why is it considered unsafe to access an optional
with <b>value()</b>, if it's not provably populated with a
value? For that matter, why is <b>CHECK()</b> followed by
<b>operator*()</b> any better than <b>value()</b>, given
that they are semantically equivalent (on configurations
that disable exceptions)?</p>

<p style="margin-left:9%; margin-top: 1em">The answer is
that we assume most users do not realize the difference
between <b>value()</b> and <b>operator*()</b>. Shifting to
<b>operator*()</b> and some form of explicit value-presence
check or explicit program termination has two
advantages:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>Readability. The check, and any potential side effects
like program shutdown, are very clear in the code.
Separating access from checks can actually make the checks
more obvious.</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>Performance. A single check can cover many or even all
accesses within scope. This gives the user the best of both
worlds -- the safety of a dynamic check, but without
incurring redundant costs.</p></td></tr>
</table>

<h3>bugprone-undefined-memory-manipulation
<a name="bugprone-undefined-memory-manipulation"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds calls of
memory manipulation functions <b>memset()</b>,
<b>memcpy()</b> and <b>memmove()</b> on
non-TriviallyCopyable objects resulting in undefined
behavior.</p>

<p style="margin-left:9%; margin-top: 1em">Using memory
manipulation functions on non-TriviallyCopyable objects can
lead to a range of subtle and challenging issues in C++
code. The most immediate concern is the potential for
undefined behavior, where the state of the object may become
corrupted or invalid. This can manifest as crashes, data
corruption, or unexpected behavior at runtime, making it
challenging to identify and diagnose the root cause.
Additionally, misuse of memory manipulation functions can
bypass essential object-specific operations, such as
constructors and destructors, leading to resource leaks or
improper initialization.</p>

<p style="margin-left:9%; margin-top: 1em">For example,
when using <b>memcpy</b> to copy <b>std::string</b>, pointer
data is being copied, and it can result in a double free
issue.</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;cstring&gt; <br>
#include &lt;string&gt;</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
std::string source = &quot;Hello&quot;; <br>
std::string destination;</p>


<p style="margin-left:13%; margin-top: 1em">std::memcpy(&amp;destination,
&amp;source, sizeof(std::string));</p>

<p style="margin-left:13%; margin-top: 1em">// Undefined
behavior may occur here, during std::string destructor call.
<br>
return 0; <br>
}</p>

<h3>bugprone-undelegated-constructor
<a name="bugprone-undelegated-constructor"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds creation
of temporary objects in constructors that look like a
function call to another constructor of the same class.</p>

<p style="margin-left:9%; margin-top: 1em">The user most
likely meant to use a delegating constructor or base class
initializer.</p>

<h3>bugprone-unhandled-exception-at-new
<a name="bugprone-unhandled-exception-at-new"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds calls to
<b>new</b> with missing exception handler for
<b>std::bad_alloc</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Calls to
<b>new</b> may throw exceptions of type
<b>std::bad_alloc</b> that should be handled. Alternatively,
the nonthrowing form of <b>new</b> can be used. The check
verifies that the exception is handled in the function that
calls <b>new</b>.</p>

<p style="margin-left:9%; margin-top: 1em">If a nonthrowing
version is used or the exception is allowed to propagate out
of the function no warning is generated.</p>

<p style="margin-left:9%; margin-top: 1em">The exception
handler is checked if it catches a <b>std::bad_alloc</b> or
<b>std::exception</b> exception type, or all exceptions
(catch-all). The check assumes that any user-defined
<b>operator new</b> is either <b>noexcept</b> or may throw
an exception of type <b>std::bad_alloc</b> (or one derived
from it). Other exception class types are not taken into
account.</p>

<p style="margin-left:13%; margin-top: 1em">int *f()
noexcept { <br>
int *p = new int[1000]; // warning: missing exception
handler for allocation failure at 'new' <br>
// ... <br>
return p; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int *f1() { //
not 'noexcept' <br>
int *p = new int[1000]; // no warning: exception can be
handled outside <br>
// of this function <br>
// ... <br>
return p; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int *f2()
noexcept { <br>
try { <br>
int *p = new int[1000]; // no warning: exception is handled
<br>
// ... <br>
return p; <br>
} catch (std::bad_alloc &amp;) { <br>
// ... <br>
} <br>
// ... <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int *f3()
noexcept { <br>
int *p = new (std::nothrow) int[1000]; // no warning:
&quot;nothrow&quot; is used <br>
// ... <br>
return p; <br>
}</p>

<h3>bugprone-unhandled-self-assignment
<a name="bugprone-unhandled-self-assignment"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>cert-oop54-cpp</i>
redirects here as an alias for this check. For the CERT
alias, the <i>WarnOnlyIfThisHasSuspiciousField</i> option is
set to <i>false</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Finds
user-defined copy assignment operators which do not protect
the code against self-assignment either by checking
self-assignment explicitly or using the copy-and-swap or the
copy-and-move method.</p>

<p style="margin-left:9%; margin-top: 1em">By default, this
check searches only those classes which have any pointer or
C array field to avoid false positives. In case of a pointer
or a C array, it's likely that self-copy assignment breaks
the object if the copy assignment operator was not written
with care.</p>

<p style="margin-left:9%; margin-top: 1em">See also:
<i>OOP54-CPP. Gracefully handle self-copy assignment</i></p>

<p style="margin-left:9%; margin-top: 1em">A copy
assignment operator must prevent that self-copy assignment
ruins the object state. A typical use case is when the class
has a pointer field and the copy assignment operator first
releases the pointed object and then tries to assign it:</p>

<p style="margin-left:13%; margin-top: 1em">class T { <br>
int* p;</p>

<p style="margin-left:13%; margin-top: 1em">public: <br>
T(const T &amp;rhs) : p(rhs.p ? new int(*rhs.p) : nullptr)
{} <br>
&#732;T() { delete p; }</p>

<p style="margin-left:13%; margin-top: 1em">// ...</p>

<p style="margin-left:13%; margin-top: 1em">T&amp;
operator=(const T &amp;rhs) { <br>
delete p; <br>
p = new int(*rhs.p); <br>
return *this; <br>
} <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">There are two
common C++ patterns to avoid this problem. The first is the
self-assignment check:</p>

<p style="margin-left:13%; margin-top: 1em">class T { <br>
int* p;</p>

<p style="margin-left:13%; margin-top: 1em">public: <br>
T(const T &amp;rhs) : p(rhs.p ? new int(*rhs.p) : nullptr)
{} <br>
&#732;T() { delete p; }</p>

<p style="margin-left:13%; margin-top: 1em">// ...</p>

<p style="margin-left:13%; margin-top: 1em">T&amp;
operator=(const T &amp;rhs) { <br>
if(this == &amp;rhs) <br>
return *this;</p>

<p style="margin-left:13%; margin-top: 1em">delete p; <br>
p = new int(*rhs.p); <br>
return *this; <br>
} <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">The second one
is the copy-and-swap method when we create a temporary copy
(using the copy constructor) and then swap this temporary
object with <b>this</b>:</p>

<p style="margin-left:13%; margin-top: 1em">class T { <br>
int* p;</p>

<p style="margin-left:13%; margin-top: 1em">public: <br>
T(const T &amp;rhs) : p(rhs.p ? new int(*rhs.p) : nullptr)
{} <br>
&#732;T() { delete p; }</p>

<p style="margin-left:13%; margin-top: 1em">// ...</p>

<p style="margin-left:13%; margin-top: 1em">void swap(T
&amp;rhs) { <br>
using std::swap; <br>
swap(p, rhs.p); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">T&amp;
operator=(const T &amp;rhs) { <br>
T(rhs).swap(*this); <br>
return *this; <br>
} <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">There is a third
pattern which is less common. Let's call it the
copy-and-move method when we create a temporary copy (using
the copy constructor) and then move this temporary object
into <b>this</b> (needs a move assignment operator):</p>

<p style="margin-left:13%; margin-top: 1em">class T { <br>
int* p;</p>

<p style="margin-left:13%; margin-top: 1em">public: <br>
T(const T &amp;rhs) : p(rhs.p ? new int(*rhs.p) : nullptr)
{} <br>
&#732;T() { delete p; }</p>

<p style="margin-left:13%; margin-top: 1em">// ...</p>

<p style="margin-left:13%; margin-top: 1em">T&amp;
operator=(const T &amp;rhs) { <br>
T t = rhs; <br>
*this = std::move(t); <br>
return *this; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">T&amp;
operator=(T &amp;&amp;rhs) { <br>
p = rhs.p; <br>
rhs.p = nullptr; <br>
return *this; <br>
} <br>
};</p>


<p style="margin-left:9%;"><b>WarnOnlyIfThisHasSuspiciousField</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will warn only if the container class of the copy assignment
operator has any suspicious fields (pointer or C array).
This option is set to <i>true</i> by default.</p>

<h3>bugprone-unique-ptr-array-mismatch
<a name="bugprone-unique-ptr-array-mismatch"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
initializations of C++ unique pointers to non-array type
that are initialized with an array.</p>

<p style="margin-left:9%; margin-top: 1em">If a pointer
<b>std::unique_ptr&lt;T&gt;</b> is initialized with a
new-expression <b>new T[]</b> the memory is not deallocated
correctly. A plain <b>delete</b> is used in this case to
deallocate the target memory. Instead a <b>delete[]</b> call
is needed. A <b>std::unique_ptr&lt;T[]&gt;</b> uses the
correct delete operator. The check does not emit warning if
an <b>unique_ptr</b> with user-specified deleter type is
used.</p>

<p style="margin-left:9%; margin-top: 1em">The check offers
replacement of <b>unique_ptr&lt;T&gt;</b> to
<b>unique_ptr&lt;T[]&gt;</b> if it is used at a single
variable declaration (one variable in one statement).</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>


<p style="margin-left:13%; margin-top: 1em">std::unique_ptr&lt;Foo&gt;
x(new Foo[10]); // -&gt; std::unique_ptr&lt;Foo[]&gt; x(new
Foo[10]); <br>
// &#710; warning: unique pointer to non-array is
initialized with array <br>
std::unique_ptr&lt;Foo&gt; x1(new Foo), x2(new Foo[10]); //
no replacement <br>
// &#710; warning: unique pointer to non-array is
initialized with array</p>

<p style="margin-left:13%; margin-top: 1em">D d; <br>
std::unique_ptr&lt;Foo, D&gt; x3(new Foo[10], d); // no
warning (custom deleter used)</p>

<p style="margin-left:13%; margin-top: 1em">struct S { <br>
std::unique_ptr&lt;Foo&gt; x(new Foo[10]); // no replacement
in this case <br>
// &#710; warning: unique pointer to non-array is
initialized with array <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">This check
partially covers the CERT C++ Coding Standard rule -
<i>MEM51-CPP. Properly deallocate dynamically allocated
resources</i> However, only the <b>std::unique_ptr</b> case
is detected by this check.</p>

<h3>bugprone-unsafe-functions
<a name="bugprone-unsafe-functions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for
functions that have safer, more secure replacements
available, or are considered deprecated due to design flaws.
The check heavily relies on the functions from the <b>Annex
K.</b> &quot;Bounds-checking interfaces&quot; of C11.
<b><br>
The check implements the following rules from the CERT C
Coding <br>
Standard:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>Recommendation <i>MSC24-C. Do not use deprecated or
obsolescent functions</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>Rule <i>MSC33-C. Do not pass invalid data to the
asctime() function</i>.</p></td></tr>
</table>


<p style="margin-left:9%; margin-top: 1em"><i>cert-msc24-c</i>
and <i>cert-msc33-c</i> redirect here as aliases of this
check.</p>

<h3>Unsafe functions
<a name="Unsafe functions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">If <i>Annex
K.</i> is available, a replacement from <i>Annex K.</i> is
suggested for the following functions:</p>

<p style="margin-left:9%; margin-top: 1em"><b>asctime</b>,
<b>asctime_r</b>, <b>bsearch</b>, <b>ctime</b>,
<b>fopen</b>, <b>fprintf</b>, <b>freopen</b>, <b>fscanf</b>,
<b>fwprintf</b>, <b>fwscanf</b>, <b>getenv</b>, <b>gets</b>,
<b>gmtime</b>, <b>localtime</b>, <b>mbsrtowcs</b>,
<b>mbstowcs</b>, <b>memcpy</b>, <b>memmove</b>,
<b>memset</b>, <b>printf</b>, <b>qsort</b>, <b>scanf</b>,
<b>snprintf</b>, <b>sprintf</b>, <b>sscanf</b>,
<b>strcat</b>, <b>strcpy</b>, <b>strerror</b>,
<b>strlen</b>, <b>strncat</b>, <b>strncpy</b>,
<b>strtok</b>, <b>swprintf</b>, <b>swscanf</b>,
<b>vfprintf</b>, <b>vfscanf</b>, <b>vfwprintf</b>,
<b>vfwscanf</b>, <b>vprintf</b>, <b>vscanf</b>,
<b>vsnprintf</b>, <b>vsprintf</b>, <b>vsscanf</b>,
<b>vswprintf</b>, <b>vswscanf</b>, <b>vwprintf</b>,
<b>vwscanf</b>, <b>wcrtomb</b>, <b>wcscat</b>,
<b>wcscpy</b>, <b>wcslen</b>, <b>wcsncat</b>,
<b>wcsncpy</b>, <b>wcsrtombs</b>, <b>wcstok</b>,
<b>wcstombs</b>, <b>wctomb</b>, <b>wmemcpy</b>,
<b>wmemmove</b>, <b>wprintf</b>, <b>wscanf</b>.</p>

<p style="margin-left:9%; margin-top: 1em">If <i>Annex
K.</i> is not available, replacements are suggested only for
the following functions from the previous list:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="66%">


<p style="margin-top: 1em"><b>asctime</b>,
<b>asctime_r</b>, suggested replacement: <b>strftime</b></p></td>
<td width="19%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="66%">


<p><b>gets</b>, suggested replacement: <b>fgets</b></p></td>
<td width="19%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">The following
functions are always checked, regardless of <i>Annex K</i>
availability:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="49%">


<p style="margin-top: 1em"><b>rewind</b>, suggested
replacement: <b>fseek</b></p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="49%">


<p><b>setbuf</b>, suggested replacement: <b>setvbuf</b></p></td>
<td width="36%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">If
<i>ReportMoreUnsafeFunctions</i> is enabled, the following
functions are also checked:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em"><b>bcmp</b>, suggested
replacement: <b>memcmp</b></p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><b>bcopy</b>, suggested replacement: <b>memcpy_s</b> if
<i>Annex K</i> is available, or <b>memcpy</b></p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><b>bzero</b>, suggested replacement: <b>memset_s</b> if
<i>Annex K</i> is available, or <b>memset</b></p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><b>getpw</b>, suggested replacement: <b>getpwuid</b></p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><b>vfork</b>, suggested replacement:
<b>posix_spawn</b></p> </td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Although
mentioned in the associated CERT rules, the following
functions are <b>ignored</b> by the check:</p>

<p style="margin-left:9%; margin-top: 1em"><b>atof</b>,
<b>atoi</b>, <b>atol</b>, <b>atoll</b>, <b>tmpfile</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The availability
of <i>Annex K</i> is determined based on the following
macros:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em"><b>__STDC_LIB_EXT1__</b>:
feature macro, which indicates the presence of <i>Annex K.
&quot;Bounds-checking interfaces&quot;</i> in the library
implementation</p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><b>__STDC_WANT_LIB_EXT1__</b>: user-defined macro, which
indicates that the user requests the functions from <i>Annex
K.</i> to be defined.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Both macros have
to be defined to suggest replacement functions from <i>Annex
K.</i> <b>__STDC_LIB_EXT1__</b> is defined by the library
implementation, and <b>__STDC_WANT_LIB_EXT1__</b> must be
defined to <b>1</b> by the user <b>before</b> including any
system headers.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>ReportMoreUnsafeFunctions</b></p>

<p style="margin-left:18%;">When <i>true</i>, additional
functions from widely used APIs (such as POSIX) are added to
the list of reported functions. See the main documentation
of the check for the complete list as to what this option
enables. Default is <i>true</i>.</p>

<h3>Examples
<a name="Examples"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">#ifndef
__STDC_LIB_EXT1__ <br>
#error &quot;Annex K is not supported by the current
standard library implementation.&quot; <br>
#endif</p>

<p style="margin-left:13%; margin-top: 1em">#define
__STDC_WANT_LIB_EXT1__ 1</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;string.h&gt; // Defines functions from Annex K. <br>
#include &lt;stdio.h&gt;</p>

<p style="margin-left:13%; margin-top: 1em">enum { BUFSIZE
= 32 };</p>

<p style="margin-left:13%; margin-top: 1em">void
Unsafe(const char *Msg) { <br>
static const char Prefix[] = &quot;Error: &quot;; <br>
static const char Suffix[] = &quot;\n&quot;; <br>
char Buf[BUFSIZE] = {0};</p>

<p style="margin-left:13%; margin-top: 1em">strcpy(Buf,
Prefix); // warning: function 'strcpy' is not
bounds-checking; 'strcpy_s' should be used instead. <br>
strcat(Buf, Msg); // warning: function 'strcat' is not
bounds-checking; 'strcat_s' should be used instead. <br>
strcat(Buf, Suffix); // warning: function 'strcat' is not
bounds-checking; 'strcat_s' should be used instead. <br>
if (fputs(buf, stderr) &lt; 0) { <br>
// error handling <br>
return; <br>
} <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
UsingSafeFunctions(const char *Msg) { <br>
static const char Prefix[] = &quot;Error: &quot;; <br>
static const char Suffix[] = &quot;\n&quot;; <br>
char Buf[BUFSIZE] = {0};</p>

<p style="margin-left:13%; margin-top: 1em">if
(strcpy_s(Buf, BUFSIZE, Prefix) != 0) { <br>
// error handling <br>
return; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">if
(strcat_s(Buf, BUFSIZE, Msg) != 0) { <br>
// error handling <br>
return; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">if
(strcat_s(Buf, BUFSIZE, Suffix) != 0) { <br>
// error handling <br>
return; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">if (fputs(Buf,
stderr) &lt; 0) { <br>
// error handling <br>
return; <br>
} <br>
}</p>

<h3>bugprone-unused-local-non-trivial-variable
<a name="bugprone-unused-local-non-trivial-variable"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns when a
local non trivial variable is unused within a function. The
following types of variables are excluded from this
check:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p>trivial and trivially copyable</p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p>references and pointers</p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p>exception variables in catch clauses</p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p>static or thread local</p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p>structured bindings</p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p>variables with <b>[[maybe_unused]]</b> attribute</p></td>
<td width="36%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">This check can
be configured to warn on all non-trivial variables by
setting <i>IncludeTypes</i> to <i>.*</i>, and excluding
specific types using <i>ExcludeTypes</i>.</p>

<p style="margin-left:9%; margin-top: 1em">In the this
example, <i>my_lock</i> would generate a warning that it is
unused.</p>

<p style="margin-left:13%; margin-top: 1em">std::mutex
my_lock; <br>
// my_lock local variable is never used</p>

<p style="margin-left:9%; margin-top: 1em">In the next
example, <i>future2</i> would generate a warning that it is
unused.</p>


<p style="margin-left:13%; margin-top: 1em">std::future&lt;MyObject&gt;
future1; <br>
std::future&lt;MyObject&gt; future2; <br>
// ... <br>
MyObject foo = future1.get(); <br>
// future2 is not used.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IncludeTypes</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
regular expressions matching types of variables to check. By
default the following types are checked:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="33%">


<p><i>::std::.*mutex</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="33%">


<p><i>::std::future</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="33%">


<p><i>::std::basic_string</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="33%">


<p><i>::std::basic_regex</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="33%">


<p><i>::std::basic_istringstream</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="33%">


<p><i>::std::basic_stringstream</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="33%">


<p><i>::std::bitset</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="33%">


<p><i>::std::filesystem::path</i></p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:9%;"><b>ExcludeTypes</b></p>

<p style="margin-left:18%;">A semicolon-separated list of
regular expressions matching types that are excluded from
the <i>IncludeTypes</i> matches. By default it is an empty
list.</p>

<h3>bugprone-unused-raii
<a name="bugprone-unused-raii"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
temporaries that look like RAII objects.</p>

<p style="margin-left:9%; margin-top: 1em">The canonical
example for this is a scoped lock.</p>

<p style="margin-left:13%; margin-top: 1em">{ <br>
scoped_lock(&amp;global_mutex); <br>
critical_section(); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The destructor
of the scoped_lock is called before the
<b>critical_section</b> is entered, leaving it
unprotected.</p>

<p style="margin-left:9%; margin-top: 1em">We apply a
number of heuristics to reduce the false positive count of
this check:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Ignore code expanded from macros. Testing frameworks
make heavy use of this.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Ignore types with trivial destructors. They are very
unlikely to be RAII objects and there's no difference when
they are deleted.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Ignore objects at the end of a compound statement
(doesn't change behavior).</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Ignore objects returned from a call.</p></td></tr>
</table>

<h3>bugprone-unused-return-value
<a name="bugprone-unused-return-value"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns on unused
function return values. The checked functions can be
configured.</p>

<p style="margin-left:9%; margin-top: 1em">Operator
overloading with assignment semantics are ignored.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>CheckedFunctions</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
functions to check. This parameter supports regexp. The
function is checked if the name and scope matches, with any
arguments. By default the following functions are checked:
<b>&#710;::std::async$, &#710;::std::launder$,
&#710;::std::remove$, &#710;::std::remove_if$,
&#710;::std::unique$, &#710;::std::unique_ptr::release$,
&#710;::std::basic_string::empty$,
&#710;::std::vector::empty$, &#710;::std::back_inserter$,
&#710;::std::distance$, &#710;::std::find$,
&#710;::std::find_if$, &#710;::std::inserter$,
&#710;::std::lower_bound$, &#710;::std::make_pair$,
&#710;::std::map::count$, &#710;::std::map::find$,
&#710;::std::map::lower_bound$,
&#710;::std::multimap::equal_range$,
&#710;::std::multimap::upper_bound$,
&#710;::std::set::count$, &#710;::std::set::find$,
&#710;::std::setfill$, &#710;::std::setprecision$,
&#710;::std::setw$, &#710;::std::upper_bound$,
&#710;::std::vector::at$, &#710;::bsearch$, &#710;::ferror$,
&#710;::feof$, &#710;::isalnum$, &#710;::isalpha$,
&#710;::isblank$, &#710;::iscntrl$, &#710;::isdigit$,
&#710;::isgraph$, &#710;::islower$, &#710;::isprint$,
&#710;::ispunct$, &#710;::isspace$, &#710;::isupper$,
&#710;::iswalnum$, &#710;::iswprint$, &#710;::iswspace$,
&#710;::isxdigit$, &#710;::memchr$, &#710;::memcmp$,
&#710;::strcmp$, &#710;::strcoll$, &#710;::strncmp$,
&#710;::strpbrk$, &#710;::strrchr$, &#710;::strspn$,
&#710;::strstr$, &#710;::wcscmp$, &#710;::access$,
&#710;::bind$, &#710;::connect$, &#710;::difftime$,
&#710;::dlsym$, &#710;::fnmatch$, &#710;::getaddrinfo$,
&#710;::getopt$, &#710;::htonl$, &#710;::htons$,
&#710;::iconv_open$, &#710;::inet_addr$, isascii$, isatty$,
&#710;::mmap$, &#710;::newlocale$, &#710;::openat$,
&#710;::pathconf$, &#710;::pthread_equal$,
&#710;::pthread_getspecific$,
&#710;::pthread_mutex_trylock$, &#710;::readdir$,
&#710;::readlink$, &#710;::recvmsg$, &#710;::regexec$,
&#710;::scandir$, &#710;::semget$, &#710;::setjmp$,
&#710;::shm_open$, &#710;::shmget$, &#710;::sigismember$,
&#710;::strcasecmp$, &#710;::strsignal$,
&#710;::ttyname$</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><b>std::async()</b>. Not using the return value makes
the call synchronous.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><b>std::launder()</b>. Not using the return value
usually means that the function interface was misunderstood
by the programmer. Only the returned pointer is
&quot;laundered&quot;, not the argument.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><b>std::remove()</b>, <b>std::remove_if()</b> and
<b>std::unique()</b>. The returned iterator indicates the
boundary between elements to keep and elements to be
removed. Not using the return value means that the
information about which elements to remove is lost.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><b>std::unique_ptr::release()</b>. Not using the return
value can lead to resource leaks if the same pointer isn't
stored anywhere else. Often, ignoring the <b>release()</b>
return value indicates that the programmer confused the
function with <b>reset()</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><b>std::basic_string::empty()</b> and
<b>std::vector::empty()</b>. Not using the return value
often indicates that the programmer confused the function
with <b>clear()</b>.</p></td></tr>
</table>

<p style="margin-left:9%;"><b>CheckedReturnTypes</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
function return types to check. By default the following
function return types are checked:
<i>&#710;::std::error_code$</i>,
<i>&#710;::std::error_condition$</i>,
<i>&#710;::std::errc$</i>, <i>&#710;::std::expected$</i>,
<i>&#710;::boost::system::error_code$</i></p>

<p style="margin-left:9%;"><b>AllowCastToVoid</b></p>

<p style="margin-left:18%;">Controls whether casting return
values to <b>void</b> is permitted. Default:
<i>false</i>.</p>


<p style="margin-left:9%; margin-top: 1em"><i>cert-err33-c</i>
is an alias of this check that checks a fixed and large set
of standard library functions.</p>

<h3>bugprone-use-after-move
<a name="bugprone-use-after-move"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns if an
object is used after it has been moved, for example:</p>

<p style="margin-left:13%; margin-top: 1em">std::string str
= &quot;Hello, world!\n&quot;; <br>
std::vector&lt;std::string&gt; messages; <br>
messages.emplace_back(std::move(str)); <br>
std::cout &lt;&lt; str;</p>

<p style="margin-left:9%; margin-top: 1em">The last line
will trigger a warning that <b>str</b> is used after it has
been moved.</p>

<p style="margin-left:9%; margin-top: 1em">The check does
not trigger a warning if the object is reinitialized after
the move and before the use. For example, no warning will be
output for this code:</p>


<p style="margin-left:13%; margin-top: 1em">messages.emplace_back(std::move(str));
<br>
str = &quot;Greetings, stranger!\n&quot;; <br>
std::cout &lt;&lt; str;</p>

<p style="margin-left:9%; margin-top: 1em">Subsections
below explain more precisely what exactly the check
considers to be a move, use, and reinitialization.</p>

<p style="margin-left:9%; margin-top: 1em">The check takes
control flow into account. A warning is only emitted if the
use can be reached from the move. This means that the
following code does not produce a warning:</p>

<p style="margin-left:13%; margin-top: 1em">if (condition)
{ <br>
messages.emplace_back(std::move(str)); <br>
} else { <br>
std::cout &lt;&lt; str; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">On the other
hand, the following code does produce a warning:</p>

<p style="margin-left:13%; margin-top: 1em">for (int i = 0;
i &lt; 10; ++i) { <br>
std::cout &lt;&lt; str; <br>
messages.emplace_back(std::move(str)); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">(The
use-after-move happens on the second iteration of the
loop.)</p>

<p style="margin-left:9%; margin-top: 1em">In some cases,
the check may not be able to detect that two branches are
mutually exclusive. For example (assuming that <b>i</b> is
an int):</p>

<p style="margin-left:13%; margin-top: 1em">if (i == 1) {
<br>
messages.emplace_back(std::move(str)); <br>
} <br>
if (i == 2) { <br>
std::cout &lt;&lt; str; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In this case,
the check will erroneously produce a warning, even though it
is not possible for both the move and the use to be
executed. More formally, the analysis is <i>flow-sensitive
but not path-sensitive</i>.</p>

<h3>Silencing erroneous warnings
<a name="Silencing erroneous warnings"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">An erroneous
warning can be silenced by reinitializing the object after
the move:</p>

<p style="margin-left:13%; margin-top: 1em">if (i == 1) {
<br>
messages.emplace_back(std::move(str)); <br>
str = &quot;&quot;; <br>
} <br>
if (i == 2) { <br>
std::cout &lt;&lt; str; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">If you want to
avoid the overhead of actually reinitializing the object,
you can create a dummy function that causes the check to
assume the object was reinitialized:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;class T&gt; <br>
void IS_INITIALIZED(T&amp;) {}</p>

<p style="margin-left:9%; margin-top: 1em">You can use this
as follows:</p>

<p style="margin-left:13%; margin-top: 1em">if (i == 1) {
<br>
messages.emplace_back(std::move(str)); <br>
} <br>
if (i == 2) { <br>
IS_INITIALIZED(str); <br>
std::cout &lt;&lt; str; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The check will
not output a warning in this case because passing the object
to a function as a non-const pointer or reference counts as
a reinitialization (see section <i>Reinitialization</i>
below).</p>

<h3>Unsequenced moves, uses, and reinitializations
<a name="Unsequenced moves, uses, and reinitializations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">In many cases,
C++ does not make any guarantees about the order in which
sub-expressions of a statement are evaluated. This means
that in code like the following, it is not guaranteed
whether the use will happen before or after the move:</p>

<p style="margin-left:13%; margin-top: 1em">void f(int i,
std::vector&lt;int&gt; v); <br>
std::vector&lt;int&gt; v = { 1, 2, 3 }; <br>
f(v[1], std::move(v));</p>

<p style="margin-left:9%; margin-top: 1em">In this kind of
situation, the check will note that the use and move are
unsequenced.</p>

<p style="margin-left:9%; margin-top: 1em">The check will
also take sequencing rules into account when
reinitializations occur in the same statement as moves or
uses. A reinitialization is only considered to reinitialize
a variable if it is guaranteed to be evaluated after the
move and before the use.</p>

<h3>Move
<a name="Move"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check
currently only considers calls of <b>std::move</b> on local
variables or function parameters. It does not check moves of
member variables or global variables.</p>

<p style="margin-left:9%; margin-top: 1em">Any call of
<b>std::move</b> on a variable is considered to cause a move
of that variable, even if the result of <b>std::move</b> is
not passed to an rvalue reference parameter.</p>

<p style="margin-left:9%; margin-top: 1em">This means that
the check will flag a use-after-move even on a type that
does not define a move constructor or move assignment
operator. This is intentional. Developers may use
<b>std::move</b> on such a type in the expectation that the
type will add move semantics in the future. If such a
<b>std::move</b> has the potential to cause a
use-after-move, we want to warn about it even if the type
does not implement move semantics yet.</p>

<p style="margin-left:9%; margin-top: 1em">Furthermore, if
the result of <b>std::move</b> <i>is</i> passed to an rvalue
reference parameter, this will always be considered to cause
a move, even if the function that consumes this parameter
does not move from it, or if it does so only conditionally.
For example, in the following situation, the check will
assume that a move always takes place:</p>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;std::string&gt;
messages; <br>
void f(std::string &amp;&amp;str) { <br>
// Only remember the message if it isn't empty. <br>
if (!str.empty()) { <br>
messages.emplace_back(std::move(str)); <br>
} <br>
} <br>
std::string str = &quot;&quot;; <br>
f(std::move(str));</p>

<p style="margin-left:9%; margin-top: 1em">The check will
assume that the last line causes a move, even though, in
this particular case, it does not. Again, this is
intentional.</p>

<p style="margin-left:9%; margin-top: 1em">There is one
special case: A call to <b>std::move</b> inside a
<b>try_emplace</b> call is conservatively assumed not to
move. This is to avoid spurious warnings, as the check has
no way to reason about the <b>bool</b> returned by
<b>try_emplace</b>.</p>

<p style="margin-left:9%; margin-top: 1em">When analyzing
the order in which moves, uses and reinitializations happen
(see section <i>Unsequenced moves, uses, and
reinitializations</i>), the move is assumed to occur in
whichever function the result of the <b>std::move</b> is
passed to.</p>

<p style="margin-left:9%; margin-top: 1em">The check also
handles perfect-forwarding with <b>std::forward</b> so the
following code will also trigger a use-after-move
warning.</p>

<p style="margin-left:13%; margin-top: 1em">void
consume(int);</p>

<p style="margin-left:13%; margin-top: 1em">void
f(int&amp;&amp; i) { <br>
consume(std::forward&lt;int&gt;(i)); <br>
consume(std::forward&lt;int&gt;(i)); // use-after-move <br>
}</p>

<h3>Use
<a name="Use"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Any occurrence
of the moved variable that is not a reinitialization (see
below) is considered to be a use.</p>

<p style="margin-left:9%; margin-top: 1em">An exception to
this are objects of type <b>std::unique_ptr</b>,
<b>std::shared_ptr</b> and <b>std::weak_ptr</b>, which have
defined move behavior (objects of these classes are
guaranteed to be empty after they have been moved from).
Therefore, an object of these classes will only be
considered to be used if it is dereferenced, i.e. if
<b>operator*</b>, <b>operator-&gt;</b> or <b>operator[]</b>
(in the case of <b>std::unique_ptr&lt;T []&gt;</b>) is
called on it.</p>

<p style="margin-left:9%; margin-top: 1em">If multiple uses
occur after a move, only the first of these is flagged.</p>

<h3>Reinitialization
<a name="Reinitialization"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check
considers a variable to be reinitialized in the following
cases:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>The variable occurs on the left-hand side of an
assignment.</p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>The variable is passed to a function as a non-const
pointer or non-const lvalue reference. (It is assumed that
the variable may be an out-parameter for the function.)</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><b>clear()</b> or <b>assign()</b> is called on the
variable and the variable is of one of the standard
container types <b>basic_string</b>, <b>vector</b>,
<b>deque</b>, <b>forward_list</b>, <b>list</b>, <b>set</b>,
<b>map</b>, <b>multiset</b>, <b>multimap</b>,
<b>unordered_set</b>, <b>unordered_map</b>,
<b>unordered_multiset</b>, <b>unordered_multimap</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><b>reset()</b> is called on the variable and the
variable is of type <b>std::unique_ptr</b>,
<b>std::shared_ptr</b> or <b>std::weak_ptr</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>A member function marked with the
<b>[[clang::reinitializes]]</b> attribute is called on the
variable.</p> </td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">If the variable
in question is a struct and an individual member variable of
that struct is written to, the check does not consider this
to be a reinitialization -- even if, eventually, all member
variables of the struct are written to. For example:</p>

<p style="margin-left:13%; margin-top: 1em">struct S { <br>
std::string str; <br>
int i; <br>
}; <br>
S s = { &quot;Hello, world!\n&quot;, 42 }; <br>
S s_other = std::move(s); <br>
s.str = &quot;Lorem ipsum&quot;; <br>
s.i = 99;</p>

<p style="margin-left:9%; margin-top: 1em">The check will
not consider <b>s</b> to be reinitialized after the last
line; instead, the line that assigns to <b>s.str</b> will be
flagged as a use-after-move. This is intentional as this
pattern of reinitializing a struct is error-prone. For
example, if an additional member variable is added to
<b>S</b>, it is easy to forget to add the reinitialization
for this additional member. Instead, it is safer to assign
to the entire struct in one go, and this will also avoid the
use-after-move warning.</p>

<h3>bugprone-virtual-near-miss
<a name="bugprone-virtual-near-miss"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn if a
function is a near miss (i.e. the name is very similar and
the function signature is the same) to a virtual function
from a base class.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">struct Base {
<br>
virtual void func(); <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">struct Derived
: Base { <br>
virtual void funk(); <br>
// warning: 'Derived::funk' has a similar name and the same
signature as virtual method 'Base::func'; did you mean to
override it? <br>
};</p>

<h3>cert-con36-c
<a name="cert-con36-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-con36-c</i> check is an alias, please see
<i>bugprone-spuriously-wake-up-functions</i> for more
information.</p>

<h3>cert-con54-cpp
<a name="cert-con54-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-con54-cpp</i> check is an alias, please see
<i>bugprone-spuriously-wake-up-functions</i> for more
information.</p>

<h3>cert-ctr56-cpp
<a name="cert-ctr56-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-ctr56-cpp</i> check is an alias, please see
<i>bugprone-pointer-arithmetic-on-polymorphic-object</i> for
more information.</p>

<h3>cert-dcl03-c
<a name="cert-dcl03-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-dcl03-c</i> check is an alias, please see
<i>misc-static-assert</i> for more information.</p>

<h3>cert-dcl16-c
<a name="cert-dcl16-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-dcl16-c</i> check is an alias, please see
<i>readability-uppercase-literal-suffix</i> for more
information.</p>

<h3>cert-dcl37-c
<a name="cert-dcl37-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-dcl37-c</i> check is an alias, please see
<i>bugprone-reserved-identifier</i> for more
information.</p>

<h3>cert-dcl50-cpp
<a name="cert-dcl50-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
all function definitions (but not declarations) of C-style
variadic functions.</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard rule
<i>DCL50-CPP. Do not define a C-style variadic
function</i>.</p>

<h3>cert-dcl51-cpp
<a name="cert-dcl51-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-dcl51-cpp</i> check is an alias, please see
<i>bugprone-reserved-identifier</i> for more
information.</p>

<h3>cert-dcl54-cpp
<a name="cert-dcl54-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-dcl54-cpp</i> check is an alias, please see
<i>misc-new-delete-overloads</i> for more information.</p>

<h3>cert-dcl58-cpp
<a name="cert-dcl58-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Modification of
the <b>std</b> or <b>posix</b> namespace can result in
undefined behavior. This check warns for such modifications.
The <b>std</b> (or <b>posix</b>) namespace is allowed to be
extended with (class or function) template specializations
that depend on an user-defined type (a type that is not
defined in the standard system headers).</p>

<p style="margin-left:9%; margin-top: 1em">The check
detects the following (user provided) declarations in
namespace <b>std</b> or <b>posix</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Anything that is not a template
specialization.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Explicit specializations of any standard library
function template or class template, if it does not have any
user-defined type as template argument.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Explicit specializations of any member function of a
standard library class template.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Explicit specializations of any member function template
of a standard library class or class template.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Explicit or partial specialization of any member class
template of a standard library class or class template.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">namespace std {
<br>
int x; // warning: modification of 'std' namespace can
result in undefined behavior [cert-dcl58-cpp] <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">namespace
posix::a { // warning: modification of 'posix' namespace can
result in undefined behavior <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;&gt; <br>
struct ::std::hash&lt;long&gt; { // warning: modification of
'std' namespace can result in undefined behavior <br>
unsigned long operator()(const long &amp;K) const { <br>
return K; <br>
} <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">struct MyData {
long data; };</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;&gt; <br>
struct ::std::hash&lt;MyData&gt; { // no warning:
specialization with user-defined type <br>
unsigned long operator()(const MyData &amp;K) const { <br>
return K.data; <br>
} <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">namespace std {
<br>
template &lt;&gt; <br>
void swap&lt;bool&gt;(bool &amp;a, bool &amp;b); // warning:
modification of 'std' namespace can result in undefined
behavior</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;&gt; <br>
bool less&lt;void&gt;::operator()&lt;MyData &amp;&amp;,
MyData &amp;&amp;&gt;(MyData &amp;&amp;, MyData &amp;&amp;)
const { // warning: modification of 'std' namespace can
result in undefined behavior <br>
return true; <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard rule
<i>DCL58-CPP. Do not modify the standard namespaces</i>.</p>

<h3>cert-dcl59-cpp
<a name="cert-dcl59-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-dcl59-cpp</i> check is an alias, please see
<i>google-build-namespaces</i> for more information.</p>

<h3>cert-env33-c
<a name="cert-env33-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
calls to <b>system()</b>, <b>popen()</b>, and
<b>_popen()</b>, which execute a command processor. It does
not flag calls to <b>system()</b> with a null pointer
argument, as such a call checks for the presence of a
command processor but does not actually attempt to execute a
command.</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C Coding Standard rule <i>ENV33-C.
Do not call system()</i>.</p>

<h3>cert-err09-cpp
<a name="cert-err09-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-err09-cpp</i> check is an alias, please see
<i>misc-throw-by-value-catch-by-reference</i> for more
information.</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard recommendation
ERR09-CPP. Throw anonymous temporaries. However, all of the
CERT recommendations have been removed from public view, and
so their justification for the behavior of this check
requires an account on their wiki to view.</p>

<h3>cert-err33-c
<a name="cert-err33-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns on unused
function return values. Many of the standard library
functions return a value that indicates if the call was
successful. Ignoring the returned value can cause unexpected
behavior if an error has occurred. The following functions
are checked:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p style="margin-top: 1em">aligned_alloc()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>asctime_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>at_quick_exit()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>atexit()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>bsearch()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>bsearch_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>btowc()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>c16rtomb()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>c32rtomb()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>calloc()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>clock()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>cnd_broadcast()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>cnd_init()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>cnd_signal()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>cnd_timedwait()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>cnd_wait()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>ctime_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fclose()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fflush()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fgetc()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fgetpos()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fgets()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fgetwc()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fopen()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fopen_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fprintf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fprintf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fputc()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fputs()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fputwc()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fputws()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fread()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>freopen()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>freopen_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fscanf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fscanf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fseek()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fsetpos()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>ftell()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fwprintf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fwprintf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fwrite()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fwscanf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>fwscanf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>getc()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>getchar()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>getenv()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>getenv_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>gets_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>getwc()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>getwchar()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>gmtime()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>gmtime_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>localtime()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>localtime_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>malloc()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>mbrtoc16()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>mbrtoc32()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>mbsrtowcs()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>mbsrtowcs_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>mbstowcs()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>mbstowcs_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>memchr()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>mktime()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>mtx_init()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>mtx_lock()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>mtx_timedlock()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>mtx_trylock()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>mtx_unlock()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>printf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>putc()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>putwc()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>raise()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>realloc()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>remove()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>rename()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>setlocale()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>setvbuf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>scanf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>scanf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>signal()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>snprintf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>snprintf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>sprintf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>sprintf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>sscanf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>sscanf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strchr()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strerror_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strftime()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strpbrk()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strrchr()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strstr()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strtod()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strtof()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strtoimax()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strtok()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strtok_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strtol()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strtold()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strtoll()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strtoumax()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strtoul()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strtoull()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>strxfrm()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>swprintf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>swprintf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>swscanf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>swscanf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>thrd_create()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>thrd_detach()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>thrd_join()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>thrd_sleep()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>time()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>timespec_get()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>tmpfile()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>tmpfile_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>tmpnam()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>tmpnam_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>tss_create()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>tss_get()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>tss_set()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>ungetc()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>ungetwc()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vfprintf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vfprintf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vfscanf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vfscanf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vfwprintf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vfwprintf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vfwscanf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vfwscanf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vprintf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vscanf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vscanf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vsnprintf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vsnprintf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vsprintf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vsprintf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vsscanf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vsscanf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vswprintf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vswprintf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vswscanf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vswscanf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vwprintf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vwscanf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>vwscanf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcrtomb()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcschr()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcsftime()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcspbrk()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcsrchr()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcsrtombs()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcsrtombs_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcsstr()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcstod()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcstof()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcstoimax()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcstok()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcstok_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcstol()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcstold()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcstoll()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcstombs()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcstombs_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcstoumax()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcstoul()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcstoull()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wcsxfrm()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wctob()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wctrans()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wctype()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wmemchr()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wprintf_s()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wscanf()</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="19%">


<p>wscanf_s()</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">This check is an
alias of check <i>bugprone-unused-return-value</i> with a
fixed set of functions.</p>

<p style="margin-left:9%; margin-top: 1em">Suppressing
issues by casting to <b>void</b> is enabled by default and
can be disabled by setting <i>AllowCastToVoid</i> option to
<b>false</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The check
corresponds to a part of CERT C Coding Standard rule
<i>ERR33-C. Detect and handle standard library errors</i>.
The list of checked functions is taken from the rule, with
following exception:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">The check can not differentiate
if a function is called with <b>NULL</b> argument. Therefore
the following functions are not checked: <b>mblen</b>,
<b>mbrlen</b>, <b>mbrtowc</b>, <b>mbtowc</b>, <b>wctomb</b>,
<b>wctomb_s</b></p> </td></tr>
</table>

<h3>cert-err34-c
<a name="cert-err34-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
calls to string-to-number conversion functions that do not
verify the validity of the conversion, such as <b>atoi()</b>
or <b>scanf()</b>. It does not flag calls to
<b>strtol()</b>, or other, related conversion functions that
do perform better error checking.</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;stdlib.h&gt;</p>

<p style="margin-left:13%; margin-top: 1em">void func(const
char *buff) { <br>
int si;</p>

<p style="margin-left:13%; margin-top: 1em">if (buff) {
<br>
si = atoi(buff); /* 'atoi' used to convert a string to an
integer, but function will <br>
not report conversion errors; consider using 'strtol'
instead. */ <br>
} else { <br>
/* Handle error */ <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C Coding Standard rule <i>ERR34-C.
Detect errors when converting a string to a number</i>.</p>

<h3>cert-err52-cpp
<a name="cert-err52-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
all call expressions involving <b>setjmp()</b> and
<b>longjmp()</b>.</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard rule
<i>ERR52-CPP. Do not use setjmp() or longjmp()</i>.</p>

<h3>cert-err58-cpp
<a name="cert-err58-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
all <b>static</b> or <b>thread_local</b> variable
declarations where the initializer for the object may throw
an exception.</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard rule
<i>ERR58-CPP. Handle all exceptions thrown before main()
begins executing</i>.</p>

<h3>cert-err60-cpp
<a name="cert-err60-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
all throw expressions where the exception object is not
nothrow copy constructible.</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard rule
<i>ERR60-CPP. Exception objects must be nothrow copy
constructible</i>.</p>

<h3>cert-err61-cpp
<a name="cert-err61-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-err61-cpp</i> check is an alias, please see
<i>misc-throw-by-value-catch-by-reference</i> for more
information.</p>

<h3>cert-exp42-c
<a name="cert-exp42-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-exp42-c</i> check is an alias, please see
<i>bugprone-suspicious-memory-comparison</i> for more
information.</p>

<h3>cert-fio38-c
<a name="cert-fio38-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-fio38-c</i> check is an alias, please see
<i>misc-non-copyable-objects</i> for more information.</p>

<h3>cert-flp30-c
<a name="cert-flp30-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
<b>for</b> loops where the induction expression has a
floating-point type.</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C Coding Standard rule <i>FLP30-C.
Do not use floating-point variables as loop
counters</i>.</p>

<h3>cert-flp37-c
<a name="cert-flp37-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-flp37-c</i> check is an alias, please see
<i>bugprone-suspicious-memory-comparison</i> for more
information.</p>

<h3>cert-int09-c
<a name="cert-int09-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-int09-c</i> check is an alias, please see
<i>readability-enum-initial-value</i> for more
information.</p>

<h3>cert-mem57-cpp
<a name="cert-mem57-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
uses of default <b>operator new</b> where the type has
extended alignment (an alignment greater than the
fundamental alignment). (The default <b>operator new</b> is
guaranteed to provide the correct alignment if the requested
alignment is less or equal to the fundamental alignment).
Only cases are detected (by design) where the <b>operator
new</b> is not user-defined and is not a placement new (the
reason is that in these cases we assume that the user
provided the correct memory allocation).</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard rule
<i>MEM57-CPP. Avoid using default operator new for
over-aligned types</i>.</p>

<h3>cert-msc24-c
<a name="cert-msc24-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-msc24-c</i> check is an alias, please see
<i>bugprone-unsafe-functions</i> for more information.</p>

<h3>cert-msc30-c
<a name="cert-msc30-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-msc30-c</i> check is an alias, please see
<i>cert-msc50-cpp</i> for more information.</p>

<h3>cert-msc32-c
<a name="cert-msc32-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-msc32-c</i> check is an alias, please see
<i>cert-msc51-cpp</i> for more information.</p>

<h3>cert-msc33-c
<a name="cert-msc33-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-msc33-c</i> check is an alias, please see
<i>bugprone-unsafe-functions</i> for more information.</p>

<h3>cert-msc50-cpp
<a name="cert-msc50-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Pseudorandom
number generators use mathematical algorithms to produce a
sequence of numbers with good statistical properties, but
the numbers produced are not genuinely random. The
<b>std::rand()</b> function takes a seed (number), runs a
mathematical operation on it and returns the result. By
manipulating the seed the result can be predictable. This
check warns for the usage of <b>std::rand()</b>.</p>

<h3>cert-msc51-cpp
<a name="cert-msc51-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
all pseudo-random number engines, engine adaptor
instantiations and <b>srand()</b> when initialized or seeded
with default argument, constant expression or any
user-configurable type. Pseudo-random number engines seeded
with a predictable value may cause vulnerabilities e.g. in
security protocols. This is a CERT security rule, see
<i>MSC51-CPP. Ensure your random number generator is
properly seeded</i> and <i>MSC32-C. Properly seed
pseudorandom number generators</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">void foo() {
<br>
std::mt19937 engine1; // Diagnose, always generate the same
sequence <br>
std::mt19937 engine2(1); // Diagnose <br>
engine1.seed(); // Diagnose <br>
engine2.seed(1); // Diagnose</p>

<p style="margin-left:13%; margin-top: 1em">std::time_t t;
<br>
engine1.seed(std::time(&amp;t)); // Diagnose, system time
might be controlled by user</p>

<p style="margin-left:13%; margin-top: 1em">int x =
atoi(argv[1]); <br>
std::mt19937 engine3(x); // Will not warn <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>DisallowedSeedTypes</b></p>

<p style="margin-left:18%;">A comma-separated list of the
type names which are disallowed. Default values are
<b>time_t</b>, <b>std::time_t</b>.</p>

<h3>cert-msc54-cpp
<a name="cert-msc54-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-msc54-cpp</i> check is an alias, please see
<i>bugprone-signal-handler</i> for more information.</p>

<h3>cert-oop11-cpp
<a name="cert-oop11-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-oop11-cpp check</i> is an alias, please see
<i>performance-move-constructor-init</i> for more
information.</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard recommendation
OOP11-CPP. Do not copy-initialize members or base classes
from a move constructor. However, all of the CERT
recommendations have been removed from public view, and so
their justification for the behavior of this check requires
an account on their wiki to view.</p>

<h3>cert-oop54-cpp
<a name="cert-oop54-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-oop54-cpp</i> check is an alias, please see
<i>bugprone-unhandled-self-assignment</i> for more
information.</p>

<h3>cert-oop57-cpp
<a name="cert-oop57-cpp"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">Flags use of
the <i>C</i> standard library functions <b>memset</b>,
<b>memcpy</b> and <b>memcmp</b> and similar derivatives on
non-trivial types.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>MemSetNames</b></p>

<p style="margin-left:18%;">Specify extra functions to flag
that act similarly to <b>memset</b>. Specify names in a
semicolon delimited list. Default is an empty string. The
check will detect the following functions: <i>memset</i>,
<i>std::memset</i>.</p>

<p style="margin-left:9%;"><b>MemCpyNames</b></p>

<p style="margin-left:18%;">Specify extra functions to flag
that act similarly to <b>memcpy</b>. Specify names in a
semicolon delimited list. Default is an empty string. The
check will detect the following functions:
<i>std::memcpy</i>, <i>memcpy</i>, <i>std::memmove</i>,
<i>memmove</i>, <i>std::strcpy</i>, <i>strcpy</i>,
<i>memccpy</i>, <i>stpncpy</i>, <i>strncpy</i>.</p>

<p style="margin-left:9%;"><b>MemCmpNames</b></p>

<p style="margin-left:18%;">Specify extra functions to flag
that act similarly to <b>memcmp</b>. Specify names in a
semicolon delimited list. Default is an empty string. The
check will detect the following functions:
<i>std::memcmp</i>, <i>memcmp</i>, <i>std::strcmp</i>,
<i>strcmp</i>, <i>strncmp</i>.</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard rule
<i>OOP57-CPP. Prefer special member functions and overloaded
operators to C Standard Library functions</i>.</p>

<h3>cert-oop58-cpp
<a name="cert-oop58-cpp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
assignments to the copied object and its direct or indirect
members in copy constructors and copy assignment
operators.</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C Coding Standard rule <i>OOP58-CPP.
Copy operations must not mutate the source object</i>.</p>

<h3>cert-pos44-c
<a name="cert-pos44-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-pos44-c</i> check is an alias, please see
<i>bugprone-bad-signal-to-kill-thread</i> for more
information.</p>

<h3>cert-pos47-c
<a name="cert-pos47-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-pos47-c</i> check is an alias, please see
<i>concurrency-thread-canceltype-asynchronous</i> for more
information.</p>

<h3>cert-sig30-c
<a name="cert-sig30-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-sig30-c</i> check is an alias, please see
<i>bugprone-signal-handler</i> for more information.</p>

<h3>cert-str34-c
<a name="cert-str34-c"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cert-str34-c</i> check is an alias, please see
<i>bugprone-signed-char-misuse</i> for more information.</p>

<h3>clang-analyzer-core.BitwiseShift
<a name="clang-analyzer-core.BitwiseShift"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds cases
where bitwise shift operation causes undefined
behaviour.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-core.BitwiseShift</i> check is an alias,
please see - <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>

<h3>clang-analyzer-core.CallAndMessage
<a name="clang-analyzer-core.CallAndMessage"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
logical errors for function calls and Objective-C message
expressions (e.g., uninitialized arguments, null function
pointers).</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-core.CallAndMessage</i> check is an alias,
please see - <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>

<h3>clang-analyzer-core.DivideZero
<a name="clang-analyzer-core.DivideZero"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
division by zero.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-core.DivideZero</i> check is an alias,
please see <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>

<h3>clang-analyzer-core.NonNullParamChecker
<a name="clang-analyzer-core.NonNullParamChecker"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for null
pointers passed as arguments to a function whose arguments
are references or marked with the 'nonnull' attribute.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-core.NonNullParamChecker</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-core.NullDereference
<a name="clang-analyzer-core.NullDereference"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
dereferences of null pointers.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-core.NullDereference</i> check is an
alias, please see - <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-core.StackAddressEscape
<a name="clang-analyzer-core.StackAddressEscape"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check that
addresses to stack memory do not escape the function.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-core.StackAddressEscape</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-core.UndefinedBinaryOperatorResult
<a name="clang-analyzer-core.UndefinedBinaryOperatorResult"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
undefined results of binary operators.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-core.UndefinedBinaryOperatorResult</i>
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>

<h3>clang-analyzer-core.VLASize
<a name="clang-analyzer-core.VLASize"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
declarations of VLA of undefined or zero size.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-core.VLASize</i> check is an alias, please
see <i>Clang Static Analyzer Available Checkers</i> for more
information.</p>

<h3>clang-analyzer-core.uninitialized.ArraySubscript
<a name="clang-analyzer-core.uninitialized.ArraySubscript"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
uninitialized values used as array subscripts.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-core.uninitialized.ArraySubscript</i>
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>

<h3>clang-analyzer-core.uninitialized.Assign
<a name="clang-analyzer-core.uninitialized.Assign"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
assigning uninitialized values.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-core.uninitialized.Assign</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-core.uninitialized.Branch
<a name="clang-analyzer-core.uninitialized.Branch"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
uninitialized values used as branch conditions.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-core.uninitialized.Branch</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-core.uninitialized.CapturedBlockVariable
<a name="clang-analyzer-core.uninitialized.CapturedBlockVariable"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for blocks
that capture uninitialized values.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-core.uninitialized.CapturedBlockVariable</i>
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>

<h3>clang-analyzer-core.uninitialized.NewArraySize
<a name="clang-analyzer-core.uninitialized.NewArraySize"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check if the
size of the array in a new[] expression is undefined.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-core.uninitialized.NewArraySize</i> check
is an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-core.uninitialized.UndefReturn
<a name="clang-analyzer-core.uninitialized.UndefReturn"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
uninitialized values being returned to the caller.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-core.uninitialized.UndefReturn</i> check
is an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-cplusplus.ArrayDelete
<a name="clang-analyzer-cplusplus.ArrayDelete"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Reports
destructions of arrays of polymorphic objects that are
destructed as their base class.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-cplusplus.ArrayDelete</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-cplusplus.InnerPointer
<a name="clang-analyzer-cplusplus.InnerPointer"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for inner
pointers of C++ containers used after re/deallocation.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-cplusplus.InnerPointer</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-cplusplus.Move
<a name="clang-analyzer-cplusplus.Move"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Find
use-after-move bugs in C++.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-cplusplus.Move</i> check is an alias,
please see <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>

<h3>clang-analyzer-cplusplus.NewDelete
<a name="clang-analyzer-cplusplus.NewDelete"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
double-free and use-after-free problems. Traces memory
managed by new/delete.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-cplusplus.NewDelete</i> check is an alias,
please see - <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>

<h3>clang-analyzer-cplusplus.NewDeleteLeaks
<a name="clang-analyzer-cplusplus.NewDeleteLeaks"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for memory
leaks. Traces memory managed by new/delete.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-cplusplus.NewDeleteLeaks</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-cplusplus.PlacementNew
<a name="clang-analyzer-cplusplus.PlacementNew"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check if default
placement new is provided with pointers to sufficient
storage capacity.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-cplusplus.PlacementNew</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-cplusplus.PureVirtualCall
<a name="clang-analyzer-cplusplus.PureVirtualCall"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check pure
virtual function calls during construction/destruction.</p>

<p style="margin-left:9%; margin-top: 1em">The
clang-analyzer-cplusplus.PureVirtualCall check is an alias
of Clang Static Analyzer cplusplus.PureVirtualCall.</p>

<h3>clang-analyzer-cplusplus.StringChecker
<a name="clang-analyzer-cplusplus.StringChecker"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks C++
std::string bugs.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-cplusplus.StringChecker</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-deadcode.DeadStores
<a name="clang-analyzer-deadcode.DeadStores"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for values
stored to variables that are never read afterwards.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-deadcode.DeadStores</i> check is an alias,
please see - <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>

<h3>clang-analyzer-fuchsia.HandleChecker
<a name="clang-analyzer-fuchsia.HandleChecker"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">A Checker that
detect leaks related to Fuchsia handles.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-fuchsia.HandleChecker</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-nullability.NullPassedToNonnull
<a name="clang-analyzer-nullability.NullPassedToNonnull"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns when a
null pointer is passed to a pointer which has a _Nonnull
type.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-nullability.NullPassedToNonnull</i> check
is an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-nullability.NullReturnedFromNonnull
<a name="clang-analyzer-nullability.NullReturnedFromNonnull"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns when a
null pointer is returned from a function that has _Nonnull
return type.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-nullability.NullReturnedFromNonnull</i>
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>

<h3>clang-analyzer-nullability.NullableDereferenced
<a name="clang-analyzer-nullability.NullableDereferenced"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns when a
nullable pointer is dereferenced.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-nullability.NullableDereferenced</i> check
is an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-nullability.NullablePassedToNonnull
<a name="clang-analyzer-nullability.NullablePassedToNonnull"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns when a
nullable pointer is passed to a pointer which has a _Nonnull
type.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-nullability.NullablePassedToNonnull</i>
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>

<h3>clang-analyzer-nullability.NullableReturnedFromNonnull
<a name="clang-analyzer-nullability.NullableReturnedFromNonnull"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns when a
nullable pointer is returned from a function that has
_Nonnull return type.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-nullability.NullableReturnedFromNonnull</i>
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>

<h3>clang-analyzer-optin.core.EnumCastOutOfRange
<a name="clang-analyzer-optin.core.EnumCastOutOfRange"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check integer to
enumeration casts for out of range values.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-optin.core.EnumCastOutOfRange</i> check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-optin.cplusplus.UninitializedObject
<a name="clang-analyzer-optin.cplusplus.UninitializedObject"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Reports
uninitialized fields after object construction.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-optin.cplusplus.UninitializedObject</i>
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>

<h3>clang-analyzer-optin.cplusplus.VirtualCall
<a name="clang-analyzer-optin.cplusplus.VirtualCall"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check virtual
function calls during construction/destruction.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-optin.cplusplus.VirtualCall</i> check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-optin.mpi.MPI-Checker
<a name="clang-analyzer-optin.mpi.MPI-Checker"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks MPI
code.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-optin.mpi.MPI-Checker</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-optin.osx.OSObjectCStyleCast
<a name="clang-analyzer-optin.osx.OSObjectCStyleCast"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checker for
C-style casts of OSObjects.</p>

<p style="margin-left:9%; margin-top: 1em">The
clang-analyzer-optin.osx.OSObjectCStyleCast check is an
alias of Clang Static Analyzer
optin.osx.OSObjectCStyleCast.</p>

<h3>clang-analyzer-optin.osx.cocoa.localizability.EmptyLocalizationContextChecker
<a name="clang-analyzer-optin.osx.cocoa.localizability.EmptyLocalizationContextChecker"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check that
NSLocalizedString macros include a comment for context.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-optin.osx.cocoa.localizability.EmptyLocalizationContextChecker</i>
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>

<h3>clang-analyzer-optin.osx.cocoa.localizability.NonLocalizedStringChecker
<a name="clang-analyzer-optin.osx.cocoa.localizability.NonLocalizedStringChecker"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns about uses
of non-localized NSStrings passed to UI methods expecting
localized NSStrings.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-optin.osx.cocoa.localizability.NonLocalizedStringChecker</i>
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>

<h3>clang-analyzer-optin.performance.GCDAntipattern
<a name="clang-analyzer-optin.performance.GCDAntipattern"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
performance anti-patterns when using Grand Central
Dispatch.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-optin.performance.GCDAntipattern</i> check
is an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-optin.performance.Padding
<a name="clang-analyzer-optin.performance.Padding"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
excessively padded structs.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-optin.performance.Padding</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-optin.portability.UnixAPI
<a name="clang-analyzer-optin.portability.UnixAPI"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
implementation-defined behavior in UNIX/Posix functions.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-optin.portability.UnixAPI</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-optin.taint.TaintedAlloc
<a name="clang-analyzer-optin.taint.TaintedAlloc"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for memory
allocations, where the size parameter might be a tainted
(attacker controlled) value.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-optin.taint.TaintedAlloc</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.API
<a name="clang-analyzer-osx.API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for proper
uses of various Apple APIs.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.API</i> check is an alias, please see
<i>Clang Static Analyzer Available Checkers</i> for more
information.</p>

<h3>clang-analyzer-osx.MIG
<a name="clang-analyzer-osx.MIG"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Find violations
of the Mach Interface Generator calling convention.</p>

<p style="margin-left:9%; margin-top: 1em">The
clang-analyzer-osx.MIG check is an alias of Clang Static
Analyzer osx.MIG.</p>

<h3>clang-analyzer-osx.NumberObjectConversion
<a name="clang-analyzer-osx.NumberObjectConversion"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
erroneous conversions of objects representing numbers into
numbers.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.NumberObjectConversion</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.OSObjectRetainCount
<a name="clang-analyzer-osx.OSObjectRetainCount"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for leaks
and improper reference count management for OSObject.</p>

<p style="margin-left:9%; margin-top: 1em">The
clang-analyzer-osx.OSObjectRetainCount check is an alias of
Clang Static Analyzer osx.OSObjectRetainCount.</p>

<h3>clang-analyzer-osx.ObjCProperty
<a name="clang-analyzer-osx.ObjCProperty"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for proper
uses of Objective-C properties.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.ObjCProperty</i> check is an alias,
please see <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>

<h3>clang-analyzer-osx.SecKeychainAPI
<a name="clang-analyzer-osx.SecKeychainAPI"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for proper
uses of Secure Keychain APIs.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.SecKeychainAPI</i> check is an alias,
please see - <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>

<h3>clang-analyzer-osx.cocoa.AtSync
<a name="clang-analyzer-osx.cocoa.AtSync"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for nil
pointers used as mutexes for @synchronized.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.AtSync</i> check is an alias,
please see <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>

<h3>clang-analyzer-osx.cocoa.AutoreleaseWrite
<a name="clang-analyzer-osx.cocoa.AutoreleaseWrite"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn about
potentially crashing writes to autoreleasing objects from
different autoreleasing pools in Objective-C.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.AutoreleaseWrite</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.cocoa.ClassRelease
<a name="clang-analyzer-osx.cocoa.ClassRelease"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
sending 'retain', 'release', or 'autorelease' directly to a
Class.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.ClassRelease</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.cocoa.Dealloc
<a name="clang-analyzer-osx.cocoa.Dealloc"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn about
Objective-C classes that lack a correct implementation of
-dealloc.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.Dealloc</i> check is an alias,
please see - <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>

<h3>clang-analyzer-osx.cocoa.IncompatibleMethodTypes
<a name="clang-analyzer-osx.cocoa.IncompatibleMethodTypes"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn about
Objective-C method signatures with type
incompatibilities.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.IncompatibleMethodTypes</i>
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.cocoa.Loops
<a name="clang-analyzer-osx.cocoa.Loops"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Improved
modeling of loops using Cocoa collection types.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.Loops</i> check is an alias,
please see <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>

<h3>clang-analyzer-osx.cocoa.MissingSuperCall
<a name="clang-analyzer-osx.cocoa.MissingSuperCall"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn about
Objective-C methods that lack a necessary call to super.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.MissingSuperCall</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.cocoa.NSAutoreleasePool
<a name="clang-analyzer-osx.cocoa.NSAutoreleasePool"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn for
suboptimal uses of NSAutoreleasePool in Objective-C GC
mode.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.NSAutoreleasePool</i> check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.cocoa.NSError
<a name="clang-analyzer-osx.cocoa.NSError"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check usage of
NSError** parameters.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.NSError</i> check is an alias,
please see - <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>

<h3>clang-analyzer-osx.cocoa.NilArg
<a name="clang-analyzer-osx.cocoa.NilArg"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
prohibited nil arguments to ObjC method calls.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.NilArg</i> check is an alias,
please see <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>

<h3>clang-analyzer-osx.cocoa.NonNilReturnValue
<a name="clang-analyzer-osx.cocoa.NonNilReturnValue"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Model the APIs
that are guaranteed to return a non-nil value.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.NonNilReturnValue</i> check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.cocoa.ObjCGenerics
<a name="clang-analyzer-osx.cocoa.ObjCGenerics"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for type
errors when using Objective-C generics.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.ObjCGenerics</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.cocoa.RetainCount
<a name="clang-analyzer-osx.cocoa.RetainCount"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for leaks
and improper reference count management.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.RetainCount</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.cocoa.RunLoopAutoreleaseLeak
<a name="clang-analyzer-osx.cocoa.RunLoopAutoreleaseLeak"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for leaked
memory in autorelease pools that will never be drained.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.RunLoopAutoreleaseLeak</i> check
is an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.cocoa.SelfInit
<a name="clang-analyzer-osx.cocoa.SelfInit"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check that
'self' is properly initialized inside an initializer
method.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.SelfInit</i> check is an alias,
please see - <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>

<h3>clang-analyzer-osx.cocoa.SuperDealloc
<a name="clang-analyzer-osx.cocoa.SuperDealloc"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn about
improper use of '[super dealloc]' in Objective-C.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.SuperDealloc</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.cocoa.UnusedIvars
<a name="clang-analyzer-osx.cocoa.UnusedIvars"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn about
private ivars that are never used.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.UnusedIvars</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.cocoa.VariadicMethodTypes
<a name="clang-analyzer-osx.cocoa.VariadicMethodTypes"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
passing non-Objective-C types to variadic collection
initialization methods that expect only Objective-C
types.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.cocoa.VariadicMethodTypes</i> check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.coreFoundation.CFError
<a name="clang-analyzer-osx.coreFoundation.CFError"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check usage of
CFErrorRef* parameters.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.coreFoundation.CFError</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.coreFoundation.CFNumber
<a name="clang-analyzer-osx.coreFoundation.CFNumber"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for proper
uses of CFNumber APIs.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.coreFoundation.CFNumber</i> check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.coreFoundation.CFRetainRelease
<a name="clang-analyzer-osx.coreFoundation.CFRetainRelease"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for null
arguments to CFRetain/CFRelease/CFMakeCollectable.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.coreFoundation.CFRetainRelease</i>
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.coreFoundation.containers.OutOfBounds
<a name="clang-analyzer-osx.coreFoundation.containers.OutOfBounds"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for index
out-of-bounds when using 'CFArray' API.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.coreFoundation.containers.OutOfBounds</i>
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>

<h3>clang-analyzer-osx.coreFoundation.containers.PointerSizedValues
<a name="clang-analyzer-osx.coreFoundation.containers.PointerSizedValues"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns if
'CFArray', 'CFDictionary', 'CFSet' are created with
non-pointer-size values.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-osx.coreFoundation.containers.PointerSizedValues</i>
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>

<h3>clang-analyzer-security.FloatLoopCounter
<a name="clang-analyzer-security.FloatLoopCounter"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn on using a
floating point value as a loop counter (CERT: FLP30-C,
FLP30-CPP).</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-security.FloatLoopCounter</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-security.PutenvStackArray
<a name="clang-analyzer-security.PutenvStackArray"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds calls to
the function 'putenv' which pass a pointer to an automatic
(stack-allocated) array as the argument.</p>

<p style="margin-left:9%; margin-top: 1em">The
clang-analyzer-security.PutenvStackArray check is an alias
of Clang Static Analyzer security.PutenvStackArray.</p>

<h3>clang-analyzer-security.SetgidSetuidOrder
<a name="clang-analyzer-security.SetgidSetuidOrder"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn on possible
reversed order of 'setgid(getgid()))' and 'setuid(getuid())'
(CERT: POS36-C).</p>

<p style="margin-left:9%; margin-top: 1em">The
clang-analyzer-security.SetgidSetuidOrder check is an alias
of Clang Static Analyzer security.SetgidSetuidOrder.</p>

<h3>clang-analyzer-security.cert.env.InvalidPtr
<a name="clang-analyzer-security.cert.env.InvalidPtr"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds usages of
possibly invalidated pointers.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-security.cert.env.InvalidPtr</i> check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling
<a name="clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn on uses of
unsecure or deprecated buffer manipulating functions.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling</i>
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>

<h3>clang-analyzer-security.insecureAPI.UncheckedReturn
<a name="clang-analyzer-security.insecureAPI.UncheckedReturn"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn on uses of
functions whose return values must be always checked.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-security.insecureAPI.UncheckedReturn</i>
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>

<h3>clang-analyzer-security.insecureAPI.bcmp
<a name="clang-analyzer-security.insecureAPI.bcmp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn on uses of
the 'bcmp' function.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-security.insecureAPI.bcmp</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-security.insecureAPI.bcopy
<a name="clang-analyzer-security.insecureAPI.bcopy"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn on uses of
the 'bcopy' function.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-security.insecureAPI.bcopy</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-security.insecureAPI.bzero
<a name="clang-analyzer-security.insecureAPI.bzero"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn on uses of
the 'bzero' function.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-security.insecureAPI.bzero</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-security.insecureAPI.decodeValueOfObjCType
<a name="clang-analyzer-security.insecureAPI.decodeValueOfObjCType"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn on uses of
the '-decodeValueOfObjCType:at:' method.</p>

<p style="margin-left:9%; margin-top: 1em">The
clang-analyzer-security.insecureAPI.decodeValueOfObjCType
check is an alias of Clang Static Analyzer
security.insecureAPI.decodeValueOfObjCType.</p>

<h3>clang-analyzer-security.insecureAPI.getpw
<a name="clang-analyzer-security.insecureAPI.getpw"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn on uses of
the 'getpw' function.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-security.insecureAPI.getpw</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-security.insecureAPI.gets
<a name="clang-analyzer-security.insecureAPI.gets"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn on uses of
the 'gets' function.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-security.insecureAPI.gets</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-security.insecureAPI.mkstemp
<a name="clang-analyzer-security.insecureAPI.mkstemp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn when
'mkstemp' is passed fewer than 6 X's in the format
string.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-security.insecureAPI.mkstemp</i> check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-security.insecureAPI.mktemp
<a name="clang-analyzer-security.insecureAPI.mktemp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn on uses of
the 'mktemp' function.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-security.insecureAPI.mktemp</i> check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-security.insecureAPI.rand
<a name="clang-analyzer-security.insecureAPI.rand"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn on uses of
the 'rand', 'random', and related functions.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-security.insecureAPI.rand</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-security.insecureAPI.strcpy
<a name="clang-analyzer-security.insecureAPI.strcpy"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn on uses of
the 'strcpy' and 'strcat' functions.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-security.insecureAPI.strcpy</i> check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-security.insecureAPI.vfork
<a name="clang-analyzer-security.insecureAPI.vfork"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn on uses of
the 'vfork' function.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-security.insecureAPI.vfork</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-unix.API
<a name="clang-analyzer-unix.API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check calls to
various UNIX/Posix functions.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-unix.API</i> check is an alias, please see
<i>Clang Static Analyzer Available Checkers</i> for more
information.</p>

<h3>clang-analyzer-unix.BlockInCriticalSection
<a name="clang-analyzer-unix.BlockInCriticalSection"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for calls
to blocking functions inside a critical section.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-unix.BlockInCriticalSection</i> check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-unix.Errno
<a name="clang-analyzer-unix.Errno"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
improper use of 'errno'.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-unix.Errno</i> check is an alias, please
see <i>Clang Static Analyzer Available Checkers</i> for more
information.</p>

<h3>clang-analyzer-unix.Malloc
<a name="clang-analyzer-unix.Malloc"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for memory
leaks, double free, and use-after-free problems. Traces
memory managed by malloc()/free().</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-unix.Malloc</i> check is an alias, please
see <i>Clang Static Analyzer Available Checkers</i> for more
information.</p>

<h3>clang-analyzer-unix.MallocSizeof
<a name="clang-analyzer-unix.MallocSizeof"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
dubious malloc arguments involving sizeof.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-unix.MallocSizeof</i> check is an alias,
please see - <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>

<h3>clang-analyzer-unix.MismatchedDeallocator
<a name="clang-analyzer-unix.MismatchedDeallocator"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
mismatched deallocators.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-unix.MismatchedDeallocator</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-unix.StdCLibraryFunctions
<a name="clang-analyzer-unix.StdCLibraryFunctions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
invalid arguments of C standard library functions, and apply
relations between arguments and return value.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-unix.StdCLibraryFunctions</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-unix.Stream
<a name="clang-analyzer-unix.Stream"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check stream
handling functions.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-unix.Stream</i> check is an alias, please
see <i>Clang Static Analyzer Available Checkers</i> for more
information.</p>

<h3>clang-analyzer-unix.Vfork
<a name="clang-analyzer-unix.Vfork"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for proper
usage of vfork.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-unix.Vfork</i> check is an alias, please
see <i>Clang Static Analyzer Available Checkers</i> for more
information.</p>

<h3>clang-analyzer-unix.cstring.BadSizeArg
<a name="clang-analyzer-unix.cstring.BadSizeArg"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check the size
argument passed into C string functions for common erroneous
patterns.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-unix.cstring.BadSizeArg</i> check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-unix.cstring.NullArg
<a name="clang-analyzer-unix.cstring.NullArg"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for null
pointers being passed as arguments to C string
functions.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-unix.cstring.NullArg</i> check is an
alias, please see - <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-valist.CopyToSelf
<a name="clang-analyzer-valist.CopyToSelf"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
va_lists which are copied onto itself.</p>

<p style="margin-left:9%; margin-top: 1em">The
clang-analyzer-valist.CopyToSelf check is an alias of Clang
Static Analyzer valist.CopyToSelf.</p>

<h3>clang-analyzer-valist.Uninitialized
<a name="clang-analyzer-valist.Uninitialized"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for usages
of uninitialized (or already released) va_lists.</p>

<p style="margin-left:9%; margin-top: 1em">The
clang-analyzer-valist.Uninitialized check is an alias of
Clang Static Analyzer valist.Uninitialized.</p>

<h3>clang-analyzer-valist.Unterminated
<a name="clang-analyzer-valist.Unterminated"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
va_lists which are not released by a va_end call.</p>

<p style="margin-left:9%; margin-top: 1em">The
clang-analyzer-valist.Unterminated check is an alias of
Clang Static Analyzer valist.Unterminated.</p>

<h3>clang-analyzer-webkit.NoUncountedMemberChecker
<a name="clang-analyzer-webkit.NoUncountedMemberChecker"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for no
uncounted member variables.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-webkit.NoUncountedMemberChecker</i> check
is an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-webkit.RefCntblBaseVirtualDtor
<a name="clang-analyzer-webkit.RefCntblBaseVirtualDtor"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for any
ref-countable base class having virtual destructor.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-webkit.RefCntblBaseVirtualDtor</i> check
is an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>

<h3>clang-analyzer-webkit.UncountedLambdaCapturesChecker
<a name="clang-analyzer-webkit.UncountedLambdaCapturesChecker"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check uncounted
lambda captures.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>clang-analyzer-webkit.UncountedLambdaCapturesChecker</i>
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>

<h3>concurrency-mt-unsafe
<a name="concurrency-mt-unsafe"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for some
thread-unsafe functions against a black list of
known-to-be-unsafe functions. Usually they access static
variables without synchronization (e.g. gmtime(3)) or
utilize signals in a racy way. The set of functions to check
is specified with the <i>FunctionSet</i> option.</p>

<p style="margin-left:9%; margin-top: 1em">Note that using
some thread-unsafe functions may be still valid in
concurrent programming if only a single thread is used (e.g.
setenv(3)), however, some functions may track a state in
global variables which would be clobbered by subsequent
(non-parallel, but concurrent) calls to a related function.
E.g. the following code suffers from unprotected accesses to
a global state:</p>

<p style="margin-left:13%; margin-top: 1em">// getnetent(3)
maintains global state with DB connection, etc. <br>
// If a concurrent green thread calls getnetent(3), the
global state is corrupted. <br>
netent = getnetent(); <br>
yield(); <br>
netent = getnetent();</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">tm =
gmtime(timep); // uses a global buffer</p>

<p style="margin-left:13%; margin-top: 1em">sleep(1); //
implementation may use SIGALRM</p>

<p style="margin-left:9%;"><b>FunctionSet</b></p>

<p style="margin-left:18%;">Specifies which functions in
libc should be considered thread-safe, possible values are
<i>posix</i>, <i>glibc</i>, or <i>any</i>.</p>

<p style="margin-left:18%; margin-top: 1em"><i>posix</i>
means POSIX defined thread-unsafe functions. POSIX.1-2001 in
&quot;2.9.1 Thread-Safety&quot; defines that all functions
specified in the standard are thread-safe except a
predefined list of thread-unsafe functions.</p>

<p style="margin-left:18%; margin-top: 1em">Glibc defines
some of them as thread-safe (e.g. dirname(3)), but adds
non-POSIX thread-unsafe ones (e.g. getopt_long(3)). Glibc's
list is compiled from GNU web documentation with a search
for MT-Safe tag: -
<i>https://www.gnu.org/software/libc/manual/html_node/POSIX-Safety-Concepts.html</i></p>

<p style="margin-left:18%; margin-top: 1em">If you want to
identify thread-unsafe API for at least one libc or unsure
which libc will be used, use <i>any</i> (default).</p>

<h3>concurrency-thread-canceltype-asynchronous
<a name="concurrency-thread-canceltype-asynchronous"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
<b>pthread_setcanceltype</b> function calls where a thread's
cancellation type is set to asynchronous. Asynchronous
cancellation type (<b>PTHREAD_CANCEL_ASYNCHRONOUS</b>) is
generally unsafe, use type <b>PTHREAD_CANCEL_DEFERRED</b>
instead which is the default. Even with deferred
cancellation, a cancellation point in an asynchronous signal
handler may still be acted upon and the effect is as if it
was an asynchronous cancellation.</p>


<p style="margin-left:13%; margin-top: 1em">pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS,
&amp;oldtype);</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C Coding Standard rule <i>POS47-C.
Do not use threads that can be canceled
asynchronously</i>.</p>


<p style="margin-left:9%; margin-top: 1em"><i>cert-pos47-c</i>
redirects here as an alias of this check.</p>

<h3>cppcoreguidelines-avoid-c-arrays
<a name="cppcoreguidelines-avoid-c-arrays"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
cppcoreguidelines-avoid-c-arrays check is an alias, please
see <i>modernize-avoid-c-arrays</i> for more
information.</p>

<h3>cppcoreguidelines-avoid-capturing-lambda-coroutines
<a name="cppcoreguidelines-avoid-capturing-lambda-coroutines"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Flags C++20
coroutine lambdas with non-empty capture lists that may
cause use-after-free errors and suggests avoiding captures
or ensuring the lambda closure object has a guaranteed
lifetime.</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>CP.51</i> from the C++ Core Guidelines.</p>

<p style="margin-left:9%; margin-top: 1em">Using coroutine
lambdas with non-empty capture lists can be risky, as
capturing variables can lead to accessing freed memory after
the first suspension point. This issue can occur even with
refcounted smart pointers and copyable types. When a lambda
expression creates a coroutine, it results in a closure
object with storage, which is often on the stack and will
eventually go out of scope. When the closure object goes out
of scope, its captures also go out of scope. While normal
lambdas finish executing before this happens, coroutine
lambdas may resume from suspension after the closure object
has been destructed, resulting in use-after-free memory
access for all captures.</p>

<p style="margin-left:9%; margin-top: 1em">Consider the
following example:</p>

<p style="margin-left:13%; margin-top: 1em">int value =
get_value(); <br>
std::shared_ptr&lt;Foo&gt; sharedFoo = get_foo(); <br>
{ <br>
const auto lambda = [value, sharedFoo]() -&gt;
std::future&lt;void&gt; <br>
{ <br>
co_await something(); <br>
// &quot;sharedFoo&quot; and &quot;value&quot; have already
been destroyed <br>
// the &quot;shared&quot; pointer didn't accomplish anything
<br>
}; <br>
lambda(); <br>
} // the lambda closure object has now gone out of scope</p>

<p style="margin-left:9%; margin-top: 1em">In this example,
the lambda object is defined with two captures: value and
<b>sharedFoo</b>. When <b>lambda()</b> is called, the lambda
object is created on the stack, and the captures are copied
into the closure object. When the coroutine is suspended,
the lambda object goes out of scope, and the closure object
is destroyed. When the coroutine is resumed, the captured
variables may have been destroyed, resulting in
use-after-free bugs.</p>

<p style="margin-left:9%; margin-top: 1em">In conclusion,
the use of coroutine lambdas with non-empty capture lists
can lead to use-after-free errors when resuming the
coroutine after the closure object has been destroyed. This
check helps prevent such errors by flagging C++20 coroutine
lambdas with non-empty capture lists and suggesting avoiding
captures or ensuring the lambda closure object has a
guaranteed lifetime.</p>

<p style="margin-left:9%; margin-top: 1em">Following these
guidelines can help ensure the safe and reliable use of
coroutine lambdas in C++ code.</p>

<h3>cppcoreguidelines-avoid-const-or-ref-data-members
<a name="cppcoreguidelines-avoid-const-or-ref-data-members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check warns
when structs or classes that are copyable or movable, and
have const-qualified or reference (lvalue or rvalue) data
members. Having such members is rarely useful, and makes the
class only copy-constructible but not copy-assignable.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">// Bad,
const-qualified member <br>
struct Const { <br>
const int x; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// Good: <br>
class Foo { <br>
public: <br>
int get() const { return x; } <br>
private: <br>
int x; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">// Bad, lvalue
reference member <br>
struct Ref { <br>
int&amp; x; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">// Good: <br>
struct Foo { <br>
int* x; <br>
std::unique_ptr&lt;int&gt; x; <br>
std::shared_ptr&lt;int&gt; x; <br>
gsl::not_null&lt;int*&gt; x; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">// Bad, rvalue
reference member <br>
struct RefRef { <br>
int&amp;&amp; x; <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>C.12</i> from the C++ Core Guidelines.</p>

<p style="margin-left:9%; margin-top: 1em">Further reading:
<i>Data members: Never const</i>.</p>

<h3>cppcoreguidelines-avoid-do-while
<a name="cppcoreguidelines-avoid-do-while"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns when using
<b>do-while</b> loops. They are less readable than plain
<b>while</b> loops, since the termination condition is at
the end and the condition is not checked prior to the first
iteration. This can lead to subtle bugs.</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>ES.75</i> from the C++ Core Guidelines.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">int x; <br>
do { <br>
std::cin &gt;&gt; x; <br>
// ... <br>
} while (x &lt; 0);</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">Ignore the check when analyzing
macros. This is useful for safely defining function-like
macros:</p>

<p style="margin-left:22%; margin-top: 1em">#define
FOO_BAR(x) \ <br>
do { \ <br>
foo(x); \ <br>
bar(x); \ <br>
} while(0)</p>

<p style="margin-left:18%; margin-top: 1em">Defaults to
<i>false</i>.</p>

<h3>cppcoreguidelines-avoid-goto
<a name="cppcoreguidelines-avoid-goto"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The usage of
<b>goto</b> for control flow is error prone and should be
replaced with looping constructs. Only forward jumps in
nested loops are accepted.</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>ES.76</i> from the C++ Core Guidelines and
<i>6.3.1</i> from High Integrity C++ Coding Standard.</p>

<p style="margin-left:9%; margin-top: 1em">For more
information on why to avoid programming with <b>goto</b> you
can read the famous paper <i>A Case against the GO TO
Statement.</i>.</p>

<p style="margin-left:9%; margin-top: 1em">The check
diagnoses <b>goto</b> for backward jumps in every language
mode. These should be replaced with <i>C/C++</i> looping
constructs.</p>

<p style="margin-left:13%; margin-top: 1em">// Bad,
handwritten for loop. <br>
int i = 0; <br>
// Jump label for the loop <br>
loop_start: <br>
do_some_operation();</p>

<p style="margin-left:13%; margin-top: 1em">if (i &lt; 100)
{ <br>
++i; <br>
goto loop_start; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// Better <br>
for(int i = 0; i &lt; 100; ++i) <br>
do_some_operation();</p>

<p style="margin-left:9%; margin-top: 1em">Modern C++ needs
<b>goto</b> only to jump out of nested loops.</p>

<p style="margin-left:13%; margin-top: 1em">for(int i = 0;
i &lt; 100; ++i) { <br>
for(int j = 0; j &lt; 100; ++j) { <br>
if (i * j &gt; 500) <br>
goto early_exit; <br>
} <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">early_exit:
<br>
some_operation();</p>

<p style="margin-left:9%; margin-top: 1em">All other uses
of <b>goto</b> are diagnosed in <i>C++</i>.</p>

<h3>cppcoreguidelines-avoid-magic-numbers
<a name="cppcoreguidelines-avoid-magic-numbers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
cppcoreguidelines-avoid-magic-numbers check is an alias,
please see <i>readability-magic-numbers</i> for more
information.</p>

<h3>cppcoreguidelines-avoid-non-const-global-variables
<a name="cppcoreguidelines-avoid-non-const-global-variables"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds non-const
global variables as described in <i>I.2</i> of C++ Core
Guidelines. As <i>R.6</i> of C++ Core Guidelines is a
duplicate of rule <i>I.2</i> it also covers that rule.</p>

<p style="margin-left:13%; margin-top: 1em">char a; //
Warns! <br>
const char b = 0;</p>

<p style="margin-left:13%; margin-top: 1em">namespace
some_namespace <br>
{ <br>
char c; // Warns! <br>
const char d = 0; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">char * c_ptr1 =
&amp;some_namespace::c; // Warns! <br>
char *const c_const_ptr = &amp;some_namespace::c; // Warns!
<br>
char &amp; c_reference = some_namespace::c; // Warns!</p>

<p style="margin-left:13%; margin-top: 1em">class Foo // No
Warnings inside Foo, only namespace scope is covered <br>
{ <br>
public: <br>
char e = 0; <br>
const char f = 0; <br>
protected: <br>
char g = 0; <br>
private: <br>
char h = 0; <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">The variables
<b>a</b>, <b>c</b>, <b>c_ptr1</b>, <b>c_const_ptr</b> and
<b>c_reference</b> will all generate warnings since they are
either a non-const globally accessible variable, a pointer
or a reference providing global access to non-const data or
both.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>AllowInternalLinkage</b></p>

<p style="margin-left:18%;">When set to <i>true</i>, static
non-const variables and variables in anonymous namespaces
will not generate a warning. The default value is
<i>false</i>.</p>

<h3>cppcoreguidelines-avoid-reference-coroutine-parameters
<a name="cppcoreguidelines-avoid-reference-coroutine-parameters"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns when a
coroutine accepts reference parameters. After a coroutine
suspend point, references could be dangling and no longer
valid. Instead, pass parameters as values.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>


<p style="margin-left:13%; margin-top: 1em">std::future&lt;int&gt;
someCoroutine(int&amp; val) { <br>
co_await ...; <br>
// When the coroutine is resumed, 'val' might no longer be
valid. <br>
if (val) ... <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>CP.53</i> from the C++ Core Guidelines.</p>

<h3>cppcoreguidelines-c-copy-assignment-signature
<a name="cppcoreguidelines-c-copy-assignment-signature"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cppcoreguidelines-c-copy-assignment-signature</i> check
is an alias, please see
<i>misc-unconventional-assign-operator</i> for more
information.</p>

<h3>cppcoreguidelines-explicit-virtual-functions
<a name="cppcoreguidelines-explicit-virtual-functions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>cppcoreguidelines-explicit-virtual-functions</i> check is
an alias, please see <i>modernize-use-override</i> for more
information.</p>

<h3>cppcoreguidelines-init-variables
<a name="cppcoreguidelines-init-variables"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks whether
there are local variables that are declared without an
initial value. These may lead to unexpected behavior if
there is a code path that reads the variable before
assigning to it.</p>

<p style="margin-left:9%; margin-top: 1em">This rule is
part of the <i>Type safety (Type.5)</i> profile and
<i>ES.20</i> from the C++ Core Guidelines.</p>

<p style="margin-left:9%; margin-top: 1em">Only integers,
booleans, floats, doubles and pointers are checked. The fix
option initializes all detected values with the value of
zero. An exception is float and double types, which are
initialized to NaN.</p>

<p style="margin-left:9%; margin-top: 1em">As an example a
function that looks like this:</p>

<p style="margin-left:13%; margin-top: 1em">void function()
{ <br>
int x; <br>
char *txt; <br>
double d;</p>

<p style="margin-left:13%; margin-top: 1em">// Rest of the
function. <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Would be
rewritten to look like this:</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;math.h&gt;</p>

<p style="margin-left:13%; margin-top: 1em">void function()
{ <br>
int x = 0; <br>
char *txt = nullptr; <br>
double d = NAN;</p>

<p style="margin-left:13%; margin-top: 1em">// Rest of the
function. <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">It warns for the
uninitialized enum case, but without a FixIt:</p>

<p style="margin-left:13%; margin-top: 1em">enum A {A1, A2,
A3}; <br>
enum A_c : char { A_c1, A_c2, A_c3 }; <br>
enum class B { B1, B2, B3 }; <br>
enum class B_i : int { B_i1, B_i2, B_i3 }; <br>
void function() { <br>
A a; // Warning: variable 'a' is not initialized <br>
A_c a_c; // Warning: variable 'a_c' is not initialized <br>
B b; // Warning: variable 'b' is not initialized <br>
B_i b_i; // Warning: variable 'b_i' is not initialized <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IncludeStyle</b></p>

<p style="margin-left:18%;">A string specifying which
include-style is used, <i>llvm</i> or <i>google</i>. Default
is <i>llvm</i>.</p>

<p style="margin-left:9%;"><b>MathHeader</b></p>

<p style="margin-left:18%;">A string specifying the header
to include to get the definition of <i>NAN</i>. Default is
<i>&lt;math.h&gt;</i>.</p>

<h3>cppcoreguidelines-interfaces-global-init
<a name="cppcoreguidelines-interfaces-global-init"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
initializers of globals that access extern objects, and
therefore can lead to order-of-initialization problems.</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>I.22</i> from the C++ Core Guidelines.</p>

<p style="margin-left:9%; margin-top: 1em">Note that
currently this does not flag calls to non-constexpr
functions, and therefore globals could still be accessed
from functions themselves.</p>

<h3>cppcoreguidelines-macro-to-enum
<a name="cppcoreguidelines-macro-to-enum"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
cppcoreguidelines-macro-to-enum check is an alias, please
see <i>modernize-macro-to-enum</i> for more information.</p>

<h3>cppcoreguidelines-macro-usage
<a name="cppcoreguidelines-macro-usage"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds macro
usage that is considered problematic because better language
constructs exist for the task.</p>

<p style="margin-left:9%; margin-top: 1em">The relevant
sections in the C++ Core Guidelines are <i>ES.31</i>, and
<i>ES.32</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">#define C 0
<br>
#define F1(x, y) ((a) &gt; (b) ? (a) : (b)) <br>
#define F2(...) (__VA_ARGS__) <br>
#define F3(x, y) x##y <br>
#define COMMA , <br>
#define NORETURN [[noreturn]] <br>
#define DEPRECATED attribute((deprecated)) <br>
#if LIB_EXPORTS <br>
#define DLLEXPORTS __declspec(dllexport) <br>
#else <br>
#define DLLEXPORTS __declspec(dllimport) <br>
#endif</p>

<p style="margin-left:9%; margin-top: 1em">results in the
following warnings:</p>

<p style="margin-left:13%; margin-top: 1em">4 warnings
generated. <br>
test.cpp:1:9: warning: macro 'C' used to declare a constant;
consider using a 'constexpr' constant
[cppcoreguidelines-macro-usage] <br>
#define C 0 <br>
&#710; <br>
test.cpp:2:9: warning: function-like macro 'F1' used;
consider a 'constexpr' template function
[cppcoreguidelines-macro-usage] <br>
#define F1(x, y) ((a) &gt; (b) ? (a) : (b)) <br>
&#710; <br>
test.cpp:3:9: warning: variadic macro 'F2' used; consider
using a 'constexpr' variadic template function
[cppcoreguidelines-macro-usage] <br>
#define F2(...) (__VA_ARGS__) <br>
&#710;</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>AllowedRegexp</b></p>

<p style="margin-left:18%;">A regular expression to filter
allowed macros. For example
<i>DEBUG*|LIBTORRENT*|TORRENT*|UNI*</i> could be applied to
filter <i>libtorrent</i>. Default value is
<i>&#710;DEBUG_*</i>.</p>

<p style="margin-left:9%;"><b>CheckCapsOnly</b></p>

<p style="margin-left:18%;">Boolean flag to warn on all
macros except those with CAPS_ONLY names. This option is
intended to ease introduction of this check into older code
bases. Default value is <i>false</i>.</p>


<p style="margin-left:9%;"><b>IgnoreCommandLineMacros</b></p>

<p style="margin-left:18%;">Boolean flag to toggle ignoring
command-line-defined macros. Default value is
<i>true</i>.</p>

<h3>cppcoreguidelines-misleading-capture-default-by-value
<a name="cppcoreguidelines-misleading-capture-default-by-value"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns when
lambda specify a by-value capture default and capture
<b>this</b>.</p>

<p style="margin-left:9%; margin-top: 1em">By-value capture
defaults in member functions can be misleading about whether
data members are captured by value or reference. This occurs
because specifying the capture default <b>[=]</b> actually
captures the <b>this</b> pointer by value, not the data
members themselves. As a result, data members are still
indirectly accessed via the captured <b>this</b> pointer,
which essentially means they are being accessed by
reference. Therefore, even when using <b>[=]</b>, data
members are effectively captured by reference, which might
not align with the user's expectations.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">struct AClass {
<br>
int member; <br>
void misleadingLogic() { <br>
int local = 0; <br>
member = 0; <br>
auto f = [=]() mutable { <br>
local += 1; <br>
member += 1; <br>
}; <br>
f(); <br>
// Here, local is 0 but member is 1 <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
clearLogic() { <br>
int local = 0; <br>
member = 0; <br>
auto f = [this, local]() mutable { <br>
local += 1; <br>
member += 1; <br>
}; <br>
f(); <br>
// Here, local is 0 but member is 1 <br>
} <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>F.54</i> from the C++ Core Guidelines.</p>

<h3>cppcoreguidelines-missing-std-forward
<a name="cppcoreguidelines-missing-std-forward"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns when a
forwarding reference parameter is not forwarded inside the
function body.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;class T&gt; <br>
void wrapper(T&amp;&amp; t) { <br>
impl(std::forward&lt;T&gt;(t), 1, 2); // Correct <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;class T&gt; <br>
void wrapper2(T&amp;&amp; t) { <br>
impl(t, 1, 2); // Oops - should use std::forward&lt;T&gt;(t)
<br>
}</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;class T&gt; <br>
void wrapper3(T&amp;&amp; t) { <br>
impl(std::move(t), 1, 2); // Also buggy - should use
std::forward&lt;T&gt;(t) <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;class F&gt; <br>
void wrapper_function(F&amp;&amp; f) { <br>
std::forward&lt;F&gt;(f)(1, 2); // Correct <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;class F&gt; <br>
void wrapper_function2(F&amp;&amp; f) { <br>
f(1, 2); // Incorrect - may not invoke the desired qualified
function operator <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>F.19</i> from the C++ Core Guidelines.</p>

<h3>cppcoreguidelines-narrowing-conversions
<a name="cppcoreguidelines-narrowing-conversions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for
silent narrowing conversions, e.g: <b>int i = 0; i +=
0.1;</b>. While the issue is obvious in this former example,
it might not be so in the following: <b>void
MyClass::f(double d) { int_member_ += d; }</b>.</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>ES.46</i> from the C++ Core Guidelines.
<b><br>
We enforce only part of the guideline, more specifically, we
flag <br>
narrowing conversions from:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>an integer to a narrower integer (e.g. <b>char</b> to
<b>unsigned char</b>) if WarnOnIntegerNarrowingConversion
Option is set,</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>an integer to a narrower floating-point (e.g.
<b>uint64_t</b> to <b>float</b>) if
WarnOnIntegerToFloatingPointNarrowingConversion Option is
set,</p> </td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>a floating-point to an integer (e.g. <b>double</b> to
<b>int</b>),</p> </td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>a floating-point to a narrower floating-point (e.g.
<b>double</b> to <b>float</b>) if
WarnOnFloatingPointNarrowingConversion Option is set.</p></td></tr>
</table>

<p style="margin-left:9%;"><b>This check will flag:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>All narrowing conversions that are not marked by an
explicit cast (c-style or <b>static_cast</b>). For example:
<b>int i = 0; i += 0.1;</b>, <b>void f(int);
f(0.1);</b>,</p> </td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>All applications of binary operators with a narrowing
conversions. For example: <b>int i; i+= 0.1;</b>.</p></td></tr>
</table>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>WarnOnIntegerNarrowingConversion</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will warn on narrowing integer conversion (e.g. <b>int</b>
to <b>size_t</b>). <i>true</i> by default.</p>


<p style="margin-left:9%;"><b>WarnOnIntegerToFloatingPointNarrowingConversion</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will warn on narrowing integer to floating-point conversion
(e.g. <b>size_t</b> to <b>double</b>). <i>true</i> by
default.</p>


<p style="margin-left:9%;"><b>WarnOnFloatingPointNarrowingConversion</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will warn on narrowing floating point conversion (e.g.
<b>double</b> to <b>float</b>). <i>true</i> by default.</p>


<p style="margin-left:9%;"><b>WarnWithinTemplateInstantiation</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will warn on narrowing conversions within template
instantiations. <i>false</i> by default.</p>


<p style="margin-left:9%;"><b>WarnOnEquivalentBitWidth</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will warn on narrowing conversions that arise from casting
between types of equivalent bit width. (e.g. <i>int n =
uint(0);</i> or <i>long long n = double(0);</i>) <i>true</i>
by default.</p>


<p style="margin-left:9%;"><b>IgnoreConversionFromTypes</b></p>

<p style="margin-left:18%;">Narrowing conversions from any
type in this semicolon-separated list will be ignored. This
may be useful to weed out commonly occurring, but less
commonly problematic assignments such as <i>int n =
std::vector&lt;char&gt;().size();</i> or <i>int n =
std::difference(it1, it2);</i>. The default list is empty,
but one suggested list for a legacy codebase would be
<i>size_t;ptrdiff_t;size_type;difference_type</i>.</p>

<p style="margin-left:9%;"><b>PedanticMode</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will warn on assigning a floating point constant to an
integer value even if the floating point value is exactly
representable in the destination type (e.g. <b>int i =
1.0;</b>). <i>false</i> by default.</p>

<h3>FAQ
<a name="FAQ"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="77%">


<p style="margin-top: 1em">What does &quot;narrowing
conversion from 'int' to 'float'&quot; mean?</p></td>
<td width="8%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">An IEEE754
Floating Point number can represent all integer values in
the range [-2&#710;PrecisionBits, 2&#710;PrecisionBits]
where PrecisionBits is the number of bits in the
mantissa.</p>

<p style="margin-left:9%; margin-top: 1em">For <b>float</b>
this would be [-2&#710;23, 2&#710;23], where <b>int</b> can
represent values in the range [-2&#710;31, 2&#710;31-1].</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="52%">


<p style="margin-top: 1em">What does
&quot;implementation-defined&quot; mean?</p></td>
<td width="33%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">You may have
encountered messages like &quot;narrowing conversion from
'unsigned int' to signed type 'int' is
implementation-defined&quot;. The C/C++ standard does not
mandate two's complement for signed integers, and so the
compiler is free to define what the semantics are for
converting an unsigned integer to signed integer. Clang's
implementation uses the two's complement format.</p>

<h3>cppcoreguidelines-no-malloc
<a name="cppcoreguidelines-no-malloc"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
handles C-Style memory management using <b>malloc()</b>,
<b>realloc()</b>, <b>calloc()</b> and <b>free()</b>. It
warns about its use and tries to suggest the use of an
appropriate RAII object. Furthermore, it can be configured
to check against a user-specified list of functions that are
used for memory management (e.g.
<b>posix_memalign()</b>).</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>R.10</i> from the C++ Core Guidelines.</p>

<p style="margin-left:9%; margin-top: 1em">There is no
attempt made to provide fix-it hints, since manual resource
management isn't easily transformed automatically into
RAII.</p>

<p style="margin-left:13%; margin-top: 1em">// Warns each
of the following lines. <br>
// Containers like std::vector or std::string should be
used. <br>
char* some_string = (char*) malloc(sizeof(char) * 20); <br>
char* some_string = (char*) realloc(sizeof(char) * 30); <br>
free(some_string);</p>

<p style="margin-left:13%; margin-top: 1em">int* int_array
= (int*) calloc(30, sizeof(int));</p>

<p style="margin-left:13%; margin-top: 1em">// Rather use a
smartpointer or stack variable. <br>
struct some_struct* s = (struct some_struct*)
malloc(sizeof(struct some_struct));</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>Allocations</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
fully qualified names of memory allocation functions.
Defaults to <b>::malloc;::calloc</b>.</p>

<p style="margin-left:9%;"><b>Deallocations</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
fully qualified names of memory allocation functions.
Defaults to <b>::free</b>.</p>

<p style="margin-left:9%;"><b>Reallocations</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
fully qualified names of memory allocation functions.
Defaults to <b>::realloc</b>.</p>

<h3>cppcoreguidelines-no-suspend-with-lock
<a name="cppcoreguidelines-no-suspend-with-lock"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Flags coroutines
that suspend while a lock guard is in scope at the
suspension point.</p>

<p style="margin-left:9%; margin-top: 1em">When a coroutine
suspends, any mutexes held by the coroutine will remain
locked until the coroutine resumes and eventually destructs
the lock guard. This can lead to long periods with a mutex
held and runs the risk of deadlock.</p>

<p style="margin-left:9%; margin-top: 1em">Instead, locks
should be released before suspending a coroutine.</p>

<p style="margin-left:9%; margin-top: 1em">This check only
checks suspending coroutines while a lock_guard is in scope;
it does not consider manual locking or unlocking of mutexes,
e.g., through calls to <b>std::mutex::lock()</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">future
bad_coro() { <br>
std::lock_guard lock{mtx}; <br>
++some_counter; <br>
co_await something(); // Suspending while holding a mutex
<br>
}</p>

<p style="margin-left:13%; margin-top: 1em">future
good_coro() { <br>
{ <br>
std::lock_guard lock{mtx}; <br>
++some_counter; <br>
} <br>
// Destroy the lock_guard to release the mutex before
suspending the coroutine <br>
co_await something(); // Suspending while holding a mutex
<br>
}</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>CP.52</i> from the C++ Core Guidelines.</p>

<h3>cppcoreguidelines-noexcept-destructor
<a name="cppcoreguidelines-noexcept-destructor"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
implements <i>C.37</i> from the C++ Core Guidelines.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>cppcoreguidelines-noexcept-destructor</i> check is an
alias, please see <i>performance-noexcept-destructor</i> for
more information.</p>

<h3>cppcoreguidelines-noexcept-move-operations
<a name="cppcoreguidelines-noexcept-move-operations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
implements <i>C.66</i> from the C++ Core Guidelines.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>cppcoreguidelines-noexcept-move-operations</i> check is
an alias, please see
<i>performance-noexcept-move-constructor</i> for more
information.</p>

<h3>cppcoreguidelines-noexcept-swap
<a name="cppcoreguidelines-noexcept-swap"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
implements <i>C.83</i> , <i>C.84</i> and <i>C.85</i> from
the C++ Core Guidelines.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>cppcoreguidelines-noexcept-swap check</i> is an alias,
please see <i>performance-noexcept-swap</i> for more
information.</p>

<h3>cppcoreguidelines-non-private-member-variables-in-classes
<a name="cppcoreguidelines-non-private-member-variables-in-classes"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
cppcoreguidelines-non-private-member-variables-in-classes
check is an alias, please see
<i>misc-non-private-member-variables-in-classes</i> for more
information.</p>

<h3>cppcoreguidelines-owning-memory
<a name="cppcoreguidelines-owning-memory"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
implements the type-based semantics of
<b>gsl::owner&lt;T*&gt;</b>, which allows static analysis on
code, that uses raw pointers to handle resources like
dynamic memory, but won't introduce RAII concepts.</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>I.11</i>, <i>C.33</i>, <i>R.3</i> and
<i>GSL.Views</i> from the C++ Core Guidelines. The
definition of a <b>gsl::owner&lt;T*&gt;</b> is straight
forward</p>

<p style="margin-left:13%; margin-top: 1em">namespace gsl {
template &lt;typename T&gt; owner = T; }</p>

<p style="margin-left:9%; margin-top: 1em">It is therefore
simple to introduce the owner even without using an
implementation of the <i>Guideline Support Library</i>.</p>

<p style="margin-left:9%; margin-top: 1em">All checks are
purely type based and not (yet) flow sensitive.</p>

<p style="margin-left:9%; margin-top: 1em">The following
examples will demonstrate the correct and incorrect
initializations of owners, assignment is handled the same
way. Note that both <b>new</b> and <b>malloc()</b>-like
resource functions are considered to produce resources.</p>

<p style="margin-left:13%; margin-top: 1em">// Creating an
owner with factory functions is checked. <br>
gsl::owner&lt;int*&gt; function_that_returns_owner() {
return gsl::owner&lt;int*&gt;(new int(42)); }</p>

<p style="margin-left:13%; margin-top: 1em">// Dynamic
memory must be assigned to an owner <br>
int* Something = new int(42); // BAD, will be caught <br>
gsl::owner&lt;int*&gt; Owner = new int(42); // Good <br>
gsl::owner&lt;int*&gt; Owner = new int[42]; // Good as
well</p>

<p style="margin-left:13%; margin-top: 1em">// Returned
owner must be assigned to an owner <br>
int* Something = function_that_returns_owner(); // Bad,
factory function <br>
gsl::owner&lt;int*&gt; Owner =
function_that_returns_owner(); // Good, result lands in
owner</p>

<p style="margin-left:13%; margin-top: 1em">// Something
not a resource or owner should not be assigned to owners
<br>
int Stack = 42; <br>
gsl::owner&lt;int*&gt; Owned = &amp;Stack; // Bad, not a
resource assigned</p>

<p style="margin-left:9%; margin-top: 1em">In the case of
dynamic memory as resource, only <b>gsl::owner&lt;T*&gt;</b>
variables are allowed to be deleted.</p>

<p style="margin-left:13%; margin-top: 1em">// Example Bad,
non-owner as resource handle, will be caught. <br>
int* NonOwner = new int(42); // First warning here, since
new must land in an owner <br>
delete NonOwner; // Second warning here, since only owners
are allowed to be deleted</p>

<p style="margin-left:13%; margin-top: 1em">// Example
Good, Ownership correctly stated <br>
gsl::owner&lt;int*&gt; Owner = new int(42); // Good <br>
delete Owner; // Good as well, statically enforced, that
only owners get deleted</p>

<p style="margin-left:9%; margin-top: 1em">The check will
furthermore ensure, that functions, that expect a
<b>gsl::owner&lt;T*&gt;</b> as argument get called with
either a <b>gsl::owner&lt;T*&gt;</b> or a newly created
resource.</p>

<p style="margin-left:13%; margin-top: 1em">void
expects_owner(gsl::owner&lt;int*&gt; o) { delete o; }</p>

<p style="margin-left:13%; margin-top: 1em">// Bad Code
<br>
int NonOwner = 42; <br>
expects_owner(&amp;NonOwner); // Bad, will get caught</p>

<p style="margin-left:13%; margin-top: 1em">// Good Code
<br>
gsl::owner&lt;int*&gt; Owner = new int(42); <br>
expects_owner(Owner); // Good <br>
expects_owner(new int(42)); // Good as well, recognized
created resource</p>

<p style="margin-left:13%; margin-top: 1em">// Port legacy
code for better resource-safety <br>
gsl::owner&lt;FILE*&gt; File =
fopen(&quot;my_file.txt&quot;, &quot;rw+&quot;); <br>
FILE* BadFile = fopen(&quot;another_file.txt&quot;,
&quot;w&quot;); // Bad, warned</p>

<p style="margin-left:13%; margin-top: 1em">// ... use the
file</p>

<p style="margin-left:13%; margin-top: 1em">fclose(File);
// Ok, File is annotated as 'owner&lt;&gt;' <br>
fclose(BadFile); // BadFile is not an 'owner&lt;&gt;', will
be warned</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>LegacyResourceProducers</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
fully qualified names of legacy functions that create
resources but cannot introduce <b>gsl::owner&lt;&gt;</b>.
Defaults to
<b>::malloc;::aligned_alloc;::realloc;::calloc;::fopen;::freopen;::tmpfile</b>.</p>


<p style="margin-left:9%;"><b>LegacyResourceConsumers</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
fully qualified names of legacy functions expecting resource
owners as pointer arguments but cannot introduce
<b>gsl::owner&lt;&gt;</b>. Defaults to
<b>::free;::realloc;::freopen;::fclose</b>.</p>

<h3>Limitations
<a name="Limitations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Using
<b>gsl::owner&lt;T*&gt;</b> in a typedef or alias is not
handled correctly.</p>

<p style="margin-left:13%; margin-top: 1em">using heap_int
= gsl::owner&lt;int*&gt;; <br>
heap_int allocated = new int(42); // False positive!</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>gsl::owner&lt;T*&gt;</b> is declared as a templated type
alias. In template functions and classes, like in the
example below, the information of the type aliases gets
lost. Therefore using <b>gsl::owner&lt;T*&gt;</b> in a heavy
templated code base might lead to false positives.</p>

<p style="margin-left:9%; margin-top: 1em">Known code
constructs that do not get diagnosed correctly are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="34%">


<p><b>std::exchange</b></p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="34%">


<p><b>std::vector&lt;gsl::owner&lt;T*&gt;&gt;</b></p></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:13%; margin-top: 1em">// This
template function works as expected. Type information
doesn't get lost. <br>
template &lt;typename T&gt; <br>
void delete_owner(gsl::owner&lt;T*&gt; owned_object) { <br>
delete owned_object; // Everything alright <br>
}</p>


<p style="margin-left:13%; margin-top: 1em">gsl::owner&lt;int*&gt;
function_that_returns_owner() { return
gsl::owner&lt;int*&gt;(new int(42)); }</p>

<p style="margin-left:13%; margin-top: 1em">// Type
deduction does not work for auto variables. <br>
// This is caught by the check and will be noted
accordingly. <br>
auto OwnedObject = function_that_returns_owner(); // Type of
OwnedObject will be int*</p>

<p style="margin-left:13%; margin-top: 1em">// Problematic
function template that looses the typeinformation on owner
<br>
template &lt;typename T&gt; <br>
void bad_template_function(T some_object) { <br>
// This line will trigger the warning, that a non-owner is
assigned to an owner <br>
gsl::owner&lt;T*&gt; new_owner = some_object; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// Calling the
function with an owner still yields a false positive. <br>
bad_template_function(gsl::owner&lt;int*&gt;(new
int(42)));</p>

<p style="margin-left:13%; margin-top: 1em">// The same
issue occurs with templated classes like the following. <br>
template &lt;typename T&gt; <br>
class OwnedValue { <br>
public: <br>
const T getValue() const { return _val; } <br>
private: <br>
T _val; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">// Code, that
yields a false positive. <br>
OwnedValue&lt;gsl::owner&lt;int*&gt;&gt; Owner(new int(42));
// Type deduction yield T -&gt; int * <br>
// False positive, getValue returns int* and not
gsl::owner&lt;int*&gt; <br>
gsl::owner&lt;int*&gt; OwnedInt = Owner.getValue();</p>

<p style="margin-left:9%; margin-top: 1em">Another
limitation of the current implementation is only the type
based checking. Suppose you have code like the
following:</p>

<p style="margin-left:13%; margin-top: 1em">// Two owners
with assigned resources <br>
gsl::owner&lt;int*&gt; Owner1 = new int(42); <br>
gsl::owner&lt;int*&gt; Owner2 = new int(42);</p>

<p style="margin-left:13%; margin-top: 1em">Owner2 =
Owner1; // Conceptual Leak of initial resource of Owner2!
<br>
Owner1 = nullptr;</p>

<p style="margin-left:9%; margin-top: 1em">The semantic of
a <b>gsl::owner&lt;T*&gt;</b> is mostly like a
<b>std::unique_ptr&lt;T&gt;</b>, therefore assignment of two
<b>gsl::owner&lt;T*&gt;</b> is considered a move, which
requires that the resource <b>Owner2</b> must have been
released before the assignment. This kind of condition could
be caught in later improvements of this check with
flowsensitive analysis. Currently, the <i>Clang Static
Analyzer</i> catches this bug for dynamic memory, but not
for general types of resources.</p>

<h3>cppcoreguidelines-prefer-member-initializer
<a name="cppcoreguidelines-prefer-member-initializer"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds member
initializations in the constructor body which can be
converted into member initializers of the constructor
instead. This not only improves the readability of the code
but also positively affects its performance. Class-member
assignments inside a control statement or following the
first control statement are ignored.</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>C.49</i> from the C++ Core Guidelines.</p>

<p style="margin-left:9%; margin-top: 1em">Please note,
that this check does not enforce rule <i>C.48</i> from the
C++ Core Guidelines. For that purpose see check
<i>modernize-use-default-member-init</i>.</p>

<h3>Example 1
<a name="Example 1"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">class C { <br>
int n; <br>
int m; <br>
public: <br>
C() { <br>
n = 1; // Literal in default constructor <br>
if (dice()) <br>
return; <br>
m = 1; <br>
} <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">Here <b>n</b>
can be initialized in the constructor initializer list,
unlike <b>m</b>, as <b>m</b>'s initialization follows a
control statement (<b>if</b>):</p>

<p style="margin-left:13%; margin-top: 1em">class C { <br>
int n; <br>
int m; <br>
public: <br>
C(): n(1) { <br>
if (dice()) <br>
return; <br>
m = 1; <br>
} <br>
};</p>

<h3>Example 2
<a name="Example 2"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">class C { <br>
int n; <br>
int m; <br>
public: <br>
C(int nn, int mm) { <br>
n = nn; // Neither default constructor nor literal <br>
if (dice()) <br>
return; <br>
m = mm; <br>
} <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">Here <b>n</b>
can be initialized in the constructor initializer list,
unlike <b>m</b>, as <b>m</b>'s initialization follows a
control statement (<b>if</b>):</p>

<p style="margin-left:13%; margin-top: 1em">C(int nn, int
mm) : n(nn) { <br>
if (dice()) <br>
return; <br>
m = mm; <br>
}</p>

<h3>cppcoreguidelines-pro-bounds-array-to-pointer-decay
<a name="cppcoreguidelines-pro-bounds-array-to-pointer-decay"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
all array to pointer decays.</p>

<p style="margin-left:9%; margin-top: 1em">Pointers should
not be used as arrays. <b>span&lt;T&gt;</b> is a
bounds-checked, safe alternative to using pointers to access
arrays.</p>

<p style="margin-left:9%; margin-top: 1em">This rule is
part of the <i>Bounds safety (Bounds 3)</i> profile from the
C++ Core Guidelines.</p>

<h3>cppcoreguidelines-pro-bounds-constant-array-index
<a name="cppcoreguidelines-pro-bounds-constant-array-index"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
all array subscript expressions on static arrays and
<b>std::arrays</b> that either do not have a constant
integer expression index or are out of bounds (for
<b>std::array</b>). For out-of-bounds checking of static
arrays, see the <i>-Warray-bounds</i> Clang diagnostic.</p>

<p style="margin-left:9%; margin-top: 1em">This rule is
part of the <i>Bounds safety (Bounds 2)</i> profile from the
C++ Core Guidelines.</p>

<p style="margin-left:9%; margin-top: 1em">Optionally, this
check can generate fixes using <b>gsl::at</b> for
indexing.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>GslHeader</b></p>

<p style="margin-left:18%;">The check can generate fixes
after this option has been set to the name of the include
file that contains <b>gsl::at()</b>, e.g.
<i>&quot;gsl/gsl.h&quot;</i>.</p>

<p style="margin-left:9%;"><b>IncludeStyle</b></p>

<p style="margin-left:18%;">A string specifying which
include-style is used, <i>llvm</i> or <i>google</i>. Default
is <i>llvm</i>.</p>

<h3>cppcoreguidelines-pro-bounds-pointer-arithmetic
<a name="cppcoreguidelines-pro-bounds-pointer-arithmetic"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
all usage of pointer arithmetic, because it could lead to an
invalid pointer. Subtraction of two pointers is not flagged
by this check.</p>

<p style="margin-left:9%; margin-top: 1em">Pointers should
only refer to single objects, and pointer arithmetic is
fragile and easy to get wrong. <b>span&lt;T&gt;</b> is a
bounds-checked, safe type for accessing arrays of data.</p>

<p style="margin-left:9%; margin-top: 1em">This rule is
part of the <i>Bounds safety (Bounds 1)</i> profile from the
C++ Core Guidelines.</p>

<h3>cppcoreguidelines-pro-type-const-cast
<a name="cppcoreguidelines-pro-type-const-cast"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Imposes
limitations on the use of <b>const_cast</b> within C++ code.
It depends on the <i>StrictMode</i> option setting to
determine whether it should flag all instances of
<b>const_cast</b> or only those that remove either
<b>const</b> or <b>volatile</b> qualifier.</p>

<p style="margin-left:9%; margin-top: 1em">Modifying a
variable that has been declared as <b>const</b> in C++ is
generally considered undefined behavior, and this remains
true even when using <b>const_cast</b>. In C++, the
<b>const</b> qualifier indicates that a variable is intended
to be read-only, and the compiler enforces this by
disallowing any attempts to change the value of that
variable.</p>

<p style="margin-left:9%; margin-top: 1em">Removing the
<b>volatile</b> qualifier in C++ can have serious
consequences. This qualifier indicates that a variable's
value can change unpredictably, and removing it may lead to
undefined behavior, optimization problems, and debugging
challenges. It's essential to retain the <b>volatile</b>
qualifier in situations where the variable's volatility is a
crucial aspect of program correctness and reliability.</p>

<p style="margin-left:9%; margin-top: 1em">This rule is
part of the <i>Type safety (Type 3)</i> profile and
<i>ES.50: Don&rsquo;t cast away const</i> rule from the C++
Core Guidelines.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>StrictMode</b></p>

<p style="margin-left:18%;">When this setting is set to
<i>true</i>, it means that any usage of <b>const_cast</b> is
not allowed. On the other hand, when it's set to
<i>false</i>, it permits casting to <b>const</b> or
<b>volatile</b> types. Default value is <i>false</i>.</p>

<h3>cppcoreguidelines-pro-type-cstyle-cast
<a name="cppcoreguidelines-pro-type-cstyle-cast"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
all use of C-style casts that perform a <b>static_cast</b>
downcast, <b>const_cast</b>, or <b>reinterpret_cast</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Use of these
casts can violate type safety and cause the program to
access a variable that is actually of type X to be accessed
as if it were of an unrelated type Z. Note that a C-style
<b>(T)expression</b> cast means to perform the first of the
following that is possible: a <b>const_cast</b>, a
<b>static_cast</b>, a <b>static_cast</b> followed by a
<b>const_cast</b>, a <b>reinterpret_cast</b>, or a
<b>reinterpret_cast</b> followed by a <b>const_cast</b>.
This rule bans <b>(T)expression</b> only when used to
perform an unsafe cast.</p>

<p style="margin-left:9%; margin-top: 1em">This rule is
part of the <i>Type safety (Type.4)</i> profile from the C++
Core Guidelines.</p>

<h3>cppcoreguidelines-pro-type-member-init
<a name="cppcoreguidelines-pro-type-member-init"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check flags
user-provided constructor definitions that do not initialize
all fields that would be left in an undefined state by
default construction, e.g. builtins, pointers and record
types without user-provided default constructors containing
at least one such type. If these fields aren't initialized,
the constructor will leave some of the memory in an
undefined state.</p>

<p style="margin-left:9%; margin-top: 1em">For C++11 it
suggests fixes to add in-class field initializers. For older
versions it inserts the field initializers into the
constructor initializer list. It will also initialize any
direct base classes that need to be zeroed in the
constructor initializer list.</p>

<p style="margin-left:9%; margin-top: 1em">The check takes
assignment of fields in the constructor body into account
but generates false positives for fields initialized in
methods invoked in the constructor body.</p>

<p style="margin-left:9%; margin-top: 1em">The check also
flags variables with automatic storage duration that have
record types without a user-provided constructor and are not
initialized. The suggested fix is to zero initialize the
variable via <b>{}</b> for C++11 and beyond or <b>= {}</b>
for older language versions.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreArrays</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, the
check will not warn about array members that are not
zero-initialized during construction. For performance
critical code, it may be important to not initialize
fixed-size array members. Default is <i>false</i>.</p>

<p style="margin-left:9%;"><b>UseAssignment</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, the
check will provide fix-its with literal initializers (
<b>int i = 0;</b> ) instead of curly braces ( <b>int
i{};</b> ).</p>

<p style="margin-left:9%; margin-top: 1em">This rule is
part of the <i>Type safety (Type.6)</i> profile from the C++
Core Guidelines.</p>

<h3>cppcoreguidelines-pro-type-reinterpret-cast
<a name="cppcoreguidelines-pro-type-reinterpret-cast"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
all uses of <b>reinterpret_cast</b> in C++ code.</p>

<p style="margin-left:9%; margin-top: 1em">Use of these
casts can violate type safety and cause the program to
access a variable that is actually of type <b>X</b> to be
accessed as if it were of an unrelated type <b>Z</b>.</p>

<p style="margin-left:9%; margin-top: 1em">This rule is
part of the <i>Type safety (Type.1.1)</i> profile from the
C++ Core Guidelines.</p>

<h3>cppcoreguidelines-pro-type-static-cast-downcast
<a name="cppcoreguidelines-pro-type-static-cast-downcast"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
all usages of <b>static_cast</b>, where a base class is
casted to a derived class. In those cases, a fix-it is
provided to convert the cast to a <b>dynamic_cast</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Use of these
casts can violate type safety and cause the program to
access a variable that is actually of type <b>X</b> to be
accessed as if it were of an unrelated type <b>Z</b>.</p>

<p style="margin-left:9%; margin-top: 1em">This rule is
part of the <i>Type safety (Type.2)</i> profile from the C++
Core Guidelines.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>StrictMode</b></p>

<p style="margin-left:18%;">When set to <i>false</i>, no
warnings are emitted for casts on non-polymorphic types.
Default is <i>true</i>.</p>

<h3>cppcoreguidelines-pro-type-union-access
<a name="cppcoreguidelines-pro-type-union-access"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
all access to members of unions. Passing unions as a whole
is not flagged.</p>

<p style="margin-left:9%; margin-top: 1em">Reading from a
union member assumes that member was the last one written,
and writing to a union member assumes another member with a
nontrivial destructor had its destructor called. This is
fragile because it cannot generally be enforced to be safe
in the language and so relies on programmer discipline to
get it right.</p>

<p style="margin-left:9%; margin-top: 1em">This rule is
part of the <i>Type safety (Type.7)</i> profile from the C++
Core Guidelines.</p>

<h3>cppcoreguidelines-pro-type-vararg
<a name="cppcoreguidelines-pro-type-vararg"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check flags
all calls to c-style vararg functions and all use of
<b>va_arg</b>.</p>

<p style="margin-left:9%; margin-top: 1em">To allow for
SFINAE use of vararg functions, a call is not flagged if a
literal 0 is passed as the only vararg argument or function
is used in unevaluated context.</p>

<p style="margin-left:9%; margin-top: 1em">Passing to
varargs assumes the correct type will be read. This is
fragile because it cannot generally be enforced to be safe
in the language and so relies on programmer discipline to
get it right.</p>

<p style="margin-left:9%; margin-top: 1em">This rule is
part of the <i>Type safety (Type.8)</i> profile from the C++
Core Guidelines.</p>

<h3>cppcoreguidelines-rvalue-reference-param-not-moved
<a name="cppcoreguidelines-rvalue-reference-param-not-moved"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns when an
rvalue reference function parameter is never moved within
the function body.</p>

<p style="margin-left:9%; margin-top: 1em">Rvalue reference
parameters indicate a parameter that should be moved with
<b>std::move</b> from within the function body. Any such
parameter that is never moved is confusing and potentially
indicative of a buggy program.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">void
logic(std::string&amp;&amp; Input) { <br>
std::string Copy(Input); // Oops - forgot to std::move <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Note that
parameters that are unused and marked as such will not be
diagnosed.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">void
conditional_use([[maybe_unused]] std::string&amp;&amp;
Input) { <br>
// No diagnostic here since Input is unused and marked as
such <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>AllowPartialMove</b></p>

<p style="margin-left:22%;">If set to <i>true</i>, the
check accepts <b>std::move</b> calls containing any
subexpression containing the parameter. CppCoreGuideline
F.18 officially mandates that the parameter itself must be
moved. Default is <i>false</i>.</p>

<p style="margin-left:22%; margin-top: 1em">// 'p' is
flagged by this check if and only if AllowPartialMove is
false <br>
void move_members_of(pair&lt;Obj, Obj&gt;&amp;&amp; p) {
<br>
pair&lt;Obj, Obj&gt; other; <br>
other.first = std::move(p.first); <br>
other.second = std::move(p.second); <br>
}</p>

<p style="margin-left:22%; margin-top: 1em">// 'p' is never
flagged by this check <br>
void move_whole_pair(pair&lt;Obj, Obj&gt;&amp;&amp; p) {
<br>
pair&lt;Obj, Obj&gt; other = std::move(p); <br>
}</p>

<p style="margin-left:9%;"><b>IgnoreUnnamedParams</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, the
check ignores unnamed rvalue reference parameters. Default
is <i>false</i>.</p>


<p style="margin-left:9%;"><b>IgnoreNonDeducedTemplateTypes</b></p>

<p style="margin-left:22%;">If set to <i>true</i>, the
check ignores non-deduced template type rvalue reference
parameters. Default is <i>false</i>.</p>

<p style="margin-left:22%; margin-top: 1em">template
&lt;class T&gt; <br>
struct SomeClass { <br>
// Below, 'T' is not deduced and 'T&amp;&amp;' is an rvalue
reference type. <br>
// This will be flagged if and only if
IgnoreNonDeducedTemplateTypes is <br>
// false. One suggested fix would be to specialize the class
for 'T' and <br>
// 'T&amp;' separately (e.g., see std::future), or allow
only one of 'T' or <br>
// 'T&amp;' instantiations of SomeClass (e.g., see
std::optional). <br>
SomeClass(T&amp;&amp; t) { } <br>
};</p>

<p style="margin-left:22%; margin-top: 1em">// Never
flagged, since 'T' is a forwarding reference in a deduced
context <br>
template &lt;class T&gt; <br>
void forwarding_ref(T&amp;&amp; t) { <br>
T other = std::forward&lt;T&gt;(t); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>F.18</i> from the C++ Core Guidelines.</p>

<h3>cppcoreguidelines-slicing
<a name="cppcoreguidelines-slicing"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Flags slicing of
member variables or vtable. Slicing happens when copying a
derived object into a base object: the members of the
derived object (both member variables and virtual member
functions) will be discarded. This can be misleading
especially for member function slicing, for example:</p>

<p style="margin-left:13%; margin-top: 1em">struct B { int
a; virtual int f(); }; <br>
struct D : B { int b; int f() override; };</p>

<p style="margin-left:13%; margin-top: 1em">void use(B b) {
// Missing reference, intended? <br>
b.f(); // Calls B::f. <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">D d; <br>
use(d); // Slice.</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>ES.63</i> and <i>C.145</i> from the C++ Core
Guidelines.</p>

<h3>cppcoreguidelines-special-member-functions
<a name="cppcoreguidelines-special-member-functions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check finds
classes where some but not all of the special member
functions are defined.</p>

<p style="margin-left:9%; margin-top: 1em">By default the
compiler defines a copy constructor, copy assignment
operator, move constructor, move assignment operator and
destructor. The default can be suppressed by explicit
user-definitions. The relationship between which functions
will be suppressed by definitions of other functions is
complicated and it is advised that all five are defaulted or
explicitly defined.</p>

<p style="margin-left:9%; margin-top: 1em">Note that
defining a function with <b>= delete</b> is considered to be
a definition.</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>C.21</i> from the C++ Core Guidelines.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>AllowSoleDefaultDtor</b></p>

<p style="margin-left:18%;">When set to <i>true</i>
(default is <i>false</i>), this check will only trigger on
destructors if they are defined and not defaulted.</p>

<p style="margin-left:22%; margin-top: 1em">struct A { //
This is fine. <br>
virtual &#732;A() = default; <br>
};</p>

<p style="margin-left:22%; margin-top: 1em">struct B { //
This is not fine. <br>
&#732;B() {} <br>
};</p>

<p style="margin-left:22%; margin-top: 1em">struct C { <br>
// This is not checked, because the destructor might be
defaulted in <br>
// another translation unit. <br>
&#732;C(); <br>
};</p>


<p style="margin-left:9%;"><b>AllowMissingMoveFunctions</b></p>

<p style="margin-left:18%;">When set to <i>true</i>
(default is <i>false</i>), this check doesn't flag classes
which define no move operations at all. It still flags
classes which define only one of either move constructor or
move assignment operator. With this option enabled, the
following class won't be flagged:</p>

<p style="margin-left:22%; margin-top: 1em">struct A { <br>
A(const A&amp;); <br>
A&amp; operator=(const A&amp;); <br>
&#732;A(); <br>
};</p>


<p style="margin-left:9%;"><b>AllowMissingMoveFunctionsWhenCopyIsDeleted</b></p>

<p style="margin-left:18%;">When set to <i>true</i>
(default is <i>false</i>), this check doesn't flag classes
which define deleted copy operations but don't define move
operations. This flag is related to Google C++ Style Guide
<i>Copyable and Movable Types</i>. With this option enabled,
the following class won't be flagged:</p>

<p style="margin-left:22%; margin-top: 1em">struct A { <br>
A(const A&amp;) = delete; <br>
A&amp; operator=(const A&amp;) = delete; <br>
&#732;A(); <br>
};</p>


<p style="margin-left:9%;"><b>AllowImplicitlyDeletedCopyOrMove</b></p>

<p style="margin-left:18%;">When set to <i>true</i>
(default is <i>false</i>), this check doesn't flag classes
which implicitly delete copy or move operations. With this
option enabled, the following class won't be flagged:</p>

<p style="margin-left:22%; margin-top: 1em">struct A :
boost::noncopyable { <br>
&#732;A() { std::cout &lt;&lt; &quot;dtor\n&quot;; } <br>
};</p>

<h3>cppcoreguidelines-use-default-member-init
<a name="cppcoreguidelines-use-default-member-init"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
implements <i>C.48</i> from the C++ Core Guidelines.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>cppcoreguidelines-use-default-member-init</i> check is an
alias, please see <i>modernize-use-default-member-init</i>
for more information.</p>

<h3>cppcoreguidelines-virtual-class-destructor
<a name="cppcoreguidelines-virtual-class-destructor"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds virtual
classes whose destructor is neither public and virtual nor
protected and non-virtual. A virtual class's destructor
should be specified in one of these ways to prevent
undefined behavior.</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>C.35</i> from the C++ Core Guidelines.</p>

<p style="margin-left:9%; margin-top: 1em">Note that this
check will diagnose a class with a virtual method regardless
of whether the class is used as a base class or not.</p>

<p style="margin-left:9%; margin-top: 1em">Fixes are
available for user-declared and implicit destructors that
are either public and non-virtual or protected and virtual.
No fixes are offered for private destructors. There, the
decision whether to make them private and virtual or
protected and non-virtual depends on the use case and is
thus left to the user.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">For example, the
following classes/structs get flagged by the check since
they violate guideline <b>C.35</b>:</p>

<p style="margin-left:13%; margin-top: 1em">struct Foo { //
NOK, protected destructor should not be virtual <br>
virtual void f(); <br>
protected: <br>
virtual &#732;Foo(){} <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">class Bar { //
NOK, public destructor should be virtual <br>
virtual void f(); <br>
public: <br>
&#732;Bar(){} <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">This would be
rewritten to look like this:</p>

<p style="margin-left:13%; margin-top: 1em">struct Foo { //
OK, destructor is not virtual anymore <br>
virtual void f(); <br>
protected: <br>
&#732;Foo(){} <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">class Bar { //
OK, destructor is now virtual <br>
virtual void f(); <br>
public: <br>
virtual &#732;Bar(){} <br>
};</p>

<h3>darwin-avoid-spinlock
<a name="darwin-avoid-spinlock"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds usages of
<b>OSSpinlock</b>, which is deprecated due to potential
livelock problems.</p>

<p style="margin-left:9%; margin-top: 1em">This check will
detect following function invocations:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="20%">


<p><b>OSSpinlockLock</b></p></td>
<td width="68%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="20%">


<p><b>OSSpinlockTry</b></p></td>
<td width="68%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="20%">


<p><b>OSSpinlockUnlock</b></p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">The
corresponding information about the problem of
<b>OSSpinlock</b>: -
<i>https://blog.postmates.com/why-spinlocks-are-bad-on-ios-b69fc5221058</i></p>

<h3>darwin-dispatch-once-nonstatic
<a name="darwin-dispatch-once-nonstatic"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
declarations of <b>dispatch_once_t</b> variables without
static or global storage. The behavior of using
<b>dispatch_once_t</b> predicates with automatic or dynamic
storage is undefined by libdispatch, and should be
avoided.</p>

<p style="margin-left:9%; margin-top: 1em">It is a common
pattern to have functions initialize internal static or
global data once when the function runs, but programmers
have been known to miss the static on the
<b>dispatch_once_t</b> predicate, leading to an
uninitialized flag value at the mercy of the stack.</p>

<p style="margin-left:9%; margin-top: 1em">Programmers have
also been known to make <b>dispatch_once_t</b> variables be
members of structs or classes, with the intent to lazily
perform some expensive struct or class member initialization
only once; however, this violates the libdispatch
requirements.</p>

<p style="margin-left:9%; margin-top: 1em">See the
discussion section of <i>Apple's dispatch_once
documentation</i> for more information.</p>

<h3>fuchsia-default-arguments-calls
<a name="fuchsia-default-arguments-calls"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns if a
function or method is called with default arguments.</p>

<p style="margin-left:9%; margin-top: 1em">For example,
given the declaration:</p>

<p style="margin-left:13%; margin-top: 1em">int foo(int
value = 5) { return value; }</p>

<p style="margin-left:9%; margin-top: 1em">A function call
expression that uses a default argument will be diagnosed.
Calling it without defaults will not cause a warning:</p>

<p style="margin-left:13%; margin-top: 1em">foo(); //
warning <br>
foo(0); // no warning</p>

<p style="margin-left:9%; margin-top: 1em">See the features
disallowed in Fuchsia at -
<i>https://fuchsia.dev/fuchsia-src/development/languages/c-cpp/cxx?hl=en</i></p>

<h3>fuchsia-default-arguments-declarations
<a name="fuchsia-default-arguments-declarations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns if a
function or method is declared with default parameters.</p>

<p style="margin-left:9%; margin-top: 1em">For example, the
declaration:</p>

<p style="margin-left:13%; margin-top: 1em">int foo(int
value = 5) { return value; }</p>

<p style="margin-left:9%; margin-top: 1em">will cause a
warning.</p>

<p style="margin-left:9%; margin-top: 1em">See the features
disallowed in Fuchsia at -
<i>https://fuchsia.dev/fuchsia-src/development/languages/c-cpp/cxx?hl=en</i></p>

<h3>fuchsia-header-anon-namespaces
<a name="fuchsia-header-anon-namespaces"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
fuchsia-header-anon-namespaces check is an alias, please see
<i>google-build-namespace</i> for more information.</p>

<h3>fuchsia-multiple-inheritance
<a name="fuchsia-multiple-inheritance"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns if a class
inherits from multiple classes that are not pure
virtual.</p>

<p style="margin-left:9%; margin-top: 1em">For example,
declaring a class that inherits from multiple concrete
classes is disallowed:</p>

<p style="margin-left:13%; margin-top: 1em">class Base_A {
<br>
public: <br>
virtual int foo() { return 0; } <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">class Base_B {
<br>
public: <br>
virtual int bar() { return 0; } <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">// Warning <br>
class Bad_Child1 : public Base_A, Base_B {};</p>

<p style="margin-left:9%; margin-top: 1em">A class that
inherits from a pure virtual is allowed:</p>

<p style="margin-left:13%; margin-top: 1em">class
Interface_A { <br>
public: <br>
virtual int foo() = 0; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">class
Interface_B { <br>
public: <br>
virtual int bar() = 0; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">// No warning
<br>
class Good_Child1 : public Interface_A, Interface_B { <br>
virtual int foo() override { return 0; } <br>
virtual int bar() override { return 0; } <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">See the features
disallowed in Fuchsia at -
<i>https://fuchsia.dev/fuchsia-src/development/languages/c-cpp/cxx?hl=en</i></p>

<h3>fuchsia-overloaded-operator
<a name="fuchsia-overloaded-operator"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns if an
operator is overloaded, except for the assignment (copy and
move) operators.</p>

<p style="margin-left:9%; margin-top: 1em">For example:</p>

<p style="margin-left:13%; margin-top: 1em">int
operator+(int); // Warning</p>

<p style="margin-left:13%; margin-top: 1em">B
&amp;operator=(const B &amp;Other); // No warning <br>
B &amp;operator=(B &amp;&amp;Other) // No warning</p>

<p style="margin-left:9%; margin-top: 1em">See the features
disallowed in Fuchsia at -
<i>https://fuchsia.dev/fuchsia-src/development/languages/c-cpp/cxx?hl=en</i></p>

<h3>fuchsia-statically-constructed-objects
<a name="fuchsia-statically-constructed-objects"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns if global,
non-trivial objects with static storage are constructed,
unless the object is statically initialized with a
<b>constexpr</b> constructor or has no explicit
constructor.</p>

<p style="margin-left:9%; margin-top: 1em">For example:</p>

<p style="margin-left:13%; margin-top: 1em">class A {};</p>

<p style="margin-left:13%; margin-top: 1em">class B { <br>
public: <br>
B(int Val) : Val(Val) {} <br>
private: <br>
int Val; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">class C { <br>
public: <br>
constexpr C(int Val) : Val(Val) {} <br>
C(int Val1, int Val2) : Val(Val1+Val2) {}</p>

<p style="margin-left:13%; margin-top: 1em">private: <br>
int Val; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">static A a; //
No warning, as there is no explicit constructor <br>
static C c(0); // No warning, as constructor is
constexpr</p>

<p style="margin-left:13%; margin-top: 1em">static B b(0);
// Warning, as constructor is not constexpr <br>
static C c2(0, 1); // Warning, as constructor is not
constexpr</p>

<p style="margin-left:13%; margin-top: 1em">static int i;
// No warning, as it is trivial</p>

<p style="margin-left:13%; margin-top: 1em">extern int
get_i(); <br>
static C c3(get_i());// Warning, as the constructor is
dynamically initialized</p>

<p style="margin-left:9%; margin-top: 1em">See the features
disallowed in Fuchsia at -
<i>https://fuchsia.dev/fuchsia-src/development/languages/c-cpp/cxx?hl=en</i></p>

<h3>fuchsia-trailing-return
<a name="fuchsia-trailing-return"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Functions that
have trailing returns are disallowed, except for those using
<b>decltype</b> specifiers and lambda with otherwise
unutterable return types.</p>

<p style="margin-left:9%; margin-top: 1em">For example:</p>

<p style="margin-left:13%; margin-top: 1em">// No warning
<br>
int add_one(const int arg) { return arg; }</p>

<p style="margin-left:13%; margin-top: 1em">// Warning <br>
auto get_add_one() -&gt; int (*)(const int) { <br>
return add_one; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Exceptions are
made for lambdas and <b>decltype</b> specifiers:</p>

<p style="margin-left:13%; margin-top: 1em">// No warning
<br>
auto lambda = [](double x, double y) -&gt; double {return x
+ y;};</p>

<p style="margin-left:13%; margin-top: 1em">// No warning
<br>
template &lt;typename T1, typename T2&gt; <br>
auto fn(const T1 &amp;lhs, const T2 &amp;rhs) -&gt;
decltype(lhs + rhs) { <br>
return lhs + rhs; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">See the features
disallowed in Fuchsia at -
<i>https://fuchsia.dev/fuchsia-src/development/languages/c-cpp/cxx?hl=en</i></p>

<h3>fuchsia-virtual-inheritance
<a name="fuchsia-virtual-inheritance"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns if classes
are defined with virtual inheritance.</p>

<p style="margin-left:9%; margin-top: 1em">For example,
classes should not be defined with virtual inheritance:</p>

<p style="margin-left:13%; margin-top: 1em">class B :
public virtual A {}; // warning</p>

<p style="margin-left:9%; margin-top: 1em">See the features
disallowed in Fuchsia at -
<i>https://fuchsia.dev/fuchsia-src/development/languages/c-cpp/cxx?hl=en</i></p>

<h3>google-build-explicit-make-pair
<a name="google-build-explicit-make-pair"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check that
<b>make_pair</b>'s template arguments are deduced.</p>

<p style="margin-left:9%; margin-top: 1em">G++ 4.6 in C++11
mode fails badly if <b>make_pair</b>'s template arguments
are specified explicitly, and such use isn't intended in any
case.</p>

<p style="margin-left:9%; margin-top: 1em">Corresponding
cpplint.py check name: <i>build/explicit_make_pair</i>.</p>

<h3>google-build-namespaces
<a name="google-build-namespaces"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>cert-dcl59-cpp</i>
redirects here as an alias for this check.
<i>fuchsia-header-anon-namespaces</i> redirects here as an
alias for this check.</p>

<p style="margin-left:9%; margin-top: 1em">Finds anonymous
namespaces in headers.</p>


<p style="margin-left:9%; margin-top: 1em"><i>https://google.github.io/styleguide/cppguide.html#Namespaces</i></p>

<p style="margin-left:9%; margin-top: 1em">Corresponding
cpplint.py check name: <i>build/namespaces</i>.</p>

<h3>google-build-using-namespace
<a name="google-build-using-namespace"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds <b>using
namespace</b> directives.</p>

<p style="margin-left:9%; margin-top: 1em">The check
implements the following rule of the <i>Google C++ Style
Guide</i>:</p>

<p style="margin-left:13%;">You may not use a
using-directive to make all names from a namespace
available.</p>

<p style="margin-left:13%; margin-top: 1em">// Forbidden --
This pollutes the namespace. <br>
using namespace foo;</p>

<p style="margin-left:9%; margin-top: 1em">Corresponding
cpplint.py check name: <i>build/namespaces</i>.</p>

<h3>google-default-arguments
<a name="google-default-arguments"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks that
default arguments are not given for virtual methods.</p>

<p style="margin-left:9%; margin-top: 1em">See
<i>https://google.github.io/styleguide/cppguide.html#Default_Arguments</i></p>

<h3>google-explicit-constructor
<a name="google-explicit-constructor"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks that
constructors callable with a single argument and conversion
operators are marked explicit to avoid the risk of
unintentional implicit conversions.</p>

<p style="margin-left:9%; margin-top: 1em">Consider this
example:</p>

<p style="margin-left:13%; margin-top: 1em">struct S { <br>
int x; <br>
operator bool() const { return true; } <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">bool f() { <br>
S a{1}; <br>
S b{2}; <br>
return a == b; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The function
will return <b>true</b>, since the objects are implicitly
converted to <b>bool</b> before comparison, which is
unlikely to be the intent.</p>

<p style="margin-left:9%; margin-top: 1em">The check will
suggest inserting <b>explicit</b> before the constructor or
conversion operator declaration. However, copy and move
constructors should not be explicit, as well as constructors
taking a single <b>initializer_list</b> argument.</p>

<p style="margin-left:9%; margin-top: 1em">This code:</p>

<p style="margin-left:13%; margin-top: 1em">struct S { <br>
S(int a); <br>
explicit S(const S&amp;); <br>
operator bool() const; <br>
...</p>

<p style="margin-left:9%; margin-top: 1em">will become</p>

<p style="margin-left:13%; margin-top: 1em">struct S { <br>
explicit S(int a); <br>
S(const S&amp;); <br>
explicit operator bool() const; <br>
...</p>

<p style="margin-left:9%; margin-top: 1em">See -
<i>https://google.github.io/styleguide/cppguide.html#Explicit_Constructors</i></p>

<h3>google-global-names-in-headers
<a name="google-global-names-in-headers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Flag global
namespace pollution in header files. Right now it only
triggers on <b>using</b> declarations and directives.</p>

<p style="margin-left:9%; margin-top: 1em">The relevant
style guide section is -
<i>https://google.github.io/styleguide/cppguide.html#Namespaces</i>.</p>

<h3>google-objc-avoid-nsobject-new
<a name="google-objc-avoid-nsobject-new"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds calls to
<b>+new</b> or overrides of it, which are prohibited by the
Google Objective-C style guide.</p>

<p style="margin-left:9%; margin-top: 1em">The Google
Objective-C style guide forbids calling <b>+new</b> or
overriding it in class implementations, preferring
<b>+alloc</b> and <b>-init</b> methods to instantiate
objects.</p>

<p style="margin-left:9%; margin-top: 1em">An example:</p>

<p style="margin-left:13%; margin-top: 1em">NSDate *now =
[NSDate new]; <br>
Foo *bar = [Foo new];</p>

<p style="margin-left:9%; margin-top: 1em">Instead, code
should use <b>+alloc</b>/<b>-init</b> or class factory
methods.</p>

<p style="margin-left:13%; margin-top: 1em">NSDate *now =
[NSDate date]; <br>
Foo *bar = [[Foo alloc] init];</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the Google Objective-C Style Guide rule <i>Do
Not Use +new</i>.</p>

<h3>google-objc-avoid-throwing-exception
<a name="google-objc-avoid-throwing-exception"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds uses of
throwing exceptions usages in Objective-C files.</p>

<p style="margin-left:9%; margin-top: 1em">For the same
reason as the Google C++ style guide, we prefer not throwing
exceptions from Objective-C code.</p>

<p style="margin-left:9%; margin-top: 1em">The
corresponding C++ style guide rule: -
<i>https://google.github.io/styleguide/cppguide.html#Exceptions</i></p>

<p style="margin-left:9%; margin-top: 1em">Instead, prefer
passing in <b>NSError **</b> and return <b>BOOL</b> to
indicate success or failure.</p>

<p style="margin-left:9%; margin-top: 1em">A
counterexample:</p>

<p style="margin-left:13%; margin-top: 1em">-
(void)readFile { <br>
if ([self isError]) { <br>
@throw [NSException exceptionWithName:...]; <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Instead,
returning an error via <b>NSError **</b> is preferred:</p>

<p style="margin-left:13%; margin-top: 1em">-
(BOOL)readFileWithError:(NSError **)error { <br>
if ([self isError]) { <br>
*error = [NSError errorWithDomain:...]; <br>
return NO; <br>
} <br>
return YES; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The
corresponding style guide rule: -
<i>https://google.github.io/styleguide/objcguide.html#avoid-throwing-exceptions</i></p>

<h3>google-objc-function-naming
<a name="google-objc-function-naming"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds function
declarations in Objective-C files that do not follow the
pattern described in the Google Objective-C Style Guide.</p>

<p style="margin-left:9%; margin-top: 1em">The
corresponding style guide rule can be found here: -
<i>https://google.github.io/styleguide/objcguide.html#function-names</i></p>

<p style="margin-left:9%; margin-top: 1em">All function
names should be in Pascal case. Functions whose storage
class is not static should have an appropriate prefix.</p>

<p style="margin-left:9%; margin-top: 1em">The following
code sample does not follow this pattern:</p>

<p style="margin-left:13%; margin-top: 1em">static bool
is_positive(int i) { return i &gt; 0; } <br>
bool IsNegative(int i) { return i &lt; 0; }</p>

<p style="margin-left:9%; margin-top: 1em">The sample above
might be corrected to the following code:</p>

<p style="margin-left:13%; margin-top: 1em">static bool
IsPositive(int i) { return i &gt; 0; } <br>
bool *ABCIsNegative(int i) { return i &lt; 0; }</p>

<h3>google-objc-global-variable-declaration
<a name="google-objc-global-variable-declaration"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds global
variable declarations in Objective-C files that do not
follow the pattern of variable names in Google's Objective-C
Style Guide.</p>

<p style="margin-left:9%; margin-top: 1em">The
corresponding style guide rule: -
<i>https://google.github.io/styleguide/objcguide.html#variable-names</i></p>

<p style="margin-left:9%; margin-top: 1em">All the global
variables should follow the pattern of <b>g[A-Z].*</b>
(variables) or <b>k[A-Z].*</b> (constants). The check will
suggest a variable name that follows the pattern if it can
be inferred from the original name.</p>

<p style="margin-left:9%; margin-top: 1em">For code:</p>

<p style="margin-left:13%; margin-top: 1em">static
NSString* myString = @&quot;hello&quot;;</p>

<p style="margin-left:9%; margin-top: 1em">The fix will
be:</p>

<p style="margin-left:13%; margin-top: 1em">static
NSString* gMyString = @&quot;hello&quot;;</p>

<p style="margin-left:9%; margin-top: 1em">Another example
of constant:</p>

<p style="margin-left:13%; margin-top: 1em">static
NSString* const myConstString = @&quot;hello&quot;;</p>

<p style="margin-left:9%; margin-top: 1em">The fix will
be:</p>

<p style="margin-left:13%; margin-top: 1em">static
NSString* const kMyConstString = @&quot;hello&quot;;</p>

<p style="margin-left:9%; margin-top: 1em">However for code
that prefixed with non-alphabetical characters like:</p>

<p style="margin-left:13%; margin-top: 1em">static
NSString* __anotherString = @&quot;world&quot;;</p>

<p style="margin-left:9%; margin-top: 1em">The check will
give a warning message but will not be able to suggest a
fix. The user needs to fix it on their own.</p>

<h3>google-readability-avoid-underscore-in-googletest-name
<a name="google-readability-avoid-underscore-in-googletest-name"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks whether
there are underscores in googletest test suite names and
test names in test macros:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="15%">


<p style="margin-top: 1em"><b>TEST</b></p></td>
<td width="73%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="15%">


<p><b>TEST_F</b></p></td>
<td width="73%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="15%">


<p><b>TEST_P</b></p></td>
<td width="73%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="15%">


<p><b>TYPED_TEST</b></p></td>
<td width="73%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="15%">


<p><b>TYPED_TEST_P</b></p></td>
<td width="73%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">The
<b>FRIEND_TEST</b> macro is not included.</p>

<p style="margin-left:9%; margin-top: 1em">For example:</p>


<p style="margin-left:13%; margin-top: 1em">TEST(TestSuiteName,
Illegal_TestName) {} <br>
TEST(Illegal_TestSuiteName, TestName) {}</p>

<p style="margin-left:9%; margin-top: 1em">would trigger
the check. <i>Underscores are not allowed</i> in test suite
name nor test names.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>DISABLED_</b> prefix, which may be used to <i>disable
test suites and individual tests</i>, is removed from the
test suite name and test name before checking for
underscores.</p>

<p style="margin-left:9%; margin-top: 1em">This check does
not propose any fixes.</p>

<h3>google-readability-braces-around-statements
<a name="google-readability-braces-around-statements"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>google-readability-braces-around-statements</i> check is
an alias, please see
<i>readability-braces-around-statements</i> for more
information.</p>

<h3>google-readability-casting
<a name="google-readability-casting"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds usages of
C-style casts.</p>


<p style="margin-left:9%; margin-top: 1em"><i>https://google.github.io/styleguide/cppguide.html#Casting</i></p>

<p style="margin-left:9%; margin-top: 1em">Corresponding
cpplint.py check name: <i>readability/casting</i>.</p>

<p style="margin-left:9%; margin-top: 1em">This check is
similar to <b>-Wold-style-cast</b>, but it suggests
automated fixes in some cases. The reported locations should
not be different from the ones generated by
<b>-Wold-style-cast</b>.</p>

<h3>google-readability-function-size
<a name="google-readability-function-size"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>google-readability-function-size</i> check is an alias,
please see <i>readability-function-size</i> for more
information.</p>

<h3>google-readability-namespace-comments
<a name="google-readability-namespace-comments"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>google-readability-namespace-comments check</i> is an
alias, please see <i>llvm-namespace-comment</i> for more
information.</p>

<h3>google-readability-todo
<a name="google-readability-todo"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds TODO
comments without a username or bug number.</p>

<p style="margin-left:9%; margin-top: 1em">The relevant
style guide section is -
<i>https://google.github.io/styleguide/cppguide.html#TODO_Comments</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Corresponding
cpplint.py check: <i>readability/todo</i></p>

<h3>google-runtime-int
<a name="google-runtime-int"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds uses of
<b>short</b>, <b>long</b> and <b>long long</b> and suggest
replacing them with <b>u?intXX(_t)?</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The
corresponding style guide rule: -
<i>https://google.github.io/styleguide/cppguide.html#Integer_Types</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Corresponding
cpplint.py check: <i>runtime/int</i>.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>UnsignedTypePrefix</b></p>

<p style="margin-left:18%;">A string specifying the
unsigned type prefix. Default is <i>uint</i>.</p>

<p style="margin-left:9%;"><b>SignedTypePrefix</b></p>

<p style="margin-left:18%;">A string specifying the signed
type prefix. Default is <i>int</i>.</p>

<p style="margin-left:9%;"><b>TypeSuffix</b></p>

<p style="margin-left:18%;">A string specifying the type
suffix. Default is an empty string.</p>

<h3>google-runtime-operator
<a name="google-runtime-operator"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds overloads
of unary <b>operator &amp;</b>.</p>


<p style="margin-left:9%; margin-top: 1em"><i>https://google.github.io/styleguide/cppguide.html#Operator_Overloading</i></p>

<p style="margin-left:9%; margin-top: 1em">Corresponding
cpplint.py check name: <i>runtime/operator</i>.</p>

<h3>google-upgrade-googletest-case
<a name="google-upgrade-googletest-case"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds uses of
deprecated Google Test version 1.9 APIs with names
containing <b>case</b> and replaces them with equivalent
APIs with <b>suite</b>.</p>

<p style="margin-left:9%; margin-top: 1em">All names
containing <b>case</b> are being replaced to be consistent
with the meanings of &quot;test case&quot; and &quot;test
suite&quot; as used by the International Software Testing
Qualifications Board and ISO 29119.</p>

<p style="margin-left:9%; margin-top: 1em">The new names
are a part of Google Test version 1.9 (release pending). It
is recommended that users update their dependency to version
1.9 and then use this check to remove deprecated names.</p>

<p style="margin-left:9%; margin-top: 1em">The affected
APIs are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Member functions of <b>testing::Test</b>,
<b>testing::TestInfo</b>, <b>testing::TestEventListener</b>,
<b>testing::UnitTest</b>, and any type inheriting from these
types</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>The macros <b>TYPED_TEST_CASE</b>,
<b>TYPED_TEST_CASE_P</b>, <b>REGISTER_TYPED_TEST_CASE_P</b>,
and <b>INSTANTIATE_TYPED_TEST_CASE_P</b></p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>The type alias <b>testing::TestCase</b></p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Examples of
fixes created by this check:</p>

<p style="margin-left:13%; margin-top: 1em">class FooTest :
public testing::Test { <br>
public: <br>
static void SetUpTestCase(); <br>
static void TearDownTestCase(); <br>
};</p>


<p style="margin-left:13%; margin-top: 1em">TYPED_TEST_CASE(BarTest,
BarTypes);</p>

<p style="margin-left:9%; margin-top: 1em">becomes</p>

<p style="margin-left:13%; margin-top: 1em">class FooTest :
public testing::Test { <br>
public: <br>
static void SetUpTestSuite(); <br>
static void TearDownTestSuite(); <br>
};</p>


<p style="margin-left:13%; margin-top: 1em">TYPED_TEST_SUITE(BarTest,
BarTypes);</p>

<p style="margin-left:9%; margin-top: 1em">For better
consistency of user code, the check renames both virtual and
non-virtual member functions with matching names in derived
types. The check tries to provide only a warning when a fix
cannot be made safely, as is the case with some template and
macro uses.</p>

<h3>hicpp-avoid-c-arrays
<a name="hicpp-avoid-c-arrays"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
hicpp-avoid-c-arrays check is an alias, please see
<i>modernize-avoid-c-arrays</i> for more information. It
partly enforces the <i>rule 4.1.1</i>.</p>

<h3>hicpp-avoid-goto
<a name="hicpp-avoid-goto"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>hicpp-avoid-goto</i> check is an alias, please see
<i>cppcoreguidelines-avoid-goto</i> for more information. It
enforces the - <i>rule 6.3.1</i>.</p>

<h3>hicpp-braces-around-statements
<a name="hicpp-braces-around-statements"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>hicpp-braces-around-statements</i> check is an alias,
please see <i>readability-braces-around-statements</i> for
more information. It enforces the <i>rule 6.1.1</i>.</p>

<h3>hicpp-deprecated-headers
<a name="hicpp-deprecated-headers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>hicpp-deprecated-headers</i> check is an alias, please
see <i>modernize-deprecated-headers</i> for more
information. It enforces the - <i>rule 1.3.3</i>.</p>

<h3>hicpp-exception-baseclass
<a name="hicpp-exception-baseclass"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Ensure that
every value that in a <b>throw</b> expression is an instance
of <b>std::exception</b>.</p>

<p style="margin-left:9%; margin-top: 1em">This enforces
<i>rule 15.1</i> of the High Integrity C++ Coding
Standard.</p>

<p style="margin-left:13%; margin-top: 1em">class
custom_exception {};</p>

<p style="margin-left:13%; margin-top: 1em">void throwing()
noexcept(false) { <br>
// Problematic throw expressions. <br>
throw int(42); <br>
throw custom_exception(); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">class
mathematical_error : public std::exception {};</p>

<p style="margin-left:13%; margin-top: 1em">void
throwing2() noexcept(false) { <br>
// These kind of throws are ok. <br>
throw mathematical_error(); <br>
throw std::runtime_error(); <br>
throw std::exception(); <br>
}</p>

<h3>hicpp-explicit-conversions
<a name="hicpp-explicit-conversions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check is an
alias for <i>google-explicit-constructor</i>. Used to
enforce parts of <i>rule 5.4.1</i>. This check will enforce
that constructors and conversion operators are marked
<i>explicit</i>. Other forms of casting checks are
implemented in other places. The following checks can be
used to check for more forms of casting:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="60%">



<p style="margin-top: 1em"><i>cppcoreguidelines-pro-type-static-cast-downcast</i></p> </td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="60%">


<p><i>cppcoreguidelines-pro-type-reinterpret-cast</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="60%">


<p><i>cppcoreguidelines-pro-type-const-cast</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="60%">


<p><i>cppcoreguidelines-pro-type-cstyle-cast</i></p></td>
<td width="28%">
</td></tr>
</table>

<h3>hicpp-function-size
<a name="hicpp-function-size"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check is an
alias for <i>readability-function-size</i>. Useful to
enforce multiple sections on function complexity.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p style="margin-top: 1em"><i>rule 8.2.2</i></p></td>
<td width="76%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p><i>rule 8.3.1</i></p></td>
<td width="76%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p><i>rule 8.3.2</i></p></td>
<td width="76%">
</td></tr>
</table>

<h3>hicpp-ignored-remove-result
<a name="hicpp-ignored-remove-result"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Ensure that the
result of <b>std::remove</b>, <b>std::remove_if</b> and
<b>std::unique</b> are not ignored according to <i>rule
17.5.1</i>.</p>

<p style="margin-left:9%; margin-top: 1em">The mutating
algorithms <b>std::remove</b>, <b>std::remove_if</b> and
both overloads of <b>std::unique</b> operate by swapping or
moving elements of the range they are operating over. On
completion, they return an iterator to the last valid
element. In the majority of cases the correct behavior is to
use this result as the first operand in a call to
<b>std::erase</b>.</p>

<p style="margin-left:9%; margin-top: 1em">This check is a
subset of <i>bugprone-unused-return-value</i> and depending
on used options it can be superfluous to enable both
checks.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>AllowCastToVoid</b></p>

<p style="margin-left:18%;">Controls whether casting return
values to <b>void</b> is permitted. Default:
<i>true</i>.</p>

<h3>hicpp-invalid-access-moved
<a name="hicpp-invalid-access-moved"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check is an
alias for <i>bugprone-use-after-move</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Implements parts
of the <i>rule 8.4.1</i> to check if moved-from objects are
accessed.</p>

<h3>hicpp-member-init
<a name="hicpp-member-init"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check is an
alias for <i>cppcoreguidelines-pro-type-member-init</i>.
Implements the check for <i>rule 12.4.2</i> to initialize
class members in the right order.</p>

<h3>hicpp-move-const-arg
<a name="hicpp-move-const-arg"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>hicpp-move-const-arg</i> check is an alias, please see
<i>performance-move-const-arg</i> for more information. It
enforces the <i>rule 17.3.1</i>.</p>

<h3>hicpp-multiway-paths-covered
<a name="hicpp-multiway-paths-covered"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
discovers situations where code paths are not fully-covered.
It furthermore suggests using <b>if</b> instead of
<b>switch</b> if the code will be more clear. The <i>rule
6.1.2</i> and <i>rule 6.1.4</i> of the High Integrity C++
Coding Standard are enforced.</p>

<p style="margin-left:9%; margin-top: 1em"><b>if-else
if</b> chains that miss a final <b>else</b> branch might
lead to unexpected program execution and be the result of a
logical error. If the missing <b>else</b> branch is intended
you can leave it empty with a clarifying comment. This
warning can be noisy on some code bases, so it is disabled
by default.</p>

<p style="margin-left:13%; margin-top: 1em">void f1() {
<br>
int i = determineTheNumber();</p>

<p style="margin-left:13%; margin-top: 1em">if(i &gt; 0) {
<br>
// Some Calculation <br>
} else if (i &lt; 0) { <br>
// Precondition violated or something else. <br>
} <br>
// ... <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Similar
arguments hold for <b>switch</b> statements which do not
cover all possible code paths.</p>

<p style="margin-left:13%; margin-top: 1em">// The missing
default branch might be a logical error. It can be kept
empty <br>
// if there is nothing to do, making it explicit. <br>
void f2(int i) { <br>
switch (i) { <br>
case 0: // something <br>
break; <br>
case 1: // something else <br>
break; <br>
} <br>
// All other numbers? <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// Violates
this rule as well, but already emits a compiler warning
(-Wswitch). <br>
enum Color { Red, Green, Blue, Yellow }; <br>
void f3(enum Color c) { <br>
switch (c) { <br>
case Red: // We can't drive for now. <br>
break; <br>
case Green: // We are allowed to drive. <br>
break; <br>
} <br>
// Other cases missing <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The <i>rule
6.1.4</i> requires every <b>switch</b> statement to have at
least two <b>case</b> labels other than a <i>default</i>
label. Otherwise, the <b>switch</b> could be better
expressed with an <b>if</b> statement. Degenerated
<b>switch</b> statements without any labels are caught as
well.</p>

<p style="margin-left:13%; margin-top: 1em">// Degenerated
switch that could be better written as `if` <br>
int i = 42; <br>
switch(i) { <br>
case 1: // do something here <br>
default: // do something else here <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// Should
rather be the following: <br>
if (i == 1) { <br>
// do something here <br>
} <br>
else { <br>
// do something here <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// A completely
degenerated switch will be diagnosed. <br>
int i = 42; <br>
switch(i) {}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>WarnOnMissingElse</b></p>

<p style="margin-left:18%;">Boolean flag that activates a
warning for missing <b>else</b> branches. Default is
<i>false</i>.</p>

<h3>hicpp-named-parameter
<a name="hicpp-named-parameter"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check is an
alias for <i>readability-named-parameter</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Implements
<i>rule 8.2.1</i>.</p>

<h3>hicpp-new-delete-operators
<a name="hicpp-new-delete-operators"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check is an
alias for <i>misc-new-delete-overloads</i>. Implements
<i>rule 12.3.1</i> to ensure the <i>new</i> and
<i>delete</i> operators have the correct signature.</p>

<h3>hicpp-no-array-decay
<a name="hicpp-no-array-decay"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>hicpp-no-array-decay</i> check is an alias, please see
<i>cppcoreguidelines-pro-bounds-array-to-pointer-decay</i>
for more information. It enforces the <i>rule 4.1.1</i>.</p>

<h3>hicpp-no-assembler
<a name="hicpp-no-assembler"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for
assembler statements. Use of inline assembly should be
avoided since it restricts the portability of the code.</p>

<p style="margin-left:9%; margin-top: 1em">This enforces
<i>rule 7.5.1</i> of the High Integrity C++ Coding
Standard.</p>

<h3>hicpp-no-malloc
<a name="hicpp-no-malloc"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>hicpp-no-malloc</i> check is an alias, please see
<i>cppcoreguidelines-no-malloc</i> for more information. It
enforces the <i>rule 5.3.2</i>.</p>

<h3>hicpp-noexcept-move
<a name="hicpp-noexcept-move"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check is an
alias for <i>performance-noexcept-move-constructor</i>.
Checks <i>rule 12.5.4</i> to mark move assignment and move
construction <i>noexcept</i>.</p>

<h3>hicpp-signed-bitwise
<a name="hicpp-signed-bitwise"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds uses of
bitwise operations on signed integer types, which may lead
to undefined or implementation defined behavior.</p>

<p style="margin-left:9%; margin-top: 1em">The according
rule is defined in the <i>High Integrity C++ Standard,
Section 5.6.1</i>.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnorePositiveIntegerLiterals</b></p>

<p style="margin-left:18%;">If this option is set to
<i>true</i>, the check will not warn on bitwise operations
with positive integer literals, e.g. <i>&#732;0</i>, <i>2
&lt;&lt; 1</i>, etc. Default value is <i>false</i>.</p>

<h3>hicpp-special-member-functions
<a name="hicpp-special-member-functions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check is an
alias for <i>cppcoreguidelines-special-member-functions</i>.
Checks that special member functions have the correct
signature, according to <i>rule 12.5.7</i>.</p>

<h3>hicpp-static-assert
<a name="hicpp-static-assert"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>hicpp-static-assert</i> check is an alias, please see
<i>misc-static-assert</i> for more information. It enforces
the <i>rule 7.1.10</i>.</p>

<h3>hicpp-undelegated-constructor
<a name="hicpp-undelegated-constructor"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check is an
alias for <i>bugprone-undelegated-constructor</i>. Partially
implements <i>rule 12.4.5</i> to find misplaced constructor
calls inside a constructor.</p>

<p style="margin-left:13%; margin-top: 1em">struct Ctor {
<br>
Ctor(); <br>
Ctor(int); <br>
Ctor(int, int); <br>
Ctor(Ctor *i) { <br>
// All Ctor() calls result in a temporary object <br>
Ctor(); // did you intend to call a delegated constructor?
<br>
Ctor(0); // did you intend to call a delegated constructor?
<br>
Ctor(1, 2); // did you intend to call a delegated
constructor? <br>
foo(); <br>
} <br>
};</p>

<h3>hicpp-uppercase-literal-suffix
<a name="hicpp-uppercase-literal-suffix"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
hicpp-uppercase-literal-suffix check is an alias, please see
<i>readability-uppercase-literal-suffix</i> for more
information.</p>

<p style="margin-left:9%; margin-top: 1em">Partially
implements <i>rule 4.2.1</i> to ensure that the <b>U</b>
suffix is writeln properly.</p>

<h3>hicpp-use-auto
<a name="hicpp-use-auto"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>hicpp-use-auto</i> check is an alias, please see
<i>modernize-use-auto</i> for more information. It enforces
the <i>rule 7.1.8</i>.</p>

<h3>hicpp-use-emplace
<a name="hicpp-use-emplace"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>hicpp-use-emplace</i> check is an alias, please see
<i>modernize-use-emplace</i> for more information. It
enforces the <i>rule 17.4.2</i>.</p>

<h3>hicpp-use-equals-default
<a name="hicpp-use-equals-default"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check is an
alias for <i>modernize-use-equals-default</i>. Implements -
<i>rule 12.5.1</i> to explicitly default special member
functions.</p>

<h3>hicpp-use-equals-delete
<a name="hicpp-use-equals-delete"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check is an
alias for <i>modernize-use-equals-delete</i>. Implements -
<i>rule 12.5.1</i> to explicitly default or delete special
member functions.</p>

<h3>hicpp-use-noexcept
<a name="hicpp-use-noexcept"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>hicpp-use-noexcept</i> check is an alias, please see
<i>modernize-use-noexcept</i> for more information. It
enforces the <i>rule 1.3.5</i>.</p>

<h3>hicpp-use-nullptr
<a name="hicpp-use-nullptr"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>hicpp-use-nullptr</i> check is an alias, please see
<i>modernize-use-nullptr</i> for more information. It
enforces the <i>rule 2.5.3</i>.</p>

<h3>hicpp-use-override
<a name="hicpp-use-override"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check is an
alias for <i>modernize-use-override</i>. Implements <i>rule
10.2.1</i> to declare a virtual function <i>override</i>
when overriding.</p>

<h3>hicpp-vararg
<a name="hicpp-vararg"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>hicpp-vararg</i> check is an alias, please see
<i>cppcoreguidelines-pro-type-vararg</i> for more
information. It enforces the <i>rule 14.1.1</i>.</p>

<h3>linuxkernel-must-check-errs
<a name="linuxkernel-must-check-errs"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks Linux
kernel code to see if it uses the results from the functions
in <b>linux/err.h</b>. Also checks to see if code uses the
results from functions that directly return a value from one
of these error functions.</p>

<p style="margin-left:9%; margin-top: 1em">This is
important in the Linux kernel because <b>ERR_PTR</b>,
<b>PTR_ERR</b>, <b>IS_ERR</b>, <b>IS_ERR_OR_NULL</b>,
<b>ERR_CAST</b>, and <b>PTR_ERR_OR_ZERO</b> return values
must be checked, since positive pointers and negative error
codes are being used in the same context. These functions
are marked with <b>__attribute__((warn_unused_result))</b>,
but some kernel versions do not have this warning enabled
for clang.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">/* Trivial
unused call to an ERR function */ <br>
PTR_ERR_OR_ZERO(some_function_call());</p>

<p style="margin-left:13%; margin-top: 1em">/* A function
that returns ERR_PTR. */ <br>
void *fn() { ERR_PTR(-EINVAL); }</p>

<p style="margin-left:13%; margin-top: 1em">/* An invalid
use of fn. */ <br>
fn();</p>

<h3>llvm-else-after-return
<a name="llvm-else-after-return"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>llvm-else-after-return</i> check is an alias, please see
<i>readability-else-after-return</i> for more
information.</p>

<h3>llvm-header-guard
<a name="llvm-header-guard"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds and fixes
header guards that do not adhere to LLVM style.</p>

<h3>llvm-include-order
<a name="llvm-include-order"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks the
correct order of <b>#includes</b>.</p>

<p style="margin-left:9%; margin-top: 1em">See
<i>https://llvm.org/docs/CodingStandards.html#include-style</i></p>

<h3>llvm-namespace-comment
<a name="llvm-namespace-comment"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>google-readability-namespace-comments</i>
redirects here as an alias for this check.</p>

<p style="margin-left:9%; margin-top: 1em">Checks that long
namespaces have a closing comment.</p>


<p style="margin-left:9%; margin-top: 1em"><i>https://llvm.org/docs/CodingStandards.html#namespace-indentation</i></p>


<p style="margin-left:9%; margin-top: 1em"><i>https://google.github.io/styleguide/cppguide.html#Namespaces</i></p>

<p style="margin-left:13%; margin-top: 1em">namespace n1 {
<br>
void f(); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">namespace n1 {
<br>
void f(); <br>
} // namespace n1</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>ShortNamespaceLines</b></p>

<p style="margin-left:18%;">Requires the closing brace of
the namespace definition to be followed by a closing comment
if the body of the namespace has more than
<i>ShortNamespaceLines</i> lines of code. The value is an
unsigned integer that defaults to <i>1U</i>.</p>

<p style="margin-left:9%;"><b>SpacesBeforeComments</b></p>

<p style="margin-left:18%;">An unsigned integer specifying
the number of spaces before the comment closing a namespace
definition. Default is <i>1U</i>.</p>

<h3>llvm-prefer-isa-or-dyn-cast-in-conditionals
<a name="llvm-prefer-isa-or-dyn-cast-in-conditionals"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Looks at
conditionals and finds and replaces cases of
<b>cast&lt;&gt;</b>, which will assert rather than return a
null pointer, and <b>dyn_cast&lt;&gt;</b> where the return
value is not captured. Additionally, finds and replaces
cases that match the pattern <b>var &amp;&amp;
isa&lt;X&gt;(var)</b>, where <b>var</b> is evaluated
twice.</p>

<p style="margin-left:13%; margin-top: 1em">// Finds these:
<br>
if (auto x = cast&lt;X&gt;(y)) {} <br>
// is replaced by: <br>
if (auto x = dyn_cast&lt;X&gt;(y)) {}</p>

<p style="margin-left:13%; margin-top: 1em">if
(cast&lt;X&gt;(y)) {} <br>
// is replaced by: <br>
if (isa&lt;X&gt;(y)) {}</p>

<p style="margin-left:13%; margin-top: 1em">if
(dyn_cast&lt;X&gt;(y)) {} <br>
// is replaced by: <br>
if (isa&lt;X&gt;(y)) {}</p>

<p style="margin-left:13%; margin-top: 1em">if (var
&amp;&amp; isa&lt;T&gt;(var)) {} <br>
// is replaced by: <br>
if (isa_and_nonnull&lt;T&gt;(var.foo())) {}</p>

<p style="margin-left:13%; margin-top: 1em">// Other cases
are ignored, e.g.: <br>
if (auto f = cast&lt;Z&gt;(y)-&gt;foo()) {} <br>
if (cast&lt;Z&gt;(y)-&gt;foo()) {} <br>
if (X.cast(y)) {}</p>

<h3>llvm-prefer-register-over-unsigned
<a name="llvm-prefer-register-over-unsigned"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds historical
use of <b>unsigned</b> to hold vregs and physregs and
rewrites them to use <b>Register</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Currently this
works by finding all variables of unsigned integer type
whose initializer begins with an implicit cast from
<b>Register</b> to <b>unsigned</b>.</p>

<p style="margin-left:13%; margin-top: 1em">void
example(MachineOperand &amp;MO) { <br>
unsigned Reg = MO.getReg(); <br>
... <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">becomes:</p>

<p style="margin-left:13%; margin-top: 1em">void
example(MachineOperand &amp;MO) { <br>
Register Reg = MO.getReg(); <br>
... <br>
}</p>

<h3>llvm-qualified-auto
<a name="llvm-qualified-auto"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>llvm-qualified-auto check</i> is an alias, please see
<i>readability-qualified-auto</i> for more information.</p>

<h3>llvm-twine-local
<a name="llvm-twine-local"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Looks for local
<b>Twine</b> variables which are prone to use after frees
and should be generally avoided.</p>

<p style="margin-left:13%; margin-top: 1em">static Twine
Moo = Twine(&quot;bark&quot;) + &quot;bah&quot;;</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">static
std::string Moo = (Twine(&quot;bark&quot;) +
&quot;bah&quot;).str();</p>

<h3>llvmlibc-callee-namespace
<a name="llvmlibc-callee-namespace"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks all calls
resolve to functions within correct namespace.</p>

<p style="margin-left:13%; margin-top: 1em">//
Implementation inside the LIBC_NAMESPACE namespace. <br>
// Correct if: <br>
// - LIBC_NAMESPACE is a macro <br>
// - LIBC_NAMESPACE expansion starts with `__llvm_libc` <br>
namespace LIBC_NAMESPACE {</p>

<p style="margin-left:13%; margin-top: 1em">// Allow calls
with the fully qualified name. <br>
LIBC_NAMESPACE::strlen(&quot;hello&quot;);</p>

<p style="margin-left:13%; margin-top: 1em">// Allow calls
to compiler provided functions. <br>
(void)__builtin_abs(-1);</p>

<p style="margin-left:13%; margin-top: 1em">// Bare calls
are allowed as long as they resolve to the correct
namespace. <br>
strlen(&quot;world&quot;);</p>

<p style="margin-left:13%; margin-top: 1em">// Disallow
calling into functions in the global namespace. <br>
::strlen(&quot;!&quot;);</p>

<p style="margin-left:13%; margin-top: 1em">} // namespace
LIBC_NAMESPACE</p>

<h3>llvmlibc-implementation-in-namespace
<a name="llvmlibc-implementation-in-namespace"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks that all
declarations in the llvm-libc implementation are within the
correct namespace.</p>

<p style="margin-left:13%; margin-top: 1em">//
Implementation inside the LIBC_NAMESPACE_DECL namespace.
<br>
// Correct if: <br>
// - LIBC_NAMESPACE_DECL is a macro <br>
// - LIBC_NAMESPACE_DECL expansion starts with
`[[gnu::visibility(&quot;hidden&quot;)]] __llvm_libc` <br>
namespace LIBC_NAMESPACE_DECL { <br>
void LLVM_LIBC_ENTRYPOINT(strcpy)(char *dest, const char
*src) {} <br>
// Namespaces within LIBC_NAMESPACE_DECL namespace are
allowed. <br>
namespace inner { <br>
int localVar = 0; <br>
} <br>
// Functions with C linkage are allowed. <br>
extern &quot;C&quot; void str_fuzz() {} <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// Incorrect:
implementation not in the LIBC_NAMESPACE_DECL namespace.
<br>
void LLVM_LIBC_ENTRYPOINT(strcpy)(char *dest, const char
*src) {}</p>

<p style="margin-left:13%; margin-top: 1em">// Incorrect:
outer most namespace is not the LIBC_NAMESPACE_DECL macro.
<br>
namespace something_else { <br>
void LLVM_LIBC_ENTRYPOINT(strcpy)(char *dest, const char
*src) {} <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// Incorrect:
outer most namespace expansion does not start with
`[[gnu::visibility(&quot;hidden&quot;)]] __llvm_libc`. <br>
#define LIBC_NAMESPACE_DECL custom_namespace <br>
namespace LIBC_NAMESPACE_DECL { <br>
void LLVM_LIBC_ENTRYPOINT(strcpy)(char *dest, const char
*src) {} <br>
}</p>

<h3>llvmlibc-inline-function-decl
<a name="llvmlibc-inline-function-decl"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks that all
implicitly and explicitly inline functions in header files
are tagged with the <b>LIBC_INLINE</b> macro, except for
functions implicit to classes or deleted functions. See the
<i>libc style guide</i> for more information about this
macro.</p>

<h3>llvmlibc-restrict-system-libc-headers
<a name="llvmlibc-restrict-system-libc-headers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds includes
of system libc headers not provided by the compiler within
llvm-libc implementations.</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;stdio.h&gt; // Not allowed because it is part of system
libc. <br>
#include &lt;stddef.h&gt; // Allowed because it is provided
by the compiler. <br>
#include &quot;internal/stdio.h&quot; // Allowed because it
is NOT part of system libc.</p>

<p style="margin-left:9%; margin-top: 1em">This check is
necessary because accidentally including system libc headers
can lead to subtle and hard to detect bugs. For example
consider a system libc whose <b>dirent</b> struct has
slightly different field ordering than llvm-libc. While this
will compile successfully, this can cause issues during
runtime because they are ABI incompatible.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>Includes</b></p>

<p style="margin-left:18%;">A string containing a comma
separated glob list of allowed include filenames. Similar to
the -checks glob list for running clang-tidy itself, the two
wildcard characters are <i>*</i> and <i>-</i>, to include
and exclude globs, respectively. The default is <i>-*</i>,
which disallows all includes.</p>

<p style="margin-left:18%; margin-top: 1em">This can be
used to allow known safe includes such as Linux development
headers. See <i>portability-restrict-system-includes</i> for
more details.</p>

<h3>misc-confusable-identifiers
<a name="misc-confusable-identifiers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn about
confusable identifiers, i.e. identifiers that are visually
close to each other, but use different Unicode characters.
This detects a potential attack described in
<i>CVE-2021-42574</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">int fo; //
Initial character is U+0066 (LATIN SMALL LETTER F). <br>
int &#119839;o; // Initial character is U+1D41F
(MATHEMATICAL BOLD SMALL F) not U+0066 (LATIN SMALL LETTER
F).</p>

<h3>misc-const-correctness
<a name="misc-const-correctness"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
implements detection of local variables which could be
declared as <b>const</b> but are not. Declaring variables as
<b>const</b> is required or recommended by many coding
guidelines, such as: <i>ES.25</i> from the C++ Core
Guidelines and <i>AUTOSAR C++14 Rule A7-1-1 (6.7.1
Specifiers)</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Please note that
this check's analysis is type-based only. Variables that are
not modified but used to create a non-const handle that
might escape the scope are not diagnosed as potential
<b>const</b>.</p>

<p style="margin-left:13%; margin-top: 1em">// Declare a
variable, which is not ``const`` ... <br>
int i = 42; <br>
// but use it as read-only. This means that `i` can be
declared ``const``. <br>
int result = i * i; // Before transformation <br>
int const result = i * i; // After transformation</p>

<p style="margin-left:9%; margin-top: 1em">The check can
analyze values, pointers and references but not (yet)
pointees:</p>

<p style="margin-left:13%; margin-top: 1em">// Normal
values like built-ins or objects. <br>
int potential_const_int = 42; // Before transformation <br>
int const potential_const_int = 42; // After transformation
<br>
int copy_of_value = potential_const_int;</p>

<p style="margin-left:13%; margin-top: 1em">MyClass
could_be_const; // Before transformation <br>
MyClass const could_be_const; // After transformation <br>
could_be_const.const_qualified_method();</p>

<p style="margin-left:13%; margin-top: 1em">// References
can be declared const as well. <br>
int &amp;reference_value = potential_const_int; // Before
transformation <br>
int const&amp; reference_value = potential_const_int; //
After transformation <br>
int another_copy = reference_value;</p>

<p style="margin-left:13%; margin-top: 1em">// The similar
semantics of pointers are not (yet) analyzed. <br>
int *pointer_variable = &amp;potential_const_int; // _NO_
'const int *pointer_variable' suggestion. <br>
int last_copy = *pointer_variable;</p>

<p style="margin-left:9%; margin-top: 1em">The automatic
code transformation is only applied to variables that are
declared in single declarations. You may want to prepare
your code base with <i>readability-isolate-declaration</i>
first.</p>

<p style="margin-left:9%; margin-top: 1em">Note that there
is the check
<i>cppcoreguidelines-avoid-non-const-global-variables</i> to
enforce <b>const</b> correctness on all globals.</p>

<h3>Known Limitations
<a name="Known Limitations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check does
not run on <i>C</i> code.</p>

<p style="margin-left:9%; margin-top: 1em">The check will
not analyze templated variables or variables that are
instantiation dependent. Different instantiations can result
in different <b>const</b> correctness properties and in
general it is not possible to find all instantiations of a
template. The template might be used differently in an
independent translation unit.</p>

<p style="margin-left:9%; margin-top: 1em">Pointees can not
be analyzed for constness yet. The following code shows this
limitation.</p>

<p style="margin-left:13%; margin-top: 1em">// Declare a
variable that will not be modified. <br>
int constant_value = 42;</p>

<p style="margin-left:13%; margin-top: 1em">// Declare a
pointer to that variable, that does not modify either, but
misses 'const'. <br>
// Could be 'const int *pointer_to_constant =
&amp;constant_value;' <br>
int *pointer_to_constant = &amp;constant_value;</p>

<p style="margin-left:13%; margin-top: 1em">// Usage: <br>
int result = 520 * 120 * (*pointer_to_constant);</p>

<p style="margin-left:9%; margin-top: 1em">This limitation
affects the capability to add <b>const</b> to methods which
is not possible, too.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>AnalyzeValues
(default = true)</b></p>

<p style="margin-left:18%;">Enable or disable the analysis
of ordinary value variables, like <b>int i = 42;</b></p>

<p style="margin-left:22%; margin-top: 1em">// Warning <br>
int i = 42; <br>
// No warning <br>
int const i = 42;</p>

<p style="margin-left:22%; margin-top: 1em">// Warning <br>
int a[] = {42, 42, 42}; <br>
// No warning <br>
int const a[] = {42, 42, 42};</p>

<p style="margin-left:9%;"><b>AnalyzeReferences (default =
true)</b></p>

<p style="margin-left:18%;">Enable or disable the analysis
of reference variables, like <b>int &amp;ref = i;</b></p>

<p style="margin-left:22%; margin-top: 1em">int i = 42;
<br>
// Warning <br>
int&amp; ref = i; <br>
// No warning <br>
int const&amp; ref = i;</p>

<p style="margin-left:9%;"><b>WarnPointersAsValues (default
= false)</b></p>

<p style="margin-left:18%;">This option enables the
suggestion for <b>const</b> of the pointer itself. Pointer
values have two possibilities to be <b>const</b>, the
pointer and the value pointing to.</p>

<p style="margin-left:22%; margin-top: 1em">int value =
42;</p>

<p style="margin-left:22%; margin-top: 1em">// Warning <br>
const int * pointer_variable = &amp;value; <br>
// No warning <br>
const int *const pointer_variable = &amp;value;</p>

<p style="margin-left:9%;"><b>TransformValues (default =
true)</b></p>

<p style="margin-left:18%;">Provides fixit-hints for value
types that automatically add <b>const</b> if its a single
declaration.</p>

<p style="margin-left:22%; margin-top: 1em">// Before <br>
int value = 42; <br>
// After <br>
int const value = 42;</p>

<p style="margin-left:22%; margin-top: 1em">// Before <br>
int a[] = {42, 42, 42}; <br>
// After <br>
int const a[] = {42, 42, 42};</p>

<p style="margin-left:22%; margin-top: 1em">// Result is
modified later in its life-time. No diagnostic and fixit
hint will be emitted. <br>
int result = value * 3; <br>
result -= 10;</p>

<p style="margin-left:9%;"><b>TransformReferences (default
= true)</b></p>

<p style="margin-left:18%;">Provides fixit-hints for
reference types that automatically add <b>const</b> if its a
single declaration.</p>

<p style="margin-left:22%; margin-top: 1em">// This
variable could still be a constant. But because there is a
non-const reference to <br>
// it, it can not be transformed (yet). <br>
int value = 42; <br>
// The reference 'ref_value' is not modified and can be made
'const int &amp;ref_value = value;' <br>
// Before <br>
int &amp;ref_value = value; <br>
// After <br>
int const &amp;ref_value = value;</p>

<p style="margin-left:22%; margin-top: 1em">// Result is
modified later in its life-time. No diagnostic and fixit
hint will be emitted. <br>
int result = ref_value * 3; <br>
result -= 10;</p>

<p style="margin-left:9%;"><b>TransformPointersAsValues
(default = false)</b></p>

<p style="margin-left:18%;">Provides fixit-hints for
pointers if their pointee is not changed. This does not
analyze if the value-pointed-to is unchanged!</p>

<p style="margin-left:18%; margin-top: 1em">Requires
'WarnPointersAsValues' to be 'true'.</p>

<p style="margin-left:22%; margin-top: 1em">int value =
42;</p>

<p style="margin-left:22%; margin-top: 1em">// Before <br>
const int * pointer_variable = &amp;value; <br>
// After <br>
const int *const pointer_variable = &amp;value;</p>

<p style="margin-left:22%; margin-top: 1em">// Before <br>
const int * a[] = {&amp;value, &amp;value}; <br>
// After <br>
const int *const a[] = {&amp;value, &amp;value};</p>

<p style="margin-left:22%; margin-top: 1em">// Before <br>
int *ptr_value = &amp;value; <br>
// After <br>
int *const ptr_value = &amp;value;</p>

<p style="margin-left:22%; margin-top: 1em">int result =
100 * (*ptr_value); // Does not modify the pointer itself.
<br>
// This modification of the pointee is still allowed and not
diagnosed. <br>
*ptr_value = 0;</p>

<p style="margin-left:22%; margin-top: 1em">// The
following pointer may not become a 'int *const'. <br>
int *changing_pointee = &amp;value; <br>
changing_pointee = &amp;result;</p>

<h3>misc-coroutine-hostile-raii
<a name="misc-coroutine-hostile-raii"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects when
objects of certain hostile RAII types persists across
suspension points in a coroutine. Such hostile types include
scoped-lockable types and types belonging to a configurable
denylist.</p>

<p style="margin-left:9%; margin-top: 1em">Some objects
require that they be destroyed on the same thread that
created them. Traditionally this requirement was often
phrased as &quot;must be a local variable&quot;, under the
assumption that local variables always work this way.
However this is incorrect with C++20 coroutines, since an
intervening <b>co_await</b> may cause the coroutine to
suspend and later be resumed on another thread.</p>

<p style="margin-left:9%; margin-top: 1em">The lifetime of
an object that requires being destroyed on the same thread
must not encompass a <b>co_await</b> or <b>co_yield</b>
point. If you create/destroy an object, you must do so
without allowing the coroutine to suspend in the
meantime.</p>

<p style="margin-left:9%; margin-top: 1em">Following types
are considered as hostile:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>Scoped-lockable types: A scoped-lockable object
persisting across a suspension point is problematic as the
lock held by this object could be unlocked by a different
thread. This would be undefined behaviour. This includes all
types annotated with the <b>scoped_lockable</b>
attribute.</p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>Types belonging to a configurable denylist.</p></td></tr>
</table>

<p style="margin-left:13%; margin-top: 1em">// Call some
async API while holding a lock. <br>
task coro() { <br>
const std::lock_guard l(&amp;mu_);</p>

<p style="margin-left:13%; margin-top: 1em">// Oops! The
async Bar function may finish on a different <br>
// thread from the one that created the lock_guard (and
called <br>
// Mutex::Lock). After suspension, Mutex::Unlock will be
called on the wrong thread. <br>
co_await Bar(); <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>RAIITypesList</b></p>

<p style="margin-left:18%;">A semicolon-separated list of
qualified types which should not be allowed to persist
across suspension points. Eg: <b>my::lockable;
a::b;::my::other::lockable;</b> The default value of this
option is
<i>&quot;std::lock_guard;std::scoped_lock&quot;</i>.</p>


<p style="margin-left:9%;"><b>AllowedAwaitablesList</b></p>

<p style="margin-left:18%;">A semicolon-separated list of
qualified types of awaitables types which can be safely
awaited while having hostile RAII objects in scope.</p>


<p style="margin-left:18%; margin-top: 1em"><b>co_await</b>-ing
an expression of <b>awaitable</b> type is considered safe if
the <b>awaitable</b> type is part of this list. RAII objects
persisting across such a <b>co_await</b> expression are
considered safe and hence are not flagged.</p>

<p style="margin-left:18%; margin-top: 1em">Example
usage:</p>

<p style="margin-left:22%; margin-top: 1em">// Consider
option AllowedAwaitablesList = &quot;safe_awaitable&quot;
<br>
struct safe_awaitable { <br>
bool await_ready() noexcept { return false; } <br>
void await_suspend(std::coroutine_handle&lt;&gt;) noexcept
{} <br>
void await_resume() noexcept {} <br>
}; <br>
auto wait() { return safe_awaitable{}; }</p>

<p style="margin-left:22%; margin-top: 1em">task coro() {
<br>
// This persists across both the co_await's but is not
flagged <br>
// because the awaitable is considered safe to await on.
<br>
const std::lock_guard l(&amp;mu_); <br>
co_await safe_awaitable{}; <br>
co_await wait(); <br>
}</p>

<p style="margin-left:18%; margin-top: 1em">Eg:
<b>my::safe::awaitable;other::awaitable</b> The default
value of this option is empty string
<i>&quot;&quot;</i>.</p>

<h3>misc-definitions-in-headers
<a name="misc-definitions-in-headers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds non-extern
non-inline function and variable definitions in header
files, which can lead to potential ODR violations in case
these headers are included from multiple translation
units.</p>

<p style="margin-left:13%; margin-top: 1em">// Foo.h <br>
int a = 1; // Warning: variable definition. <br>
extern int d; // OK: extern variable.</p>

<p style="margin-left:13%; margin-top: 1em">namespace N {
<br>
int e = 2; // Warning: variable definition. <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// Warning:
variable definition. <br>
const char* str = &quot;foo&quot;;</p>

<p style="margin-left:13%; margin-top: 1em">// OK: internal
linkage variable definitions are ignored for now. <br>
// Although these might also cause ODR violations, we can be
less certain and <br>
// should try to keep the false-positive rate down. <br>
static int b = 1; <br>
const int c = 1; <br>
const char* const str2 = &quot;foo&quot;; <br>
constexpr int k = 1; <br>
namespace { int x = 1; }</p>

<p style="margin-left:13%; margin-top: 1em">// Warning:
function definition. <br>
int g() { <br>
return 1; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// OK: inline
function definition is allowed to be defined multiple times.
<br>
inline int e() { <br>
return 1; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">class A { <br>
public: <br>
int f1() { return 1; } // OK: implicitly inline member
function definition is allowed. <br>
int f2();</p>

<p style="margin-left:13%; margin-top: 1em">static int d;
<br>
};</p>

<p style="margin-left:13%; margin-top: 1em">// Warning: not
an inline member function definition. <br>
int A::f2() { return 1; }</p>

<p style="margin-left:13%; margin-top: 1em">// OK: class
static data member declaration is allowed. <br>
int A::d = 1;</p>

<p style="margin-left:13%; margin-top: 1em">// OK: function
template is allowed. <br>
template&lt;typename T&gt; <br>
T f3() { <br>
T a = 1; <br>
return a; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// Warning:
full specialization of a function template is not allowed.
<br>
template &lt;&gt; <br>
int f3() { <br>
int a = 1; <br>
return a; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T&gt; <br>
struct B { <br>
void f1(); <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">// OK: member
function definition of a class template is allowed. <br>
template &lt;typename T&gt; <br>
void B&lt;T&gt;::f1() {}</p>

<p style="margin-left:13%; margin-top: 1em">class CE { <br>
constexpr static int i = 5; // OK: inline variable
definition. <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">inline int i =
5; // OK: inline variable definition.</p>

<p style="margin-left:13%; margin-top: 1em">constexpr int
f10() { return 0; } // OK: constexpr function implies
inline.</p>

<p style="margin-left:13%; margin-top: 1em">// OK: C++14
variable templates are inline. <br>
template &lt;class T&gt; <br>
constexpr T pi = T(3.1415926L);</p>

<p style="margin-left:9%; margin-top: 1em">When
<b>clang-tidy</b> is invoked with the <i>--fix-notes</i>
option, this check provides fixes that automatically add the
<b>inline</b> keyword to discovered functions. Please note
that the addition of the <b>inline</b> keyword to variables
is not currently supported by this check.</p>

<h3>misc-header-include-cycle
<a name="misc-header-include-cycle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check detects
cyclic <b>#include</b> dependencies between user-defined
headers.</p>

<p style="margin-left:13%; margin-top: 1em">// Header A.hpp
<br>
#pragma once <br>
#include &quot;B.hpp&quot;</p>

<p style="margin-left:13%; margin-top: 1em">// Header B.hpp
<br>
#pragma once <br>
#include &quot;C.hpp&quot;</p>

<p style="margin-left:13%; margin-top: 1em">// Header C.hpp
<br>
#pragma once <br>
#include &quot;A.hpp&quot;</p>

<p style="margin-left:13%; margin-top: 1em">// Include
chain: A-&gt;B-&gt;C-&gt;A</p>

<p style="margin-left:9%; margin-top: 1em">Header files are
a crucial part of many C++ programs as they provide a way to
organize declarations and definitions shared across multiple
source files. However, header files can also create problems
when they become entangled in complex dependency cycles.
Such cycles can cause issues with compilation times,
unnecessary rebuilds, and make it harder to understand the
overall structure of the code.</p>

<p style="margin-left:9%; margin-top: 1em">To address these
issues, a check has been developed to detect cyclic
dependencies between header files, also known as
&quot;include cycles&quot;. An include cycle occurs when a
header file <i>A</i> includes header file <i>B</i>, and
<i>B</i> (or any subsequent included header file) includes
back header file <i>A</i>, resulting in a circular
dependency cycle.</p>

<p style="margin-left:9%; margin-top: 1em">This check
operates at the preprocessor level and specifically analyzes
user-defined headers and their dependencies. It focuses
solely on detecting include cycles while disregarding other
types or function dependencies. This specialized analysis
helps identify and prevent issues related to header file
organization.</p>

<p style="margin-left:9%; margin-top: 1em">By detecting
include cycles early in the development process, developers
can identify and resolve these issues before they become
more difficult and time-consuming to fix. This can lead to
faster compile times, improved code quality, and a more
maintainable codebase overall. Additionally, by ensuring
that header files are organized in a way that avoids cyclic
dependencies, developers can make their code easier to
understand and modify over time.</p>

<p style="margin-left:9%; margin-top: 1em">It's worth
noting that only user-defined headers their dependencies are
analyzed, System includes such as standard library headers
and third-party library headers are excluded. System
includes are usually well-designed and free of include
cycles, and ignoring them helps to focus on potential issues
within the project's own codebase. This limitation doesn't
diminish the ability to detect <b>#include</b> cycles within
the analyzed code.</p>

<p style="margin-left:9%; margin-top: 1em">Developers
should carefully review any warnings or feedback provided by
this solution. While the analysis aims to identify and
prevent include cycles, there may be situations where
exceptions or modifications are necessary. It's important to
exercise judgment and consider the specific context of the
codebase when making adjustments.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoredFilesList</b></p>

<p style="margin-left:18%;">Provides a way to exclude
specific files/headers from the warnings raised by a check.
This can be achieved by specifying a semicolon-separated
list of regular expressions or filenames. This option can be
used as an alternative to <b>//NOLINT</b> when using it is
not possible. The default value of this option is an empty
string, indicating that no files are ignored by default.</p>

<h3>misc-include-cleaner
<a name="misc-include-cleaner"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for
unused and missing includes. Generates findings only for the
main file of a translation unit. Findings correspond to -
<i>https://clangd.llvm.org/design/include-cleaner</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">// foo.h <br>
class Foo{}; <br>
// bar.h <br>
#include &quot;baz.h&quot; <br>
class Bar{}; <br>
// baz.h <br>
class Baz{}; <br>
// main.cc <br>
#include &quot;bar.h&quot; // OK: uses class Bar from bar.h
<br>
#include &quot;foo.h&quot; // warning: unused include
&quot;foo.h&quot; <br>
Bar bar; <br>
Baz baz; // warning: missing include &quot;baz.h&quot;</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreHeaders</b></p>

<p style="margin-left:18%;">A semicolon-separated list of
regexes to disable insertion/removal of header files that
match this regex as a suffix. E.g., <i>foo/.*</i> disables
insertion/removal for all headers under the directory
<i>foo</i>. By default, no headers will be ignored.</p>

<p style="margin-left:9%;"><b>DeduplicateFindings</b></p>

<p style="margin-left:18%;">A boolean that controls whether
the check should deduplicate findings for the same symbol.
Defaults to <i>true</i>.</p>

<h3>misc-misleading-bidirectional
<a name="misc-misleading-bidirectional"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warn about
unterminated bidirectional unicode sequence, detecting
potential attack as described in the <i>Trojan Source</i>
attack.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;iostream&gt;</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
bool isAdmin = false; <br>
/*&#8238; } &#8294;if (isAdmin)&#8297; &#8294; begin admins
only */ <br>
std::cout &lt;&lt; &quot;You are an admin.\n&quot;; <br>
/* end admins only &#8238; { &#8294;*/ <br>
return 0; <br>
}</p>

<h3>misc-misleading-identifier
<a name="misc-misleading-identifier"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
identifiers that contain Unicode characters with
right-to-left direction, which can be confusing as they may
change the understanding of a whole statement line, as
described in <i>Trojan Source</i>.</p>

<p style="margin-left:9%; margin-top: 1em">An example of
such misleading code follows:</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;stdio.h&gt;</p>

<p style="margin-left:13%; margin-top: 1em">short int
&#1488; = (short int)0; <br>
short int &#1490; = (short int)12345;</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
int &#1488; = &#1490;; // a local variable, set to zero?
<br>
printf(&quot;&#1490; is %d\n&quot;, &#1490;); <br>
printf(&quot;&#1488; is %d\n&quot;, &#1488;); <br>
}</p>

<h3>misc-misplaced-const
<a name="misc-misplaced-const"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
diagnoses when a <b>const</b> qualifier is applied to a
<b>typedef</b>/ <b>using</b> to a pointer type rather than
to the pointee, because such constructs are often misleading
to developers because the <b>const</b> applies to the
pointer rather than the pointee.</p>

<p style="margin-left:9%; margin-top: 1em">For instance, in
the following code, the resulting type is <b>int * const</b>
rather than <b>const int *</b>:</p>

<p style="margin-left:13%; margin-top: 1em">typedef int
*int_ptr; <br>
void f(const int_ptr ptr) { <br>
*ptr = 0; // potentially quite unexpectedly the int can be
modified here <br>
ptr = 0; // does not compile <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The check does
not diagnose when the underlying <b>typedef</b>/<b>using</b>
type is a pointer to a <b>const</b> type or a function
pointer type. This is because the <b>const</b> qualifier is
less likely to be mistaken because it would be redundant (or
disallowed) on the underlying pointee type.</p>

<h3>misc-new-delete-overloads
<a name="misc-new-delete-overloads"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>cert-dcl54-cpp</i>
redirects here as an alias for this check.</p>

<p style="margin-left:9%; margin-top: 1em">The check flags
overloaded operator <b>new()</b> and operator
<b>delete()</b> functions that do not have a corresponding
free store function defined within the same scope. For
instance, the check will flag a class implementation of a
non-placement operator <b>new()</b> when the class does not
also define a non-placement operator <b>delete()</b>
function as well.</p>

<p style="margin-left:9%; margin-top: 1em">The check does
not flag implicitly-defined operators, deleted or private
operators, or placement operators.</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to CERT C++ Coding Standard rule <i>DCL54-CPP.
Overload allocation and deallocation functions as a pair in
the same scope</i>.</p>

<h3>misc-no-recursion
<a name="misc-no-recursion"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds strongly
connected functions (by analyzing the call graph for SCC's
(Strongly Connected Components) that are loops), diagnoses
each function in the cycle, and displays one example of a
possible call graph loop (recursion).</p>

<p style="margin-left:9%; margin-top: 1em">References:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>CERT C++ Coding Standard rule <i>DCL56-CPP. Avoid cycles
during initialization of static objects</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>JPL Institutional Coding Standard for the C Programming
Language (JPL DOCID D-60411) rule <i>2.4 Do not use direct
or indirect recursion</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>OpenCL Specification, Version 1.2 rule <i>6.9
Restrictions: i. Recursion is not supported.</i>.</p></td></tr>
</table>


<p style="margin-left:9%; margin-top: 1em">Limitations:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p style="margin-top: 1em">The check does not handle calls
done through function pointers</p></td>
<td width="9%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>The check does not handle C++ destructors</p></td>
<td width="9%">
</td></tr>
</table>

<h3>misc-non-copyable-objects
<a name="misc-non-copyable-objects"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>cert-fio38-c</i>
redirects here as an alias for this check.</p>

<p style="margin-left:9%; margin-top: 1em">The check flags
dereferences and non-pointer declarations of objects that
are not meant to be passed by value, such as C FILE objects
or POSIX <b>pthread_mutex_t</b> objects.</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to CERT C++ Coding Standard rule <i>FIO38-C. Do
not copy a FILE object</i>.</p>

<h3>misc-non-private-member-variables-in-classes
<a name="misc-non-private-member-variables-in-classes"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>cppcoreguidelines-non-private-member-variables-in-classes</i>
redirects here as an alias for this check.</p>

<p style="margin-left:9%; margin-top: 1em">Finds classes
that contain non-static data members in addition to
user-declared non-static member functions and diagnose all
data members declared with a non-<b>public</b> access
specifier. The data members should be declared as
<b>private</b> and accessed through member functions instead
of exposed to derived classes or class consumers.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreClassesWithAllMemberVariablesBeingPublic</b></p>

<p style="margin-left:18%;">Allows to completely ignore
classes if <b>all</b> the member variables in that class a
declared with a <b>public</b> access specifier.</p>


<p style="margin-left:9%;"><b>IgnorePublicMemberVariables</b></p>

<p style="margin-left:18%;">Allows to ignore (not diagnose)
<b>all</b> the member variables declared with a
<b>public</b> access specifier.</p>

<h3>misc-redundant-expression
<a name="misc-redundant-expression"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detect redundant
expressions which are typically errors due to
copy-paste.</p>

<p style="margin-left:9%; margin-top: 1em">Depending on the
operator expressions may be</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="41%">


<p>redundant,</p></td>
<td width="47%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="41%">


<p>always <b>true</b>,</p></td>
<td width="47%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="41%">


<p>always <b>false</b>,</p></td>
<td width="47%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="41%">


<p>always a constant (zero or one).</p></td>
<td width="47%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">((x+1) | (x+1))
// (x+1) is redundant <br>
(p-&gt;x == p-&gt;x) // always true <br>
(p-&gt;x &lt; p-&gt;x) // always false <br>
(speed - speed + 1 == 12) // speed - speed is always
zero</p>

<h3>misc-static-assert
<a name="misc-static-assert"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>cert-dcl03-c</i>
redirects here as an alias for this check.</p>

<p style="margin-left:9%; margin-top: 1em">Replaces
<b>assert()</b> with <b>static_assert()</b> if the condition
is evaluable at compile time.</p>

<p style="margin-left:9%; margin-top: 1em">The condition of
<b>static_assert()</b> is evaluated at compile time which is
safer and more efficient.</p>

<h3>misc-throw-by-value-catch-by-reference
<a name="misc-throw-by-value-catch-by-reference"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>cert-err09-cpp</i>
and <i>cert-err61-cpp</i> redirect here as aliases of this
check.</p>

<p style="margin-left:9%; margin-top: 1em">Finds violations
of the rule &quot;Throw by value, catch by reference&quot;
presented for example in &quot;C++ Coding Standards&quot; by
H. Sutter and A. Alexandrescu, as well as the CERT C++
Coding Standard rule <i>ERR61-CPP. Catch exceptions by
lvalue reference</i>. <b><br>
Exceptions:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>Throwing string literals will not be flagged despite
being a pointer. They are not susceptible to slicing and the
usage of string literals is idiomatic.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>Catching character pointers (<b>char</b>,
<b>wchar_t</b>, unicode character types) will not be flagged
to allow catching string literals.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>Moved named values will not be flagged as not throwing
an anonymous temporary. In this case we can be sure that the
user knows that the object can't be accessed outside catch
blocks handling the error.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>Throwing function parameters will not be flagged as not
throwing an anonymous temporary. This allows helper
functions for throwing.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>Re-throwing caught exception variables will not be
flagged as not throwing an anonymous temporary. Although
this can usually be done by just writing <b>throw;</b> it
happens often enough in real code.</p></td></tr>
</table>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>CheckThrowTemporaries</b></p>

<p style="margin-left:18%;">Triggers detection of
violations of the CERT recommendation ERR09-CPP. Throw
anonymous temporaries. Default is <i>true</i>.</p>

<p style="margin-left:9%;"><b>WarnOnLargeObject</b></p>

<p style="margin-left:18%;">Also warns for any large,
trivial object caught by value. Catching a large object by
value is not dangerous but affects the performance
negatively. The maximum size of an object allowed to be
caught without warning can be set using the <i>MaxSize</i>
option. Default is <i>false</i>.</p>

<p style="margin-left:9%;"><b>MaxSize</b></p>

<p style="margin-left:18%;">Determines the maximum size of
an object allowed to be caught without warning. Only
applicable if <i>WarnOnLargeObject</i> is set to
<i>true</i>. If the option is set by the user to
<i>std::numeric_limits&lt;uint64_t&gt;::max()</i> then it
reverts to the default value. Default is the size of
<i>size_t</i>.</p>

<h3>misc-unconventional-assign-operator
<a name="misc-unconventional-assign-operator"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
declarations of assign operators with the wrong return
and/or argument types and definitions with good return type
but wrong <b>return</b> statements.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>The return type must be <b>Class&amp;</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>The assignment may be from the class type by value,
const lvalue reference, non-const rvalue reference, or from
a completely different type (e.g. <b>int</b>).</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>Private and deleted operators are ignored.</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>The operator must always return <b>*this</b>.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">This check
implements <i>AUTOSAR C++14 Rule A13-2-1</i>.</p>

<h3>misc-uniqueptr-reset-release
<a name="misc-uniqueptr-reset-release"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Find and replace
<b>unique_ptr::reset(release())</b> with
<b>std::move()</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>


<p style="margin-left:13%; margin-top: 1em">std::unique_ptr&lt;Foo&gt;
x, y; <br>
x.reset(y.release()); -&gt; x = std::move(y);</p>

<p style="margin-left:9%; margin-top: 1em">If <b>y</b> is
already rvalue, <b>std::move()</b> is not added. <b>x</b>
and <b>y</b> can also be
<b>std::unique_ptr&lt;Foo&gt;*</b>.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IncludeStyle</b></p>

<p style="margin-left:18%;">A string specifying which
include-style is used, <i>llvm</i> or <i>google</i>. Default
is <i>llvm</i>.</p>

<h3>misc-unused-alias-decls
<a name="misc-unused-alias-decls"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds unused
namespace alias declarations.</p>

<p style="margin-left:13%; margin-top: 1em">namespace
my_namespace { <br>
class C {}; <br>
} <br>
namespace unused_alias = ::my_namespace;</p>

<h3>misc-unused-parameters
<a name="misc-unused-parameters"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds unused
function parameters. Unused parameters may signify a bug in
the code (e.g. when a different parameter is used instead).
The suggested fixes either comment parameter name out or
remove the parameter completely, if all callers of the
function are in the same translation unit and can be
updated.</p>

<p style="margin-left:9%; margin-top: 1em">The check is
similar to the <b>-Wunused-parameter</b> compiler diagnostic
and can be used to prepare a codebase to enabling of that
diagnostic. By default the check is more permissive (see
<i>StrictMode</i>).</p>

<p style="margin-left:13%; margin-top: 1em">void a(int i) {
/*some code that doesn't use `i`*/ }</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">void a(int
/*i*/) { /*some code that doesn't use `i`*/ }</p>

<p style="margin-left:13%; margin-top: 1em">static void
staticFunctionA(int i); <br>
static void staticFunctionA(int i) { /*some code that
doesn't use `i`*/ }</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">static void
staticFunctionA() <br>
static void staticFunctionA() { /*some code that doesn't use
`i`*/ }</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>StrictMode</b></p>

<p style="margin-left:18%;">When <i>false</i> (default
value), the check will ignore trivially unused parameters,
i.e. when the corresponding function has an empty body (and
in case of constructors - no constructor initializers). When
the function body is empty, an unused parameter is unlikely
to be unnoticed by a human reader, and there's basically no
place for a bug to hide.</p>

<p style="margin-left:9%;"><b>IgnoreVirtual</b></p>

<p style="margin-left:18%;">Determines whether virtual
method parameters should be inspected. Set to <i>true</i> to
ignore them. Default is <i>false</i>.</p>

<h3>misc-unused-using-decls
<a name="misc-unused-using-decls"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds unused
<b>using</b> declarations.</p>

<p style="margin-left:9%; margin-top: 1em">Unused
<b>using`</b> declarations in header files will not be
diagnosed since these using declarations are part of the
header's public API. Allowed header file extensions can be
configured via the global option
<i>HeaderFileExtensions</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">// main.cpp
<br>
namespace n { class C; } <br>
using n::C; // Never actually used.</p>

<h3>misc-use-anonymous-namespace
<a name="misc-use-anonymous-namespace"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds instances
of <b>static</b> functions or variables declared at global
scope that could instead be moved into an anonymous
namespace.</p>

<p style="margin-left:9%; margin-top: 1em">Anonymous
namespaces are the &quot;superior alternative&quot;
according to the C++ Standard. <b>static</b> was proposed
for deprecation, but later un-deprecated to keep C
compatibility [1]. <b>static</b> is an overloaded term with
different meanings in different contexts, so it can create
confusion.</p>

<p style="margin-left:9%; margin-top: 1em">The following
uses of <b>static</b> will <i>not</i> be diagnosed:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Functions or variables in header files, since anonymous
namespaces in headers is considered an antipattern. Allowed
header file extensions can be configured via the global
option <i>HeaderFileExtensions</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p><b>const</b> or <b>constexpr</b> variables, since they
already have implicit internal linkage in C++.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">// Bad <br>
static void foo(); <br>
static int x;</p>

<p style="margin-left:13%; margin-top: 1em">// Good <br>
namespace { <br>
void foo(); <br>
int x; <br>
} // namespace</p>

<p style="margin-left:9%; margin-top: 1em">[1]
<i>Undeprecating static</i></p>

<h3>misc-use-internal-linkage
<a name="misc-use-internal-linkage"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects
variables and functions that can be marked as static or
moved into an anonymous namespace to enforce internal
linkage.</p>

<p style="margin-left:9%; margin-top: 1em">Static functions
and variables are scoped to a single file. Marking functions
and variables as static helps to better remove dead code. In
addition, it gives the compiler more information and allows
for more aggressive optimizations.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">int v1; // can
be marked as static</p>

<p style="margin-left:13%; margin-top: 1em">void fn1(); //
can be marked as static</p>

<p style="margin-left:13%; margin-top: 1em">namespace {
<br>
// already in anonymous namespace <br>
int v2; <br>
void fn2(); <br>
} <br>
// already declared as extern <br>
extern int v2;</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>FixMode</b></p>

<p style="margin-left:18%;">Selects what kind of a fix the
check should provide. The default is <i>UseStatic</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="5%">


<p><b>None</b></p></td>
<td width="4%"></td>
<td width="31%">


<p>Don't fix automatically.</p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:18%;"><b>UseStatic</b></p>

<p style="margin-left:27%;">Add <b>static</b> for internal
linkage variable and function.</p>

<h3>modernize-avoid-bind
<a name="modernize-avoid-bind"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check finds
uses of <b>std::bind</b> and <b>boost::bind</b> and replaces
them with lambdas. Lambdas will use value-capture unless
reference capture is explicitly requested with
<b>std::ref</b> or <b>boost::ref</b>.</p>

<p style="margin-left:9%; margin-top: 1em">It supports
arbitrary callables including member functions, function
objects, and free functions, and all variations thereof.
Anything that you can pass to the first argument of
<b>bind</b> should be diagnosable. Currently, the only known
case where a fix-it is unsupported is when the same
placeholder is specified multiple times in the parameter
list.</p>

<p style="margin-left:9%; margin-top: 1em">Given:</p>

<p style="margin-left:13%; margin-top: 1em">int add(int x,
int y) { return x + y; }</p>

<p style="margin-left:9%; margin-top: 1em">Then:</p>

<p style="margin-left:13%; margin-top: 1em">void f() { <br>
int x = 2; <br>
auto clj = std::bind(add, x, _1); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">is replaced
by:</p>

<p style="margin-left:13%; margin-top: 1em">void f() { <br>
int x = 2; <br>
auto clj = [=](auto &amp;&amp; arg1) { return add(x, arg1);
}; <br>
}</p>


<p style="margin-left:9%; margin-top: 1em"><b>std::bind</b>
can be hard to read and can result in larger object files
and binaries due to type information that will not be
produced by equivalent lambdas.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>PermissiveParameterList</b></p>

<p style="margin-left:18%;">If the option is set to
<i>true</i>, the check will append <b>auto&amp;&amp;...</b>
to the end of every placeholder parameter list. Without
this, it is possible for a fix-it to perform an incorrect
transformation in the case where the result of the
<b>bind</b> is used in the context of a type erased functor
such as <b>std::function</b> which allows mismatched
arguments. For example:</p>

<p style="margin-left:13%; margin-top: 1em">int add(int x,
int y) { return x + y; } <br>
int foo() { <br>
std::function&lt;int(int,int)&gt; ignore_args =
std::bind(add, 2, 2); <br>
return ignore_args(3, 3); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">is valid code,
and returns <i>4</i>. The actual values passed to
<b>ignore_args</b> are simply ignored. Without
<b>PermissiveParameterList</b>, this would be transformed
into</p>

<p style="margin-left:13%; margin-top: 1em">int add(int x,
int y) { return x + y; } <br>
int foo() { <br>
std::function&lt;int(int,int)&gt; ignore_args = [] { return
add(2, 2); } <br>
return ignore_args(3, 3); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">which will
<i>not</i> compile, since the lambda does not contain an
<b>operator()</b> that accepts 2 arguments. With permissive
parameter list, it instead generates</p>

<p style="margin-left:13%; margin-top: 1em">int add(int x,
int y) { return x + y; } <br>
int foo() { <br>
std::function&lt;int(int,int)&gt; ignore_args =
[](auto&amp;&amp;...) { return add(2, 2); } <br>
return ignore_args(3, 3); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">which is
correct.</p>

<p style="margin-left:9%; margin-top: 1em">This check
requires using C++14 or higher to run.</p>

<h3>modernize-avoid-c-arrays
<a name="modernize-avoid-c-arrays"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>cppcoreguidelines-avoid-c-arrays</i>
redirects here as an alias for this check.</p>


<p style="margin-left:9%; margin-top: 1em"><i>hicpp-avoid-c-arrays</i>
redirects here as an alias for this check.</p>

<p style="margin-left:9%; margin-top: 1em">Finds C-style
array types and recommend to use <b>std::array&lt;&gt;</b> /
<b>std::vector&lt;&gt;</b>. All types of C arrays are
diagnosed.</p>

<p style="margin-left:9%; margin-top: 1em">However, fix-it
are potentially dangerous in header files and are therefore
not emitted right now.</p>

<p style="margin-left:13%; margin-top: 1em">int a[] = {1,
2}; // warning: do not declare C-style arrays, use
std::array&lt;&gt; instead</p>

<p style="margin-left:13%; margin-top: 1em">int b[1]; //
warning: do not declare C-style arrays, use
std::array&lt;&gt; instead</p>

<p style="margin-left:13%; margin-top: 1em">void foo() {
<br>
int c[b[0]]; // warning: do not declare C VLA arrays, use
std::vector&lt;&gt; instead <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T, int Size&gt; <br>
class array { <br>
T d[Size]; // warning: do not declare C-style arrays, use
std::array&lt;&gt; instead</p>

<p style="margin-left:13%; margin-top: 1em">int e[1]; //
warning: do not declare C-style arrays, use
std::array&lt;&gt; instead <br>
};</p>


<p style="margin-left:13%; margin-top: 1em">array&lt;int[4],
2&gt; d; // warning: do not declare C-style arrays, use
std::array&lt;&gt; instead</p>

<p style="margin-left:13%; margin-top: 1em">using k =
int[4]; // warning: do not declare C-style arrays, use
std::array&lt;&gt; instead</p>

<p style="margin-left:9%; margin-top: 1em">However, the
<b>extern &quot;C&quot;</b> code is ignored, since it is
common to share such headers between C code, and C++
code.</p>

<p style="margin-left:13%; margin-top: 1em">// Some header
<br>
extern &quot;C&quot; {</p>

<p style="margin-left:13%; margin-top: 1em">int f[] = {1,
2}; // not diagnosed</p>

<p style="margin-left:13%; margin-top: 1em">int j[1]; //
not diagnosed</p>

<p style="margin-left:13%; margin-top: 1em">inline void
bar() { <br>
{ <br>
int j[j[0]]; // not diagnosed <br>
} <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">}</p>

<p style="margin-left:9%; margin-top: 1em">Similarly, the
<b>main()</b> function is ignored. Its second and third
parameters can be either <b>char* argv[]</b> or <b>char**
argv</b>, but cannot be <b>std::array&lt;&gt;</b>. <b><br>
AllowStringArrays</b></p>

<p style="margin-left:18%;">When set to <i>true</i>
(default is <i>false</i>), variables of character array type
with deduced length, initialized directly from string
literals, will be ignored. This option doesn't affect cases
where length can't be deduced, resembling pointers, as seen
in class members and parameters. Example:</p>

<p style="margin-left:22%; margin-top: 1em">const char
name[] = &quot;Some name&quot;;</p>

<h3>modernize-concat-nested-namespaces
<a name="modernize-concat-nested-namespaces"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for use
of nested namespaces such as <b>namespace a { namespace b {
... } }</b> and suggests changing to the more concise syntax
introduced in C++17: <b>namespace a::b { ... }</b>. Inline
namespaces are not modified.</p>

<p style="margin-left:9%; margin-top: 1em">For example:</p>

<p style="margin-left:13%; margin-top: 1em">namespace n1 {
<br>
namespace n2 { <br>
void t(); <br>
} <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">namespace n3 {
<br>
namespace n4 { <br>
namespace n5 { <br>
void t(); <br>
} <br>
} <br>
namespace n6 { <br>
namespace n7 { <br>
void t(); <br>
} <br>
} <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// in c++20
<br>
namespace n8 { <br>
inline namespace n9 { <br>
void t(); <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Will be modified
to:</p>

<p style="margin-left:13%; margin-top: 1em">namespace
n1::n2 { <br>
void t(); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">namespace n3 {
<br>
namespace n4::n5 { <br>
void t(); <br>
} <br>
namespace n6::n7 { <br>
void t(); <br>
} <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// in c++20
<br>
namespace n8::inline n9 { <br>
void t(); <br>
}</p>

<h3>modernize-deprecated-headers
<a name="modernize-deprecated-headers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Some headers
from C library were deprecated in C++ and are no longer
welcome in C++ codebases. Some have no effect in C++. For
more details refer to the C++14 Standard [depr.c.headers]
section.</p>

<p style="margin-left:9%; margin-top: 1em">This check
replaces C standard library headers with their C++
alternatives and removes redundant ones.</p>

<p style="margin-left:13%; margin-top: 1em">// C++ source
file... <br>
#include &lt;assert.h&gt; <br>
#include &lt;stdbool.h&gt;</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;cassert&gt; <br>
// No 'stdbool.h' here.</p>

<p style="margin-left:9%; margin-top: 1em">Important note:
the Standard doesn't guarantee that the C++ headers declare
all the same functions in the global namespace. The check in
its current form can break the code that uses library
symbols from the global namespace.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;assert.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;complex.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;ctype.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;errno.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;fenv.h&gt;</i> // deprecated since C++11</p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;float.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;inttypes.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;limits.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;locale.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;math.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;setjmp.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;signal.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;stdarg.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;stddef.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;stdint.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;stdio.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;stdlib.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;string.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;tgmath.h&gt;</i> // deprecated since C++11</p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;time.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;uchar.h&gt;</i> // deprecated since C++11</p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;wchar.h&gt;</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p><i>&lt;wctype.h&gt;</i></p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">If the specified
standard is older than C++11 the check will only replace
headers deprecated before C++11, otherwise -- every header
that appeared in the previous list.</p>

<p style="margin-left:9%; margin-top: 1em">These headers
don't have effect in C++:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="15%">


<p style="margin-top: 1em"><i>&lt;iso646.h&gt;</i></p></td>
<td width="73%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="15%">


<p><i>&lt;stdalign.h&gt;</i></p></td>
<td width="73%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="15%">


<p><i>&lt;stdbool.h&gt;</i></p></td>
<td width="73%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">The checker
ignores <i>include</i> directives within <i>extern
&quot;C&quot; { ... }</i> blocks, since a library might want
to expose some API for C and C++ libraries.</p>

<p style="margin-left:13%; margin-top: 1em">// C++ source
file... <br>
extern &quot;C&quot; { <br>
#include &lt;assert.h&gt; // Left intact. <br>
#include &lt;stdbool.h&gt; // Left intact. <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>CheckHeaderFile</b></p>

<p style="margin-left:18%;"><i>clang-tidy</i> cannot know
if the header file included by the currently analyzed C++
source file is not included by any other C source files.
Hence, to omit false-positives and wrong fixit-hints, we
ignore emitting reports into header files. One can set this
option to <i>true</i> if they know that the header files in
the project are only used by C++ source file. Default is
<i>false</i>.</p>

<h3>modernize-deprecated-ios-base-aliases
<a name="modernize-deprecated-ios-base-aliases"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects usage of
the deprecated member types of <b>std::ios_base</b> and
replaces those that have a non-deprecated equivalent.</p>

<h3>modernize-loop-convert
<a name="modernize-loop-convert"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
converts <b>for(...; ...; ...)</b> loops to use the new
range-based loops in C++11.</p>

<p style="margin-left:9%; margin-top: 1em">Three kinds of
loops can be converted:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="76%">


<p>Loops over statically allocated arrays.</p></td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="76%">


<p>Loops over containers, using iterators.</p></td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="76%">


<p>Loops over array-like containers, using
<b>operator[]</b> and <b>at()</b>.</p></td>
<td width="12%">
</td></tr>
</table>

<h3>MinConfidence option
<a name="MinConfidence option"></a>
</h3>


<h3>risky
<a name="risky"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">In loops where
the container expression is more complex than just a
reference to a declared expression (a variable, function,
enum, etc.), and some part of it appears elsewhere in the
loop, we lower our confidence in the transformation due to
the increased risk of changing semantics. Transformations
for these loops are marked as <i>risky</i>, and thus will
only be converted if the minimum required confidence level
is set to <i>risky</i>.</p>

<p style="margin-left:13%; margin-top: 1em">int
arr[10][20]; <br>
int l = 5;</p>

<p style="margin-left:13%; margin-top: 1em">for (int j = 0;
j &lt; 20; ++j) <br>
int k = arr[l][j] + l; // using l outside arr[l] is
considered risky</p>

<p style="margin-left:13%; margin-top: 1em">for (int i = 0;
i &lt; obj.getVector().size(); ++i) <br>
obj.foo(10); // using 'obj' is considered risky</p>

<p style="margin-left:9%; margin-top: 1em">See
<i>Range-based loops evaluate end() only once</i> for an
example of an incorrect transformation when the minimum
required confidence level is set to <i>risky</i>.</p>

<h3>reasonable (Default)
<a name="reasonable (Default)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">If a loop calls
<b>.end()</b> or <b>.size()</b> after each iteration, the
transformation for that loop is marked as <i>reasonable</i>,
and thus will be converted if the required confidence level
is set to <i>reasonable</i> (default) or lower.</p>

<p style="margin-left:13%; margin-top: 1em">// using size()
is considered reasonable <br>
for (int i = 0; i &lt; container.size(); ++i) <br>
cout &lt;&lt; container[i];</p>

<h3>safe
<a name="safe"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Any other loops
that do not match the above criteria to be marked as
<i>risky</i> or <i>reasonable</i> are marked <i>safe</i>,
and thus will be converted if the required confidence level
is set to <i>safe</i> or lower.</p>

<p style="margin-left:13%; margin-top: 1em">int arr[] =
{1,2,3};</p>

<p style="margin-left:13%; margin-top: 1em">for (int i = 0;
i &lt; 3; ++i) <br>
cout &lt;&lt; arr[i];</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Original:</p>

<p style="margin-left:13%; margin-top: 1em">const int N =
5; <br>
int arr[] = {1,2,3,4,5}; <br>
vector&lt;int&gt; v; <br>
v.push_back(1); <br>
v.push_back(2); <br>
v.push_back(3);</p>

<p style="margin-left:13%; margin-top: 1em">// safe
conversion <br>
for (int i = 0; i &lt; N; ++i) <br>
cout &lt;&lt; arr[i];</p>

<p style="margin-left:13%; margin-top: 1em">// reasonable
conversion <br>
for (vector&lt;int&gt;::iterator it = v.begin(); it !=
v.end(); ++it) <br>
cout &lt;&lt; *it;</p>

<p style="margin-left:13%; margin-top: 1em">// reasonable
conversion <br>
for (vector&lt;int&gt;::iterator it = begin(v); it !=
end(v); ++it) <br>
cout &lt;&lt; *it;</p>

<p style="margin-left:13%; margin-top: 1em">// reasonable
conversion <br>
for (vector&lt;int&gt;::iterator it = std::begin(v); it !=
std::end(v); ++it) <br>
cout &lt;&lt; *it;</p>

<p style="margin-left:13%; margin-top: 1em">// reasonable
conversion <br>
for (int i = 0; i &lt; v.size(); ++i) <br>
cout &lt;&lt; v[i];</p>

<p style="margin-left:13%; margin-top: 1em">// reasonable
conversion <br>
for (int i = 0; i &lt; size(v); ++i) <br>
cout &lt;&lt; v[i];</p>

<p style="margin-left:9%; margin-top: 1em">After applying
the check with minimum confidence level set to
<i>reasonable</i> (default):</p>

<p style="margin-left:13%; margin-top: 1em">const int N =
5; <br>
int arr[] = {1,2,3,4,5}; <br>
vector&lt;int&gt; v; <br>
v.push_back(1); <br>
v.push_back(2); <br>
v.push_back(3);</p>

<p style="margin-left:13%; margin-top: 1em">// safe
conversion <br>
for (auto &amp; elem : arr) <br>
cout &lt;&lt; elem;</p>

<p style="margin-left:13%; margin-top: 1em">// reasonable
conversion <br>
for (auto &amp; elem : v) <br>
cout &lt;&lt; elem;</p>

<p style="margin-left:13%; margin-top: 1em">// reasonable
conversion <br>
for (auto &amp; elem : v) <br>
cout &lt;&lt; elem;</p>

<h3>Reverse Iterator Support
<a name="Reverse Iterator Support"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The converter is
also capable of transforming iterator loops which use
<b>rbegin</b> and <b>rend</b> for looping backwards over a
container. Out of the box this will automatically happen in
C++20 mode using the <b>ranges</b> library, however the
check can be configured to work without C++20 by specifying
a function to reverse a range and optionally the header file
where that function lives. <b><br>
UseCxx20ReverseRanges</b></p>

<p style="margin-left:18%;">When set to true convert loops
when in C++20 or later mode using
<b>std::ranges::reverse_view</b>. Default value is
<b>true</b>.</p>


<p style="margin-left:9%;"><b>MakeReverseRangeFunction</b></p>

<p style="margin-left:18%;">Specify the function used to
reverse an iterator pair, the function should accept a class
with <b>rbegin</b> and <b>rend</b> methods and return a
class with <b>begin</b> and <b>end</b> methods that call the
<b>rbegin</b> and <b>rend</b> methods respectively. Common
examples are <b>ranges::reverse_view</b> and
<b>llvm::reverse</b>. Default value is an empty string.</p>


<p style="margin-left:9%;"><b>MakeReverseRangeHeader</b></p>

<p style="margin-left:18%;">Specifies the header file where
<i>MakeReverseRangeFunction</i> is declared. For the
previous examples this option would be set to
<b>range/v3/view/reverse.hpp</b> and
<b>llvm/ADT/STLExtras.h</b> respectively. If this is an
empty string and <i>MakeReverseRangeFunction</i> is set, the
check will proceed on the assumption that the function is
already available in the translation unit. This can be
wrapped in angle brackets to signify to add the include as a
system include. Default value is an empty string.</p>

<p style="margin-left:9%;"><b>IncludeStyle</b></p>

<p style="margin-left:18%;">A string specifying which
include-style is used, <i>llvm</i> or <i>google</i>. Default
is <i>llvm</i>.</p>

<h3>Limitations
<a name="Limitations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">There are
certain situations where the tool may erroneously perform
transformations that remove information and change
semantics. Users of the tool should be aware of the behavior
and limitations of the check outlined by the cases
below.</p>

<h3>Comments inside loop headers
<a name="Comments inside loop headers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Comments inside
the original loop header are ignored and deleted when
transformed.</p>

<p style="margin-left:13%; margin-top: 1em">for (int i = 0;
i &lt; N; /* This will be deleted */ ++i) { }</p>

<h3>Range-based loops evaluate end() only once
<a name="Range-based loops evaluate end() only once"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The C++11
range-based for loop calls <b>.end()</b> only once during
the initialization of the loop. If in the original loop
<b>.end()</b> is called after each iteration the semantics
of the transformed loop may differ.</p>

<p style="margin-left:13%; margin-top: 1em">// The
following is semantically equivalent to the C++11
range-based for loop, <br>
// therefore the semantics of the header will not change.
<br>
for (iterator it = container.begin(), e = container.end();
it != e; ++it) { }</p>

<p style="margin-left:13%; margin-top: 1em">// Instead of
calling .end() after each iteration, this loop will be <br>
// transformed to call .end() only once during the
initialization of the loop, <br>
// which may affect semantics. <br>
for (iterator it = container.begin(); it != container.end();
++it) { }</p>

<p style="margin-left:9%; margin-top: 1em">As explained
above, calling member functions of the container in the body
of the loop is considered <i>risky</i>. If the called member
function modifies the container the semantics of the
converted loop will differ due to <b>.end()</b> being called
only once.</p>

<p style="margin-left:13%; margin-top: 1em">bool flag =
false; <br>
for (vector&lt;T&gt;::iterator it = vec.begin(); it !=
vec.end(); ++it) { <br>
// Add a copy of the first element to the end of the vector.
<br>
if (!flag) { <br>
// This line makes this transformation 'risky'. <br>
vec.push_back(*it); <br>
flag = true; <br>
} <br>
cout &lt;&lt; *it; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The original
code above prints out the contents of the container
including the newly added element while the converted loop,
shown below, will only print the original contents and not
the newly added element.</p>

<p style="margin-left:13%; margin-top: 1em">bool flag =
false; <br>
for (auto &amp; elem : vec) { <br>
// Add a copy of the first element to the end of the vector.
<br>
if (!flag) { <br>
// This line makes this transformation 'risky' <br>
vec.push_back(elem); <br>
flag = true; <br>
} <br>
cout &lt;&lt; elem; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Semantics will
also be affected if <b>.end()</b> has side effects. For
example, in the case where calls to <b>.end()</b> are logged
the semantics will change in the transformed loop if
<b>.end()</b> was originally called after each
iteration.</p>

<p style="margin-left:13%; margin-top: 1em">iterator end()
{ <br>
num_of_end_calls++; <br>
return container.end(); <br>
}</p>

<h3>Overloaded operator-&gt;() with side effects
<a name="Overloaded operator-&gt;() with side effects"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Similarly, if
<b>operator-&gt;()</b> was overloaded to have side effects,
such as logging, the semantics will change. If the
iterator's <b>operator-&gt;()</b> was used in the original
loop it will be replaced with <b>&lt;container
element&gt;.&lt;member&gt;</b> instead due to the implicit
dereference as part of the range-based for loop. Therefore
any side effect of the overloaded <b>operator-&gt;()</b>
will no longer be performed.</p>

<p style="margin-left:13%; margin-top: 1em">for (iterator
it = c.begin(); it != c.end(); ++it) { <br>
it-&gt;func(); // Using operator-&gt;() <br>
} <br>
// Will be transformed to: <br>
for (auto &amp; elem : c) { <br>
elem.func(); // No longer using operator-&gt;() <br>
}</p>

<h3>Pointers and references to containers
<a name="Pointers and references to containers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">While most of
the check's risk analysis is dedicated to determining
whether the iterator or container was modified within the
loop, it is possible to circumvent the analysis by accessing
and modifying the container through a pointer or
reference.</p>

<p style="margin-left:9%; margin-top: 1em">If the container
were directly used instead of using the pointer or reference
the following transformation would have only been applied at
the <i>risky</i> level since calling a member function of
the container is considered <i>risky</i>. The check cannot
identify expressions associated with the container that are
different than the one used in the loop header, therefore
the transformation below ends up being performed at the
<i>safe</i> level.</p>


<p style="margin-left:13%; margin-top: 1em">vector&lt;int&gt;
vec;</p>


<p style="margin-left:13%; margin-top: 1em">vector&lt;int&gt;
*ptr = &amp;vec; <br>
vector&lt;int&gt; &amp;ref = vec;</p>

<p style="margin-left:13%; margin-top: 1em">for
(vector&lt;int&gt;::iterator it = vec.begin(), e =
vec.end(); it != e; ++it) { <br>
if (!flag) { <br>
// Accessing and modifying the container is considered
risky, but the risk <br>
// level is not raised here. <br>
ptr-&gt;push_back(*it); <br>
ref.push_back(*it); <br>
flag = true; <br>
} <br>
}</p>

<h3>OpenMP
<a name="OpenMP"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">As range-based
for loops are only available since OpenMP 5, this check
should not be used on code with a compatibility requirement
of OpenMP prior to version 5. It is <b>intentional</b> that
this check does not make any attempts to exclude incorrect
diagnostics on OpenMP for loops prior to OpenMP 5.</p>

<p style="margin-left:9%; margin-top: 1em">To prevent this
check to be applied (and to break) OpenMP for loops but
still be applied to non-OpenMP for loops the usage of
<b>NOLINT</b> (see <i>Suppressing Undesired Diagnostics</i>)
on the specific for loops is recommended.</p>

<h3>modernize-macro-to-enum
<a name="modernize-macro-to-enum"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Replaces groups
of adjacent macros with an unscoped anonymous enum. Using an
unscoped anonymous enum ensures that everywhere the macro
token was used previously, the enumerator name may be safely
used.</p>

<p style="margin-left:9%; margin-top: 1em">This check can
be used to enforce the C++ core guideline <i>Enum.1: Prefer
enumerations over macros</i>, within the constraints
outlined below.</p>

<p style="margin-left:9%; margin-top: 1em">Potential macros
for replacement must meet the following constraints:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Macros must expand only to integral literal tokens or
expressions of literal tokens. The expression may contain
any of the unary operators <b>-</b>, <b>+</b>, <b>&#732;</b>
or <b>!</b>, any of the binary operators <b>,</b>, <b>-</b>,
<b>+</b>, <b>*</b>, <b>/</b>, <b>%</b>, <b>&amp;</b>,
<b>|</b>, <b>&#710;</b>, <b>&lt;</b>, <b>&gt;</b>,
<b>&lt;=</b>, <b>&gt;=</b>, <b>==</b>, <b>!=</b>, <b>||</b>,
<b>&amp;&amp;</b>, <b>&lt;&lt;</b>, <b>&gt;&gt;</b> or
<b>&lt;=&gt;</b>, the ternary operator <b>?:</b> and its
<i>GNU extension</i>. Parenthesized expressions are also
recognized. This recognizes most valid expressions. In
particular, expressions with the <b>sizeof</b> operator are
not recognized.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Macros must be defined on sequential source file lines,
or with only comment lines in between macro definitions.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Macros must all be defined in the same source file.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Macros must not be defined within a conditional
compilation block. (Conditional include guards are exempt
from this constraint.)</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Macros must not be defined adjacent to other
preprocessor directives.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Macros must not be used in any conditional preprocessing
directive.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Macros must not be used as arguments to other
macros.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Macros must not be undefined.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Macros must be defined at the top-level, not inside any
declaration or definition.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Each cluster of
macros meeting the above constraints is presumed to be a set
of values suitable for replacement by an anonymous enum.
From there, a developer can give the anonymous enum a name
and continue refactoring to a scoped enum if desired.
Comments on the same line as a macro definition or between
subsequent macro definitions are preserved in the output. No
formatting is assumed in the provided replacements, although
clang-tidy can optionally format all fixes.</p>


<p style="margin-left:9%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:13%;">Initializing expressions are
assumed to be valid initializers for an enum. C requires
that enum values fit into an <b>int</b>, but this may not be
the case for some accepted constant expressions. For
instance <b>1 &lt;&lt; 40</b> will not fit into an
<b>int</b> when the size of an <b>int</b> is 32 bits.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">#define RED
0xFF0000 <br>
#define GREEN 0x00FF00 <br>
#define BLUE 0x0000FF</p>

<p style="margin-left:13%; margin-top: 1em">#define TM_NONE
(-1) // No method selected. <br>
#define TM_ONE 1 // Use tailored method one. <br>
#define TM_TWO 2 // Use tailored method two. Method two <br>
// is preferable to method one. <br>
#define TM_THREE 3 // Use tailored method three.</p>

<p style="margin-left:9%; margin-top: 1em">becomes</p>

<p style="margin-left:13%; margin-top: 1em">enum { <br>
RED = 0xFF0000, <br>
GREEN = 0x00FF00, <br>
BLUE = 0x0000FF <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">enum { <br>
TM_NONE = (-1), // No method selected. <br>
TM_ONE = 1, // Use tailored method one. <br>
TM_TWO = 2, // Use tailored method two. Method two <br>
// is preferable to method one. <br>
TM_THREE = 3 // Use tailored method three. <br>
};</p>

<h3>modernize-make-shared
<a name="modernize-make-shared"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check finds
the creation of <b>std::shared_ptr</b> objects by explicitly
calling the constructor and a <b>new</b> expression, and
replaces it with a call to <b>std::make_shared</b>.</p>

<p style="margin-left:13%; margin-top: 1em">auto my_ptr =
std::shared_ptr&lt;MyPair&gt;(new MyPair(1, 2));</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">auto my_ptr =
std::make_shared&lt;MyPair&gt;(1, 2);</p>

<p style="margin-left:9%; margin-top: 1em">This check also
finds calls to <b>std::shared_ptr::reset()</b> with a
<b>new</b> expression, and replaces it with a call to
<b>std::make_shared</b>.</p>


<p style="margin-left:13%; margin-top: 1em">my_ptr.reset(new
MyPair(1, 2));</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">my_ptr =
std::make_shared&lt;MyPair&gt;(1, 2);</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>MakeSmartPtrFunction</b></p>

<p style="margin-left:18%;">A string specifying the name of
make-shared-ptr function. Default is
<i>std::make_shared</i>.</p>


<p style="margin-left:9%;"><b>MakeSmartPtrFunctionHeader</b></p>

<p style="margin-left:18%;">A string specifying the
corresponding header of make-shared-ptr function. Default is
<i>memory</i>.</p>

<p style="margin-left:9%;"><b>IncludeStyle</b></p>

<p style="margin-left:18%;">A string specifying which
include-style is used, <i>llvm</i> or <i>google</i>. Default
is <i>llvm</i>.</p>

<p style="margin-left:9%;"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, the
check will not give warnings inside macros. Default is
<i>true</i>.</p>


<p style="margin-left:9%;"><b>IgnoreDefaultInitialization</b></p>

<p style="margin-left:18%;">If set to non-zero, the check
does not suggest edits that will transform default
initialization into value initialization, as this can cause
performance regressions. Default is <i>1</i>.</p>

<h3>modernize-make-unique
<a name="modernize-make-unique"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check finds
the creation of <b>std::unique_ptr</b> objects by explicitly
calling the constructor and a <b>new</b> expression, and
replaces it with a call to <b>std::make_unique</b>,
introduced in C++14.</p>

<p style="margin-left:13%; margin-top: 1em">auto my_ptr =
std::unique_ptr&lt;MyPair&gt;(new MyPair(1, 2));</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">auto my_ptr =
std::make_unique&lt;MyPair&gt;(1, 2);</p>

<p style="margin-left:9%; margin-top: 1em">This check also
finds calls to <b>std::unique_ptr::reset()</b> with a
<b>new</b> expression, and replaces it with a call to
<b>std::make_unique</b>.</p>


<p style="margin-left:13%; margin-top: 1em">my_ptr.reset(new
MyPair(1, 2));</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">my_ptr =
std::make_unique&lt;MyPair&gt;(1, 2);</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>MakeSmartPtrFunction</b></p>

<p style="margin-left:18%;">A string specifying the name of
make-unique-ptr function. Default is
<i>std::make_unique</i>.</p>


<p style="margin-left:9%;"><b>MakeSmartPtrFunctionHeader</b></p>

<p style="margin-left:18%;">A string specifying the
corresponding header of make-unique-ptr function. Default is
<i>&lt;memory&gt;</i>.</p>

<p style="margin-left:9%;"><b>IncludeStyle</b></p>

<p style="margin-left:18%;">A string specifying which
include-style is used, <i>llvm</i> or <i>google</i>. Default
is <i>llvm</i>.</p>

<p style="margin-left:9%;"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, the
check will not give warnings inside macros. Default is
<i>true</i>.</p>


<p style="margin-left:9%;"><b>IgnoreDefaultInitialization</b></p>

<p style="margin-left:18%;">If set to non-zero, the check
does not suggest edits that will transform default
initialization into value initialization, as this can cause
performance regressions. Default is <i>1</i>.</p>

<h3>modernize-min-max-use-initializer-list
<a name="modernize-min-max-use-initializer-list"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Replaces nested
<b>std::min</b> and <b>std::max</b> calls with an
initializer list where applicable.</p>

<p style="margin-left:9%; margin-top: 1em">For instance,
consider the following code:</p>

<p style="margin-left:13%; margin-top: 1em">int a =
std::max(std::max(i, j), k);</p>

<p style="margin-left:9%; margin-top: 1em">The check will
transform the above code to:</p>

<p style="margin-left:13%; margin-top: 1em">int a =
std::max({i, j, k});</p>

<h3>Performance Considerations
<a name="Performance Considerations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">While this check
simplifies the code and makes it more readable, it may cause
performance degradation for non-trivial types due to the
need to copy objects into the initializer list.</p>

<p style="margin-left:9%; margin-top: 1em">To avoid this,
it is recommended to use <i>std::ref</i> or <i>std::cref</i>
for non-trivial types:</p>

<p style="margin-left:13%; margin-top: 1em">std::string b =
std::max({std::ref(i), std::ref(j), std::ref(k)});</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IncludeStyle</b></p>

<p style="margin-left:18%;">A string specifying which
include-style is used, <i>llvm</i> or <i>google</i>. Default
is <i>llvm</i>.</p>


<p style="margin-left:9%;"><b>IgnoreNonTrivialTypes</b></p>

<p style="margin-left:18%;">A boolean specifying whether to
ignore non-trivial types. Default is <i>true</i>.</p>


<p style="margin-left:9%;"><b>IgnoreTrivialTypesOfSizeAbove</b></p>

<p style="margin-left:18%;">An integer specifying the size
(in bytes) above which trivial types are ignored. Default is
<i>32</i>.</p>

<h3>modernize-pass-by-value
<a name="modernize-pass-by-value"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">With move
semantics added to the language and the standard library
updated with move constructors added for many types it is
now interesting to take an argument directly by value,
instead of by const-reference, and then copy. This check
allows the compiler to take care of choosing the best way to
construct the copy.</p>

<p style="margin-left:9%; margin-top: 1em">The
transformation is usually beneficial when the calling code
passes an <i>rvalue</i> and assumes the move construction is
a cheap operation. This short example illustrates how the
construction of the value happens:</p>

<p style="margin-left:13%; margin-top: 1em">void
foo(std::string s); <br>
std::string get_str();</p>

<p style="margin-left:13%; margin-top: 1em">void f(const
std::string &amp;str) { <br>
foo(str); // lvalue -&gt; copy construction <br>
foo(get_str()); // prvalue -&gt; move construction <br>
}</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">Currently, only constructors
are transformed to make use of pass-by-value. Contributions
that handle other situations are welcome!</p>

<h3>Pass-by-value in constructors
<a name="Pass-by-value in constructors"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Replaces the
uses of const-references constructor parameters that are
copied into class fields. The parameter is then moved with
<i>std::move()</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Since
<b>std::move()</b> is a library function declared in
<i>&lt;utility&gt;</i> it may be necessary to add this
include. The check will add the include directive when
necessary.</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;string&gt;</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
public: <br>
- Foo(const std::string &amp;Copied, const std::string
&amp;ReadOnly) <br>
- : Copied(Copied), ReadOnly(ReadOnly) <br>
+ Foo(std::string Copied, const std::string &amp;ReadOnly)
<br>
+ : Copied(std::move(Copied)), ReadOnly(ReadOnly) <br>
{}</p>

<p style="margin-left:13%; margin-top: 1em">private: <br>
std::string Copied; <br>
const std::string &amp;ReadOnly; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">std::string
get_cwd();</p>

<p style="margin-left:13%; margin-top: 1em">void f(const
std::string &amp;Path) { <br>
// The parameter corresponding to 'get_cwd()' is
move-constructed. By <br>
// using pass-by-value in the Foo constructor we managed to
avoid a <br>
// copy-construction. <br>
Foo foo(get_cwd(), Path); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">If the parameter
is used more than once no transformation is performed since
moved objects have an undefined state. It means the
following code will be left untouched:</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;string&gt;</p>

<p style="margin-left:13%; margin-top: 1em">void pass(const
std::string &amp;S);</p>

<p style="margin-left:13%; margin-top: 1em">struct Foo {
<br>
Foo(const std::string &amp;S) : Str(S) { <br>
pass(S); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">std::string
Str; <br>
};</p>

<h3>Known limitations
<a name="Known limitations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">A situation
where the generated code can be wrong is when the object
referenced is modified before the assignment in the
init-list through a &quot;hidden&quot; reference.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">std::string
s(&quot;foo&quot;);</p>

<p style="margin-left:13%; margin-top: 1em">struct Base {
<br>
Base() { <br>
s = &quot;bar&quot;; <br>
} <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">struct Derived
: Base { <br>
- Derived(const std::string &amp;S) : Field(S) <br>
+ Derived(std::string S) : Field(std::move(S)) <br>
{ }</p>

<p style="margin-left:13%; margin-top: 1em">std::string
Field; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">void f() { <br>
- Derived d(s); // d.Field holds &quot;bar&quot; <br>
+ Derived d(s); // d.Field holds &quot;foo&quot; <br>
}</p>

<h3>Note about delayed template parsing
<a name="Note about delayed template parsing"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">When delayed
template parsing is enabled, constructors part of templated
contexts; templated constructors, constructors in class
templates, constructors of inner classes of template
classes, etc., are not transformed. Delayed template parsing
is enabled by default on Windows as a Microsoft extension:
<i>Clang Compiler User's Manual - Microsoft
extensions</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Delayed template
parsing can be enabled using the
<i>-fdelayed-template-parsing</i> flag and disabled using
<i>-fno-delayed-template-parsing</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T&gt; class C { <br>
std::string S;</p>

<p style="margin-left:13%; margin-top: 1em">public: <br>
= // using -fdelayed-template-parsing (default on Windows)
<br>
= C(const std::string &amp;S) : S(S) {}</p>

<p style="margin-left:13%; margin-top: 1em">+ // using
-fno-delayed-template-parsing (default on non-Windows
systems) <br>
+ C(std::string S) : S(std::move(S)) {} <br>
};</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">For more information about the
pass-by-value idiom, read: <i>Want Speed? Pass by
Value</i>.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IncludeStyle</b></p>

<p style="margin-left:18%;">A string specifying which
include-style is used, <i>llvm</i> or <i>google</i>. Default
is <i>llvm</i>.</p>

<p style="margin-left:9%;"><b>ValuesOnly</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
only warns about copied parameters that are already passed
by value. Default is <i>false</i>.</p>

<h3>modernize-raw-string-literal
<a name="modernize-raw-string-literal"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
selectively replaces string literals containing escaped
characters with raw string literals.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">const char
*const Quotes{&quot;embedded \&quot;quotes\&quot;&quot;};
<br>
const char *const Paragraph{&quot;Line one.\nLine two.\nLine
three.\n&quot;}; <br>
const char *const SingleLine{&quot;Single line.\n&quot;};
<br>
const char *const TrailingSpace{&quot;Look here -&gt;
\n&quot;}; <br>
const char *const Tab{&quot;One\tTwo\n&quot;}; <br>
const char *const Bell{&quot;Hello!\a And welcome!&quot;};
<br>
const char *const Path{&quot;C:\\Program
Files\\Vendor\\Application.exe&quot;}; <br>
const char *const RegEx{&quot;\\w\\([a-z]\\)&quot;};</p>

<p style="margin-left:9%; margin-top: 1em">becomes</p>

<p style="margin-left:13%; margin-top: 1em">const char
*const Quotes{R&quot;(embedded &quot;quotes&quot;)&quot;};
<br>
const char *const Paragraph{&quot;Line one.\nLine two.\nLine
three.\n&quot;}; <br>
const char *const SingleLine{&quot;Single line.\n&quot;};
<br>
const char *const TrailingSpace{&quot;Look here -&gt;
\n&quot;}; <br>
const char *const Tab{&quot;One\tTwo\n&quot;}; <br>
const char *const Bell{&quot;Hello!\a And welcome!&quot;};
<br>
const char *const Path{R&quot;(C:\Program
Files\Vendor\Application.exe)&quot;}; <br>
const char *const RegEx{R&quot;(\w\([a-z]\))&quot;};</p>

<p style="margin-left:9%; margin-top: 1em">The presence of
any of the following escapes can cause the string to be
converted to a raw string literal: <b>\\</b>, <b>\'</b>,
<b>\&quot;</b>, <b>\?</b>, and octal or hexadecimal escapes
for printable ASCII characters.</p>

<p style="margin-left:9%; margin-top: 1em">A string literal
containing only escaped newlines is a common way of writing
lines of text output. Introducing physical newlines with raw
string literals in this case is likely to impede
readability. These string literals are left unchanged.</p>

<p style="margin-left:9%; margin-top: 1em">An escaped
horizontal tab, form feed, or vertical tab prevents the
string literal from being converted. The presence of a
horizontal tab, form feed or vertical tab in source code is
not visually obvious. <b><br>
DelimiterStem</b></p>

<p style="margin-left:18%;">Custom delimiter to escape
characters in raw string literals. It is used in the
following construction:
<b>R&quot;stem_delimiter(contents)stem_delimiter&quot;</b>.
The default value is <i>lit</i>.</p>


<p style="margin-left:9%;"><b>ReplaceShorterLiterals</b></p>

<p style="margin-left:18%;">Controls replacing shorter
non-raw string literals with longer raw string literals.
Setting this option to <i>true</i> enables the replacement.
The default value is <i>false</i> (shorter literals are not
replaced).</p>

<h3>modernize-redundant-void-arg
<a name="modernize-redundant-void-arg"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Find and remove
redundant <b>void</b> argument lists. <b><br>
Examples:</b></p>

<h3>modernize-replace-auto-ptr
<a name="modernize-replace-auto-ptr"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
replaces the uses of the deprecated class
<b>std::auto_ptr</b> by <b>std::unique_ptr</b> (introduced
in C++11). The transfer of ownership, done by the
copy-constructor and the assignment operator, is changed to
match <b>std::unique_ptr</b> usage by using explicit calls
to <b>std::move()</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Migration
example:</p>

<p style="margin-left:13%; margin-top: 1em">-void
take_ownership_fn(std::auto_ptr&lt;int&gt; int_ptr); <br>
+void take_ownership_fn(std::unique_ptr&lt;int&gt;
int_ptr);</p>

<p style="margin-left:13%; margin-top: 1em">void f(int x) {
<br>
- std::auto_ptr&lt;int&gt; a(new int(x)); <br>
- std::auto_ptr&lt;int&gt; b; <br>
+ std::unique_ptr&lt;int&gt; a(new int(x)); <br>
+ std::unique_ptr&lt;int&gt; b;</p>

<p style="margin-left:13%; margin-top: 1em">- b = a; <br>
- take_ownership_fn(b); <br>
+ b = std::move(a); <br>
+ take_ownership_fn(std::move(b)); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Since
<b>std::move()</b> is a library function declared in
<b>&lt;utility&gt;</b> it may be necessary to add this
include. The check will add the include directive when
necessary.</p>

<h3>Known Limitations
<a name="Known Limitations"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">If headers modification is not
activated or if a header is not allowed to be changed this
check will produce broken code (compilation error), where
the headers' code will stay unchanged while the code using
them will be changed.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Client code that declares a reference to an
<b>std::auto_ptr</b> coming from code that can't be migrated
(such as a header coming from a 3 <small>rd</small> party
library) will produce a compilation error after migration.
This is because the type of the reference will be changed to
<b>std::unique_ptr</b> but the type returned by the library
won't change, binding a reference to <b>std::unique_ptr</b>
from an <b>std::auto_ptr</b>. This pattern doesn't make much
sense and usually <b>std::auto_ptr</b> are stored by value
(otherwise what is the point in using them instead of a
reference or a pointer?).</p></td></tr>
</table>

<p style="margin-left:13%; margin-top: 1em">//
&lt;3rd-party header...&gt; <br>
std::auto_ptr&lt;int&gt; get_value(); <br>
const std::auto_ptr&lt;int&gt; &amp; get_ref();</p>

<p style="margin-left:13%; margin-top: 1em">// &lt;calling
code (with migration)...&gt; <br>
-std::auto_ptr&lt;int&gt; a(get_value()); <br>
+std::unique_ptr&lt;int&gt; a(get_value()); // ok,
unique_ptr constructed from auto_ptr</p>

<p style="margin-left:13%; margin-top: 1em">-const
std::auto_ptr&lt;int&gt; &amp; p = get_ptr(); <br>
+const std::unique_ptr&lt;int&gt; &amp; p = get_ptr(); //
won't compile</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="55%">


<p style="margin-top: 1em">Non-instantiated templates
aren't modified.</p></td>
<td width="33%">
</td></tr>
</table>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename X&gt; <br>
void f() { <br>
std::auto_ptr&lt;X&gt; p; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// only
'f&lt;int&gt;()' (or similar) will trigger the
replacement.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IncludeStyle</b></p>

<p style="margin-left:18%;">A string specifying which
include-style is used, <i>llvm</i> or <i>google</i>. Default
is <i>llvm</i>.</p>

<h3>modernize-replace-disallow-copy-and-assign-macro
<a name="modernize-replace-disallow-copy-and-assign-macro"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds macro
expansions of <b>DISALLOW_COPY_AND_ASSIGN(Type)</b> and
replaces them with a deleted copy constructor and a deleted
assignment operator.</p>

<p style="margin-left:9%; margin-top: 1em">Before the
<b>delete</b> keyword was introduced in C++11 it was common
practice to declare a copy constructor and an assignment
operator as private members. This effectively makes them
unusable to the public API of a class.</p>

<p style="margin-left:9%; margin-top: 1em">With the advent
of the <b>delete</b> keyword in C++11 we can abandon the
<b>private</b> access of the copy constructor and the
assignment operator and delete the methods entirely.</p>

<p style="margin-left:9%; margin-top: 1em">When running
this check on a code like this:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
private: <br>
DISALLOW_COPY_AND_ASSIGN(Foo); <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">It will be
transformed to this:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
private: <br>
Foo(const Foo &amp;) = delete; <br>
const Foo &amp;operator=(const Foo &amp;) = delete; <br>
};</p>

<h3>Known Limitations
<a name="Known Limitations"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Notice that the migration
example above leaves the <b>private</b> access specification
untouched. You might want to run the check
<i>modernize-use-equals-delete</i> to get warnings for
deleted functions in private sections.</p></td></tr>
</table>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>MacroName</b></p>

<p style="margin-left:18%;">A string specifying the macro
name whose expansion will be replaced. Default is
<i>DISALLOW_COPY_AND_ASSIGN</i>.</p>

<p style="margin-left:9%; margin-top: 1em">See: -
<i>https://en.cppreference.com/w/cpp/language/function#Deleted_functions</i></p>

<h3>modernize-replace-random-shuffle
<a name="modernize-replace-random-shuffle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check will
find occurrences of <b>std::random_shuffle</b> and replace
it with <b>std::shuffle</b>. In C++17
<b>std::random_shuffle</b> will no longer be available and
thus we need to replace it.</p>

<p style="margin-left:9%; margin-top: 1em">Below are two
examples of what kind of occurrences will be found and two
examples of what it will be replaced with.</p>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;int&gt;
v;</p>

<p style="margin-left:13%; margin-top: 1em">// First
example <br>
std::random_shuffle(vec.begin(), vec.end());</p>

<p style="margin-left:13%; margin-top: 1em">// Second
example <br>
std::random_shuffle(vec.begin(), vec.end(), randomFunc);</p>

<p style="margin-left:9%; margin-top: 1em">Both of these
examples will be replaced with:</p>


<p style="margin-left:13%; margin-top: 1em">std::shuffle(vec.begin(),
vec.end(), std::mt19937(std::random_device()()));</p>

<p style="margin-left:9%; margin-top: 1em">The second
example will also receive a warning that <b>randomFunc</b>
is no longer supported in the same way as before so if the
user wants the same functionality, the user will need to
change the implementation of the <b>randomFunc</b>.</p>

<p style="margin-left:9%; margin-top: 1em">One thing to be
aware of here is that <b>std::random_device</b> is quite
expensive to initialize. So if you are using the code in a
performance critical place, you probably want to initialize
it elsewhere. Another thing is that the seeding quality of
the suggested fix is quite poor: <b>std::mt19937</b> has an
internal state of 624 32-bit integers, but is only seeded
with a single integer. So if you require higher quality
randomness, you should consider seeding better, for
example:</p>


<p style="margin-left:13%; margin-top: 1em">std::shuffle(v.begin(),
v.end(), []() { <br>
std::mt19937::result_type seeds[std::mt19937::state_size];
<br>
std::random_device device; <br>
std::uniform_int_distribution&lt;typename
std::mt19937::result_type&gt; dist; <br>
std::generate(std::begin(seeds), std::end(seeds), [&amp;] {
return dist(device); }); <br>
std::seed_seq seq(std::begin(seeds), std::end(seeds)); <br>
return std::mt19937(seq); <br>
}());</p>

<h3>modernize-return-braced-init-list
<a name="modernize-return-braced-init-list"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Replaces
explicit calls to the constructor in a return with a braced
initializer list. This way the return type is not needlessly
duplicated in the function definition and the return
statement.</p>

<p style="margin-left:13%; margin-top: 1em">Foo bar() {
<br>
Baz baz; <br>
return Foo(baz); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// transforms
to:</p>

<p style="margin-left:13%; margin-top: 1em">Foo bar() {
<br>
Baz baz; <br>
return {baz}; <br>
}</p>

<h3>modernize-shrink-to-fit
<a name="modernize-shrink-to-fit"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Replace copy and
swap tricks on shrinkable containers with the
<b>shrink_to_fit()</b> method call.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>shrink_to_fit()</b> method is more readable and more
effective than the copy and swap trick to reduce the
capacity of a shrinkable container. Note that, the
<b>shrink_to_fit()</b> method is only available in C++11 and
up.</p>

<h3>modernize-type-traits
<a name="modernize-type-traits"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Converts
standard library type traits of the form
<b>traits&lt;...&gt;::type</b> and
<b>traits&lt;...&gt;::value</b> into
<b>traits_t&lt;...&gt;</b> and <b>traits_v&lt;...&gt;</b>
respectively.</p>

<p style="margin-left:9%; margin-top: 1em">For example:</p>


<p style="margin-left:13%; margin-top: 1em">std::is_integral&lt;T&gt;::value
<br>
std::is_same&lt;int, float&gt;::value <br>
typename std::add_const&lt;T&gt;::type <br>
std::make_signed&lt;unsigned&gt;::type</p>

<p style="margin-left:9%; margin-top: 1em">Would be
converted into:</p>


<p style="margin-left:13%; margin-top: 1em">std::is_integral_v&lt;T&gt;
<br>
std::is_same_v&lt;int, float&gt; <br>
std::add_const_t&lt;T&gt; <br>
std::make_signed_t&lt;unsigned&gt;</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">If <i>true</i> don't diagnose
traits defined in macros.</p>

<p style="margin-left:18%; margin-top: 1em">Note: Fixes
will never be emitted for code inside of macros.</p>

<p style="margin-left:22%; margin-top: 1em">#define
IS_SIGNED(T) std::is_signed&lt;T&gt;::value</p>

<p style="margin-left:18%; margin-top: 1em">Defaults to
<i>false</i>.</p>

<h3>modernize-unary-static-assert
<a name="modernize-unary-static-assert"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check
diagnoses any <b>static_assert</b> declaration with an empty
string literal and provides a fix-it to replace the
declaration with a single-argument <b>static_assert</b>
declaration.</p>

<p style="margin-left:9%; margin-top: 1em">The check is
only applicable for C++17 and later code.</p>

<p style="margin-left:9%; margin-top: 1em">The following
code:</p>

<p style="margin-left:13%; margin-top: 1em">void
f_textless(int a) { <br>
static_assert(sizeof(a) &lt;= 10, &quot;&quot;); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">is replaced
by:</p>

<p style="margin-left:13%; margin-top: 1em">void
f_textless(int a) { <br>
static_assert(sizeof(a) &lt;= 10); <br>
}</p>

<h3>modernize-use-auto
<a name="modernize-use-auto"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check is
responsible for using the <b>auto</b> type specifier for
variable declarations to <i>improve code readability and
maintainability</i>. For example:</p>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;int&gt;::iterator
I = my_container.begin();</p>

<p style="margin-left:13%; margin-top: 1em">// transforms
to:</p>

<p style="margin-left:13%; margin-top: 1em">auto I =
my_container.begin();</p>

<p style="margin-left:9%; margin-top: 1em">The <b>auto</b>
type specifier will only be introduced in situations where
the variable type matches the type of the initializer
expression. In other words <b>auto</b> should deduce the
same type that was originally spelled in the source.
However, not every situation should be transformed:</p>

<p style="margin-left:13%; margin-top: 1em">int val = 42;
<br>
InfoStruct &amp;I = SomeObject.getInfo();</p>

<p style="margin-left:13%; margin-top: 1em">// Should not
become:</p>

<p style="margin-left:13%; margin-top: 1em">auto val = 42;
<br>
auto &amp;I = SomeObject.getInfo();</p>

<p style="margin-left:9%; margin-top: 1em">In this example
using <b>auto</b> for builtins doesn't improve readability.
In other situations it makes the code less self-documenting
impairing readability and maintainability. As a result,
<b>auto</b> is used only introduced in specific situations
described below.</p>

<h3>Iterators
<a name="Iterators"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Iterator type
specifiers tend to be long and used frequently, especially
in loop constructs. Since the functions generating iterators
have a common format, the type specifier can be replaced
without obscuring the meaning of code while improving
readability and maintainability.</p>

<p style="margin-left:13%; margin-top: 1em">for
(std::vector&lt;int&gt;::iterator I = my_container.begin(),
<br>
E = my_container.end(); <br>
I != E; ++I) { <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">for (auto I =
my_container.begin(), E = my_container.end(); I != E; ++I) {
<br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The check will
only replace iterator type-specifiers when all of the
following conditions are satisfied:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="87%">


<p>The iterator is for one of the standard containers in
<b>std</b> namespace:</p></td>
<td width="1%">
</td></tr>
</table>

<p style="margin-left:12%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%"></td>
<td width="1%"></td>
<td width="23%">


<p style="margin-top: 1em"><b>array</b></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%">


<p><b>deque</b></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%">


<p><b>forward_list</b></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%">


<p><b>list</b></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%">


<p><b>vector</b></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%">


<p><b>map</b></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%">


<p><b>multimap</b></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%">


<p><b>set</b></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%">


<p><b>multiset</b></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%">


<p><b>unordered_map</b></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%">


<p><b>unordered_multimap</b></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%">


<p><b>unordered_set</b></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%">


<p><b>unordered_multiset</b></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%">


<p><b>queue</b></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%">


<p><b>priority_queue</b></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%">


<p><b>stack</b></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%"></td>
<td width="63%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">The iterator is
one of the possible iterator types for standard
containers:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="28%">


<p style="margin-top: 1em"><b>iterator</b></p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="28%">


<p><b>reverse_iterator</b></p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="28%">


<p><b>const_iterator</b></p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="28%">


<p><b>const_reverse_iterator</b></p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="28%"></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">In addition to
using iterator types directly, typedefs or other ways of
referring to those types are also allowed. However,
implementation-specific types for which a type like
<b>std::vector&lt;int&gt;::iterator</b> is itself a typedef
will not be transformed. Consider the following
examples:</p>

<p style="margin-left:13%; margin-top: 1em">// The
following direct uses of iterator types will be transformed.
<br>
std::vector&lt;int&gt;::iterator I = MyVec.begin(); <br>
{ <br>
using namespace std; <br>
list&lt;int&gt;::iterator I = MyList.begin(); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// The type
specifier for J would transform to auto since it's a typedef
<br>
// to a standard iterator type. <br>
typedef std::map&lt;int, std::string&gt;::const_iterator
map_iterator; <br>
map_iterator J = MyMap.begin();</p>

<p style="margin-left:13%; margin-top: 1em">// The
following implementation-specific iterator type for which
<br>
// std::vector&lt;int&gt;::iterator could be a typedef would
not be transformed. <br>
__gnu_cxx::__normal_iterator&lt;int*, std::vector&gt; K =
MyVec.begin();</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">The initializer for the variable
being declared is not a braced initializer list. Otherwise,
use of <b>auto</b> would cause the type of the variable to
be deduced as <b>std::initializer_list</b>.</p></td></tr>
</table>

<h3>New expressions
<a name="New expressions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Frequently, when
a pointer is declared and initialized with <b>new</b>, the
pointee type is written twice: in the declaration type and
in the <b>new</b> expression. In this case, the declaration
type can be replaced with <b>auto</b> improving readability
and maintainability.</p>

<p style="margin-left:13%; margin-top: 1em">TypeName
*my_pointer = new TypeName(my_param);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">auto
*my_pointer = new TypeName(my_param);</p>

<p style="margin-left:9%; margin-top: 1em">The check will
also replace the declaration type in multiple declarations,
if the following conditions are satisfied:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">All declared variables have the
same type (i.e. all of them are pointers to the same
type).</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>All declared variables are initialized with a <b>new</b>
expression.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>The types of all the new expressions are the same than
the pointee of the declaration type.</p></td></tr>
</table>

<p style="margin-left:13%; margin-top: 1em">TypeName
*my_first_pointer = new TypeName, *my_second_pointer = new
TypeName;</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">auto
*my_first_pointer = new TypeName, *my_second_pointer = new
TypeName;</p>

<h3>Cast expressions
<a name="Cast expressions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Frequently, when
a variable is declared and initialized with a cast, the
variable type is written twice: in the declaration type and
in the cast expression. In this case, the declaration type
can be replaced with <b>auto</b> improving readability and
maintainability.</p>

<p style="margin-left:13%; margin-top: 1em">TypeName
*my_pointer = static_cast&lt;TypeName&gt;(my_param);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">auto
*my_pointer = static_cast&lt;TypeName&gt;(my_param);</p>

<p style="margin-left:9%; margin-top: 1em">The check
handles <b>static_cast</b>, <b>dynamic_cast</b>,
<b>const_cast</b>, <b>reinterpret_cast</b>, functional
casts, C-style casts and function templates that behave as
casts, such as <b>llvm::dyn_cast</b>,
<b>boost::lexical_cast</b> and <b>gsl::narrow_cast</b>.
Calls to function templates are considered to behave as
casts if the first template argument is explicit and is a
type, and the function returns that type, or a pointer or
reference to it.</p>

<h3>Known Limitations
<a name="Known Limitations"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">If the initializer is an
explicit conversion constructor, the check will not replace
the type specifier even though it would be safe to do
so.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>User-defined iterators are not handled at this time.</p></td></tr>
</table>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>MinTypeNameLength</b></p>

<p style="margin-left:18%;">If the option is set to
non-zero (default <i>5</i>), the check will ignore type
names having a length less than the option value. The option
affects expressions only, not iterators. Spaces between
multi-lexeme type names (<b>long int</b>) are considered as
one. If the <i>RemoveStars</i> option (see below) is set to
<i>true</i>, then <b>*s</b> in the type are also counted as
a part of the type name.</p>

<p style="margin-left:13%; margin-top: 1em">//
MinTypeNameLength = 0, RemoveStars=0</p>

<p style="margin-left:13%; margin-top: 1em">int a =
static_cast&lt;int&gt;(foo()); // ---&gt; auto a = ... <br>
// length(bool *) = 4 <br>
bool *b = new bool; // ---&gt; auto *b = ... <br>
unsigned c = static_cast&lt;unsigned&gt;(foo()); // ---&gt;
auto c = ...</p>

<p style="margin-left:13%; margin-top: 1em">//
MinTypeNameLength = 5, RemoveStars=0</p>

<p style="margin-left:13%; margin-top: 1em">int a =
static_cast&lt;int&gt;(foo()); // ---&gt; int a = ... <br>
bool b = static_cast&lt;bool&gt;(foo()); // ---&gt; bool b =
... <br>
bool *pb = static_cast&lt;bool*&gt;(foo()); // ---&gt; bool
*pb = ... <br>
unsigned c = static_cast&lt;unsigned&gt;(foo()); // ---&gt;
auto c = ... <br>
// length(long &lt;on-or-more-spaces&gt; int) = 8 <br>
long int d = static_cast&lt;long int&gt;(foo()); // ---&gt;
auto d = ...</p>

<p style="margin-left:13%; margin-top: 1em">//
MinTypeNameLength = 5, RemoveStars=1</p>

<p style="margin-left:13%; margin-top: 1em">int a =
static_cast&lt;int&gt;(foo()); // ---&gt; int a = ... <br>
// length(int * * ) = 5 <br>
int **pa = static_cast&lt;int**&gt;(foo()); // ---&gt; auto
pa = ... <br>
bool b = static_cast&lt;bool&gt;(foo()); // ---&gt; bool b =
... <br>
bool *pb = static_cast&lt;bool*&gt;(foo()); // ---&gt; auto
pb = ... <br>
unsigned c = static_cast&lt;unsigned&gt;(foo()); // ---&gt;
auto c = ... <br>
long int d = static_cast&lt;long int&gt;(foo()); // ---&gt;
auto d = ...</p>

<p style="margin-left:9%;"><b>RemoveStars</b></p>

<p style="margin-left:18%;">If the option is set to
<i>true</i> (default is <i>false</i>), the check will remove
stars from the non-typedef pointer types when replacing type
names with <b>auto</b>. Otherwise, the check will leave
stars. For example:</p>

<p style="margin-left:13%; margin-top: 1em">TypeName
*my_first_pointer = new TypeName, *my_second_pointer = new
TypeName;</p>

<p style="margin-left:13%; margin-top: 1em">// RemoveStars
= 0</p>

<p style="margin-left:13%; margin-top: 1em">auto
*my_first_pointer = new TypeName, *my_second_pointer = new
TypeName;</p>

<p style="margin-left:13%; margin-top: 1em">// RemoveStars
= 1</p>

<p style="margin-left:13%; margin-top: 1em">auto
my_first_pointer = new TypeName, my_second_pointer = new
TypeName;</p>

<h3>modernize-use-bool-literals
<a name="modernize-use-bool-literals"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds integer
literals which are cast to <b>bool</b>.</p>

<p style="margin-left:13%; margin-top: 1em">bool p = 1;
<br>
bool f = static_cast&lt;bool&gt;(1); <br>
std::ios_base::sync_with_stdio(0); <br>
bool x = p ? 1 : 0;</p>

<p style="margin-left:13%; margin-top: 1em">// transforms
to</p>

<p style="margin-left:13%; margin-top: 1em">bool p = true;
<br>
bool f = true; <br>
std::ios_base::sync_with_stdio(false); <br>
bool x = p ? true : false;</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, the
check will not give warnings inside macros. Default is
<i>true</i>.</p>

<h3>modernize-use-constraints
<a name="modernize-use-constraints"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Replace
<b>std::enable_if</b> with C++20 requires clauses.</p>


<p style="margin-left:9%; margin-top: 1em"><b>std::enable_if</b>
is a SFINAE mechanism for selecting the desired function or
class template based on type traits or other requirements.
<b>enable_if</b> changes the meta-arity of the template, and
has other <i>adverse side effects</i> in the code. C++20
introduces concepts and constraints as a cleaner language
provided solution to achieve the same outcome.</p>

<p style="margin-left:9%; margin-top: 1em">This check finds
some common <b>std::enable_if</b> patterns that can be
replaced by C++20 requires clauses. The tool can replace
some of these patterns automatically, otherwise, the tool
will emit a diagnostic without a replacement. The tool can
detect the following <b>std::enable_if</b> patterns</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="87%">


<p><b>std::enable_if</b> in the return type of a
function</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="87%">


<p><b>std::enable_if</b> as the trailing template parameter
for function templates</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Other uses, for
example, in class templates for function parameters, are not
currently supported by this tool. Other variants such as
<b>boost::enable_if</b> are not currently supported by this
tool.</p>

<p style="margin-left:9%; margin-top: 1em">Below are some
examples of code using <b>std::enable_if</b>.</p>

<p style="margin-left:13%; margin-top: 1em">// enable_if in
function return type <br>
template &lt;typename T&gt; <br>
std::enable_if_t&lt;T::some_trait, int&gt;
only_if_t_has_the_trait() { ... }</p>

<p style="margin-left:13%; margin-top: 1em">// enable_if in
the trailing template parameter <br>
template &lt;typename T, std::enable_if_t&lt;T::some_trait,
int&gt; = 0&gt; <br>
void another_version() { ... }</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T&gt; <br>
typename std::enable_if&lt;T::some_value, Obj&gt;::type
existing_constraint() requires (T::another_value) { <br>
return Obj{}; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T, std::enable_if_t&lt;T::some_trait, int&gt; =
0&gt; <br>
struct my_class {};</p>

<p style="margin-left:9%; margin-top: 1em">The tool will
replace the above code with,</p>

<p style="margin-left:13%; margin-top: 1em">// warning: use
C++20 requires constraints instead of enable_if
[modernize-use-constraints] <br>
template &lt;typename T&gt; <br>
int only_if_t_has_the_trait() requires T::some_trait { ...
}</p>

<p style="margin-left:13%; margin-top: 1em">// warning: use
C++20 requires constraints instead of enable_if
[modernize-use-constraints] <br>
template &lt;typename T&gt; <br>
void another_version() requires T::some_trait { ... }</p>

<p style="margin-left:13%; margin-top: 1em">// The tool
will emit a diagnostic for the following, but will <br>
// not attempt to replace the code. <br>
// warning: use C++20 requires constraints instead of
enable_if [modernize-use-constraints] <br>
template &lt;typename T&gt; <br>
typename std::enable_if&lt;T::some_value, Obj&gt;::type
existing_constraint() requires (T::another_value) { <br>
return Obj{}; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// The tool
will not emit a diagnostic or attempt to replace the code.
<br>
template &lt;typename T, std::enable_if_t&lt;T::some_trait,
int&gt; = 0&gt; <br>
struct my_class {};</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">System headers are not analyzed
by this check.</p>

<h3>modernize-use-default
<a name="modernize-use-default"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check has
been renamed to <i>modernize-use-equals-default</i>.</p>

<h3>modernize-use-default-member-init
<a name="modernize-use-default-member-init"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
converts constructors' member initializers into the new
default member initializers in C++11. Other member
initializers that match the default member initializer are
removed. This can reduce repeated code or allow use of '=
default'.</p>

<p style="margin-left:13%; margin-top: 1em">struct A { <br>
A() : i(5), j(10.0) {} <br>
A(int i) : i(i), j(10.0) {} <br>
int i; <br>
double j; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">struct A { <br>
A() {} <br>
A(int i) : i(i) {} <br>
int i{5}; <br>
double j{10.0}; <br>
};</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">Only converts member
initializers for built-in types, enums, and pointers. The
<i>readability-redundant-member-init</i> check will remove
redundant member initializers for classes.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>UseAssignment</b></p>

<p style="margin-left:18%;">If this option is set to
<i>true</i> (default is <i>false</i>), the check will
initialize members with an assignment. For example:</p>

<p style="margin-left:13%; margin-top: 1em">struct A { <br>
A() {} <br>
A(int i) : i(i) {} <br>
int i = 5; <br>
double j = 10.0; <br>
};</p>

<p style="margin-left:9%;"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">If this option is set to
<i>true</i> (default is <i>true</i>), the check will not
warn about members declared inside macros.</p>

<h3>modernize-use-designated-initializers
<a name="modernize-use-designated-initializers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
initializer lists for aggregate types which could be written
as designated initializers instead.</p>

<p style="margin-left:9%; margin-top: 1em">With plain
initializer lists, it is very easy to introduce bugs when
adding new fields in the middle of a struct or class type.
The same confusion might arise when changing the order of
fields.</p>

<p style="margin-left:9%; margin-top: 1em">C++20 supports
the designated initializer syntax for aggregate types. By
applying it, we can always be sure that aggregates are
constructed correctly, because every variable being
initialized is referenced by its name.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">struct S { int
i, j; };</p>

<p style="margin-left:9%; margin-top: 1em">is an aggregate
type that should be initialized as</p>

<p style="margin-left:13%; margin-top: 1em">S s{.i = 1, .j
= 2};</p>

<p style="margin-left:9%; margin-top: 1em">instead of</p>

<p style="margin-left:13%; margin-top: 1em">S s{1, 2};</p>

<p style="margin-left:9%; margin-top: 1em">which could
easily become an issue when <b>i</b> and <b>j</b> are
swapped in the declaration of <b>S</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Even when
compiling in a language version older than C++20, depending
on your compiler, designated initializers are potentially
supported. Therefore, the check is by default restricted to
C99/C++20 and above. Check out the options
<b>-Wc99-designator</b> to get support for mixed designators
in initializer list in C and <b>-Wc++20-designator</b> for
support of designated initializers in older C++ language
modes.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">The value <i>false</i>
specifies that components of initializer lists expanded from
macros are not checked. The default value is
<i>true</i>.</p>


<p style="margin-left:9%;"><b>IgnoreSingleElementAggregates</b></p>

<p style="margin-left:18%;">The value <i>false</i>
specifies that even initializers for aggregate types with
only a single element should be checked. The default value
is <i>true</i>.</p>

<p style="margin-left:9%;"><b>RestrictToPODTypes</b></p>

<p style="margin-left:18%;">The value <i>true</i> specifies
that only Plain Old Data (POD) types shall be checked. This
makes the check applicable to even older C++ standards. The
default value is <i>false</i>.</p>


<p style="margin-left:9%;"><b>StrictCStandardCompliance</b></p>

<p style="margin-left:18%;">When set to <i>false</i>, the
check will not restrict itself to C99 and above. The default
value is <i>true</i>.</p>


<p style="margin-left:9%;"><b>StrictCppStandardCompliance</b></p>

<p style="margin-left:18%;">When set to <i>false</i>, the
check will not restrict itself to C++20 and above. The
default value is <i>true</i>.</p>

<h3>modernize-use-emplace
<a name="modernize-use-emplace"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check flags
insertions to an STL-style container done by calling the
<b>push_back</b>, <b>push</b>, or <b>push_front</b> methods
with an explicitly-constructed temporary of the container
element type. In this case, the corresponding <b>emplace</b>
equivalent methods result in less verbose and potentially
more efficient code. Right now the check doesn't support
<b>insert</b>. It also doesn't support <b>insert</b>
functions for associative containers because replacing
<b>insert</b> with <b>emplace</b> may result in <i>speed
regression</i>, but it might get support with some addition
flag in the future.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>ContainersWithPushBack</i>, <i>ContainersWithPush</i>,
and <i>ContainersWithPushFront</i> options are used to
specify the container types that support the
<b>push_back</b>, <b>push</b>, and <b>push_front</b>
operations respectively. The default values for these
options are as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p><i>ContainersWithPushBack</i>: <b>std::vector</b>,
<b>std::deque</b>, and <b>std::list</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p><i>ContainersWithPush</i>: <b>std::stack</b>,
<b>std::queue</b>, and <b>std::priority_queue</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p><i>ContainersWithPushFront</i>:
<b>std::forward_list</b>, <b>std::list</b>, and
<b>std::deque</b>.</p> </td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">This check also
reports when an <b>emplace</b>-like method is improperly
used, for example using <b>emplace_back</b> while also
calling a constructor. This creates a temporary that
requires at best a move and at worst a copy. Almost all
<b>emplace</b>-like functions in the STL are covered by
this, with <b>try_emplace</b> on <b>std::map</b> and
<b>std::unordered_map</b> being the exception as it behaves
slightly differently than all the others. More containers
can be added with the <i>EmplacyFunctions</i> option, so
long as the container defines a <b>value_type</b> type, and
the <b>emplace</b>-like functions construct a
<b>value_type</b> object.</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;MyClass&gt;
v; <br>
v.push_back(MyClass(21, 37)); <br>
v.emplace_back(MyClass(21, 37));</p>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;std::pair&lt;int,
int&gt;&gt; w;</p>


<p style="margin-left:13%; margin-top: 1em">w.push_back(std::pair&lt;int,
int&gt;(21, 37)); <br>
w.push_back(std::make_pair(21L, 37L)); <br>
w.emplace_back(std::make_pair(21L, 37L));</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;MyClass&gt;
v; <br>
v.emplace_back(21, 37); <br>
v.emplace_back(21, 37);</p>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;std::pair&lt;int,
int&gt;&gt; w; <br>
w.emplace_back(21, 37); <br>
w.emplace_back(21L, 37L); <br>
w.emplace_back(21L, 37L);</p>

<p style="margin-left:9%; margin-top: 1em">By default, the
check is able to remove unnecessary <b>std::make_pair</b>
and <b>std::make_tuple</b> calls from <b>push_back</b> calls
on containers of <b>std::pair</b> and <b>std::tuple</b>.
Custom tuple-like types can be modified by the
<i>TupleTypes</i> option; custom make functions can be
modified by the <i>TupleMakeFunctions</i> option.</p>

<p style="margin-left:9%; margin-top: 1em">The other
situation is when we pass arguments that will be converted
to a type inside a container.</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;boost::optional&lt;std::string&gt;
&gt; v; <br>
v.push_back(&quot;abc&quot;);</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;boost::optional&lt;std::string&gt;
&gt; v; <br>
v.emplace_back(&quot;abc&quot;);</p>

<p style="margin-left:9%; margin-top: 1em">In some cases
the transformation would be valid, but the code wouldn't be
exception safe. In this case the calls of <b>push_back</b>
won't be replaced.</p>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;std::unique_ptr&lt;int&gt;&gt;
v; <br>
v.push_back(std::unique_ptr&lt;int&gt;(new int(0))); <br>
auto *ptr = new int(1); <br>
v.push_back(std::unique_ptr&lt;int&gt;(ptr));</p>

<p style="margin-left:9%; margin-top: 1em">This is because
replacing it with <b>emplace_back</b> could cause a leak of
this pointer if <b>emplace_back</b> would throw exception
before emplacement (e.g. not enough memory to add a new
element).</p>

<p style="margin-left:9%; margin-top: 1em">For more info
read item 42 - &quot;Consider emplacement instead of
insertion.&quot; of Scott Meyers &quot;Effective Modern
C++&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">The default
smart pointers that are considered are
<b>std::unique_ptr</b>, <b>std::shared_ptr</b>,
<b>std::auto_ptr</b>. To specify other smart pointers or
other classes use the <i>SmartPointers</i> option.</p>

<p style="margin-left:9%; margin-top: 1em">Check also
doesn't fire if any argument of the constructor call would
be:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="84%">


<p style="margin-top: 1em">a bit-field (bit-fields can't
bind to rvalue/universal reference)</p></td>
<td width="1%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="84%">


<p>a <b>new</b> expression (to avoid leak)</p></td>
<td width="1%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="84%">


<p>if the argument would be converted via derived-to-base
cast.</p> </td>
<td width="1%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">This check
requires C++11 or higher to run.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>ContainersWithPushBack</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
class names of custom containers that support
<b>push_back</b>.</p>

<p style="margin-left:9%;"><b>ContainersWithPush</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
class names of custom containers that support
<b>push</b>.</p>


<p style="margin-left:9%;"><b>ContainersWithPushFront</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
class names of custom containers that support
<b>push_front</b>.</p>


<p style="margin-left:9%;"><b>IgnoreImplicitConstructors</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will ignore implicitly constructed arguments of
<b>push_back</b>, e.g.</p>


<p style="margin-left:22%; margin-top: 1em">std::vector&lt;std::string&gt;
v; <br>
v.push_back(&quot;a&quot;); // Ignored when
IgnoreImplicitConstructors is `true`.</p>

<p style="margin-left:18%; margin-top: 1em">Default is
<i>false</i>.</p>

<p style="margin-left:9%;"><b>SmartPointers</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
class names of custom smart pointers.</p>

<p style="margin-left:9%;"><b>TupleTypes</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
<b>std::tuple</b>-like class names.</p>

<p style="margin-left:9%;"><b>TupleMakeFunctions</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
<b>std::make_tuple</b>-like function names. Those function
calls will be removed from <b>push_back</b> calls and turned
into <b>emplace_back</b>.</p>

<p style="margin-left:9%;"><b>EmplacyFunctions</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
containers without their template parameters and some
<b>emplace</b>-like method of the container. Example:
<b>vector::emplace_back</b>. Those methods will be checked
for improper use and the check will report when a temporary
is unnecessarily created.</p>

<h3>Example
<a name="Example"></a>
</h3>



<p style="margin-left:13%; margin-top: 1em">std::vector&lt;MyTuple&lt;int,
bool, char&gt;&gt; x; <br>
x.push_back(MakeMyTuple(1, false, 'x')); <br>
x.emplace_back(MakeMyTuple(1, false, 'x'));</p>

<p style="margin-left:9%; margin-top: 1em">transforms
to:</p>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;MyTuple&lt;int,
bool, char&gt;&gt; x; <br>
x.emplace_back(1, false, 'x'); <br>
x.emplace_back(1, false, 'x');</p>

<p style="margin-left:9%; margin-top: 1em">when
<i>TupleTypes</i> is set to <b>MyTuple</b>,
<i>TupleMakeFunctions</i> is set to <b>MakeMyTuple</b>, and
<i>EmplacyFunctions</i> is set to
<b>vector::emplace_back</b>.</p>

<h3>modernize-use-equals-default
<a name="modernize-use-equals-default"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
replaces default bodies of special member functions with
<b>= default;</b>. The explicitly defaulted function
declarations enable more opportunities in optimization,
because the compiler might treat explicitly defaulted
functions as trivial.</p>

<p style="margin-left:13%; margin-top: 1em">struct A { <br>
A() {} <br>
&#732;A(); <br>
}; <br>
A::&#732;A() {}</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">struct A { <br>
A() = default; <br>
&#732;A(); <br>
}; <br>
A::&#732;A() = default;</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">Move-constructor and
move-assignment operator are not supported yet.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, the
check will not give warnings inside macros and will ignore
special members with bodies contain macros or preprocessor
directives. Default is <i>true</i>.</p>

<h3>modernize-use-equals-delete
<a name="modernize-use-equals-delete"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Identifies
unimplemented private special member functions, and
recommends using <b>= delete</b> for them. Additionally, it
recommends relocating any deleted member function from the
<b>private</b> to the <b>public</b> section.</p>

<p style="margin-left:9%; margin-top: 1em">Before the
introduction of C++11, the primary method to effectively
&quot;erase&quot; a particular function involved declaring
it as <b>private</b> without providing a definition. This
approach would result in either a compiler error (when
attempting to call a private function) or a linker error
(due to an undefined reference).</p>

<p style="margin-left:9%; margin-top: 1em">However,
subsequent to the advent of C++11, a more conventional
approach emerged for achieving this purpose. It involves
flagging functions as <b>= delete</b> and keeping them in
the <b>public</b> section of the class.</p>

<p style="margin-left:9%; margin-top: 1em">To prevent false
positives, this check is only active within a translation
unit where all other member functions have been implemented.
The check will generate partial fixes by introducing <b>=
delete</b>, but the user is responsible for manually
relocating functions to the <b>public</b> section.</p>

<p style="margin-left:13%; margin-top: 1em">// Example: bad
<br>
class A { <br>
private: <br>
A(const A&amp;); <br>
A&amp; operator=(const A&amp;); <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">// Example:
good <br>
class A { <br>
public: <br>
A(const A&amp;) = delete; <br>
A&amp; operator=(const A&amp;) = delete; <br>
};</p>

<p style="margin-left:9%;"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">If this option is set to
<i>true</i> (default is <i>true</i>), the check will not
warn about functions declared inside macros.</p>

<h3>modernize-use-nodiscard
<a name="modernize-use-nodiscard"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Adds
<b>[[nodiscard]]</b> attributes (introduced in C++17) to
member functions in order to highlight at compile time which
return values should not be ignored.</p>

<p style="margin-left:9%; margin-top: 1em">Member functions
need to satisfy the following conditions to be considered by
this check:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>no <b>[[nodiscard]]</b>, <b>[[noreturn]]</b>,
<b>__attribute__((warn_unused_result))</b>,
<b>[[clang::warn_unused_result]]</b> nor
<b>[[gcc::warn_unused_result]]</b> attribute,</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>non-void return type,</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>non-template return types,</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>const member function,</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>non-variadic functions,</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>no non-const reference parameters,</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>no pointer parameters,</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>no template parameters,</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>no template function parameters,</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>not be a member of a class with mutable member
variables,</p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>no Lambdas,</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>no conversion functions.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Such functions
have no means of altering any state or passing values other
than via the return type. Unless the member functions are
altering state via some external call (e.g. I/O).</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">bool empty()
const; <br>
bool empty(int i) const;</p>

<p style="margin-left:9%; margin-top: 1em">transforms
to:</p>

<p style="margin-left:13%; margin-top: 1em">[[nodiscard]]
bool empty() const; <br>
[[nodiscard]] bool empty(int i) const;</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>ReplacementString</b></p>

<p style="margin-left:18%;">Specifies a macro to use
instead of <b>[[nodiscard]]</b>. This is useful when
maintaining source code that needs to compile with a
pre-C++17 compiler.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">bool empty()
const; <br>
bool empty(int i) const;</p>

<p style="margin-left:9%; margin-top: 1em">transforms
to:</p>

<p style="margin-left:13%; margin-top: 1em">NO_DISCARD bool
empty() const; <br>
NO_DISCARD bool empty(int i) const;</p>

<p style="margin-left:9%; margin-top: 1em">if the
<i>ReplacementString</i> option is set to
<i>NO_DISCARD</i>.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">If the <i>ReplacementString</i>
is not a C++ attribute, but instead a macro, then that macro
must be defined in scope or the fix-it will not be
applied.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">For alternative
<b>__attribute__</b> syntax options to mark functions as
<b>[[nodiscard]]</b> in non-c++17 source code. See -
<i>https://clang.llvm.org/docs/AttributeReference.html#nodiscard-warn-unused-result</i></p>

<h3>modernize-use-noexcept
<a name="modernize-use-noexcept"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
replaces deprecated dynamic exception specifications with
the appropriate noexcept specification (introduced in
C++11). By default this check will replace <b>throw()</b>
with <b>noexcept</b>, and
<b>throw(&lt;exception&gt;[,...])</b> or <b>throw(...)</b>
with <b>noexcept(false)</b>.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">void foo()
throw(); <br>
void bar() throw(int) {}</p>

<p style="margin-left:9%; margin-top: 1em">transforms
to:</p>

<p style="margin-left:13%; margin-top: 1em">void foo()
noexcept; <br>
void bar() noexcept(false) {}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>ReplacementString</b></p>

<p style="margin-left:18%;">Users can use
<i>ReplacementString</i> to specify a macro to use instead
of <b>noexcept</b>. This is useful when maintaining source
code that uses custom exception specification marking other
than <b>noexcept</b>. Fix-it hints will only be generated
for non-throwing specifications.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">void bar()
throw(int); <br>
void foo() throw();</p>

<p style="margin-left:9%; margin-top: 1em">transforms
to:</p>

<p style="margin-left:13%; margin-top: 1em">void bar()
throw(int); // No fix-it generated. <br>
void foo() NOEXCEPT;</p>

<p style="margin-left:9%; margin-top: 1em">if the
<i>ReplacementString</i> option is set to <i>NOEXCEPT</i>.
<b><br>
UseNoexceptFalse</b></p>

<p style="margin-left:9%; margin-top: 1em">Enabled by
default, disabling will generate fix-it hints that remove
throwing dynamic exception specs, e.g.,
<b>throw(&lt;something&gt;)</b>, completely without
providing a replacement text, except for destructors and
delete operators that are <b>noexcept(true)</b> by
default.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">void foo()
throw(int) {}</p>

<p style="margin-left:13%; margin-top: 1em">struct bar {
<br>
void foobar() throw(int); <br>
void operator delete(void *ptr) throw(int); <br>
void operator delete[](void *ptr) throw(int); <br>
&#732;bar() throw(int); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">transforms
to:</p>

<p style="margin-left:13%; margin-top: 1em">void foo()
{}</p>

<p style="margin-left:13%; margin-top: 1em">struct bar {
<br>
void foobar(); <br>
void operator delete(void *ptr) noexcept(false); <br>
void operator delete[](void *ptr) noexcept(false); <br>
&#732;bar() noexcept(false); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">if the
<i>UseNoexceptFalse</i> option is set to <i>false</i>.</p>

<h3>modernize-use-nullptr
<a name="modernize-use-nullptr"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check
converts the usage of null pointer constants (e.g.
<b>NULL</b>, <b>0</b>) to use the new C++11 and C23
<b>nullptr</b> keyword.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">void
assignment() { <br>
char *a = NULL; <br>
char *b = 0; <br>
char c = 0; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int *ret_ptr()
{ <br>
return 0; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">transforms
to:</p>

<p style="margin-left:13%; margin-top: 1em">void
assignment() { <br>
char *a = nullptr; <br>
char *b = nullptr; <br>
char c = 0; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int *ret_ptr()
{ <br>
return nullptr; <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoredTypes</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
regular expressions to match pointer types for which
implicit casts will be ignored. Default value:
<i>std::_CmpUnspecifiedParam::;&#710;std::__cmp_cat::__unspec</i>.</p>

<p style="margin-left:9%;"><b>NullMacros</b></p>

<p style="margin-left:18%;">Comma-separated list of macro
names that will be transformed along with <b>NULL</b>. By
default this check will only replace the <b>NULL</b> macro
and will skip any similar user-defined macros.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">#define MY_NULL
(void*)0 <br>
void assignment() { <br>
void *p = MY_NULL; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">transforms
to:</p>

<p style="margin-left:13%; margin-top: 1em">#define MY_NULL
NULL <br>
void assignment() { <br>
int *p = nullptr; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">if the
<i>NullMacros</i> option is set to <b>MY_NULL</b>.</p>

<h3>modernize-use-override
<a name="modernize-use-override"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Adds
<b>override</b> (introduced in C++11) to overridden virtual
functions and removes <b>virtual</b> from those functions as
it is not required.</p>

<p style="margin-left:9%; margin-top: 1em"><b>virtual</b>
on non base class implementations was used to help indicate
to the user that a function was virtual. C++ compilers did
not use the presence of this to signify an overridden
function.</p>

<p style="margin-left:9%; margin-top: 1em">In C++11
<b>override</b> and <b>final</b> keywords were introduced to
allow overridden functions to be marked appropriately. Their
presence allows compilers to verify that an overridden
function correctly overrides a base class
implementation.</p>

<p style="margin-left:9%; margin-top: 1em">This can be
useful as compilers can generate a compile time error
when:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="84%">


<p>The base class implementation function signature
changes.</p> </td>
<td width="1%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="84%">


<p>The user has not created the override with the correct
signature.</p> </td>
<td width="1%">
</td></tr>
</table>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreDestructors</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, this
check will not diagnose destructors. Default is
<i>false</i>.</p>


<p style="margin-left:9%;"><b>IgnoreTemplateInstantiations</b></p>

<p style="margin-left:18%;">If set to <i>true</i>,
instructs this check to ignore virtual function overrides
that are part of template instantiations. Default is
<i>false</i>.</p>


<p style="margin-left:9%;"><b>AllowOverrideAndFinal</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, this
check will not diagnose <b>override</b> as redundant with
<b>final</b>. This is useful when code will be compiled by a
compiler with warning/error checking flags requiring
<b>override</b> explicitly on overridden members, such as
<b>gcc -Wsuggest-override</b>/<b>gcc
-Werror=suggest-override</b>. Default is <i>false</i>.</p>

<p style="margin-left:9%;"><b>OverrideSpelling</b></p>

<p style="margin-left:18%;">Specifies a macro to use
instead of <b>override</b>. This is useful when maintaining
source code that also needs to compile with a pre-C++11
compiler.</p>

<p style="margin-left:9%;"><b>FinalSpelling</b></p>

<p style="margin-left:18%;">Specifies a macro to use
instead of <b>final</b>. This is useful when maintaining
source code that also needs to compile with a pre-C++11
compiler.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">For more information on the use
of <b>override</b> see -
<i>https://en.cppreference.com/w/cpp/language/override</i></p>

<h3>modernize-use-ranges
<a name="modernize-use-ranges"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects calls to
standard library iterator algorithms that could be replaced
with a ranges version instead.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">auto Iter1 =
std::find(Items.begin(), Items.end(), 0); <br>
auto AreSame = std::equal(Items1.cbegin(), Items1.cend(),
<br>
std::begin(Items2), std::end(Items2));</p>

<p style="margin-left:9%; margin-top: 1em">Transforms
to:</p>

<p style="margin-left:13%; margin-top: 1em">auto Iter1 =
std::ranges::find(Items, 0); <br>
auto AreSame = std::ranges::equal(Items1, Items2);</p>

<h3>Supported algorithms
<a name="Supported algorithms"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Calls to the
following std library algorithms are checked:</p>


<p style="margin-left:9%; margin-top: 1em"><b>std::adjacent_find</b>,
<b>std::all_of</b>, <b>std::any_of</b>,
<b>std::binary_search</b>, <b>std::copy_backward</b>,
<b>std::copy_if</b>, <b>std::copy</b>, <b>std::destroy</b>,
<b>std::equal_range</b>, <b>std::equal</b>,
<b>std::fill</b>, <b>std::find_end</b>,
<b>std::find_if_not</b>, <b>std::find_if</b>,
<b>std::find</b>, <b>std::for_each</b>,
<b>std::generate</b>, <b>std::includes</b>,
<b>std::inplace_merge</b>, <b>std::iota</b>,
<b>std::is_heap_until</b>, <b>std::is_heap</b>,
<b>std::is_partitioned</b>, <b>std::is_permutation</b>,
<b>std::is_sorted_until</b>, <b>std::is_sorted</b>,
<b>std::lexicographical_compare</b>,
<b>std::lower_bound</b>, <b>std::make_heap</b>,
<b>std::max_element</b>, <b>std::merge</b>,
<b>std::min_element</b>, <b>std::minmax_element</b>,
<b>std::mismatch</b>, <b>std::move_backward</b>,
<b>std::move</b>, <b>std::next_permutation</b>,
<b>std::none_of</b>, <b>std::partial_sort_copy</b>,
<b>std::partition_copy</b>, <b>std::partition_point</b>,
<b>std::partition</b>, <b>std::pop_heap</b>,
<b>std::prev_permutation</b>, <b>std::push_heap</b>,
<b>std::remove_copy_if</b>, <b>std::remove_copy</b>,
<b>std::remove</b>, <b>std::remove_if</b>,
<b>std::replace_if</b>, <b>std::replace</b>,
<b>std::reverse_copy</b>, <b>std::reverse</b>,
<b>std::rotate</b>, <b>std::rotate_copy</b>,
<b>std::sample</b>, <b>std::search</b>,
<b>std::set_difference</b>, <b>std::set_intersection</b>,
<b>std::set_symmetric_difference</b>, <b>std::set_union</b>,
<b>std::shift_left</b>, <b>std::shift_right</b>,
<b>std::sort_heap</b>, <b>std::sort</b>,
<b>std::stable_partition</b>, <b>std::stable_sort</b>,
<b>std::transform</b>, <b>std::uninitialized_copy</b>,
<b>std::uninitialized_default_construct</b>,
<b>std::uninitialized_fill</b>,
<b>std::uninitialized_move</b>,
<b>std::uninitialized_value_construct</b>,
<b>std::unique_copy</b>, <b>std::unique</b>,
<b>std::upper_bound</b>.</p>

<h3>Reverse Iteration
<a name="Reverse Iteration"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">If calls are
made using reverse iterators on containers, The code will be
fixed using the <b>std::views::reverse</b> adaptor.</p>

<p style="margin-left:13%; margin-top: 1em">auto AreSame =
std::equal(Items1.rbegin(), Items1.rend(), <br>
std::crbegin(Items2), std::crend(Items2));</p>

<p style="margin-left:9%; margin-top: 1em">Transforms
to:</p>

<p style="margin-left:13%; margin-top: 1em">auto AreSame =
std::ranges::equal(std::ranges::reverse_view(Items1), <br>
std::ranges::reverse_view(Items2));</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IncludeStyle</b></p>

<p style="margin-left:18%;">A string specifying which
include-style is used, <i>llvm</i> or <i>google</i>. Default
is <i>llvm</i>.</p>

<p style="margin-left:9%;"><b>UseReversePipe</b></p>

<p style="margin-left:18%;">When <i>true</i> (default
<i>false</i>), fixes which involve reverse ranges will use
the pipe adaptor syntax instead of the function syntax.</p>


<p style="margin-left:22%; margin-top: 1em">std::find(Items.rbegin(),
Items.rend(), 0);</p>

<p style="margin-left:18%; margin-top: 1em">Transforms
to:</p>


<p style="margin-left:22%; margin-top: 1em">std::ranges::find(Items
| std::views::reverse, 0);</p>

<h3>modernize-use-starts-ends-with
<a name="modernize-use-starts-ends-with"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for
common roundabout ways to express <b>starts_with</b> and
<b>ends_with</b> and suggests replacing with
<b>starts_with</b> when the method is available. Notably,
this will work with <b>std::string</b> and
<b>std::string_view</b>.</p>

<p style="margin-left:13%; margin-top: 1em">std::string s =
&quot;...&quot;; <br>
if (s.find(&quot;prefix&quot;) == 0) { /* do something */ }
<br>
if (s.rfind(&quot;prefix&quot;, 0) == 0) { /* do something
*/ } <br>
if (s.compare(0, strlen(&quot;prefix&quot;),
&quot;prefix&quot;) == 0) { /* do something */ }</p>

<p style="margin-left:9%; margin-top: 1em">becomes</p>

<p style="margin-left:13%; margin-top: 1em">std::string s =
&quot;...&quot;; <br>
if (s.starts_with(&quot;prefix&quot;)) { /* do something */
} <br>
if (s.starts_with(&quot;prefix&quot;)) { /* do something */
} <br>
if (s.starts_with(&quot;prefix&quot;)) { /* do something */
}</p>

<h3>modernize-use-std-format
<a name="modernize-use-std-format"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Converts calls
to <b>absl::StrFormat</b>, or other functions via
configuration options, to C++20's <b>std::format</b>, or
another function via a configuration option, modifying the
format string appropriately and removing now-unnecessary
calls to <b>std::string::c_str()</b> and
<b>std::string::data()</b>.</p>

<p style="margin-left:9%; margin-top: 1em">For example, it
turns lines like</p>

<p style="margin-left:13%; margin-top: 1em">return
absl::StrFormat(&quot;The %s is %3d&quot;,
description.c_str(), value);</p>

<p style="margin-left:9%; margin-top: 1em">into:</p>

<p style="margin-left:13%; margin-top: 1em">return
std::format(&quot;The {} is {:3}&quot;, description,
value);</p>

<p style="margin-left:9%; margin-top: 1em">The check uses
the same format-string-conversion algorithm as
<i>modernize-use-std-print</i> and its shortcomings are
described in the documentation for that check.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>StrictMode</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will add casts when converting from variadic functions and
printing signed or unsigned integer types (including
fixed-width integer types from <b>&lt;cstdint&gt;</b>,
<b>ptrdiff_t</b>, <b>size_t</b> and <b>ssize_t</b>) as the
opposite signedness to ensure that the output would matches
that of a simple wrapper for <b>std::sprintf</b> that
accepted a C-style variable argument list. For example, with
<i>StrictMode</i> enabled,</p>

<p style="margin-left:22%; margin-top: 1em">extern
std::string strprintf(const char *format, ...); <br>
int i = -42; <br>
unsigned int u = 0xffffffff; <br>
return strprintf(&quot;%d %u\n&quot;, i, u);</p>

<p style="margin-left:18%; margin-top: 1em">would be
converted to</p>

<p style="margin-left:22%; margin-top: 1em">return
std::format(&quot;{} {}\n&quot;, static_cast&lt;unsigned
int&gt;(i), static_cast&lt;int&gt;(u));</p>

<p style="margin-left:18%; margin-top: 1em">to ensure that
the output will continue to be the unsigned representation
of -42 and the signed representation of 0xffffffff (often
4294967254 and -1 respectively). When <i>false</i> (which is
the default), these casts will not be added which may cause
a change in the output. Note that this option makes no
difference for the default value of
<i>StrFormatLikeFunctions</i> since <b>absl::StrFormat</b>
takes a function parameter pack and is not a variadic
function.</p>


<p style="margin-left:9%;"><b>StrFormatLikeFunctions</b></p>

<p style="margin-left:18%;">A semicolon-separated list of
(fully qualified) function names to replace, with the
requirement that the first parameter contains the
printf-style format string and the arguments to be formatted
follow immediately afterwards. The default value for this
option is <i>absl::StrFormat</i>.</p>


<p style="margin-left:9%;"><b>ReplacementFormatFunction</b></p>

<p style="margin-left:18%;">The function that will be used
to replace the function set by the
<i>StrFormatLikeFunctions</i> option rather than the default
<i>std::format</i>. It is expected that the function
provides an interface that is compatible with
<b>std::format</b>. A suitable candidate would be
<i>fmt::format</i>.</p>

<p style="margin-left:9%;"><b>FormatHeader</b></p>

<p style="margin-left:18%;">The header that must be
included for the declaration of
<i>ReplacementFormatFunction</i> so that a <b>#include</b>
directive can be added if required. If
<i>ReplacementFormatFunction</i> is <i>std::format</i> then
this option will default to <b>&lt;format&gt;</b>, otherwise
this option will default to nothing and no <b>#include</b>
directive will be added.</p>

<h3>modernize-use-std-numbers
<a name="modernize-use-std-numbers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds constants
and function calls to math functions that can be replaced
with C++20's mathematical constants from the <b>numbers</b>
header and offers fix-it hints. Does not match the use of
variables with that value, and instead, offers a replacement
for the definition of those variables. Function calls that
match the pattern of how the constant is calculated are
matched and replaced with the <b>std::numbers</b> constant.
The use of macros gets replaced with the corresponding
<b>std::numbers</b> constant, instead of changing the macro
definition.</p>

<p style="margin-left:9%; margin-top: 1em">The following
list of constants from the <b>numbers</b> header are
supported:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p><b>e</b></p></td>
<td width="76%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p><b>log2e</b></p></td>
<td width="76%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p><b>log10e</b></p></td>
<td width="76%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p><b>pi</b></p></td>
<td width="76%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p><b>inv_pi</b></p></td>
<td width="76%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p><b>inv_sqrtpi</b></p></td>
<td width="76%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p><b>ln2</b></p></td>
<td width="76%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p><b>ln10</b></p></td>
<td width="76%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p><b>sqrt2</b></p></td>
<td width="76%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p><b>sqrt3</b></p></td>
<td width="76%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p><b>inv_sqrt3</b></p></td>
<td width="76%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p><b>egamma</b></p></td>
<td width="76%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p><b>phi</b></p></td>
<td width="76%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">The list
currently includes all constants as of C++20.</p>

<p style="margin-left:9%; margin-top: 1em">The replacements
use the type of the matched constant and can remove explicit
casts, i.e., switching between <b>std::numbers::e</b>,
<b>std::numbers::e_v&lt;float&gt;</b> and
<b>std::numbers::e_v&lt;long double&gt;</b> where
appropriate.</p>

<p style="margin-left:13%; margin-top: 1em">double
sqrt(double); <br>
double log2(double); <br>
void sink(auto&amp;&amp;) {} <br>
void floatSink(float);</p>

<p style="margin-left:13%; margin-top: 1em">#define MY_PI
3.1415926</p>

<p style="margin-left:13%; margin-top: 1em">void foo() {
<br>
const double Pi = 3.141592653589; // const double Pi =
std::numbers::pi <br>
const auto Use = Pi / 2; // no match for Pi <br>
static constexpr double Euler = 2.7182818; // static
constexpr double Euler = std::numbers::e;</p>

<p style="margin-left:13%; margin-top: 1em">log2(exp(1));
// std::numbers::log2e; <br>
log2(Euler); // std::numbers::log2e; <br>
1 / sqrt(MY_PI); // std::numbers::inv_sqrtpi; <br>
sink(MY_PI); // sink(std::numbers::pi); <br>
floatSink(MY_PI); // floatSink(std::numbers::pi); <br>
floatSink(static_cast&lt;float&gt;(MY_PI)); //
floatSink(std::numbers::pi_v&lt;float&gt;); <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>DiffThreshold</b></p>

<p style="margin-left:18%;">A floating point value that
sets the detection threshold for when literals match a
constant. A literal matches a constant if <b>abs(literal -
constant) &lt; DiffThreshold</b> evaluates to <b>true</b>.
Default is <i>0.001</i>.</p>

<p style="margin-left:9%;"><b>IncludeStyle</b></p>

<p style="margin-left:18%;">A string specifying which
include-style is used, <i>llvm</i> or <i>google</i>. Default
is <i>llvm</i>.</p>

<h3>modernize-use-std-print
<a name="modernize-use-std-print"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Converts calls
to <b>printf</b>, <b>fprintf</b>, <b>absl::PrintF</b> and
<b>absl::FPrintf</b> to equivalent calls to C++23's
<b>std::print</b> or <b>std::println</b> as appropriate,
modifying the format string appropriately. The replaced and
replacement functions can be customised by configuration
options. Each argument that is the result of a call to
<b>std::string::c_str()</b> and <b>std::string::data()</b>
will have that now-unnecessary call removed in a similar
manner to the <i>readability-redundant-string-cstr</i>
check.</p>

<p style="margin-left:9%; margin-top: 1em">In other words,
it turns lines like:</p>


<p style="margin-left:13%; margin-top: 1em">fprintf(stderr,
&quot;The %s is %3d\n&quot;, description.c_str(),
value);</p>

<p style="margin-left:9%; margin-top: 1em">into:</p>


<p style="margin-left:13%; margin-top: 1em">std::println(stderr,
&quot;The {} is {:3}&quot;, description, value);</p>

<p style="margin-left:9%; margin-top: 1em">If the
<i>ReplacementPrintFunction</i> or
<i>ReplacementPrintlnFunction</i> options are left, or
assigned to their default values then this check is only
enabled with <i>-std=c++23</i> or later.</p>

<p style="margin-left:9%; margin-top: 1em">The check
doesn't do a bad job, but it's not perfect. In
particular:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>It assumes that the format string is correct for the
arguments. If you get any warnings when compiling with
<i>-Wformat</i> then misbehaviour is possible.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>At the point that the check runs, the AST contains a
single <b>StringLiteral</b> for the format string and any
macro expansion, token pasting, adjacent string literal
concatenation and escaping has been handled. Although it's
possible for the check to automatically put the escapes
back, they may not be exactly as they were written (e.g.
<b>&quot;\x0a&quot;</b> will become <b>&quot;\n&quot;</b>
and <b>&quot;ab&quot; &quot;cd&quot;</b> will become
<b>&quot;abcd&quot;</b>.) This is helpful since it means
that the <b>PRIx</b> macros from <b>&lt;inttypes.h&gt;</b>
are removed correctly.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>It supports field widths, precision, positional
arguments, leading zeros, leading <b>+</b>, alignment and
alternative forms.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Use of any unsupported flags or specifiers will cause
the entire statement to be left alone and a warning to be
emitted. Particular unsupported features are:</p></td></tr>
</table>

<p style="margin-left:12%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%"></td>
<td width="1%"></td>
<td width="48%">


<p style="margin-top: 1em">The <b>%'</b> flag for thousands
separators.</p> </td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="48%">


<p>The glibc extension <b>%m</b>.</p></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="48%"></td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em"><b>printf</b>
and similar functions return the number of characters
printed. <b>std::print</b> does not. This means that any
invocations that use the return value will not be converted.
Unfortunately this currently includes explicitly-casting to
<b>void</b>. Deficiencies in this check mean that any
invocations inside <b>GCC</b> compound statements cannot be
converted even if the resulting value is not used.</p>

<p style="margin-left:9%; margin-top: 1em">If conversion
would be incomplete or unsafe then the entire invocation
will be left unchanged.</p>

<p style="margin-left:9%; margin-top: 1em">If the call is
deemed suitable for conversion then:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em"><b>printf</b>, <b>fprintf</b>,
<b>absl::PrintF</b>, <b>absl::FPrintF</b> and any functions
specified by the <i>PrintfLikeFunctions</i> option or
<i>FprintfLikeFunctions</i> are replaced with the function
specified by the <i>ReplacementPrintlnFunction</i> option if
the format string ends with <b>\n</b> or
<i>ReplacementPrintFunction</i> otherwise.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>the format string is rewritten to use the
<b>std::formatter</b> language. If a <b>\n</b> is found at
the end of the format string not preceded by <b>r</b> then
it is removed and <i>ReplacementPrintlnFunction</i> is used
rather than <i>ReplacementPrintFunction</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>any arguments that corresponded to <b>%p</b> specifiers
that <b>std::formatter</b> wouldn't accept are wrapped in a
<b>static_cast</b> to <b>const void *</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>any arguments that corresponded to <b>%s</b> specifiers
where the argument is of <b>signed char</b> or <b>unsigned
char</b> type are wrapped in a <b>reinterpret_cast&lt;const
char *&gt;</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>any arguments where the format string and the parameter
differ in signedness will be wrapped in an appropriate
<b>static_cast</b> if <i>StrictMode</i> is enabled.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>any arguments that end in a call to
<b>std::string::c_str()</b> or <b>std::string::data()</b>
will have that call removed.</p></td></tr>
</table>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>StrictMode</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will add casts when converting from variadic functions like
<b>printf</b> and printing signed or unsigned integer types
(including fixed-width integer types from
<b>&lt;cstdint&gt;</b>, <b>ptrdiff_t</b>, <b>size_t</b> and
<b>ssize_t</b>) as the opposite signedness to ensure that
the output matches that of <b>printf</b>. This does not
apply when converting from non-variadic functions such as
<b>absl::PrintF</b> and <b>fmt::printf</b>. For example,
with <i>StrictMode</i> enabled:</p>

<p style="margin-left:22%; margin-top: 1em">int i = -42;
<br>
unsigned int u = 0xffffffff; <br>
printf(&quot;%d %u\n&quot;, i, u);</p>

<p style="margin-left:18%; margin-top: 1em">would be
converted to:</p>


<p style="margin-left:22%; margin-top: 1em">std::print(&quot;{}
{}\n&quot;, static_cast&lt;unsigned int&gt;(i),
static_cast&lt;int&gt;(u));</p>

<p style="margin-left:18%; margin-top: 1em">to ensure that
the output will continue to be the unsigned representation
of <i>-42</i> and the signed representation of
<i>0xffffffff</i> (often <i>4294967254</i> and <i>-1</i>
respectively.) When <i>false</i> (which is the default),
these casts will not be added which may cause a change in
the output.</p>

<p style="margin-left:9%;"><b>PrintfLikeFunctions</b></p>

<p style="margin-left:18%;">A semicolon-separated list of
(fully qualified) function names to replace, with the
requirement that the first parameter contains the
printf-style format string and the arguments to be formatted
follow immediately afterwards. If neither this option nor
<i>FprintfLikeFunctions</i> are set then the default value
for this option is <i>printf; absl::PrintF</i>, otherwise it
is empty.</p>

<p style="margin-left:9%;"><b>FprintfLikeFunctions</b></p>

<p style="margin-left:18%;">A semicolon-separated list of
(fully qualified) function names to replace, with the
requirement that the first parameter is retained, the second
parameter contains the printf-style format string and the
arguments to be formatted follow immediately afterwards. If
neither this option nor <i>PrintfLikeFunctions</i> are set
then the default value for this option is <i>fprintf;
absl::FPrintF</i>, otherwise it is empty.</p>


<p style="margin-left:9%;"><b>ReplacementPrintFunction</b></p>

<p style="margin-left:18%;">The function that will be used
to replace <b>printf</b>, <b>fprintf</b> etc. during
conversion rather than the default <b>std::print</b> when
the originalformat string does not end with <b>\n</b>. It is
expected that the function provides an interface that is
compatible with <b>std::print</b>. A suitable candidate
would be <b>fmt::print</b>.</p>


<p style="margin-left:9%;"><b>ReplacementPrintlnFunction</b></p>

<p style="margin-left:18%;">The function that will be used
to replace <b>printf</b>, <b>fprintf</b> etc. during
conversion rather than the default <b>std::println</b> when
the original format string ends with <b>\n</b>. It is
expected that the function provides an interface that is
compatible with <b>std::println</b>. A suitable candidate
would be <b>fmt::println</b>.</p>

<p style="margin-left:9%;"><b>PrintHeader</b></p>

<p style="margin-left:18%;">The header that must be
included for the declaration of
<i>ReplacementPrintFunction</i> so that a <b>#include</b>
directive can be added if required. If
<i>ReplacementPrintFunction</i> is <b>std::print</b> then
this option will default to <b>&lt;print&gt;</b>, otherwise
this option will default to nothing and no <b>#include</b>
directive will be added.</p>

<h3>modernize-use-trailing-return-type
<a name="modernize-use-trailing-return-type"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Rewrites
function signatures to use a trailing return type
(introduced in C++11). This transformation is purely
stylistic. The return type before the function name is
replaced by <b>auto</b> and inserted after the function
parameter list (and qualifiers).</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">int f1(); <br>
inline int f2(int arg) noexcept; <br>
virtual float f3() const &amp;&amp; = delete;</p>

<p style="margin-left:9%; margin-top: 1em">transforms
to:</p>

<p style="margin-left:13%; margin-top: 1em">auto f1() -&gt;
int; <br>
inline auto f2(int arg) -&gt; int noexcept; <br>
virtual auto f3() const &amp;&amp; -&gt; float = delete;</p>

<h3>Known Limitations
<a name="Known Limitations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The following
categories of return types cannot be rewritten
currently:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="30%">


<p>function pointers</p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="30%">


<p>member function pointers</p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="30%">


<p>member pointers</p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Unqualified
names in the return type might erroneously refer to
different entities after the rewrite. Preventing such errors
requires a full lookup of all unqualified names present in
the return type in the scope of the trailing return type
location. This location includes e.g. function parameter
names and members of the enclosing class (including all
inherited classes). Such a lookup is currently not
implemented.</p>

<p style="margin-left:9%; margin-top: 1em">Given the
following piece of code</p>

<p style="margin-left:13%; margin-top: 1em">struct S { long
long value; }; <br>
S f(unsigned S) { return {S * 2}; } <br>
class CC { <br>
int S; <br>
struct S m(); <br>
}; <br>
S CC::m() { return {0}; }</p>

<p style="margin-left:9%; margin-top: 1em">a careless
rewrite would produce the following output:</p>

<p style="margin-left:13%; margin-top: 1em">struct S { long
long value; }; <br>
auto f(unsigned S) -&gt; S { return {S * 2}; } // error <br>
class CC { <br>
int S; <br>
auto m() -&gt; struct S; <br>
}; <br>
auto CC::m() -&gt; S { return {0}; } // error</p>

<p style="margin-left:9%; margin-top: 1em">This code fails
to compile because the S in the context of f refers to the
equally named function parameter. Similarly, the S in the
context of m refers to the equally named class member. The
check can currently only detect and avoid a clash with a
function parameter name.</p>

<h3>modernize-use-transparent-functors
<a name="modernize-use-transparent-functors"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Prefer
transparent functors to non-transparent ones. When using
transparent functors, the type does not need to be repeated.
The code is easier to read, maintain and less prone to
errors. It is not possible to introduce unwanted
conversions.</p>

<p style="margin-left:13%; margin-top: 1em">//
Non-transparent functor <br>
std::map&lt;int, std::string, std::greater&lt;int&gt;&gt;
s;</p>

<p style="margin-left:13%; margin-top: 1em">// Transparent
functor. <br>
std::map&lt;int, std::string, std::greater&lt;&gt;&gt;
s;</p>

<p style="margin-left:13%; margin-top: 1em">//
Non-transparent functor <br>
using MyFunctor = std::less&lt;MyType&gt;;</p>

<p style="margin-left:9%; margin-top: 1em">It is not always
a safe transformation though. The following case will be
untouched to preserve the semantics.</p>

<p style="margin-left:13%; margin-top: 1em">//
Non-transparent functor <br>
std::map&lt;const char *, std::string,
std::greater&lt;std::string&gt;&gt; s;</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>SafeMode</b></p>

<p style="margin-left:18%;">If the option is set to
<i>true</i>, the check will not diagnose cases where using a
transparent functor cannot be guaranteed to produce
identical results as the original code. The default value
for this option is <i>false</i>.</p>

<p style="margin-left:9%; margin-top: 1em">This check
requires using C++14 or higher to run.</p>

<h3>modernize-use-uncaught-exceptions
<a name="modernize-use-uncaught-exceptions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check will
warn on calls to <b>std::uncaught_exception</b> and replace
them with calls to <b>std::uncaught_exceptions</b>, since
<b>std::uncaught_exception</b> was deprecated in C++17.</p>

<p style="margin-left:9%; margin-top: 1em">Below are a few
examples of what kind of occurrences will be found and what
they will be replaced with.</p>

<p style="margin-left:13%; margin-top: 1em">#define MACRO1
std::uncaught_exception <br>
#define MACRO2 std::uncaught_exception</p>

<p style="margin-left:13%; margin-top: 1em">int
uncaught_exception() { <br>
return 0; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
int res;</p>

<p style="margin-left:13%; margin-top: 1em">res =
uncaught_exception(); <br>
// No warning, since it is not the deprecated function from
namespace std</p>

<p style="margin-left:13%; margin-top: 1em">res = MACRO2();
<br>
// Warning, but will not be replaced</p>

<p style="margin-left:13%; margin-top: 1em">res =
std::uncaught_exception(); <br>
// Warning and replaced</p>

<p style="margin-left:13%; margin-top: 1em">using
std::uncaught_exception; <br>
// Warning and replaced</p>

<p style="margin-left:13%; margin-top: 1em">res =
uncaught_exception(); <br>
// Warning and replaced <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">After applying
the fixes the code will look like the following:</p>

<p style="margin-left:13%; margin-top: 1em">#define MACRO1
std::uncaught_exception <br>
#define MACRO2 std::uncaught_exception</p>

<p style="margin-left:13%; margin-top: 1em">int
uncaught_exception() { <br>
return 0; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
int res;</p>

<p style="margin-left:13%; margin-top: 1em">res =
uncaught_exception();</p>

<p style="margin-left:13%; margin-top: 1em">res =
MACRO2();</p>

<p style="margin-left:13%; margin-top: 1em">res =
std::uncaught_exceptions();</p>

<p style="margin-left:13%; margin-top: 1em">using
std::uncaught_exceptions;</p>

<p style="margin-left:13%; margin-top: 1em">res =
uncaught_exceptions(); <br>
}</p>

<h3>modernize-use-using
<a name="modernize-use-using"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check
converts the usage of <b>typedef</b> with <b>using</b>
keyword.</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">typedef int
variable;</p>

<p style="margin-left:13%; margin-top: 1em">class Class{};
<br>
typedef void (Class::* MyPtrType)() const;</p>

<p style="margin-left:13%; margin-top: 1em">typedef struct
{ int a; } R_t, *R_p;</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">using variable
= int;</p>

<p style="margin-left:13%; margin-top: 1em">class Class{};
<br>
using MyPtrType = void (Class::*)() const;</p>

<p style="margin-left:13%; margin-top: 1em">using R_t =
struct { int a; }; <br>
using R_p = R_t*;</p>

<p style="margin-left:9%; margin-top: 1em">The checker
ignores <i>typedef</i> within <i>extern &quot;C&quot; { ...
}</i> blocks.</p>

<p style="margin-left:13%; margin-top: 1em">extern
&quot;C&quot; { <br>
typedef int InExternC; // Left intact. <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">This check
requires using C++11 or higher to run.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, the
check will not give warnings inside macros. Default is
<i>true</i>.</p>

<p style="margin-left:9%;"><b>IgnoreExternC</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, the
check will not give warning inside <i>extern
&quot;C&quot;`scope. Default is `false</i></p>

<h3>mpi-buffer-deref
<a name="mpi-buffer-deref"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
verifies if a buffer passed to an MPI (Message Passing
Interface) function is sufficiently dereferenced. Buffers
should be passed as a single pointer or array. As MPI
function signatures specify <b>void *</b> for their buffer
types, insufficiently dereferenced buffers can be passed,
like for example as double pointers or multidimensional
arrays, without a compiler warning emitted.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">// A double
pointer is passed to the MPI function. <br>
char *buf; <br>
MPI_Send(&amp;buf, 1, MPI_CHAR, 0, 0, MPI_COMM_WORLD);</p>

<p style="margin-left:13%; margin-top: 1em">// A
multidimensional array is passed to the MPI function. <br>
short buf[1][1]; <br>
MPI_Send(buf, 1, MPI_SHORT, 0, 0, MPI_COMM_WORLD);</p>

<p style="margin-left:13%; margin-top: 1em">// A pointer to
an array is passed to the MPI function. <br>
short *buf[1]; <br>
MPI_Send(buf, 1, MPI_SHORT, 0, 0, MPI_COMM_WORLD);</p>

<h3>mpi-type-mismatch
<a name="mpi-type-mismatch"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
verifies if buffer type and MPI (Message Passing Interface)
datatype pairs match for used MPI functions. All MPI
datatypes defined by the MPI standard (3.1) are verified by
this check. User defined typedefs, custom MPI datatypes and
null pointer constants are skipped, in the course of
verification.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">// In this
case, the buffer type matches MPI datatype. <br>
char buf; <br>
MPI_Send(&amp;buf, 1, MPI_CHAR, 0, 0, MPI_COMM_WORLD);</p>

<p style="margin-left:13%; margin-top: 1em">// In the
following case, the buffer type does not match MPI datatype.
<br>
int buf; <br>
MPI_Send(&amp;buf, 1, MPI_CHAR, 0, 0, MPI_COMM_WORLD);</p>

<h3>objc-assert-equals
<a name="objc-assert-equals"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds improper
usages of <i>XCTAssertEqual</i> and <i>XCTAssertNotEqual</i>
and replaces them with <i>XCTAssertEqualObjects</i> or
<i>XCTAssertNotEqualObjects</i>.</p>

<p style="margin-left:9%; margin-top: 1em">This makes tests
less fragile, as many improperly rely on pointer equality
for strings that have equal values. This assumption is not
guaranteed by the language.</p>

<h3>objc-avoid-nserror-init
<a name="objc-avoid-nserror-init"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds improper
initialization of <b>NSError</b> objects.</p>

<p style="margin-left:9%; margin-top: 1em">According to
Apple developer document, we should always use factory
method <b>errorWithDomain:code:userInfo:</b> to create new
NSError objects instead of <b>[NSError alloc] init]</b>.
Otherwise it will lead to a warning message during
runtime.</p>

<p style="margin-left:9%; margin-top: 1em">The
corresponding information about <b>NSError</b> creation: -
<i>https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ErrorHandlingCocoa/CreateCustomizeNSError/CreateCustomizeNSError.html</i></p>

<h3>objc-dealloc-in-category
<a name="objc-dealloc-in-category"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
implementations of <b>-dealloc</b> in Objective-C
categories. The category implementation will override any
<b>-dealloc</b> in the class implementation, potentially
causing issues.</p>

<p style="margin-left:9%; margin-top: 1em">Classes
implement <b>-dealloc</b> to perform important actions to
deallocate an object. If a category on the class implements
<b>-dealloc</b>, it will override the class's implementation
and unexpected deallocation behavior may occur.</p>

<h3>objc-forbidden-subclassing
<a name="objc-forbidden-subclassing"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
Objective-C classes which are subclasses of classes which
are not designed to be subclassed.</p>

<p style="margin-left:9%; margin-top: 1em">By default,
includes a list of Objective-C classes which are publicly
documented as not supporting subclassing.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">Instead of using this check,
for code under your control, you should add
<b>__attribute__((objc_subclassing_restricted))</b> before
your <b>@interface</b> declarations to ensure the compiler
prevents others from subclassing your Objective-C classes.
See -
<i>https://clang.llvm.org/docs/AttributeReference.html#objc-subclassing-restricted</i></p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i><b>ForbiddenSuperClassNames</b></i></p>

<p style="margin-left:18%;">Semicolon-separated list of
names of Objective-C classes which do not support
subclassing.</p>

<p style="margin-left:18%; margin-top: 1em">Defaults to
<i>ABNewPersonViewController;ABPeoplePickerNavigationController;ABPersonViewController;ABUnknownPersonViewController;NSHashTable;NSMapTable;NSPointerArray;NSPointerFunctions;NSTimer;UIActionSheet;UIAlertView;UIImagePickerController;UITextInputMode;UIWebView</i>.</p>

<h3>objc-missing-hash
<a name="objc-missing-hash"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
Objective-C implementations that implement <b>-isEqual:</b>
without also appropriately implementing <b>-hash</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Apple
documentation highlights that objects that are equal must
have the same hash value: -
<i>https://developer.apple.com/documentation/objectivec/1418956-nsobject/1418795-isequal?language=objc</i></p>

<p style="margin-left:9%; margin-top: 1em">Note that the
check only verifies the presence of <b>-hash</b> in
scenarios where its omission could result in unexpected
behavior. The verification of the implementation of
<b>-hash</b> is the responsibility of the developer, e.g.,
through the addition of unit tests to verify the
implementation.</p>

<h3>objc-nsdate-formatter
<a name="objc-nsdate-formatter"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">When
<b>NSDateFormatter</b> is used to convert an <b>NSDate</b>
type to a <b>String</b> type, the user can specify a custom
format string. Certain format specifiers are undesirable
despite being legal. See -
<i>http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns</i>
for all legal date patterns.</p>

<p style="margin-left:9%; margin-top: 1em">This checker
reports as warnings the following string patterns in a date
format specifier:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="87%">


<p>yyyy + ww : Calendar year specified with week of a week
year (unless YYYY is also specified).</p></td></tr>
</table>

<p style="margin-left:13%;">&bull;</p>

<p style="margin-top: 1em"><b>Example 1:</b> Input Date:
<i>29 December 2014</i> ; Format String: <i>yyyy-ww</i>;
<br>
Output string: <i>2014-01</i> (Wrong because it&rsquo;s not
the first week of 2014)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em"><b>Example
2:</b> Input Date: <i>29 December 2014</i> ; Format String:
<i>dd-MM-yyyy (ww-YYYY)</i>; <br>
Output string: <i>29-12-2014 (01-2015)</i> (This is
correct)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="1%"></td>
<td width="87%">


<p style="margin-top: 1em">F without ee/EE : Numeric day of
week in a month without actual day.</p></td></tr>
</table>

<p style="margin-left:13%;">&bull;</p>

<p style="margin-top: 1em"><b>Example:</b> Input Date:
<i>29 December 2014</i> ; Format String: <i>F-MM</i>; <br>
Output string: <i>5-12</i> (Wrong because it reads as <i>5th
___ of Dec</i> in English)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="1%"></td>
<td width="77%">


<p style="margin-top: 1em">F without MM : Numeric day of
week in a month without month.</p></td>
<td width="10%">
</td></tr>
</table>

<p style="margin-left:13%;">&bull;</p>

<p style="margin-top: 1em"><b>Example:</b> Input Date:
<i>29 December 2014</i> ; Format String: <i>F-EE</i> <br>
Output string: <i>5-Mon</i> (Wrong because it reads as
<i>5th Mon of ___</i> in English)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p style="margin-top: 1em">4.</p></td>
<td width="1%"></td>
<td width="66%">


<p style="margin-top: 1em">WW without MM : Week of the
month without the month.</p></td>
<td width="21%">
</td></tr>
</table>

<p style="margin-left:13%;">&bull;</p>

<p style="margin-top: 1em"><b>Example:</b> Input Date:
<i>29 December 2014</i> ; Format String: <i>WW-yyyy</i> <br>
Output string: <i>05-2014</i> (Wrong because it reads as
<i>5th Week of ___</i> in English)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p style="margin-top: 1em">5.</p></td>
<td width="1%"></td>
<td width="87%">


<p style="margin-top: 1em">YYYY + QQ : Week year specified
with quarter of normal year (unless yyyy is also
specified).</p> </td></tr>
</table>

<p style="margin-left:13%;">&bull;</p>

<p style="margin-top: 1em"><b>Example 1:</b> Input Date:
<i>29 December 2014</i> ; Format String: <i>YYYY-QQ</i> <br>
Output string: <i>2015-04</i> (Wrong because it&rsquo;s not
the 4th quarter of 2015)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em"><b>Example
2:</b> Input Date: <i>29 December 2014</i> ; Format String:
<i>ww-YYYY (QQ-yyyy)</i> <br>
Output string: <i>01-2015 (04-2014)</i> (This is
correct)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p style="margin-top: 1em">6.</p></td>
<td width="1%"></td>
<td width="87%">


<p style="margin-top: 1em">YYYY + MM : Week year specified
with Month of a calendar year (unless yyyy is also
specified).</p> </td></tr>
</table>

<p style="margin-left:13%;">&bull;</p>

<p style="margin-top: 1em"><b>Example 1:</b> Input Date:
<i>29 December 2014</i> ; Format String: <i>YYYY-MM</i> <br>
Output string: <i>2015-12</i> (Wrong because it&rsquo;s not
the 12th month of 2015)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em"><b>Example
2:</b> Input Date: <i>29 December 2014</i> ; Format String:
<i>ww-YYYY (MM-yyyy)</i> <br>
Output string: <i>01-2015 (12-2014)</i> (This is
correct)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p style="margin-top: 1em">7.</p></td>
<td width="1%"></td>
<td width="87%">


<p style="margin-top: 1em">YYYY + DD : Week year with day
of a calendar year (unless yyyy is also specified).</p></td></tr>
</table>

<p style="margin-left:13%;">&bull;</p>

<p style="margin-top: 1em"><b>Example 1:</b> Input Date:
<i>29 December 2014</i> ; Format String: <i>YYYY-DD</i> <br>
Output string: <i>2015-363</i> (Wrong because it&rsquo;s not
the 363rd day of 2015)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em"><b>Example
2:</b> Input Date: <i>29 December 2014</i> ; Format String:
<i>ww-YYYY (DD-yyyy)</i> <br>
Output string: <i>01-2015 (363-2014)</i> (This is
correct)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p style="margin-top: 1em">8.</p></td>
<td width="1%"></td>
<td width="87%">


<p style="margin-top: 1em">YYYY + WW : Week year with week
of a calendar year (unless yyyy is also specified).</p></td></tr>
</table>

<p style="margin-left:13%;">&bull;</p>

<p style="margin-top: 1em"><b>Example 1:</b> Input Date:
<i>29 December 2014</i> ; Format String: <i>YYYY-WW</i> <br>
Output string: <i>2015-05</i> (Wrong because it&rsquo;s not
the 5th week of 2015)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em"><b>Example
2:</b> Input Date: <i>29 December 2014</i> ; Format String:
<i>ww-YYYY (WW-MM-yyyy)</i> <br>
Output string: <i>01-2015 (05-12-2014)</i> (This is
correct)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p style="margin-top: 1em">9.</p></td>
<td width="1%"></td>
<td width="87%">


<p style="margin-top: 1em">YYYY + F : Week year with day of
week in a calendar month (unless yyyy is also
specified).</p> </td></tr>
</table>

<p style="margin-left:13%;">&bull;</p>

<p style="margin-top: 1em"><b>Example 1:</b> Input Date:
<i>29 December 2014</i> ; Format String: <i>YYYY-ww-F-EE</i>
<br>
Output string: <i>2015-01-5-Mon</i> (Wrong because
it&rsquo;s not the 5th Monday of January in 2015)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em"><b>Example
2:</b> Input Date: <i>29 December 2014</i> ; Format String:
<i>ww-YYYY (F-EE-MM-yyyy)</i> <br>
Output string: <i>01-2015 (5-Mon-12-2014)</i> (This is
correct)</p>

<h3>objc-nsinvocation-argument-lifetime
<a name="objc-nsinvocation-argument-lifetime"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds calls to
<b>NSInvocation</b> methods under ARC that don't have proper
argument object lifetimes. When passing Objective-C objects
as parameters to the <b>NSInvocation</b> methods
<b>getArgument:atIndex:</b> and <b>getReturnValue:</b>, the
values are copied by value into the argument pointer, which
leads to incorrect releasing behavior if the object pointers
are not declared <b>__unsafe_unretained</b>.</p>

<p style="margin-left:9%; margin-top: 1em">For code:</p>

<p style="margin-left:13%; margin-top: 1em">id arg; <br>
[invocation getArgument:&amp;arg atIndex:2];</p>

<p style="margin-left:13%; margin-top: 1em">__strong id
returnValue; <br>
[invocation getReturnValue:&amp;returnValue];</p>

<p style="margin-left:9%; margin-top: 1em">The fix will
be:</p>


<p style="margin-left:13%; margin-top: 1em">__unsafe_unretained
id arg; <br>
[invocation getArgument:&amp;arg atIndex:2];</p>


<p style="margin-left:13%; margin-top: 1em">__unsafe_unretained
id returnValue; <br>
[invocation getReturnValue:&amp;returnValue];</p>

<p style="margin-left:9%; margin-top: 1em">The check will
warn on being passed instance variable references that have
lifetimes other than <b>__unsafe_unretained</b>, but does
not propose a fix:</p>

<p style="margin-left:13%; margin-top: 1em">// &quot;id
_returnValue&quot; is declaration of instance variable of
class. <br>
[invocation getReturnValue:&amp;self-&gt;_returnValue];</p>

<h3>objc-property-declaration
<a name="objc-property-declaration"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds property
declarations in Objective-C files that do not follow the
pattern of property names in Apple's programming guide. The
property name should be in the format of Lower Camel
Case.</p>

<p style="margin-left:9%; margin-top: 1em">For code:</p>


<p style="margin-left:13%; margin-top: 1em">@property(nonatomic,
assign) int LowerCamelCase;</p>

<p style="margin-left:9%; margin-top: 1em">The fix will
be:</p>


<p style="margin-left:13%; margin-top: 1em">@property(nonatomic,
assign) int lowerCamelCase;</p>

<p style="margin-left:9%; margin-top: 1em">The check will
only fix 'CamelCase' to 'camelCase'. In some other cases we
will only provide warning messages since the property name
could be complicated. Users will need to come up with a
proper name by their own.</p>

<p style="margin-left:9%; margin-top: 1em">This check also
accepts special acronyms as prefixes or suffixes. Such
prefixes or suffixes will suppress the Lower Camel Case
check according to the guide: -
<i>https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingBasics.html#//apple_ref/doc/uid/20001281-1002931-BBCFHEAB</i></p>

<p style="margin-left:9%; margin-top: 1em">For a full list
of well-known acronyms: -
<i>https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/APIAbbreviations.html#//apple_ref/doc/uid/20001285-BCIHCGAE</i></p>

<p style="margin-left:9%; margin-top: 1em">The
corresponding style rule: -
<i>https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-1001757</i></p>

<p style="margin-left:9%; margin-top: 1em">The check will
also accept property declared in category with a prefix of
lowercase letters followed by a '_' to avoid naming
conflict. For example:</p>


<p style="margin-left:13%; margin-top: 1em">@property(nonatomic,
assign) int abc_lowerCamelCase;</p>

<p style="margin-left:9%; margin-top: 1em">The
corresponding style rule: -
<i>https://developer.apple.com/library/content/qa/qa1908/_index.html</i></p>

<h3>objc-super-self
<a name="objc-super-self"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
invocations of <b>-self</b> on super instances in
initializers of subclasses of <b>NSObject</b> and recommends
calling a superclass initializer instead.</p>

<p style="margin-left:9%; margin-top: 1em">Invoking
<b>-self</b> on super instances in initializers is a common
programmer error when the programmer's original intent is to
call a superclass initializer. Failing to call a superclass
initializer breaks initializer chaining and can result in
invalid object initialization.</p>

<h3>openmp-exception-escape
<a name="openmp-exception-escape"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Analyzes OpenMP
Structured Blocks and checks that no exception escapes out
of the Structured Block it was thrown in.</p>

<p style="margin-left:9%; margin-top: 1em">As per the
OpenMP specification, a structured block is an executable
statement, possibly compound, with a single entry at the top
and a single exit at the bottom. Which means, <b>throw</b>
may not be used to 'exit' out of the structured block. If an
exception is not caught in the same structured block it was
thrown in, the behavior is undefined.</p>

<p style="margin-left:9%; margin-top: 1em">FIXME: this
check does not model SEH, <b>setjmp</b>/<b>longjmp</b>.</p>

<p style="margin-left:9%; margin-top: 1em">WARNING! This
check may be expensive on large source files.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoredExceptions</b></p>

<p style="margin-left:18%;">Comma-separated list containing
type names which are not counted as thrown exceptions in the
check. Default value is an empty string.</p>

<h3>openmp-use-default-none
<a name="openmp-use-default-none"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds OpenMP
directives that are allowed to contain a <b>default</b>
clause, but either don't specify it or the clause is
specified but with the kind other than <b>none</b>, and
suggests to use the <b>default(none)</b> clause.</p>

<p style="margin-left:9%; margin-top: 1em">Using
<b>default(none)</b> clause forces developers to explicitly
specify data sharing attributes for the variables referenced
in the construct, thus making it obvious which variables are
referenced, and what is their data sharing attribute, thus
increasing readability and possibly making errors easier to
spot.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">// ``for``
directive cannot have ``default`` clause, no diagnostics.
<br>
void n0(const int a) { <br>
#pragma omp for <br>
for (int b = 0; b &lt; a; b++) <br>
; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// ``parallel``
directive.</p>

<p style="margin-left:13%; margin-top: 1em">// ``parallel``
directive can have ``default`` clause, but said clause is
not <br>
// specified, diagnosed. <br>
void p0_0() { <br>
#pragma omp parallel <br>
; <br>
// WARNING: OpenMP directive ``parallel`` does not specify
``default`` <br>
// clause. Consider specifying ``default(none)`` clause.
<br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// ``parallel``
directive can have ``default`` clause, and said clause is
<br>
// specified, with ``none`` kind, all good. <br>
void p0_1() { <br>
#pragma omp parallel default(none) <br>
; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// ``parallel``
directive can have ``default`` clause, and said clause is
<br>
// specified, but with ``shared`` kind, which is not
``none``, diagnose. <br>
void p0_2() { <br>
#pragma omp parallel default(shared) <br>
; <br>
// WARNING: OpenMP directive ``parallel`` specifies
``default(shared)`` <br>
// clause. Consider using ``default(none)`` clause instead.
<br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// ``parallel``
directive can have ``default`` clause, and said clause is
<br>
// specified, but with ``firstprivate`` kind, which is not
``none``, diagnose. <br>
void p0_3() { <br>
#pragma omp parallel default(firstprivate) <br>
; <br>
// WARNING: OpenMP directive ``parallel`` specifies
``default(firstprivate)`` <br>
// clause. Consider using ``default(none)`` clause instead.
<br>
}</p>

<h3>performance-avoid-endl
<a name="performance-avoid-endl"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for uses
of <b>std::endl</b> on streams and suggests using the
newline character <b>'\n'</b> instead.</p>

<p style="margin-left:9%; margin-top: 1em">Rationale: Using
<b>std::endl</b> on streams can be less efficient than using
the newline character <b>'\n'</b> because <b>std::endl</b>
performs two operations: it writes a newline character to
the output stream and then flushes the stream buffer.
Writing a single newline character using <b>'\n'</b> does
not trigger a flush, which can improve performance. In
addition, flushing the stream buffer can cause additional
overhead when working with streams that are buffered.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:9%; margin-top: 1em">Consider the
following code:</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;iostream&gt;</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl;
<br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Which gets
transformed into:</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;iostream&gt;</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; '\n'; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">This code writes
a single newline character to the <b>std::cout</b> stream
without flushing the stream buffer.</p>

<p style="margin-left:9%; margin-top: 1em">Additionally, it
is important to note that the standard C++ streams (like
<b>std::cerr</b>, <b>std::wcerr</b>, <b>std::clog</b> and
<b>std::wclog</b>) always flush after a write operation,
unless <b>std::ios_base::sync_with_stdio</b> is set to
<b>false</b>. regardless of whether <b>std::endl</b> or
<b>'\n'</b> is used. Therefore, using <b>'\n'</b> with these
streams will not result in any performance gain, but it is
still recommended to use <b>'\n'</b> for consistency and
readability.</p>

<p style="margin-left:9%; margin-top: 1em">If you do need
to flush the stream buffer, you can use <b>std::flush</b>
explicitly like this:</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;iostream&gt;</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
std::cout &lt;&lt; &quot;Hello\n&quot; &lt;&lt; std::flush;
<br>
}</p>

<h3>performance-enum-size
<a name="performance-enum-size"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Recommends the
smallest possible underlying type for an <b>enum</b> or
<b>enum</b> class based on the range of its enumerators.
Analyzes the values of the enumerators in an <b>enum</b> or
<b>enum</b> class, including signed values, to recommend the
smallest possible underlying type that can represent all the
values of the <b>enum</b>. The suggested underlying types
are the integral types <b>std::uint8_t</b>,
<b>std::uint16_t</b>, and <b>std::uint32_t</b> for unsigned
types, and <b>std::int8_t</b>, <b>std::int16_t</b>, and
<b>std::int32_t</b> for signed types. Using the suggested
underlying types can help reduce the memory footprint of the
program and improve performance in some cases.</p>

<p style="margin-left:9%; margin-top: 1em">For example:</p>

<p style="margin-left:13%; margin-top: 1em">// BEFORE <br>
enum Color { <br>
RED = -1, <br>
GREEN = 0, <br>
BLUE = 1 <br>
};</p>


<p style="margin-left:13%; margin-top: 1em">std::optional&lt;Color&gt;
color_opt;</p>

<p style="margin-left:9%; margin-top: 1em">The <i>Color</i>
<b>enum</b> uses the default underlying type, which is
<b>int</b> in this case, and its enumerators have values of
-1, 0, and 1. Additionally, the
<b>std::optional&lt;Color&gt;</b> object uses 8 bytes due to
padding (platform dependent).</p>

<p style="margin-left:13%; margin-top: 1em">// AFTER <br>
enum Color : std:int8_t { <br>
RED = -1, <br>
GREEN = 0, <br>
BLUE = 1 <br>
}</p>


<p style="margin-left:13%; margin-top: 1em">std::optional&lt;Color&gt;
color_opt;</p>

<p style="margin-left:9%; margin-top: 1em">In the revised
version of the <i>Color</i> <b>enum</b>, the underlying type
has been changed to <b>std::int8_t</b>. The enumerator
<i>RED</i> has a value of -1, which can be represented by a
signed 8-bit integer.</p>

<p style="margin-left:9%; margin-top: 1em">By using a
smaller underlying type, the memory footprint of the
<i>Color</i> <b>enum</b> is reduced from 4 bytes to 1 byte.
The revised version of the <b>std::optional&lt;Color&gt;</b>
object would only require 2 bytes (due to lack of padding),
since it contains a single byte for the <i>Color</i>
<b>enum</b> and a single byte for the <b>bool</b> flag that
indicates whether the optional value is set.</p>

<p style="margin-left:9%; margin-top: 1em">Reducing the
memory footprint of an <b>enum</b> can have significant
benefits in terms of memory usage and cache performance.
However, it's important to consider the trade-offs and
potential impact on code readability and
maintainability.</p>

<p style="margin-left:9%; margin-top: 1em">Enums without
enumerators (empty) are excluded from analysis.</p>

<p style="margin-left:9%; margin-top: 1em">Requires C++11
or above. Does not provide auto-fixes.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>EnumIgnoreList</b></p>

<p style="margin-left:18%;">Option is used to ignore
certain enum types. It accepts a semicolon-separated list of
(fully qualified) enum type names or regular expressions
that match the enum type names. The default value is an
empty string, which means no enums will be ignored.</p>

<h3>performance-faster-string-find
<a name="performance-faster-string-find"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Optimize calls
to <b>std::string::find()</b> and friends when the needle
passed is a single character string literal. The character
literal overload is more efficient.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>


<p style="margin-left:13%; margin-top: 1em">str.find(&quot;A&quot;);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>


<p style="margin-left:13%; margin-top: 1em">str.find('A');</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>StringLikeClasses</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
names of string-like classes. By default only
<b>::std::basic_string</b> and
<b>::std::basic_string_view</b> are considered. The check
will only consider member functions named <b>find</b>,
<b>rfind</b>, <b>find_first_of</b>,
<b>find_first_not_of</b>, <b>find_last_of</b>, or
<b>find_last_not_of</b> within these classes.</p>

<h3>performance-for-range-copy
<a name="performance-for-range-copy"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds C++11 for
ranges where the loop variable is copied in each iteration
but it would suffice to obtain it by const reference.</p>

<p style="margin-left:9%; margin-top: 1em">The check is
only applied to loop variables of types that are expensive
to copy which means they are not trivially copyable or have
a non-trivial copy constructor or destructor.</p>

<p style="margin-left:9%; margin-top: 1em">To ensure that
it is safe to replace the copy with a const reference the
following heuristic is employed:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="87%">


<p>The loop variable is const qualified.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="87%">


<p>The loop variable is not const, but only const methods
or operators are invoked on it, or it is used as const
reference or value argument in constructors or function
calls.</p> </td></tr>
</table>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>WarnOnAllAutoCopies</b></p>

<p style="margin-left:18%;">When <i>true</i>, warns on any
use of <i>auto</i> as the type of the range-based for loop
variable. Default is <i>false</i>.</p>

<p style="margin-left:9%;"><b>AllowedTypes</b></p>

<p style="margin-left:18%;">A semicolon-separated list of
names of types allowed to be copied in each iteration.
Regular expressions are accepted, e.g.
<i>[Rr]ef(erence)?$</i> matches every type with suffix
<i>Ref</i>, <i>ref</i>, <i>Reference</i> and
<i>reference</i>. The default is empty. If a name in the
list contains the sequence <i>::</i> it is matched against
the qualified typename (i.e. <i>namespace::Type</i>,
otherwise it is matched against only the type name (i.e.
<i>Type</i>).</p>

<h3>performance-implicit-cast-in-loop
<a name="performance-implicit-cast-in-loop"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check has
been renamed to
<i>performance-implicit-conversion-in-loop</i>.</p>

<h3>performance-implicit-conversion-in-loop
<a name="performance-implicit-conversion-in-loop"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This warning
appears in a range-based loop with a loop variable of const
ref type where the type of the variable does not match the
one returned by the iterator. This means that an implicit
conversion happens, which can for example result in
expensive deep copies.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">map&lt;int,
vector&lt;string&gt;&gt; my_map; <br>
for (const pair&lt;int, vector&lt;string&gt;&gt;&amp; p :
my_map) {} <br>
// The iterator type is in fact pair&lt;const int,
vector&lt;string&gt;&gt;, which means <br>
// that the compiler added a conversion, resulting in a copy
of the vectors.</p>

<p style="margin-left:9%; margin-top: 1em">The easiest
solution is usually to use <b>const auto&amp;</b> instead of
writing the type manually.</p>

<h3>performance-inefficient-algorithm
<a name="performance-inefficient-algorithm"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns on
inefficient use of STL algorithms on associative
containers.</p>

<p style="margin-left:9%; margin-top: 1em">Associative
containers implement some of the algorithms as methods which
should be preferred to the algorithms in the algorithm
header. The methods can take advantage of the order of the
elements.</p>


<p style="margin-left:13%; margin-top: 1em">std::set&lt;int&gt;
s; <br>
auto it = std::find(s.begin(), s.end(), 43);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">auto it =
s.find(43);</p>


<p style="margin-left:13%; margin-top: 1em">std::set&lt;int&gt;
s; <br>
auto c = std::count(s.begin(), s.end(), 43);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">auto c =
s.count(43);</p>

<h3>performance-inefficient-string-concatenation
<a name="performance-inefficient-string-concatenation"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check warns
about the performance overhead arising from concatenating
strings using the <b>operator+</b>, for instance:</p>

<p style="margin-left:13%; margin-top: 1em">std::string
a(&quot;Foo&quot;), b(&quot;Bar&quot;); <br>
a = a + b;</p>

<p style="margin-left:9%; margin-top: 1em">Instead of this
structure you should use <b>operator+=</b> or
<b>std::string</b>'s (<b>std::basic_string</b>) class member
function <b>append()</b>. For instance:</p>

<p style="margin-left:13%; margin-top: 1em">std::string
a(&quot;Foo&quot;), b(&quot;Baz&quot;); <br>
for (int i = 0; i &lt; 20000; ++i) { <br>
a = a + &quot;Bar&quot; + b; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Could be
rewritten in a greatly more efficient way like:</p>

<p style="margin-left:13%; margin-top: 1em">std::string
a(&quot;Foo&quot;), b(&quot;Baz&quot;); <br>
for (int i = 0; i &lt; 20000; ++i) { <br>
a.append(&quot;Bar&quot;).append(b); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">And this can be
rewritten too:</p>

<p style="margin-left:13%; margin-top: 1em">void f(const
std::string&amp;) {} <br>
std::string a(&quot;Foo&quot;), b(&quot;Baz&quot;); <br>
void g() { <br>
f(a + &quot;Bar&quot; + b); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In a slightly
more efficient way like:</p>

<p style="margin-left:13%; margin-top: 1em">void f(const
std::string&amp;) {} <br>
std::string a(&quot;Foo&quot;), b(&quot;Baz&quot;); <br>
void g() { <br>
f(std::string(a).append(&quot;Bar&quot;).append(b)); <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>StrictMode</b></p>

<p style="margin-left:18%;">When <i>false</i>, the check
will only check the string usage in <b>while</b>, <b>for</b>
and <b>for-range</b> statements. Default is
<i>false</i>.</p>

<h3>performance-inefficient-vector-operation
<a name="performance-inefficient-vector-operation"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds possible
inefficient <b>std::vector</b> operations (e.g.
<b>push_back</b>, <b>emplace_back</b>) that may cause
unnecessary memory reallocations.</p>

<p style="margin-left:9%; margin-top: 1em">It can also find
calls that add element to protobuf repeated field in a loop
without calling Reserve() before the loop. Calling Reserve()
first can avoid unnecessary memory reallocations.</p>

<p style="margin-left:9%; margin-top: 1em">Currently, the
check only detects following kinds of loops with a single
statement body:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="47%">


<p>Counter-based for loops start with 0:</p></td>
<td width="41%">
</td></tr>
</table>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;int&gt;
v; <br>
for (int i = 0; i &lt; n; ++i) { <br>
v.push_back(n); <br>
// This will trigger the warning since the push_back may
cause multiple <br>
// memory reallocations in v. This can be avoid by inserting
a 'reserve(n)' <br>
// statement before the for statement. <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">SomeProto p;
<br>
for (int i = 0; i &lt; n; ++i) { <br>
p.add_xxx(n); <br>
// This will trigger the warning since the add_xxx may cause
multiple memory <br>
// reallocations. This can be avoid by inserting a <br>
// 'p.mutable_xxx().Reserve(n)' statement before the for
statement. <br>
}</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">For-range loops like <b>for
(range-declaration : range_expression)</b>, the type of
<b>range_expression</b> can be <b>std::vector</b>,
<b>std::array</b>, <b>std::deque</b>, <b>std::set</b>,
<b>std::unordered_set</b>, <b>std::map</b>,
<b>std::unordered_set</b>:</p> </td></tr>
</table>


<p style="margin-left:13%; margin-top: 1em">std::vector&lt;int&gt;
data; <br>
std::vector&lt;int&gt; v;</p>

<p style="margin-left:13%; margin-top: 1em">for (auto
element : data) { <br>
v.push_back(element); <br>
// This will trigger the warning since the 'push_back' may
cause multiple <br>
// memory reallocations in v. This can be avoid by inserting
a <br>
// 'reserve(data.size())' statement before the for
statement. <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>VectorLikeClasses</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
names of vector-like classes. By default only
<b>::std::vector</b> is considered.</p>

<p style="margin-left:9%;"><b>EnableProto</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will also warn on inefficient operations for proto repeated
fields. Otherwise, the check only warns on inefficient
vector operations. Default is <i>false</i>.</p>

<h3>performance-move-const-arg
<a name="performance-move-const-arg"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check
warns</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>if <b>std::move()</b> is called with a constant
argument,</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>if <b>std::move()</b> is called with an argument of a
trivially-copyable type,</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>if the result of <b>std::move()</b> is passed as a const
reference argument.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">In all three
cases, the check will suggest a fix that removes the
<b>std::move()</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Here are
examples of each of the three cases:</p>

<p style="margin-left:13%; margin-top: 1em">const string s;
<br>
return std::move(s); // Warning: std::move of the const
variable has no effect</p>

<p style="margin-left:13%; margin-top: 1em">int x; <br>
return std::move(x); // Warning: std::move of the variable
of a trivially-copyable type has no effect</p>

<p style="margin-left:13%; margin-top: 1em">void f(const
string &amp;s); <br>
string s; <br>
f(std::move(s)); // Warning: passing result of std::move as
a const reference argument; no move will actually happen</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>CheckTriviallyCopyableMove</b></p>

<p style="margin-left:18%;">If <i>true</i>, enables
detection of trivially copyable types that do not have a
move constructor. Default is <i>true</i>.</p>

<p style="margin-left:9%;"><b>CheckMoveToConstRef</b></p>

<p style="margin-left:18%;">If <i>true</i>, enables
detection of <i>std::move()</i> passed as a const reference
argument. Default is <i>true</i>.</p>

<h3>performance-move-constructor-init
<a name="performance-move-constructor-init"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em">&quot;cert-oop11-cpp&quot;
redirects here as an alias for this check.</p>

<p style="margin-left:9%; margin-top: 1em">The check flags
user-defined move constructors that have a ctor-initializer
initializing a member or base class through a copy
constructor instead of a move constructor.</p>

<h3>performance-no-automatic-move
<a name="performance-no-automatic-move"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds local
variables that cannot be automatically moved due to
constness.</p>

<p style="margin-left:9%; margin-top: 1em">Under <i>certain
conditions</i>, local values are automatically moved out
when returning from a function. A common mistake is to
declare local <b>lvalue</b> variables <b>const</b>, which
prevents the move.</p>

<p style="margin-left:9%; margin-top: 1em">Example
<i>[1]</i>:</p>


<p style="margin-left:13%; margin-top: 1em">StatusOr&lt;std::vector&lt;int&gt;&gt;
Cool() { <br>
std::vector&lt;int&gt; obj = ...; <br>
return obj; // calls
StatusOr::StatusOr(std::vector&lt;int&gt;&amp;&amp;) <br>
}</p>


<p style="margin-left:13%; margin-top: 1em">StatusOr&lt;std::vector&lt;int&gt;&gt;
NotCool() { <br>
const std::vector&lt;int&gt; obj = ...; <br>
return obj; // calls `StatusOr::StatusOr(const
std::vector&lt;int&gt;&amp;)` <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The former
version (<b>Cool</b>) should be preferred over the latter
(<b>NotCool</b>) as it will avoid allocations and
potentially large memory copies.</p>

<h3>Semantics
<a name="Semantics"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">In the example
above, <b>StatusOr::StatusOr(T&amp;&amp;)</b> have the same
semantics as long as the copy and move constructors for
<b>T</b> have the same semantics. Note that there is no
guarantee that <b>S::S(T&amp;&amp;)</b> and <b>S::S(const
T&amp;)</b> have the same semantics for any single <b>S</b>,
so we're not providing automated fixes for this check, and
judgement should be exerted when making the suggested
changes.</p>

<h3>-Wreturn-std-move
<a name="-Wreturn-std-move"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Another case
where the move cannot happen is the following:</p>


<p style="margin-left:13%; margin-top: 1em">StatusOr&lt;std::vector&lt;int&gt;&gt;
Uncool() { <br>
std::vector&lt;int&gt;&amp;&amp; obj = ...; <br>
return obj; // calls `StatusOr::StatusOr(const
std::vector&lt;int&gt;&amp;)` <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In that case the
fix is more consensual: just <i>return std::move(obj)</i>.
This is handled by the <i>-Wreturn-std-move</i> warning.</p>

<h3>performance-no-int-to-ptr
<a name="performance-no-int-to-ptr"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Diagnoses every
integer to pointer cast.</p>

<p style="margin-left:9%; margin-top: 1em">While casting an
(integral) pointer to an integer is obvious - you just get
the integral value of the pointer, casting an integer to an
(integral) pointer is deceivingly different. While you will
get a pointer with that integral value, if you got that
integral value via a pointer-to-integer cast originally, the
new pointer will lack the provenance information from the
original pointer.</p>

<p style="margin-left:9%; margin-top: 1em">So while
(integral) pointer to integer casts are effectively no-ops,
and are transparent to the optimizer, integer to (integral)
pointer casts are <i>NOT</i> transparent, and may conceal
information from optimizer.</p>

<p style="margin-left:9%; margin-top: 1em">While that may
be the intention, it is not always so. For example, let's
take a look at a routine to align the pointer up to the
multiple of 16: The obvious, naive implementation for that
is:</p>

<p style="margin-left:13%; margin-top: 1em">char* src(char*
maybe_underbiased_ptr) { <br>
uintptr_t maybe_underbiased_intptr =
(uintptr_t)maybe_underbiased_ptr; <br>
uintptr_t aligned_biased_intptr = maybe_underbiased_intptr +
15; <br>
uintptr_t aligned_intptr = aligned_biased_intptr &amp;
(&#732;15); <br>
return (char*)aligned_intptr; // warning: avoid integer to
pointer casts [performance-no-int-to-ptr] <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The check will
rightfully diagnose that cast.</p>

<p style="margin-left:9%; margin-top: 1em">But when
provenance concealment is not the goal of the code, but an
accident, this example can be rewritten as follows, without
using integer to pointer cast:</p>

<p style="margin-left:13%; margin-top: 1em">char* <br>
tgt(char* maybe_underbiased_ptr) { <br>
uintptr_t maybe_underbiased_intptr =
(uintptr_t)maybe_underbiased_ptr; <br>
uintptr_t aligned_biased_intptr = maybe_underbiased_intptr +
15; <br>
uintptr_t aligned_intptr = aligned_biased_intptr &amp;
(&#732;15); <br>
uintptr_t bias = aligned_intptr - maybe_underbiased_intptr;
<br>
return maybe_underbiased_ptr + bias; <br>
}</p>

<h3>performance-noexcept-destructor
<a name="performance-noexcept-destructor"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check flags
user-defined destructors marked with <b>noexcept(expr)</b>
where <b>expr</b> evaluates to <b>false</b> (but is not a
<b>false</b> literal itself).</p>

<p style="margin-left:9%; margin-top: 1em">When a
destructor is marked as <b>noexcept</b>, it assures the
compiler that no exceptions will be thrown during the
destruction of an object, which allows the compiler to
perform certain optimizations such as omitting exception
handling code.</p>

<h3>performance-noexcept-move-constructor
<a name="performance-noexcept-move-constructor"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check flags
user-defined move constructors and assignment operators not
marked with <b>noexcept</b> or marked with
<b>noexcept(expr)</b> where <b>expr</b> evaluates to
<b>false</b> (but is not a <b>false</b> literal itself).</p>

<p style="margin-left:9%; margin-top: 1em">Move
constructors of all the types used with STL containers, for
example, need to be declared <b>noexcept</b>. Otherwise STL
will choose copy constructors instead. The same is valid for
move assignment operations.</p>

<h3>performance-noexcept-swap
<a name="performance-noexcept-swap"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check flags
user-defined swap and iter_swap functions not marked with
<b>noexcept</b> or marked with <b>noexcept(expr)</b> where
<b>expr</b> evaluates to <b>false</b> (but is not a
<b>false</b> literal itself).</p>

<p style="margin-left:9%; margin-top: 1em">When a swap or
iter_swap function is marked as <b>noexcept</b>, it assures
the compiler that no exceptions will be thrown during the
swapping of two objects, which allows the compiler to
perform certain optimizations such as omitting exception
handling code.</p>

<h3>performance-trivially-destructible
<a name="performance-trivially-destructible"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds types that
could be made trivially-destructible by removing out-of-line
defaulted destructor declarations.</p>

<p style="margin-left:13%; margin-top: 1em">struct A:
TrivialType { <br>
&#732;A(); // Makes A non-trivially-destructible. <br>
TrivialType trivial_fields; <br>
}; <br>
A::&#732;A() = default;</p>

<h3>performance-type-promotion-in-math-fn
<a name="performance-type-promotion-in-math-fn"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds calls to C
math library functions (from <b>math.h</b> or, in C++,
<b>cmath</b>) with implicit <b>float</b> to <b>double</b>
promotions.</p>

<p style="margin-left:9%; margin-top: 1em">For example,
warns on <b>::sin(0.f)</b>, because this function's
parameter is a double. You probably meant to call
<b>std::sin(0.f)</b> (in C++), or <b>sinf(0.f)</b> (in
C).</p>

<p style="margin-left:13%; margin-top: 1em">float a; <br>
asin(a);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">float a; <br>
std::asin(a);</p>

<h3>performance-unnecessary-copy-initialization
<a name="performance-unnecessary-copy-initialization"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds local
variable declarations that are initialized using the copy
constructor of a non-trivially-copyable type but it would
suffice to obtain a const reference.</p>

<p style="margin-left:9%; margin-top: 1em">The check is
only applied if it is safe to replace the copy by a const
reference. This is the case when the variable is const
qualified or when it is only used as a const, i.e. only
const methods or operators are invoked on it, or it is used
as const reference or value argument in constructors or
function calls.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">const
string&amp; constReference(); <br>
void Function() { <br>
// The warning will suggest making this a const reference.
<br>
const string UnnecessaryCopy = constReference(); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">struct Foo {
<br>
const string&amp; name() const; <br>
}; <br>
void Function(const Foo&amp; foo) { <br>
// The warning will suggest making this a const reference.
<br>
string UnnecessaryCopy1 = foo.name(); <br>
UnnecessaryCopy1.find(&quot;bar&quot;);</p>

<p style="margin-left:13%; margin-top: 1em">// The warning
will suggest making this a const reference. <br>
string UnnecessaryCopy2 = UnnecessaryCopy1; <br>
UnnecessaryCopy2.find(&quot;bar&quot;); <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>AllowedTypes</b></p>

<p style="margin-left:18%;">A semicolon-separated list of
names of types allowed to be initialized by copying. Regular
expressions are accepted, e.g. <i>[Rr]ef(erence)?$</i>
matches every type with suffix <i>Ref</i>, <i>ref</i>,
<i>Reference</i> and <i>reference</i>. The default is empty.
If a name in the list contains the sequence <i>::</i> it is
matched against the qualified typename (i.e.
<i>namespace::Type</i>, otherwise it is matched against only
the type name (i.e. <i>Type</i>).</p>


<p style="margin-left:9%;"><b>ExcludedContainerTypes</b></p>

<p style="margin-left:18%;">A semicolon-separated list of
names of types whose methods are allowed to return the const
reference the variable is copied from. When an expensive to
copy variable is copy initialized by the return value from a
type on this list the check does not trigger. This can be
used to exclude types known to be const incorrect or where
the lifetime or immutability of returned references is not
tied to mutations of the container. An example are view
types that don't own the underlying data. Like for
<i>AllowedTypes</i> above, regular expressions are accepted
and the inclusion of <i>::</i> determines whether the
qualified typename is matched or not.</p>

<h3>performance-unnecessary-value-param
<a name="performance-unnecessary-value-param"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Flags value
parameter declarations of expensive to copy types that are
copied for each invocation but it would suffice to pass them
by const reference.</p>

<p style="margin-left:9%; margin-top: 1em">The check is
only applied to parameters of types that are expensive to
copy which means they are not trivially copyable or have a
non-trivial copy constructor or destructor.</p>

<p style="margin-left:9%; margin-top: 1em">To ensure that
it is safe to replace the value parameter with a const
reference the following heuristic is employed:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="87%">


<p>the parameter is const qualified;</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="87%">


<p>the parameter is not const, but only const methods or
operators are invoked on it, or it is used as const
reference or value argument in constructors or function
calls.</p> </td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">void f(const
string Value) { <br>
// The warning will suggest making Value a reference. <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
g(ExpensiveToCopy Value) { <br>
// The warning will suggest making Value a const reference.
<br>
Value.ConstMethd(); <br>
ExpensiveToCopy Copy(Value); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">If the parameter
is not const, only copied or assigned once and has a
non-trivial move-constructor or move-assignment operator
respectively the check will suggest to move it.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">void
setValue(string Value) { <br>
Field = Value; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Will become:</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;utility&gt;</p>

<p style="margin-left:13%; margin-top: 1em">void
setValue(string Value) { <br>
Field = std::move(Value); <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IncludeStyle</b></p>

<p style="margin-left:18%;">A string specifying which
include-style is used, <i>llvm</i> or <i>google</i>. Default
is <i>llvm</i>.</p>

<p style="margin-left:9%;"><b>AllowedTypes</b></p>

<p style="margin-left:18%;">A semicolon-separated list of
names of types allowed to be passed by value. Regular
expressions are accepted, e.g. <i>[Rr]ef(erence)?$</i>
matches every type with suffix <i>Ref</i>, <i>ref</i>,
<i>Reference</i> and <i>reference</i>. The default is empty.
If a name in the list contains the sequence <i>::</i> it is
matched against the qualified typename (i.e.
<i>namespace::Type</i>, otherwise it is matched against only
the type name (i.e. <i>Type</i>).</p>

<h3>portability-restrict-system-includes
<a name="portability-restrict-system-includes"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks to
selectively allow or disallow a configurable list of system
headers.</p>

<p style="margin-left:9%; margin-top: 1em">For example:</p>

<p style="margin-left:9%; margin-top: 1em">In order to
<b>only</b> allow <i>zlib.h</i> from the system you would
set the options to <i>-*,zlib.h</i>.</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;curses.h&gt; // Bad: disallowed system header. <br>
#include &lt;openssl/ssl.h&gt; // Bad: disallowed system
header. <br>
#include &lt;zlib.h&gt; // Good: allowed system header. <br>
#include &quot;src/myfile.h&quot; // Good: non-system header
always allowed.</p>

<p style="margin-left:9%; margin-top: 1em">In order to
allow everything <b>except</b> <i>zlib.h</i> from the system
you would set the options to <i>*,-zlib.h</i>.</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;curses.h&gt; // Good: allowed system header. <br>
#include &lt;openssl/ssl.h&gt; // Good: allowed system
header. <br>
#include &lt;zlib.h&gt; // Bad: disallowed system header.
<br>
#include &quot;src/myfile.h&quot; // Good: non-system header
always allowed.</p>

<p style="margin-left:9%; margin-top: 1em">Since the
options support globbing you can use wildcarding to allow
groups of headers.</p>


<p style="margin-left:9%; margin-top: 1em"><i>-*,openssl/*.h</i>
will allow all openssl headers but disallow any others.</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;curses.h&gt; // Bad: disallowed system header. <br>
#include &lt;openssl/ssl.h&gt; // Good: allowed system
header. <br>
#include &lt;openssl/rsa.h&gt; // Good: allowed system
header. <br>
#include &lt;zlib.h&gt; // Bad: disallowed system header.
<br>
#include &quot;src/myfile.h&quot; // Good: non-system header
always allowed.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>Includes</b></p>

<p style="margin-left:18%;">A string containing a comma
separated glob list of allowed include filenames. Similar to
the -checks glob list for running clang-tidy itself, the two
wildcard characters are <i>*</i> and <i>-</i>, to include
and exclude globs, respectively. The default is <i>*</i>,
which allows all includes.</p>

<h3>portability-simd-intrinsics
<a name="portability-simd-intrinsics"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds SIMD
intrinsics calls and suggests <b>std::experimental::simd</b>
(- <i>P0214</i>) alternatives.</p>

<p style="margin-left:9%; margin-top: 1em">If the option
<i>Suggest</i> is set to <i>true</i>, for</p>


<p style="margin-left:13%; margin-top: 1em">_mm_add_epi32(a,
b); // x86 <br>
vec_add(a, b); // Power</p>

<p style="margin-left:9%; margin-top: 1em">the check
suggests an alternative: <b>operator+</b> on
<b>std::experimental::simd</b> objects.</p>

<p style="margin-left:9%; margin-top: 1em">Otherwise, it
just complains the intrinsics are non-portable (and there
are <i>P0214</i> alternatives).</p>

<p style="margin-left:9%; margin-top: 1em">Many
architectures provide SIMD operations (e.g. x86 SSE/AVX,
Power AltiVec/VSX, ARM NEON). It is common that SIMD code
implementing the same algorithm, is written in multiple
target-dispatching pieces to optimize for different
architectures or micro-architectures.</p>

<p style="margin-left:9%; margin-top: 1em">The C++ standard
proposal <i>P0214</i> and its extensions cover many common
SIMD operations. By migrating from target-dependent
intrinsics to <i>P0214</i> operations, the SIMD code can be
simplified and pieces for different targets can be
unified.</p>

<p style="margin-left:9%; margin-top: 1em">Refer to
<i>P0214</i> for introduction and motivation for the
data-parallel standard library.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>Suggest</b></p>

<p style="margin-left:18%;">If this option is set to
<i>true</i> (default is <i>false</i>), the check will
suggest <i>P0214</i> alternatives, otherwise it only points
out the intrinsic function is non-portable.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p><b>Std</b></p></td>
<td width="5%"></td>
<td width="82%">


<p>The namespace used to suggest <i>P0214</i> alternatives.
If not specified, <i>std::</i> for <i>-std=c++20</i> and
<i>std::experimental::</i> for <i>-std=c++11</i>.</p></td></tr>
</table>

<h3>portability-std-allocator-const
<a name="portability-std-allocator-const"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Report use of
<b>std::vector&lt;const T&gt;</b> (and similar containers of
const elements). These are not allowed in standard C++, and
should usually be <b>std::vector&lt;T&gt;</b>
instead.&quot;</p>

<p style="margin-left:9%; margin-top: 1em">Per C++
<b>[allocator.requirements.general]</b>: &quot;T is any
cv-unqualified object type&quot;, <b>std::allocator&lt;const
T&gt;</b> is undefined. Many standard containers use
<b>std::allocator</b> by default and therefore their
<b>const T</b> instantiations are undefined.</p>

<p style="margin-left:9%; margin-top: 1em">libc++ defines
<b>std::allocator&lt;const T&gt;</b> as an extension which
will be removed in the future.</p>

<p style="margin-left:9%; margin-top: 1em">libstdc++ and
MSVC do not support <b>std::allocator&lt;const
T&gt;</b>:</p>

<p style="margin-left:13%; margin-top: 1em">// libstdc++
has a better diagnostic since
https://gcc.gnu.org/bugzilla/show_bug.cgi?id=48101 <br>
std::deque&lt;const int&gt; deque; // error: static
assertion failed: std::deque must have a non-const,
non-volatile value_type <br>
std::set&lt;const int&gt; set; // error: static assertion
failed: std::set must have a non-const, non-volatile
value_type <br>
std::vector&lt;int* const&gt; vector; // error: static
assertion failed: std::vector must have a non-const,
non-volatile value_type</p>

<p style="margin-left:13%; margin-top: 1em">// MSVC <br>
// error C2338: static_assert failed: 'The C++ Standard
forbids containers of const elements because
allocator&lt;const T&gt; is ill-formed.'</p>

<p style="margin-left:9%; margin-top: 1em">Code bases only
compiled with libc++ may accrue such undefined usage. This
check finds such code and prevents backsliding while
clean-up is ongoing.</p>

<h3>readability-avoid-const-params-in-decls
<a name="readability-avoid-const-params-in-decls"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks whether a
function declaration has parameters that are top level
<b>const</b>.</p>

<p style="margin-left:9%; margin-top: 1em"><b>const</b>
values in declarations do not affect the signature of a
function, so they should not be put there.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">void f(const
string); // Bad: const is top level. <br>
void f(const string&amp;); // Good: const is not top
level.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, the
check will not give warnings inside macros. Default is
<i>true</i>.</p>

<h3>readability-avoid-nested-conditional-operator
<a name="readability-avoid-nested-conditional-operator"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Identifies
instances of nested conditional operators in the code.</p>

<p style="margin-left:9%; margin-top: 1em">Nested
conditional operators, also known as ternary operators, can
contribute to reduced code readability and comprehension. So
they should be split as several statements and stored the
intermediate results in temporary variable.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">int
NestInConditional = (condition1 ? true1 : false1) ? true2 :
false2; <br>
int NestInTrue = condition1 ? (condition2 ? true1 : false1)
: false2; <br>
int NestInFalse = condition1 ? true1 : condition2 ? true2 :
false1;</p>

<p style="margin-left:9%; margin-top: 1em">This check
implements part of <i>AUTOSAR C++14 Rule A5-16-1</i>.</p>

<h3>readability-avoid-return-with-void-value
<a name="readability-avoid-return-with-void-value"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds return
statements with <b>void</b> values used within functions
with <b>void</b> result types.</p>

<p style="margin-left:9%; margin-top: 1em">A function with
a <b>void</b> return type is intended to perform a task
without producing a return value. Return statements with
expressions could lead to confusion and may miscommunicate
the function's intended behavior.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">void g(); <br>
void f() { <br>
// ... <br>
return g(); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In a long
function body, the <b>return</b> statement suggests that the
function returns a value. However, <b>return g();</b> is a
combination of two statements that should be written as</p>

<p style="margin-left:13%; margin-top: 1em">g(); <br>
return;</p>

<p style="margin-left:9%; margin-top: 1em">to make clear
that <b>g()</b> is called and immediately afterwards the
function returns (nothing).</p>

<p style="margin-left:9%; margin-top: 1em">In C, the same
issue is detected by the compiler if the <b>-Wpedantic</b>
mode is enabled.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">The value <i>false</i>
specifies that return statements expanded from macros are
not checked. The default value is <i>true</i>.</p>

<p style="margin-left:9%;"><b>StrictMode</b></p>

<p style="margin-left:18%;">The value <i>false</i>
specifies that a direct return statement shall be excluded
from the analysis if it is the only statement not contained
in a block, like <b>if (cond) return g();</b>. The default
value is <i>true</i>.</p>

<h3>readability-avoid-unconditional-preprocessor-if
<a name="readability-avoid-unconditional-preprocessor-if"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds code
blocks that are constantly enabled or disabled in
preprocessor directives by analyzing <b>#if</b> conditions,
such as <b>#if 0</b> and <b>#if 1</b>, etc.</p>

<p style="margin-left:13%; margin-top: 1em">#if 0 <br>
// some disabled code <br>
#endif</p>

<p style="margin-left:13%; margin-top: 1em">#if 1 <br>
// some enabled code that can be disabled manually <br>
#endif</p>

<p style="margin-left:9%; margin-top: 1em">Unconditional
preprocessor directives, such as <b>#if 0</b> for disabled
code and <b>#if 1</b> for enabled code, can lead to dead
code and always enabled code, respectively. Dead code can
make understanding the codebase more difficult, hinder
readability, and may be a sign of unfinished functionality
or abandoned features. This can cause maintenance issues,
confusion for future developers, and potential compilation
problems.</p>

<p style="margin-left:9%; margin-top: 1em">As a solution
for both cases, consider using preprocessor macros or
defines, like <b>#ifdef DEBUGGING_ENABLED</b>, to control
code enabling or disabling. This approach provides better
coordination and flexibility when working with different
parts of the codebase. Alternatively, you can comment out
the entire code using <b>/* */</b> block comments and add a
hint, such as <b>@todo</b>, to indicate future actions.</p>

<h3>readability-braces-around-statements
<a name="readability-braces-around-statements"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>google-readability-braces-around-statements</i>
redirects here as an alias for this check.</p>

<p style="margin-left:9%; margin-top: 1em">Checks that
bodies of <b>if</b> statements and loops (<b>for</b>, <b>do
while</b>, and <b>while</b>) are inside braces.</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">if (condition)
<br>
statement;</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">if (condition)
{ <br>
statement; <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>ShortStatementLines</b></p>

<p style="margin-left:18%;">Defines the minimal number of
lines that the statement should have in order to trigger
this check.</p>

<p style="margin-left:18%; margin-top: 1em">The number of
lines is counted from the end of condition or initial
keyword (<b>do</b>/<b>else</b>) until the last line of the
inner statement. Default value <i>0</i> means that braces
will be added to all statements (not having them
already).</p>

<h3>readability-const-return-type
<a name="readability-const-return-type"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for
functions with a <b>const</b>-qualified return type and
recommends removal of the <b>const</b> keyword. Such use of
<i>const</i> is usually superfluous, and can prevent
valuable compiler optimizations. Does not (yet) fix trailing
return types.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">const int
foo(); <br>
const Clazz foo(); <br>
Clazz *const foo();</p>

<p style="margin-left:9%; margin-top: 1em">Note that this
applies strictly to top-level qualification, which excludes
pointers or references to const values. For example, these
are fine:</p>

<p style="margin-left:13%; margin-top: 1em">const int*
foo(); <br>
const int&amp; foo(); <br>
const Clazz* foo();</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, the
check will not give warnings inside macros. Default is
<i>true</i>.</p>

<h3>readability-container-contains
<a name="readability-container-contains"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds usages of
<b>container.count()</b> and <b>container.find() ==
container.end()</b> which should be replaced by a call to
the <b>container.contains()</b> method introduced in
C++20.</p>

<p style="margin-left:9%; margin-top: 1em">Whether an
element is contained inside a container should be checked
with <b>contains</b> instead of <b>count</b>/<b>find</b>
because <b>contains</b> conveys the intent more clearly.
Furthermore, for containers which permit multiple entries
per key (<b>multimap</b>, <b>multiset</b>, ...),
<b>contains</b> is more efficient than <b>count</b> because
<b>count</b> has to do unnecessary additional work.</p>

<p style="margin-left:9%; margin-top: 1em">Examples: <br>
This check applies to <b>std::set</b>,
<b>std::unordered_set</b>, <b>std::map</b>,
<b>std::unordered_map</b> and the corresponding multi-key
variants. It is only active for C++20 and later, as the
<b>contains</b> method was only added in C++20.</p>

<h3>readability-container-data-pointer
<a name="readability-container-data-pointer"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds cases
where code could use <b>data()</b> rather than the address
of the element at index 0 in a container. This pattern is
commonly used to materialize a pointer to the backing data
of a container. <b>std::vector</b> and <b>std::string</b>
provide a <b>data()</b> accessor to retrieve the data
pointer which should be preferred.</p>

<p style="margin-left:9%; margin-top: 1em">This also
ensures that in the case that the container is empty, the
data pointer access does not perform an errant memory
access.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoredContainers</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
containers regexp for which this check won't be enforced.
Default is <i>empty</i>.</p>

<h3>readability-container-size-empty
<a name="readability-container-size-empty"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks whether a
call to the <b>size()</b>/<b>length()</b> method can be
replaced with a call to <b>empty()</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The emptiness of
a container should be checked using the <b>empty()</b>
method instead of the <b>size()</b>/<b>length()</b> method.
It is not guaranteed that <b>size()</b>/<b>length()</b> is a
constant-time function, and it is generally more efficient
and also shows clearer intent to use <b>empty()</b>.
Furthermore some containers may implement the <b>empty()</b>
method but not implement the <b>size()</b> or
<b>length()</b> method. Using <b>empty()</b> whenever
possible makes it easier to switch to another container in
the future.</p>

<p style="margin-left:9%; margin-top: 1em">The check issues
warning if a container has <b>empty()</b> and <b>size()</b>
or <b>length()</b> methods matching following
signatures:</p>

<p style="margin-left:13%; margin-top: 1em">size_type
size() const; <br>
size_type length() const; <br>
bool empty() const;</p>


<p style="margin-left:9%; margin-top: 1em"><i>size_type</i>
can be any kind of integer type. <b><br>
ExcludedComparisonTypes</b></p>

<p style="margin-left:18%;">A semicolon-separated list of
class names for which the check will ignore comparisons of
objects with default-constructed objects of the same type.
If a class is listed here, the check will not suggest using
<b>empty()</b> instead of such comparisons for objects of
that class. Default value is: <i>::std::array</i>.</p>

<h3>readability-convert-member-functions-to-static
<a name="readability-convert-member-functions-to-static"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds non-static
member functions that can be made <b>static</b> because the
functions don't use <b>this</b>.</p>

<p style="margin-left:9%; margin-top: 1em">After applying
modifications as suggested by the check, running the check
again might find more opportunities to mark member functions
<b>static</b>.</p>

<p style="margin-left:9%; margin-top: 1em">After making a
member function <b>static</b>, you might want to run the
check <i>readability-static-accessed-through-instance</i> to
replace calls like <b>Instance.method()</b> by
<b>Class::method()</b>.</p>

<h3>readability-delete-null-pointer
<a name="readability-delete-null-pointer"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks the
<b>if</b> statements where a pointer's existence is checked
and then deletes the pointer. The check is unnecessary as
deleting a null pointer has no effect.</p>

<p style="margin-left:13%; margin-top: 1em">int *p; <br>
if (p) <br>
delete p;</p>

<h3>readability-duplicate-include
<a name="readability-duplicate-include"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Looks for
duplicate includes and removes them. The check maintains a
list of included files and looks for duplicates. If a macro
is defined or undefined then the list of included files is
cleared.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;memory&gt; <br>
#include &lt;vector&gt; <br>
#include &lt;memory&gt;</p>

<p style="margin-left:9%; margin-top: 1em">becomes</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;memory&gt; <br>
#include &lt;vector&gt;</p>

<p style="margin-left:9%; margin-top: 1em">Because of the
intervening macro definitions, this code remains
unchanged:</p>

<p style="margin-left:13%; margin-top: 1em">#undef NDEBUG
<br>
#include &quot;assertion.h&quot; <br>
// ...code with assertions enabled</p>

<p style="margin-left:13%; margin-top: 1em">#define NDEBUG
<br>
#include &quot;assertion.h&quot; <br>
// ...code with assertions disabled</p>

<h3>readability-else-after-return
<a name="readability-else-after-return"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><i>LLVM Coding
Standards</i> advises to reduce indentation where possible
and where it makes understanding code easier. Early exit is
one of the suggested enforcements of that. Please do not use
<b>else</b> or <b>else if</b> after something that
interrupts control flow - like <b>return</b>, <b>break</b>,
<b>continue</b>, <b>throw</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The following
piece of code illustrates how the check works. This piece of
code:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(int
Value) { <br>
int Local = 0; <br>
for (int i = 0; i &lt; 42; i++) { <br>
if (Value == 1) { <br>
return; <br>
} else { <br>
Local++; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">if (Value == 2)
<br>
continue; <br>
else <br>
Local++;</p>

<p style="margin-left:13%; margin-top: 1em">if (Value == 3)
{ <br>
throw 42; <br>
} else { <br>
Local++; <br>
} <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Would be
transformed into:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(int
Value) { <br>
int Local = 0; <br>
for (int i = 0; i &lt; 42; i++) { <br>
if (Value == 1) { <br>
return; <br>
} <br>
Local++;</p>

<p style="margin-left:13%; margin-top: 1em">if (Value == 2)
<br>
continue; <br>
Local++;</p>

<p style="margin-left:13%; margin-top: 1em">if (Value == 3)
{ <br>
throw 42; <br>
} <br>
Local++; <br>
} <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>WarnOnUnfixable</b></p>

<p style="margin-left:18%;">When <i>true</i>, emit a
warning for cases where the check can't output a Fix-It.
These can occur with declarations inside the <b>else</b>
branch that would have an extended lifetime if the
<b>else</b> branch was removed. Default value is
<i>true</i>.</p>


<p style="margin-left:9%;"><b>WarnOnConditionVariables</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will attempt to refactor a variable defined inside the
condition of the <b>if</b> statement that is used in the
<b>else</b> branch defining them just before the <b>if</b>
statement. This can only be done if the <b>if</b> statement
is the last statement in its parent's scope. Default value
is <i>true</i>.</p>

<h3>LLVM alias
<a name="LLVM alias"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">There is an
alias of this check called llvm-else-after-return. In that
version the options <i>WarnOnUnfixable</i> and
<i>WarnOnConditionVariables</i> are both set to <i>false</i>
by default.</p>

<p style="margin-left:9%; margin-top: 1em">This check helps
to enforce this <i>LLVM Coding Standards
recommendation</i>.</p>

<h3>readability-enum-initial-value
<a name="readability-enum-initial-value"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Enforces
consistent style for enumerators' initialization, covering
three styles: none, first only, or all initialized
explicitly.</p>

<p style="margin-left:9%; margin-top: 1em">An inconsistent
style and strictness to defining the initializing value of
enumerators may cause issues if the enumeration is extended
with new enumerators that obtain their integer
representation implicitly.</p>

<p style="margin-left:9%; margin-top: 1em">The following
three cases are accepted:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="68%">


<p><b>No</b> enumerators are explicit initialized.</p></td>
<td width="19%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="68%">


<p>Exactly <b>the first</b> enumerator is explicit
initialized.</p> </td>
<td width="19%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="68%">


<p><b>All</b> enumerators are explicit initialized.</p></td>
<td width="19%">
</td></tr>
</table>

<p style="margin-left:13%; margin-top: 1em">enum A { // (1)
Valid, none of enumerators are initialized. <br>
a0, <br>
a1, <br>
a2, <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">enum B { // (2)
Valid, the first enumerator is initialized. <br>
b0 = 0, <br>
b1, <br>
b2, <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">enum C { // (3)
Valid, all of enumerators are initialized. <br>
c0 = 0, <br>
c1 = 1, <br>
c2 = 2, <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">enum D { //
Invalid, d1 is not explicitly initialized! <br>
d0 = 0, <br>
d1, <br>
d2 = 2, <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">enum E { //
Invalid, e1, e3, and e5 are not explicitly initialized. <br>
e0 = 0, <br>
e1, <br>
e2 = 2, <br>
e3, // Dangerous, as the numeric values of e3 and e5 are
both 3, and this is not explicitly visible in the code! <br>
e4 = 2, <br>
e5, <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">This check
corresponds to the CERT C Coding Standard recommendation -
<i>INT09-C. Ensure enumeration constants map to unique
values</i>.</p>


<p style="margin-left:9%; margin-top: 1em"><i>cert-int09-c</i>
redirects here as an alias of this check.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>AllowExplicitZeroFirstInitialValue</b></p>

<p style="margin-left:18%;">If set to <i>false</i>, the
first enumerator must not be explicitly initialized to a
literal <b>0</b>. Default is <i>true</i>.</p>

<p style="margin-left:22%; margin-top: 1em">enum F { <br>
f0 = 0, // Not allowed if AllowExplicitZeroFirstInitialValue
is false. <br>
f1, <br>
f2, <br>
};</p>


<p style="margin-left:9%;"><b>AllowExplicitSequentialInitialValues</b></p>

<p style="margin-left:18%;">If set to <i>false</i>,
explicit initialization to sequential values are not
allowed. Default is <i>true</i>.</p>

<p style="margin-left:22%; margin-top: 1em">enum G { <br>
g0 = 1, // Not allowed if
AllowExplicitSequentialInitialValues is false. <br>
g1 = 2, <br>
g2 = 3,</p>

<h3>readability-function-cognitive-complexity
<a name="readability-function-cognitive-complexity"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks function
Cognitive Complexity metric.</p>

<p style="margin-left:9%; margin-top: 1em">The metric is
implemented as per the <i>COGNITIVE COMPLEXITY by
SonarSource</i> specification version 1.2 (19 April
2017).</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>Threshold</b></p>

<p style="margin-left:18%;">Flag functions with Cognitive
Complexity exceeding this number. The default is
<i>25</i>.</p>


<p style="margin-left:9%;"><b>DescribeBasicIncrements</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, then for
each function exceeding the complexity threshold the check
will issue additional diagnostics on every piece of code
(loop, <i>if</i> statement, etc.) which contributes to that
complexity. See also the examples below. Default is
<i>true</i>.</p>

<p style="margin-left:9%;"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, the
check will ignore code inside macros. Note, that also any
macro arguments are ignored, even if they should count to
the complexity. As this might change in the future, this
option isn't guaranteed to be forward-compatible. Default is
<i>false</i>.</p>

<h3>Building blocks
<a name="Building blocks"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">There are three
basic building blocks of a Cognitive Complexity metric:</p>

<h3>Increment
<a name="Increment"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The following
structures increase the function's Cognitive Complexity
metric (by <i>1</i>):</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p>Conditional operators:</p></td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%"></td>
<td width="1%"></td>
<td width="24%">


<p style="margin-top: 1em"><b>if()</b></p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="24%">


<p><b>else if()</b></p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="24%">


<p><b>else</b></p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="24%">


<p><b>cond ? true : false</b></p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="24%"></td>
<td width="58%">
</td></tr>
</table>


<p style="margin-left:12%; margin-top: 1em"><b>switch()</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="7%">


<p style="margin-top: 1em">Loops:</p></td>
<td width="81%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%"></td>
<td width="1%"></td>
<td width="29%">


<p style="margin-top: 1em"><b>for()</b></p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="29%">


<p>C++11 range-based <b>for()</b></p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="29%">


<p><b>while()</b></p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="29%">


<p><b>do while()</b></p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="29%"></td>
<td width="53%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em"><b>catch
()</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p style="margin-top: 1em"><b>goto LABEL</b>, <b>goto
*(&amp;&amp;LABEL))</b>,</p> </td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p>sequences of binary logical operators:</p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%"></td>
<td width="1%"></td>
<td width="26%">


<p style="margin-top: 1em"><b>boolean1 || boolean2</b></p></td>
<td width="56%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="26%">


<p><b>boolean1 &amp;&amp; boolean2</b></p></td>
<td width="56%">
</td></tr>
</table>

<h3>Nesting level
<a name="Nesting level"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">While by itself
the nesting level does not change the function's Cognitive
Complexity metric, it is tracked, and is used by the next,
third building block. The following structures increase the
nesting level (by <i>1</i>):</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p style="margin-top: 1em">Conditional operators:</p></td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%"></td>
<td width="1%"></td>
<td width="24%">


<p style="margin-top: 1em"><b>if()</b></p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="24%">


<p><b>else if()</b></p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="24%">


<p><b>else</b></p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="24%">


<p><b>cond ? true : false</b></p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="24%"></td>
<td width="58%">
</td></tr>
</table>


<p style="margin-left:12%; margin-top: 1em"><b>switch()</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="7%">


<p style="margin-top: 1em">Loops:</p></td>
<td width="81%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%"></td>
<td width="1%"></td>
<td width="29%">


<p style="margin-top: 1em"><b>for()</b></p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="29%">


<p>C++11 range-based <b>for()</b></p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="29%">


<p><b>while()</b></p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="29%">


<p><b>do while()</b></p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="29%"></td>
<td width="53%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em"><b>catch
()</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="21%">


<p style="margin-top: 1em">Nested functions:</p></td>
<td width="67%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%"></td>
<td width="1%"></td>
<td width="17%">


<p style="margin-top: 1em">C++11 Lambda</p></td>
<td width="65%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="17%">


<p>Nested <b>class</b></p></td>
<td width="65%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="17%">


<p>Nested <b>struct</b></p></td>
<td width="65%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="17%"></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">GNU statement
expression</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="29%">


<p style="margin-top: 1em">Apple Block Declaration</p></td>
<td width="59%">
</td></tr>
</table>

<h3>Nesting increment
<a name="Nesting increment"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This is where
the previous basic building block, <i>Nesting level</i>,
matters. The following structures increase the function's
Cognitive Complexity metric by the current <i>Nesting
level</i>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p style="margin-top: 1em">Conditional operators:</p></td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%"></td>
<td width="1%"></td>
<td width="24%">


<p style="margin-top: 1em"><b>if()</b></p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="24%">


<p><b>cond ? true : false</b></p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="24%"></td>
<td width="58%">
</td></tr>
</table>


<p style="margin-left:12%; margin-top: 1em"><b>switch()</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="7%">


<p style="margin-top: 1em">Loops:</p></td>
<td width="81%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%"></td>
<td width="1%"></td>
<td width="29%">


<p style="margin-top: 1em"><b>for()</b></p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="29%">


<p>C++11 range-based <b>for()</b></p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="29%">


<p><b>while()</b></p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="29%">


<p><b>do while()</b></p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="29%"></td>
<td width="53%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em"><b>catch
()</b></p>

<h3>Examples
<a name="Examples"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The simplest
case. This function has Cognitive Complexity of
<i>0</i>.</p>

<p style="margin-left:13%; margin-top: 1em">void
function0() {}</p>

<p style="margin-left:9%; margin-top: 1em">Slightly better
example. This function has Cognitive Complexity of
<i>1</i>.</p>

<p style="margin-left:13%; margin-top: 1em">int
function1(bool var) { <br>
if(var) // +1, nesting level +1 <br>
return 42; <br>
return 0; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Full example.
This function has Cognitive Complexity of <i>3</i>.</p>

<p style="margin-left:13%; margin-top: 1em">int
function3(bool var1, bool var2) { <br>
if(var1) { // +1, nesting level +1 <br>
if(var2) // +2 (1 + current nesting level of 1), nesting
level +1 <br>
return 42; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">return 0; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In the last
example, the check will flag <i>function3</i> if the option
Threshold is set to <i>2</i> or smaller. If the option
DescribeBasicIncrements is set to <i>true</i>, it will
additionally flag the two <i>if</i> statements with the
amounts by which they increase to the complexity of the
function and the current nesting level.</p>

<h3>Limitations
<a name="Limitations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>The metric is
implemented with two notable exceptions:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><i>preprocessor conditionals</i> (<b>#ifdef</b>,
<b>#if</b>, <b>#elif</b>, <b>#else</b>, <b>#endif</b>) are
not accounted for.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><i>each method in a recursion cycle</i> is not accounted
for. It can't be fully implemented, because
cross-translational-unit analysis would be needed, which is
currently not possible in clang-tidy.</p></td></tr>
</table>

<h3>readability-function-size
<a name="readability-function-size"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>google-readability-function-size</i>
redirects here as an alias for this check.</p>

<p style="margin-left:9%; margin-top: 1em">Checks for large
functions based on various metrics.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>LineThreshold</b></p>

<p style="margin-left:18%;">Flag functions exceeding this
number of lines. The default is <i>none</i> (ignore the
number of lines).</p>

<p style="margin-left:9%;"><b>StatementThreshold</b></p>

<p style="margin-left:18%;">Flag functions exceeding this
number of statements. This may differ significantly from the
number of lines for macro-heavy code. The default is
<i>800</i>.</p>

<p style="margin-left:9%;"><b>BranchThreshold</b></p>

<p style="margin-left:18%;">Flag functions exceeding this
number of control statements. The default is <i>none</i>
(ignore the number of branches).</p>

<p style="margin-left:9%;"><b>ParameterThreshold</b></p>

<p style="margin-left:18%;">Flag functions that exceed a
specified number of parameters. The default is <i>none</i>
(ignore the number of parameters).</p>

<p style="margin-left:9%;"><b>NestingThreshold</b></p>

<p style="margin-left:18%;">Flag compound statements which
create next nesting level after <i>NestingThreshold</i>.
This may differ significantly from the expected value for
macro-heavy code. The default is <i>none</i> (ignore the
nesting level).</p>

<p style="margin-left:9%;"><b>VariableThreshold</b></p>

<p style="margin-left:18%;">Flag functions exceeding this
number of variables declared in the body. The default is
<i>none</i> (ignore the number of variables). Please note
that function parameters and variables declared in lambdas,
GNU Statement Expressions, and nested class inline functions
are not counted.</p>

<h3>readability-identifier-length
<a name="readability-identifier-length"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check finds
variables and function parameters whose length are too
short. The desired name length is configurable.</p>

<p style="margin-left:9%; margin-top: 1em">Special cases
are supported for loop counters and for exception variable
names.</p>

<h3>Options
<a name="Options"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The following
options are described below:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="73%">


<p><i>MinimumVariableNameLength</i>,
<i>IgnoredVariableNames</i></p> </td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="73%">


<p><i>MinimumParameterNameLength</i>,
<i>IgnoredParameterNames</i></p> </td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="73%">


<p><i>MinimumLoopCounterNameLength</i>,
<i>IgnoredLoopCounterNames</i></p> </td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="73%">


<p><i>MinimumExceptionNameLength</i>,
<i>IgnoredExceptionVariableNames</i></p> </td>
<td width="12%">
</td></tr>
</table>


<p style="margin-left:9%;"><b>MinimumVariableNameLength</b></p>

<p style="margin-left:18%;">All variables (other than loop
counter, exception names and function parameters) are
expected to have at least a length of
<i>MinimumVariableNameLength</i> (default is <i>3</i>).
Setting it to <i>0</i> or <i>1</i> disables the check
entirely.</p>

<p style="margin-left:22%; margin-top: 1em">int i = 42; //
warns that 'i' is too short</p>

<p style="margin-left:18%; margin-top: 1em">This check does
not have any fix suggestions in the general case since
variable names have semantic value.</p>

<p style="margin-left:9%;"><b>IgnoredVariableNames</b></p>

<p style="margin-left:18%;">Specifies a regular expression
for variable names that are to be ignored. The default value
is empty, thus no names are ignored.</p>


<p style="margin-left:9%;"><b>MinimumParameterNameLength</b></p>

<p style="margin-left:18%;">All function parameter names
are expected to have a length of at least
<i>MinimumParameterNameLength</i> (default is <i>3</i>).
Setting it to <i>0</i> or <i>1</i> disables the check
entirely.</p>

<p style="margin-left:22%; margin-top: 1em">int doubler(int
x) // warns that x is too short <br>
{ <br>
return 2 * x; <br>
}</p>

<p style="margin-left:18%; margin-top: 1em">This check does
not have any fix suggestions in the general case since
variable names have semantic value.</p>


<p style="margin-left:9%;"><b>IgnoredParameterNames</b></p>

<p style="margin-left:18%;">Specifies a regular expression
for parameters that are to be ignored. The default value is
<i>&#710;[n]$</i> for historical reasons.</p>


<p style="margin-left:9%;"><b>MinimumLoopCounterNameLength</b></p>

<p style="margin-left:18%;">Loop counter variables are
expected to have a length of at least
<i>MinimumLoopCounterNameLength</i> characters (default is
<i>2</i>). Setting it to <i>0</i> or <i>1</i> disables the
check entirely.</p>

<p style="margin-left:22%; margin-top: 1em">// This warns
that 'q' is too short. <br>
for (int q = 0; q &lt; size; ++ q) { <br>
// ... <br>
}</p>


<p style="margin-left:9%;"><b>IgnoredLoopCounterNames</b></p>

<p style="margin-left:18%;">Specifies a regular expression
for counter names that are to be ignored. The default value
is <i>&#710;[ijk_]$</i>; the first three symbols for
historical reasons and the last one since it is frequently
used as a &quot;don't care&quot; value, specifically in
tools such as Google Benchmark.</p>

<p style="margin-left:22%; margin-top: 1em">// This does
not warn by default, for historical reasons. <br>
for (int i = 0; i &lt; size; ++ i) { <br>
// ... <br>
}</p>


<p style="margin-left:9%;"><b>MinimumExceptionNameLength</b></p>

<p style="margin-left:18%;">Exception clause variables are
expected to have a length of at least
<i>MinimumExceptionNameLength</i> (default is <i>2</i>).
Setting it to <i>0</i> or <i>1</i> disables the check
entirely.</p>

<p style="margin-left:22%; margin-top: 1em">try { <br>
// ... <br>
} <br>
// This warns that 'e' is too short. <br>
catch (const std::exception&amp; x) { <br>
// ... <br>
}</p>


<p style="margin-left:9%;"><b>IgnoredExceptionVariableNames</b></p>

<p style="margin-left:18%;">Specifies a regular expression
for exception variable names that are to be ignored. The
default value is <i>&#710;[e]$</i> mainly for historical
reasons.</p>

<p style="margin-left:22%; margin-top: 1em">try { <br>
// ... <br>
} <br>
// This does not warn by default, for historical reasons.
<br>
catch (const std::exception&amp; e) { <br>
// ... <br>
}</p>

<h3>readability-identifier-naming
<a name="readability-identifier-naming"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for
identifiers naming style mismatch.</p>

<p style="margin-left:9%; margin-top: 1em">This check will
try to enforce coding guidelines on the identifiers naming.
It supports one of the following casing types and tries to
convert from one to another if a mismatch is detected</p>

<p style="margin-left:9%; margin-top: 1em">Casing types
include:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="31%">


<p><b>lower_case</b></p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="31%">


<p><b>UPPER_CASE</b></p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="31%">


<p><b>camelBack</b></p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="31%">


<p><b>CamelCase</b></p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="31%">


<p><b>camel_Snake_Back</b></p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="31%">


<p><b>Camel_Snake_Case</b></p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="31%">


<p><b>aNy_CasE</b></p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="31%">


<p><b>Leading_upper_snake_case</b></p></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">It also supports
a fixed prefix and suffix that will be prepended or appended
to the identifiers, regardless of the casing.</p>

<p style="margin-left:9%; margin-top: 1em">Many
configuration options are available, in order to be able to
create different rules for different kinds of identifiers.
In general, the rules are falling back to a more generic
rule if the specific case is not configured.</p>

<p style="margin-left:9%; margin-top: 1em">The naming of
virtual methods is reported where they occur in the base
class, but not where they are overridden, as it can't be
fixed locally there. This also applies for pseudo-override
patterns like CRTP.</p>


<p style="margin-left:9%; margin-top: 1em"><b>Leading_upper_snake_case</b>
is a naming convention where the first word is capitalized
followed by lower case word(s) separated by underscore(s)
'_'. Examples include: <i>Cap_snake_case</i>,
<i>Cobra_case</i>, <i>Foo_bar_baz</i>, and
<i>Master_copy_8gb</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Hungarian
notation can be customized using different
<i>HungarianPrefix</i> settings. The options and their
corresponding values are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p style="margin-top: 1em"><b>Off</b> - the default
setting</p> </td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p><b>On</b> - example: <b>int iVariable</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p><b>LowerCase</b> - example: <b>int i_Variable</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p><b>CamelCase</b> - example: <b>int IVariable</b></p></td>
<td width="40%">
</td></tr>
</table>

<h3>Options
<a name="Options"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The following
options are described below:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em"><i>AbstractClassCase</i>,
<i>AbstractClassPrefix</i>, <i>AbstractClassSuffix</i>,
<i>AbstractClassIgnoredRegexp</i>,
<i>AbstractClassHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>AggressiveDependentMemberLookup</i></p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>CheckAnonFieldInParent</i></p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ClassCase</i>, <i>ClassPrefix</i>,
<i>ClassSuffix</i>, <i>ClassIgnoredRegexp</i>,
<i>ClassHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ClassConstantCase</i>, <i>ClassConstantPrefix</i>,
<i>ClassConstantSuffix</i>,
<i>ClassConstantIgnoredRegexp</i>,
<i>ClassConstantHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ClassMemberCase</i>, <i>ClassMemberPrefix</i>,
<i>ClassMemberSuffix</i>, <i>ClassMemberIgnoredRegexp</i>,
<i>ClassMemberHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ClassMethodCase</i>, <i>ClassMethodPrefix</i>,
<i>ClassMethodSuffix</i>,
<i>ClassMethodIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ConceptCase</i>, <i>ConceptPrefix</i>,
<i>ConceptSuffix</i>, <i>ConceptIgnoredRegexp</i></p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ConstantCase</i>, <i>ConstantPrefix</i>,
<i>ConstantSuffix</i>, <i>ConstantIgnoredRegexp</i>,
<i>ConstantHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ConstantMemberCase</i>, <i>ConstantMemberPrefix</i>,
<i>ConstantMemberSuffix</i>,
<i>ConstantMemberIgnoredRegexp</i>,
<i>ConstantMemberHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ConstantParameterCase</i>,
<i>ConstantParameterPrefix</i>,
<i>ConstantParameterSuffix</i>,
<i>ConstantParameterIgnoredRegexp</i>,
<i>ConstantParameterHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ConstantPointerParameterCase</i>,
<i>ConstantPointerParameterPrefix</i>,
<i>ConstantPointerParameterSuffix</i>,
<i>ConstantPointerParameterIgnoredRegexp</i>,
<i>ConstantPointerParameterHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ConstexprFunctionCase</i>,
<i>ConstexprFunctionPrefix</i>,
<i>ConstexprFunctionSuffix</i>,
<i>ConstexprFunctionIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ConstexprMethodCase</i>,
<i>ConstexprMethodPrefix</i>, <i>ConstexprMethodSuffix</i>,
<i>ConstexprMethodIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ConstexprVariableCase</i>,
<i>ConstexprVariablePrefix</i>,
<i>ConstexprVariableSuffix</i>,
<i>ConstexprVariableIgnoredRegexp</i>,
<i>ConstexprVariableHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>EnumCase</i>, <i>EnumPrefix</i>, <i>EnumSuffix</i>,
<i>EnumIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>EnumConstantCase</i>, <i>EnumConstantPrefix</i>,
<i>EnumConstantSuffix</i>, <i>EnumConstantIgnoredRegexp</i>,
<i>EnumConstantHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>FunctionCase</i>, <i>FunctionPrefix</i>,
<i>FunctionSuffix</i>, <i>FunctionIgnoredRegexp</i></p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>GetConfigPerFile</i></p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>GlobalConstantCase</i>, <i>GlobalConstantPrefix</i>,
<i>GlobalConstantSuffix</i>,
<i>GlobalConstantIgnoredRegexp</i>,
<i>GlobalConstantHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>GlobalConstantPointerCase</i>,
<i>GlobalConstantPointerPrefix</i>,
<i>GlobalConstantPointerSuffix</i>,
<i>GlobalConstantPointerIgnoredRegexp</i>,
<i>GlobalConstantPointerHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>GlobalFunctionCase</i>, <i>GlobalFunctionPrefix</i>,
<i>GlobalFunctionSuffix</i>,
<i>GlobalFunctionIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>GlobalPointerCase</i>, <i>GlobalPointerPrefix</i>,
<i>GlobalPointerSuffix</i>,
<i>GlobalPointerIgnoredRegexp</i>,
<i>GlobalPointerHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>GlobalVariableCase</i>, <i>GlobalVariablePrefix</i>,
<i>GlobalVariableSuffix</i>,
<i>GlobalVariableIgnoredRegexp</i>,
<i>GlobalVariableHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>IgnoreMainLikeFunctions</i></p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>InlineNamespaceCase</i>,
<i>InlineNamespacePrefix</i>, <i>InlineNamespaceSuffix</i>,
<i>InlineNamespaceIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>LocalConstantCase</i>, <i>LocalConstantPrefix</i>,
<i>LocalConstantSuffix</i>,
<i>LocalConstantIgnoredRegexp</i>,
<i>LocalConstantHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>LocalConstantPointerCase</i>,
<i>LocalConstantPointerPrefix</i>,
<i>LocalConstantPointerSuffix</i>,
<i>LocalConstantPointerIgnoredRegexp</i>,
<i>LocalConstantPointerHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>LocalPointerCase</i>, <i>LocalPointerPrefix</i>,
<i>LocalPointerSuffix</i>, <i>LocalPointerIgnoredRegexp</i>,
<i>LocalPointerHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>LocalVariableCase</i>, <i>LocalVariablePrefix</i>,
<i>LocalVariableSuffix</i>,
<i>LocalVariableIgnoredRegexp</i>,
<i>LocalVariableHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>MacroDefinitionCase</i>,
<i>MacroDefinitionPrefix</i>, <i>MacroDefinitionSuffix</i>,
<i>MacroDefinitionIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>MemberCase</i>, <i>MemberPrefix</i>,
<i>MemberSuffix</i>, <i>MemberIgnoredRegexp</i>,
<i>MemberHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>MethodCase</i>, <i>MethodPrefix</i>,
<i>MethodSuffix</i>, <i>MethodIgnoredRegexp</i></p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>NamespaceCase</i>, <i>NamespacePrefix</i>,
<i>NamespaceSuffix</i>, <i>NamespaceIgnoredRegexp</i></p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ParameterCase</i>, <i>ParameterPrefix</i>,
<i>ParameterSuffix</i>, <i>ParameterIgnoredRegexp</i>,
<i>ParameterHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ParameterPackCase</i>, <i>ParameterPackPrefix</i>,
<i>ParameterPackSuffix</i>,
<i>ParameterPackIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>PointerParameterCase</i>,
<i>PointerParameterPrefix</i>,
<i>PointerParameterSuffix</i>,
<i>PointerParameterIgnoredRegexp</i>,
<i>PointerParameterHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>PrivateMemberCase</i>, <i>PrivateMemberPrefix</i>,
<i>PrivateMemberSuffix</i>,
<i>PrivateMemberIgnoredRegexp</i>,
<i>PrivateMemberHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>PrivateMethodCase</i>, <i>PrivateMethodPrefix</i>,
<i>PrivateMethodSuffix</i>,
<i>PrivateMethodIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ProtectedMemberCase</i>,
<i>ProtectedMemberPrefix</i>, <i>ProtectedMemberSuffix</i>,
<i>ProtectedMemberIgnoredRegexp</i>,
<i>ProtectedMemberHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ProtectedMethodCase</i>,
<i>ProtectedMethodPrefix</i>, <i>ProtectedMethodSuffix</i>,
<i>ProtectedMethodIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>PublicMemberCase</i>, <i>PublicMemberPrefix</i>,
<i>PublicMemberSuffix</i>, <i>PublicMemberIgnoredRegexp</i>,
<i>PublicMemberHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>PublicMethodCase</i>, <i>PublicMethodPrefix</i>,
<i>PublicMethodSuffix</i>,
<i>PublicMethodIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ScopedEnumConstantCase</i>,
<i>ScopedEnumConstantPrefix</i>,
<i>ScopedEnumConstantSuffix</i>,
<i>ScopedEnumConstantIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>StaticConstantCase</i>, <i>StaticConstantPrefix</i>,
<i>StaticConstantSuffix</i>,
<i>StaticConstantIgnoredRegexp</i>,
<i>StaticConstantHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>StaticVariableCase</i>, <i>StaticVariablePrefix</i>,
<i>StaticVariableSuffix</i>,
<i>StaticVariableIgnoredRegexp</i>,
<i>StaticVariableHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>StructCase</i>, <i>StructPrefix</i>,
<i>StructSuffix</i>, <i>StructIgnoredRegexp</i></p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>TemplateParameterCase</i>,
<i>TemplateParameterPrefix</i>,
<i>TemplateParameterSuffix</i>,
<i>TemplateParameterIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>TemplateTemplateParameterCase</i>,
<i>TemplateTemplateParameterPrefix</i>,
<i>TemplateTemplateParameterSuffix</i>,
<i>TemplateTemplateParameterIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>TypeAliasCase</i>, <i>TypeAliasPrefix</i>,
<i>TypeAliasSuffix</i>, <i>TypeAliasIgnoredRegexp</i></p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>TypedefCase</i>, <i>TypedefPrefix</i>,
<i>TypedefSuffix</i>, <i>TypedefIgnoredRegexp</i></p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>TypeTemplateParameterCase</i>,
<i>TypeTemplateParameterPrefix</i>,
<i>TypeTemplateParameterSuffix</i>,
<i>TypeTemplateParameterIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>UnionCase</i>, <i>UnionPrefix</i>,
<i>UnionSuffix</i>, <i>UnionIgnoredRegexp</i></p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>ValueTemplateParameterCase</i>,
<i>ValueTemplateParameterPrefix</i>,
<i>ValueTemplateParameterSuffix</i>,
<i>ValueTemplateParameterIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>VariableCase</i>, <i>VariablePrefix</i>,
<i>VariableSuffix</i>, <i>VariableIgnoredRegexp</i>,
<i>VariableHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>VirtualMethodCase</i>, <i>VirtualMethodPrefix</i>,
<i>VirtualMethodSuffix</i>,
<i>VirtualMethodIgnoredRegexp</i></p> </td></tr>
</table>

<p style="margin-left:9%;"><b>AbstractClassCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure abstract class names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>AbstractClassPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure abstract class names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>AbstractClassIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for abstract class names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>AbstractClassSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure abstract class names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>AbstractClassHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>AbstractClassCase of <b>lower_case</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>AbstractClassPrefix of <b>pre_</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>AbstractClassSuffix of <b>_post</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>AbstractClassHungarianPrefix of <b>On</b></p></td>
<td width="41%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms abstract class names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">class
ABSTRACT_CLASS { <br>
public: <br>
ABSTRACT_CLASS(); <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">class
pre_abstract_class_post { <br>
public: <br>
pre_abstract_class_post(); <br>
};</p>


<p style="margin-left:9%;"><b>AggressiveDependentMemberLookup</b></p>

<p style="margin-left:18%;">When set to <i>true</i> the
check will look in dependent base classes for dependent
member references that need changing. This can lead to
errors with template specializations so the default value is
<i>false</i>.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="38%">


<p>ClassMemberCase of <b>lower_case</b></p></td>
<td width="47%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T&gt; <br>
struct Base { <br>
T BadNamedMember; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T&gt; <br>
struct Derived : Base&lt;T&gt; { <br>
void reset() { <br>
this-&gt;BadNamedMember = 0; <br>
} <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">After if
AggressiveDependentMemberLookup is <i>false</i>:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T&gt; <br>
struct Base { <br>
T bad_named_member; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T&gt; <br>
struct Derived : Base&lt;T&gt; { <br>
void reset() { <br>
this-&gt;BadNamedMember = 0; <br>
} <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">After if
AggressiveDependentMemberLookup is <i>true</i>:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T&gt; <br>
struct Base { <br>
T bad_named_member; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T&gt; <br>
struct Derived : Base&lt;T&gt; { <br>
void reset() { <br>
this-&gt;bad_named_member = 0; <br>
} <br>
};</p>


<p style="margin-left:9%;"><b>CheckAnonFieldInParent</b></p>

<p style="margin-left:18%;">When set to <i>true</i>, fields
in anonymous records (i.e. anonymous unions and structs)
will be treated as names in the enclosing scope rather than
public members of the anonymous record for the purpose of
name checking.</p>

<p style="margin-left:9%; margin-top: 1em">For example:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
private: <br>
union { <br>
int iv_; <br>
float fv_; <br>
}; <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">If
<i>CheckAnonFieldInParent</i> is <i>false</i>, you may get
warnings that <b>iv_</b> and <b>fv_</b> are not coherent to
public member names, because <b>iv_</b> and <b>fv_</b> are
public members of the anonymous union. When
<i>CheckAnonFieldInParent</i> is <i>true</i>, <b>iv_</b> and
<b>fv_</b> will be treated as private data members of
<b>Foo</b> for the purpose of name checking and thus no
warnings will be emitted. <b><br>
ClassCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure class names conform to the selected casing.</p>

<p style="margin-left:9%;"><b>ClassPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure class names will add the prefixed with the given
value (regardless of casing).</p>

<p style="margin-left:9%;"><b>ClassIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for class names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>ClassSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure class names will add the suffix with the given value
(regardless of casing).</p>

<p style="margin-left:9%;"><b>ClassHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="34%">


<p>ClassCase of <b>lower_case</b></p></td>
<td width="51%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="34%">


<p>ClassPrefix of <b>pre_</b></p></td>
<td width="51%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="34%">


<p>ClassSuffix of <b>_post</b></p></td>
<td width="51%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="34%">


<p>ClassHungarianPrefix of <b>On</b></p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms class names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">class FOO {
<br>
public: <br>
FOO(); <br>
&#732;FOO(); <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">class
pre_foo_post { <br>
public: <br>
pre_foo_post(); <br>
&#732;pre_foo_post(); <br>
};</p>

<p style="margin-left:9%;"><b>ClassConstantCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure class constant names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>ClassConstantPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure class constant names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ClassConstantIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for class constant names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>ClassConstantSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure class constant names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ClassConstantHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>ClassConstantCase of <b>lower_case</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>ClassConstantPrefix of <b>pre_</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>ClassConstantSuffix of <b>_post</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>ClassConstantHungarianPrefix of <b>On</b></p></td>
<td width="41%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms class constant names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">class FOO {
<br>
public: <br>
static const int CLASS_CONSTANT; <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">class FOO {
<br>
public: <br>
static const int pre_class_constant_post; <br>
};</p>

<p style="margin-left:9%;"><b>ClassMemberCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure class member names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>ClassMemberPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure class member names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ClassMemberIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for class member names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>ClassMemberSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure class member names will add the suffix with the given
value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ClassMemberHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="41%">


<p>ClassMemberCase of <b>lower_case</b></p></td>
<td width="44%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="41%">


<p>ClassMemberPrefix of <b>pre_</b></p></td>
<td width="44%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="41%">


<p>ClassMemberSuffix of <b>_post</b></p></td>
<td width="44%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="41%">


<p>ClassMemberHungarianPrefix of <b>On</b></p></td>
<td width="44%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms class member names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">class FOO {
<br>
public: <br>
static int CLASS_CONSTANT; <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">class FOO {
<br>
public: <br>
static int pre_class_constant_post; <br>
};</p>

<p style="margin-left:9%;"><b>ClassMethodCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure class method names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>ClassMethodPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure class method names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ClassMethodIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for class method names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>ClassMethodSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure class method names will add the suffix with the given
value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="38%">


<p>ClassMethodCase of <b>lower_case</b></p></td>
<td width="47%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="38%">


<p>ClassMethodPrefix of <b>pre_</b></p></td>
<td width="47%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="38%">


<p>ClassMethodSuffix of <b>_post</b></p></td>
<td width="47%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms class method names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">class FOO {
<br>
public: <br>
int CLASS_MEMBER(); <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">class FOO {
<br>
public: <br>
int pre_class_member_post(); <br>
};</p>

<p style="margin-left:9%;"><b>ConceptCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure concept names conform to the selected casing.</p>

<p style="margin-left:9%;"><b>ConceptPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure concept names will add the prefixed with the given
value (regardless of casing).</p>

<p style="margin-left:9%;"><b>ConceptIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for concept names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>ConceptSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure concept names will add the suffix with the given
value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="31%">


<p>ConceptCase of <b>CamelCase</b></p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="31%">


<p>ConceptPrefix of <b>Pre</b></p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="31%">


<p>ConceptSuffix of <b>Post</b></p></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms concept names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>


<p style="margin-left:13%; margin-top: 1em">template&lt;typename
T&gt; concept my_concept = requires (T t) { {t++}; };</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>


<p style="margin-left:13%; margin-top: 1em">template&lt;typename
T&gt; concept PreMyConceptPost = requires (T t) { {t++};
};</p>

<p style="margin-left:9%;"><b>ConstantCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constant names conform to the selected casing.</p>

<p style="margin-left:9%;"><b>ConstantPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constant names will add the prefixed with the given
value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ConstantIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for constant names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>ConstantSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constant names will add the suffix with the given
value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ConstantHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="38%">


<p>ConstantCase of <b>lower_case</b></p></td>
<td width="47%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="38%">


<p>ConstantPrefix of <b>pre_</b></p></td>
<td width="47%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="38%">


<p>ConstantSuffix of <b>_post</b></p></td>
<td width="47%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="38%">


<p>ConstantHungarianPrefix of <b>On</b></p></td>
<td width="47%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms constant names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void function()
{ unsigned const MyConst_array[] = {1, 2, 3}; }</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void function()
{ unsigned const pre_myconst_array_post[] = {1, 2, 3}; }</p>

<p style="margin-left:9%;"><b>ConstantMemberCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constant member names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>ConstantMemberPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constant member names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ConstantMemberIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for constant member names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>ConstantMemberSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constant member names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ConstantMemberHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>ConstantMemberCase of <b>lower_case</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>ConstantMemberPrefix of <b>pre_</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>ConstantMemberSuffix of <b>_post</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>ConstantMemberHungarianPrefix of <b>On</b></p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms constant member names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
char const MY_ConstMember_string[4] = &quot;123&quot;; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
char const pre_my_constmember_string_post[4] =
&quot;123&quot;; <br>
}</p>


<p style="margin-left:9%;"><b>ConstantParameterCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constant parameter names conform to the selected
casing.</p>


<p style="margin-left:9%;"><b>ConstantParameterPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constant parameter names will add the prefixed with
the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ConstantParameterIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for constant parameter names matching this
regular expression.</p>


<p style="margin-left:9%;"><b>ConstantParameterSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constant parameter names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ConstantParameterHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="49%">


<p>ConstantParameterCase of <b>lower_case</b></p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="49%">


<p>ConstantParameterPrefix of <b>pre_</b></p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="49%">


<p>ConstantParameterSuffix of <b>_post</b></p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="49%">


<p>ConstantParameterHungarianPrefix of <b>On</b></p></td>
<td width="36%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms constant parameter names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void
GLOBAL_FUNCTION(int PARAMETER_1, int const
CONST_parameter);</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void
GLOBAL_FUNCTION(int PARAMETER_1, int const
pre_const_parameter_post);</p>


<p style="margin-left:9%;"><b>ConstantPointerParameterCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constant pointer parameter names conform to the
selected casing.</p>


<p style="margin-left:9%;"><b>ConstantPointerParameterPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constant pointer parameter names will add the
prefixed with the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ConstantPointerParameterIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for constant pointer parameter names matching
this regular expression.</p>


<p style="margin-left:9%;"><b>ConstantPointerParameterSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constant pointer parameter names will add the suffix
with the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ConstantPointerParameterHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="58%">


<p>ConstantPointerParameterCase of <b>lower_case</b></p></td>
<td width="27%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="58%">


<p>ConstantPointerParameterPrefix of <b>pre_</b></p></td>
<td width="27%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="58%">


<p>ConstantPointerParameterSuffix of <b>_post</b></p></td>
<td width="27%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="58%">


<p>ConstantPointerParameterHungarianPrefix of <b>On</b></p></td>
<td width="27%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms constant pointer parameter names as
follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void
GLOBAL_FUNCTION(int const *CONST_parameter);</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void
GLOBAL_FUNCTION(int const *pre_const_parameter_post);</p>


<p style="margin-left:9%;"><b>ConstexprFunctionCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constexpr function names conform to the selected
casing.</p>


<p style="margin-left:9%;"><b>ConstexprFunctionPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constexpr function names will add the prefixed with
the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ConstexprFunctionIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for constexpr function names matching this
regular expression.</p>


<p style="margin-left:9%;"><b>ConstexprFunctionSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constexpr function names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>ConstexprFunctionCase of <b>lower_case</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>ConstexprFunctionPrefix of <b>pre_</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>ConstexprFunctionSuffix of <b>_post</b></p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms constexpr function names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">constexpr int
CE_function() { return 3; }</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">constexpr int
pre_ce_function_post() { return 3; }</p>

<p style="margin-left:9%;"><b>ConstexprMethodCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constexpr method names conform to the selected
casing.</p>


<p style="margin-left:9%;"><b>ConstexprMethodPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constexpr method names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ConstexprMethodIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for constexpr method names matching this regular
expression.</p>


<p style="margin-left:9%;"><b>ConstexprMethodSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constexpr method names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>ConstexprMethodCase of <b>lower_case</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>ConstexprMethodPrefix of <b>pre_</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>ConstexprMethodSuffix of <b>_post</b></p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms constexpr method names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
public: <br>
constexpr int CST_expr_Method() { return 2; } <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
public: <br>
constexpr int pre_cst_expr_method_post() { return 2; } <br>
}</p>


<p style="margin-left:9%;"><b>ConstexprVariableCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constexpr variable names conform to the selected
casing.</p>


<p style="margin-left:9%;"><b>ConstexprVariablePrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constexpr variable names will add the prefixed with
the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ConstexprVariableIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for constexpr variable names matching this
regular expression.</p>


<p style="margin-left:9%;"><b>ConstexprVariableSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure constexpr variable names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ConstexprVariableHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="49%">


<p>ConstexprVariableCase of <b>lower_case</b></p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="49%">


<p>ConstexprVariablePrefix of <b>pre_</b></p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="49%">


<p>ConstexprVariableSuffix of <b>_post</b></p></td>
<td width="36%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="49%">


<p>ConstexprVariableHungarianPrefix of <b>On</b></p></td>
<td width="36%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms constexpr variable names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">constexpr int
ConstExpr_variable = MyConstant;</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">constexpr int
pre_constexpr_variable_post = MyConstant;</p>

<p style="margin-left:9%;"><b>EnumCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure enumeration names conform to the selected casing.</p>

<p style="margin-left:9%;"><b>EnumPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure enumeration names will add the prefixed with the
given value (regardless of casing).</p>

<p style="margin-left:9%;"><b>EnumIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for enumeration names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>EnumSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure enumeration names will add the suffix with the given
value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="29%">


<p>EnumCase of <b>lower_case</b></p></td>
<td width="56%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="29%">


<p>EnumPrefix of <b>pre_</b></p></td>
<td width="56%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="29%">


<p>EnumSuffix of <b>_post</b></p></td>
<td width="56%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms enumeration names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">enum FOO { One,
Two, Three };</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">enum
pre_foo_post { One, Two, Three };</p>

<p style="margin-left:9%;"><b>EnumConstantCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure enumeration constant names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>EnumConstantPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure enumeration constant names will add the prefixed with
the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>EnumConstantIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for enumeration constant names matching this
regular expression.</p>

<p style="margin-left:9%;"><b>EnumConstantSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure enumeration constant names will add the suffix with
the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>EnumConstantHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>EnumConstantCase of <b>lower_case</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>EnumConstantPrefix of <b>pre_</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>EnumConstantSuffix of <b>_post</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>EnumConstantHungarianPrefix of <b>On</b></p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms enumeration constant names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">enum FOO { One,
Two, Three };</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">enum FOO {
pre_One_post, pre_Two_post, pre_Three_post };</p>

<p style="margin-left:9%;"><b>FunctionCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure function names conform to the selected casing.</p>

<p style="margin-left:9%;"><b>FunctionPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure function names will add the prefixed with the given
value (regardless of casing).</p>


<p style="margin-left:9%;"><b>FunctionIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for function names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>FunctionSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure function names will add the suffix with the given
value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="34%">


<p>FunctionCase of <b>lower_case</b></p></td>
<td width="51%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="34%">


<p>FunctionPrefix of <b>pre_</b></p></td>
<td width="51%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="34%">


<p>FunctionSuffix of <b>_post</b></p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms function names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">char
MY_Function_string();</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">char
pre_my_function_string_post();</p>

<p style="margin-left:9%;"><b>GetConfigPerFile</b></p>

<p style="margin-left:18%;">When <i>true</i> the check will
look for the configuration for where an identifier is
declared. Useful for when included header files use a
different style. Default value is <i>true</i>.</p>

<p style="margin-left:9%;"><b>GlobalConstantCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure global constant names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>GlobalConstantPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure global constant names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>GlobalConstantIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for global constant names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>GlobalConstantSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure global constant names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>GlobalConstantHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>GlobalConstantCase of <b>lower_case</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>GlobalConstantPrefix of <b>pre_</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>GlobalConstantSuffix of <b>_post</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>GlobalConstantHungarianPrefix of <b>On</b></p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms global constant names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">unsigned const
MyConstGlobal_array[] = {1, 2, 3};</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">unsigned const
pre_myconstglobal_array_post[] = {1, 2, 3};</p>


<p style="margin-left:9%;"><b>GlobalConstantPointerCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure global constant pointer names conform to the selected
casing.</p>


<p style="margin-left:9%;"><b>GlobalConstantPointerPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure global constant pointer names will add the prefixed
with the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>GlobalConstantPointerIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for global constant pointer names matching this
regular expression.</p>


<p style="margin-left:9%;"><b>GlobalConstantPointerSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure global constant pointer names will add the suffix
with the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>GlobalConstantPointerHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>GlobalConstantPointerCase of <b>lower_case</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>GlobalConstantPointerPrefix of <b>pre_</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>GlobalConstantPointerSuffix of <b>_post</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>GlobalConstantPointerHungarianPrefix of <b>On</b></p></td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms global constant pointer names as
follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">int *const
MyConstantGlobalPointer = nullptr;</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">int *const
pre_myconstantglobalpointer_post = nullptr;</p>

<p style="margin-left:9%;"><b>GlobalFunctionCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure global function names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>GlobalFunctionPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure global function names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>GlobalFunctionIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for global function names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>GlobalFunctionSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure global function names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="41%">


<p>GlobalFunctionCase of <b>lower_case</b></p></td>
<td width="44%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="41%">


<p>GlobalFunctionPrefix of <b>pre_</b></p></td>
<td width="44%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="41%">


<p>GlobalFunctionSuffix of <b>_post</b></p></td>
<td width="44%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms global function names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void
GLOBAL_FUNCTION(int PARAMETER_1, int const
CONST_parameter);</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void
pre_global_function_post(int PARAMETER_1, int const
CONST_parameter);</p>

<p style="margin-left:9%;"><b>GlobalPointerCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure global pointer names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>GlobalPointerPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure global pointer names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>GlobalPointerIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for global pointer names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>GlobalPointerSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure global pointer names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>GlobalPointerHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>GlobalPointerCase of <b>lower_case</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>GlobalPointerPrefix of <b>pre_</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>GlobalPointerSuffix of <b>_post</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>GlobalPointerHungarianPrefix of <b>On</b></p></td>
<td width="41%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms global pointer names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">int
*GLOBAL3;</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">int
*pre_global3_post;</p>

<p style="margin-left:9%;"><b>GlobalVariableCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure global variable names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>GlobalVariablePrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure global variable names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>GlobalVariableIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for global variable names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>GlobalVariableSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure global variable names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>GlobalVariableHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>GlobalVariableCase of <b>lower_case</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>GlobalVariablePrefix of <b>pre_</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>GlobalVariableSuffix of <b>_post</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>GlobalVariableHungarianPrefix of <b>On</b></p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms global variable names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">int
GLOBAL3;</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">int
pre_global3_post;</p>


<p style="margin-left:9%;"><b>IgnoreMainLikeFunctions</b></p>

<p style="margin-left:18%;">When set to <i>true</i>
functions that have a similar signature to <b>main</b> or
<b>wmain</b> won't enforce checks on the names of their
parameters. Default value is <i>false</i>.</p>

<p style="margin-left:9%;"><b>InlineNamespaceCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure inline namespaces names conform to the selected
casing.</p>


<p style="margin-left:9%;"><b>InlineNamespacePrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure inline namespaces names will add the prefixed with
the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>InlineNamespaceIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for inline namespaces names matching this
regular expression.</p>


<p style="margin-left:9%;"><b>InlineNamespaceSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure inline namespaces names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>InlineNamespaceCase of <b>lower_case</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>InlineNamespacePrefix of <b>pre_</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>InlineNamespaceSuffix of <b>_post</b></p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms inline namespaces names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">namespace
FOO_NS { <br>
inline namespace InlineNamespace { <br>
... <br>
} <br>
} // namespace FOO_NS</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">namespace
FOO_NS { <br>
inline namespace pre_inlinenamespace_post { <br>
... <br>
} <br>
} // namespace FOO_NS</p>

<p style="margin-left:9%;"><b>LocalConstantCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure local constant names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>LocalConstantPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure local constant names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>LocalConstantIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for local constant names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>LocalConstantSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure local constant names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>LocalConstantHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>LocalConstantCase of <b>lower_case</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>LocalConstantPrefix of <b>pre_</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>LocalConstantSuffix of <b>_post</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>LocalConstantHungarianPrefix of <b>On</b></p></td>
<td width="41%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms local constant names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void foo() {
int const local_Constant = 3; }</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void foo() {
int const pre_local_constant_post = 3; }</p>


<p style="margin-left:9%;"><b>LocalConstantPointerCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure local constant pointer names conform to the selected
casing.</p>


<p style="margin-left:9%;"><b>LocalConstantPointerPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure local constant pointer names will add the prefixed
with the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>LocalConstantPointerIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for local constant pointer names matching this
regular expression.</p>


<p style="margin-left:9%;"><b>LocalConstantPointerSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure local constant pointer names will add the suffix with
the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>LocalConstantPointerHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>LocalConstantPointerCase of <b>lower_case</b></p></td>
<td width="32%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>LocalConstantPointerPrefix of <b>pre_</b></p></td>
<td width="32%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>LocalConstantPointerSuffix of <b>_post</b></p></td>
<td width="32%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>LocalConstantPointerHungarianPrefix of <b>On</b></p></td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms local constant pointer names as
follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void foo() {
int const *local_Constant = 3; }</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void foo() {
int const *pre_local_constant_post = 3; }</p>

<p style="margin-left:9%;"><b>LocalPointerCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure local pointer names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>LocalPointerPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure local pointer names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>LocalPointerIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for local pointer names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>LocalPointerSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure local pointer names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>LocalPointerHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>LocalPointerCase of <b>lower_case</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>LocalPointerPrefix of <b>pre_</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>LocalPointerSuffix of <b>_post</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>LocalPointerHungarianPrefix of <b>On</b></p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms local pointer names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void foo() {
int *local_Constant; }</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void foo() {
int *pre_local_constant_post; }</p>

<p style="margin-left:9%;"><b>LocalVariableCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure local variable names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>LocalVariablePrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure local variable names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>LocalVariableIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for local variable names matching this regular
expression.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="48%">


<p>LocalVariableCase of <b>CamelCase</b></p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="48%">


<p>LocalVariableIgnoredRegexp of <b>\w{1,2}</b></p></td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Will exclude
variables with a length less than or equal to 2 from the
camel case check applied to other variables. <b><br>
LocalVariableSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure local variable names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>LocalVariableHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>LocalVariableCase of <b>lower_case</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>LocalVariablePrefix of <b>pre_</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>LocalVariableSuffix of <b>_post</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>LocalVariableHungarianPrefix of <b>On</b></p></td>
<td width="41%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms local variable names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void foo() {
int local_Constant; }</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void foo() {
int pre_local_constant_post; }</p>

<p style="margin-left:9%;"><b>MacroDefinitionCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure macro definitions conform to the selected casing.</p>


<p style="margin-left:9%;"><b>MacroDefinitionPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure macro definitions will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>MacroDefinitionIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for macro definitions matching this regular
expression.</p>


<p style="margin-left:9%;"><b>MacroDefinitionSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure macro definitions will add the suffix with the given
value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>MacroDefinitionCase of <b>lower_case</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>MacroDefinitionPrefix of <b>pre_</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>MacroDefinitionSuffix of <b>_post</b></p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms macro definitions as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">#define
MY_MacroDefinition</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">#define
pre_my_macro_definition_post</p>

<p style="margin-left:9%; margin-top: 1em">Note: This will
not warn on builtin macros or macros defined on the command
line using the <b>-D</b> flag. <b><br>
MemberCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure member names conform to the selected casing.</p>

<p style="margin-left:9%;"><b>MemberPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure member names will add the prefixed with the given
value (regardless of casing).</p>

<p style="margin-left:9%;"><b>MemberIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for member names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>MemberSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure member names will add the suffix with the given value
(regardless of casing).</p>


<p style="margin-left:9%;"><b>MemberHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="35%">


<p>MemberCase of <b>lower_case</b></p></td>
<td width="50%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="35%">


<p>MemberPrefix of <b>pre_</b></p></td>
<td width="50%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="35%">


<p>MemberSuffix of <b>_post</b></p></td>
<td width="50%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="35%">


<p>MemberHungarianPrefix of <b>On</b></p></td>
<td width="50%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms member names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
char MY_ConstMember_string[4]; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
char pre_my_constmember_string_post[4]; <br>
}</p>

<p style="margin-left:9%;"><b>MethodCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure method names conform to the selected casing.</p>

<p style="margin-left:9%;"><b>MethodPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure method names will add the prefixed with the given
value (regardless of casing).</p>

<p style="margin-left:9%;"><b>MethodIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for method names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>MethodSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure method names will add the suffix with the given value
(regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="31%">


<p>MethodCase of <b>lower_case</b></p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="31%">


<p>MethodPrefix of <b>pre_</b></p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="31%">


<p>MethodSuffix of <b>_post</b></p></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms method names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
char MY_Method_string(); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
char pre_my_method_string_post(); <br>
}</p>

<p style="margin-left:9%;"><b>NamespaceCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure namespace names conform to the selected casing.</p>

<p style="margin-left:9%;"><b>NamespacePrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure namespace names will add the prefixed with the given
value (regardless of casing).</p>


<p style="margin-left:9%;"><b>NamespaceIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for namespace names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>NamespaceSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure namespace names will add the suffix with the given
value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="35%">


<p>NamespaceCase of <b>lower_case</b></p></td>
<td width="50%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="35%">


<p>NamespacePrefix of <b>pre_</b></p></td>
<td width="50%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="35%">


<p>NamespaceSuffix of <b>_post</b></p></td>
<td width="50%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms namespace names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">namespace
FOO_NS { <br>
... <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">namespace
pre_foo_ns_post { <br>
... <br>
}</p>

<p style="margin-left:9%;"><b>ParameterCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure parameter names conform to the selected casing.</p>

<p style="margin-left:9%;"><b>ParameterPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure parameter names will add the prefixed with the given
value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ParameterIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for parameter names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>ParameterSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure parameter names will add the suffix with the given
value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ParameterHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="39%">


<p>ParameterCase of <b>lower_case</b></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="39%">


<p>ParameterPrefix of <b>pre_</b></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="39%">


<p>ParameterSuffix of <b>_post</b></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="39%">


<p>ParameterHungarianPrefix of <b>On</b></p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms parameter names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void
GLOBAL_FUNCTION(int PARAMETER_1, int const
CONST_parameter);</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void
GLOBAL_FUNCTION(int pre_parameter_post, int const
CONST_parameter);</p>

<p style="margin-left:9%;"><b>ParameterPackCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure parameter pack names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>ParameterPackPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure parameter pack names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ParameterPackIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for parameter pack names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>ParameterPackSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure parameter pack names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="40%">


<p>ParameterPackCase of <b>lower_case</b></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="40%">


<p>ParameterPackPrefix of <b>pre_</b></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="40%">


<p>ParameterPackSuffix of <b>_post</b></p></td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms parameter pack names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename... TYPE_parameters&gt; { <br>
void FUNCTION(int... TYPE_parameters); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename... TYPE_parameters&gt; { <br>
void FUNCTION(int... pre_type_parameters_post); <br>
}</p>

<p style="margin-left:9%;"><b>PointerParameterCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure pointer parameter names conform to the selected
casing.</p>


<p style="margin-left:9%;"><b>PointerParameterPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure pointer parameter names will add the prefixed with
the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>PointerParameterIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for pointer parameter names matching this
regular expression.</p>


<p style="margin-left:9%;"><b>PointerParameterSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure pointer parameter names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>PointerParameterHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="48%">


<p>PointerParameterCase of <b>lower_case</b></p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="48%">


<p>PointerParameterPrefix of <b>pre_</b></p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="48%">


<p>PointerParameterSuffix of <b>_post</b></p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="48%">


<p>PointerParameterHungarianPrefix of <b>On</b></p></td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms pointer parameter names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void
FUNCTION(int *PARAMETER);</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void
FUNCTION(int *pre_parameter_post);</p>

<p style="margin-left:9%;"><b>PrivateMemberCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure private member names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>PrivateMemberPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure private member names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>PrivateMemberIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for private member names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>PrivateMemberSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure private member names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>PrivateMemberHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>PrivateMemberCase of <b>lower_case</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>PrivateMemberPrefix of <b>pre_</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>PrivateMemberSuffix of <b>_post</b></p></td>
<td width="41%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="44%">


<p>PrivateMemberHungarianPrefix of <b>On</b></p></td>
<td width="41%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms private member names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
private: <br>
int Member_Variable; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
private: <br>
int pre_member_variable_post; <br>
}</p>

<p style="margin-left:9%;"><b>PrivateMethodCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure private method names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>PrivateMethodPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure private method names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>PrivateMethodIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for private method names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>PrivateMethodSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure private method names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="40%">


<p>PrivateMethodCase of <b>lower_case</b></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="40%">


<p>PrivateMethodPrefix of <b>pre_</b></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="40%">


<p>PrivateMethodSuffix of <b>_post</b></p></td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms private method names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
private: <br>
int Member_Method(); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
private: <br>
int pre_member_method_post(); <br>
}</p>

<p style="margin-left:9%;"><b>ProtectedMemberCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure protected member names conform to the selected
casing.</p>


<p style="margin-left:9%;"><b>ProtectedMemberPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure protected member names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ProtectedMemberIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for protected member names matching this regular
expression.</p>


<p style="margin-left:9%;"><b>ProtectedMemberSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure protected member names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ProtectedMemberHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="47%">


<p>ProtectedMemberCase of <b>lower_case</b></p></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="47%">


<p>ProtectedMemberPrefix of <b>pre_</b></p></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="47%">


<p>ProtectedMemberSuffix of <b>_post</b></p></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="47%">


<p>ProtectedMemberHungarianPrefix of <b>On</b></p></td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms protected member names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
protected: <br>
int Member_Variable; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
protected: <br>
int pre_member_variable_post; <br>
}</p>

<p style="margin-left:9%;"><b>ProtectedMethodCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure protected method names conform to the selected
casing.</p>


<p style="margin-left:9%;"><b>ProtectedMethodPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure protected method names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ProtectedMethodIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for protected method names matching this regular
expression.</p>


<p style="margin-left:9%;"><b>ProtectedMethodSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure protected method names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>ProtectedMethodCase of <b>lower_case</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>ProtectedMethodPrefix of <b>pre_</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>ProtectedMethodSuffix of <b>_post</b></p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms protect method names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
protected: <br>
int Member_Method(); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
protected: <br>
int pre_member_method_post(); <br>
}</p>

<p style="margin-left:9%;"><b>PublicMemberCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure public member names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>PublicMemberPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure public member names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>PublicMemberIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for public member names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>PublicMemberSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure public member names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>PublicMemberHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>PublicMemberCase of <b>lower_case</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>PublicMemberPrefix of <b>pre_</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>PublicMemberSuffix of <b>_post</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="43%">


<p>PublicMemberHungarianPrefix of <b>On</b></p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms public member names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
public: <br>
int Member_Variable; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
public: <br>
int pre_member_variable_post; <br>
}</p>

<p style="margin-left:9%;"><b>PublicMethodCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure public method names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>PublicMethodPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure public method names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>PublicMethodIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for public method names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>PublicMethodSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure public method names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="39%">


<p>PublicMethodCase of <b>lower_case</b></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="39%">


<p>PublicMethodPrefix of <b>pre_</b></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="39%">


<p>PublicMethodSuffix of <b>_post</b></p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms public method names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
public: <br>
int Member_Method(); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
public: <br>
int pre_member_method_post(); <br>
}</p>


<p style="margin-left:9%;"><b>ScopedEnumConstantCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure scoped enum constant names conform to the selected
casing.</p>


<p style="margin-left:9%;"><b>ScopedEnumConstantPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure scoped enum constant names will add the prefixed with
the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ScopedEnumConstantIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for scoped enum constant names matching this
regular expression.</p>


<p style="margin-left:9%;"><b>ScopedEnumConstantSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure scoped enum constant names will add the suffix with
the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ScopedEnumConstantHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="50%">


<p>ScopedEnumConstantCase of <b>lower_case</b></p></td>
<td width="35%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="50%">


<p>ScopedEnumConstantPrefix of <b>pre_</b></p></td>
<td width="35%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="50%">


<p>ScopedEnumConstantSuffix of <b>_post</b></p></td>
<td width="35%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="50%">


<p>ScopedEnumConstantHungarianPrefix of <b>On</b></p></td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms enumeration constant names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">enum class FOO
{ One, Two, Three };</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">enum class FOO
{ pre_One_post, pre_Two_post, pre_Three_post };</p>

<p style="margin-left:9%;"><b>StaticConstantCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure static constant names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>StaticConstantPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure static constant names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>StaticConstantIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for static constant names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>StaticConstantSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure static constant names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>StaticConstantHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>StaticConstantCase of <b>lower_case</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>StaticConstantPrefix of <b>pre_</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>StaticConstantSuffix of <b>_post</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>StaticConstantHungarianPrefix of <b>On</b></p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms static constant names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">static unsigned
const MyConstStatic_array[] = {1, 2, 3};</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">static unsigned
const pre_myconststatic_array_post[] = {1, 2, 3};</p>

<p style="margin-left:9%;"><b>StaticVariableCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure static variable names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>StaticVariablePrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure static variable names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>StaticVariableIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for static variable names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>StaticVariableSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure static variable names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>StaticVariableHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>StaticVariableCase of <b>lower_case</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>StaticVariablePrefix of <b>pre_</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>StaticVariableSuffix of <b>_post</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>StaticVariableHungarianPrefix of <b>On</b></p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms static variable names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">static unsigned
MyStatic_array[] = {1, 2, 3};</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">static unsigned
pre_mystatic_array_post[] = {1, 2, 3};</p>

<p style="margin-left:9%;"><b>StructCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure struct names conform to the selected casing.</p>

<p style="margin-left:9%;"><b>StructPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure struct names will add the prefixed with the given
value (regardless of casing).</p>

<p style="margin-left:9%;"><b>StructIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for struct names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>StructSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure struct names will add the suffix with the given value
(regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="31%">


<p>StructCase of <b>lower_case</b></p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="31%">


<p>StructPrefix of <b>pre_</b></p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="31%">


<p>StructSuffix of <b>_post</b></p></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms struct names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">struct FOO {
<br>
FOO(); <br>
&#732;FOO(); <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">struct
pre_foo_post { <br>
pre_foo_post(); <br>
&#732;pre_foo_post(); <br>
};</p>


<p style="margin-left:9%;"><b>TemplateParameterCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure template parameter names conform to the selected
casing.</p>


<p style="margin-left:9%;"><b>TemplateParameterPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure template parameter names will add the prefixed with
the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>TemplateParameterIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for template parameter names matching this
regular expression.</p>


<p style="margin-left:9%;"><b>TemplateParameterSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure template parameter names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>TemplateParameterCase of <b>lower_case</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>TemplateParameterPrefix of <b>pre_</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>TemplateParameterSuffix of <b>_post</b></p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms template parameter names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename T&gt; class Foo {};</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;typename pre_t_post&gt; class Foo {};</p>


<p style="margin-left:9%;"><b>TemplateTemplateParameterCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure template template parameter names conform to the
selected casing.</p>


<p style="margin-left:9%;"><b>TemplateTemplateParameterPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure template template parameter names will add the
prefixed with the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>TemplateTemplateParameterIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for template template parameter names matching
this regular expression.</p>


<p style="margin-left:9%;"><b>TemplateTemplateParameterSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure template template parameter names will add the suffix
with the given value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="56%">


<p>TemplateTemplateParameterCase of <b>lower_case</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="56%">


<p>TemplateTemplateParameterPrefix of <b>pre_</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="56%">


<p>TemplateTemplateParameterSuffix of <b>_post</b></p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms template template parameter names as
follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;template &lt;typename&gt; class TPL_parameter, int
COUNT_params, <br>
typename... TYPE_parameters&gt;</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;template &lt;typename&gt; class pre_tpl_parameter_post,
int COUNT_params, <br>
typename... TYPE_parameters&gt;</p>

<p style="margin-left:9%;"><b>TypeAliasCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure type alias names conform to the selected casing.</p>

<p style="margin-left:9%;"><b>TypeAliasPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure type alias names will add the prefixed with the given
value (regardless of casing).</p>


<p style="margin-left:9%;"><b>TypeAliasIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for type alias names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>TypeAliasSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure type alias names will add the suffix with the given
value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="35%">


<p>TypeAliasCase of <b>lower_case</b></p></td>
<td width="50%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="35%">


<p>TypeAliasPrefix of <b>pre_</b></p></td>
<td width="50%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="35%">


<p>TypeAliasSuffix of <b>_post</b></p></td>
<td width="50%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms type alias names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">using
MY_STRUCT_TYPE = my_structure;</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">using
pre_my_struct_type_post = my_structure;</p>

<p style="margin-left:9%;"><b>TypedefCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure typedef names conform to the selected casing.</p>

<p style="margin-left:9%;"><b>TypedefPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure typedef names will add the prefixed with the given
value (regardless of casing).</p>

<p style="margin-left:9%;"><b>TypedefIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for typedef names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>TypedefSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure typedef names will add the suffix with the given
value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="32%">


<p>TypedefCase of <b>lower_case</b></p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="32%">


<p>TypedefPrefix of <b>pre_</b></p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="32%">


<p>TypedefSuffix of <b>_post</b></p></td>
<td width="53%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms typedef names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">typedef int
MYINT;</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">typedef int
pre_myint_post;</p>


<p style="margin-left:9%;"><b>TypeTemplateParameterCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure type template parameter names conform to the selected
casing.</p>


<p style="margin-left:9%;"><b>TypeTemplateParameterPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure type template parameter names will add the prefixed
with the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>TypeTemplateParameterIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for type template names matching this regular
expression.</p>


<p style="margin-left:9%;"><b>TypeTemplateParameterSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure type template parameter names will add the suffix
with the given value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="50%">


<p>TypeTemplateParameterCase of <b>lower_case</b></p></td>
<td width="35%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="50%">


<p>TypeTemplateParameterPrefix of <b>pre_</b></p></td>
<td width="35%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="50%">


<p>TypeTemplateParameterSuffix of <b>_post</b></p></td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms type template parameter names as
follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;template &lt;typename&gt; class TPL_parameter, int
COUNT_params, <br>
typename... TYPE_parameters&gt;</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;template &lt;typename&gt; class TPL_parameter, int
COUNT_params, <br>
typename... pre_type_parameters_post&gt;</p>

<p style="margin-left:9%;"><b>UnionCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure union names conform to the selected casing.</p>

<p style="margin-left:9%;"><b>UnionPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure union names will add the prefixed with the given
value (regardless of casing).</p>

<p style="margin-left:9%;"><b>UnionIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for union names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>UnionSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure union names will add the suffix with the given value
(regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="30%">


<p>UnionCase of <b>lower_case</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="30%">


<p>UnionPrefix of <b>pre_</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="30%">


<p>UnionSuffix of <b>_post</b></p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms union names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">union FOO {
<br>
int a; <br>
char b; <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">union
pre_foo_post { <br>
int a; <br>
char b; <br>
};</p>


<p style="margin-left:9%;"><b>ValueTemplateParameterCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure value template parameter names conform to the
selected casing.</p>


<p style="margin-left:9%;"><b>ValueTemplateParameterPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure value template parameter names will add the prefixed
with the given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>ValueTemplateParameterIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for value template parameter names matching this
regular expression.</p>


<p style="margin-left:9%;"><b>ValueTemplateParameterSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure value template parameter names will add the suffix
with the given value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="52%">


<p>ValueTemplateParameterCase of <b>lower_case</b></p></td>
<td width="33%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="52%">


<p>ValueTemplateParameterPrefix of <b>pre_</b></p></td>
<td width="33%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="52%">


<p>ValueTemplateParameterSuffix of <b>_post</b></p></td>
<td width="33%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms value template parameter names as
follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;template &lt;typename&gt; class TPL_parameter, int
COUNT_params, <br>
typename... TYPE_parameters&gt;</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">template
&lt;template &lt;typename&gt; class TPL_parameter, int
pre_count_params_post, <br>
typename... TYPE_parameters&gt;</p>

<p style="margin-left:9%;"><b>VariableCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure variable names conform to the selected casing.</p>

<p style="margin-left:9%;"><b>VariablePrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure variable names will add the prefixed with the given
value (regardless of casing).</p>


<p style="margin-left:9%;"><b>VariableIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for variable names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>VariableSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure variable names will add the suffix with the given
value (regardless of casing).</p>


<p style="margin-left:9%;"><b>VariableHungarianPrefix</b></p>

<p style="margin-left:18%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="38%">


<p>VariableCase of <b>lower_case</b></p></td>
<td width="47%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="38%">


<p>VariablePrefix of <b>pre_</b></p></td>
<td width="47%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="38%">


<p>VariableSuffix of <b>_post</b></p></td>
<td width="47%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="38%">


<p>VariableHungarianPrefix of <b>On</b></p></td>
<td width="47%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms variable names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">unsigned
MyVariable;</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">unsigned
pre_myvariable_post;</p>

<p style="margin-left:9%;"><b>VirtualMethodCase</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure virtual method names conform to the selected
casing.</p>

<p style="margin-left:9%;"><b>VirtualMethodPrefix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure virtual method names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:9%;"><b>VirtualMethodIgnoredRegexp</b></p>

<p style="margin-left:18%;">Identifier naming checks won't
be enforced for virtual method names matching this regular
expression.</p>

<p style="margin-left:9%;"><b>VirtualMethodSuffix</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure virtual method names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:9%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="40%">


<p>VirtualMethodCase of <b>lower_case</b></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="40%">


<p>VirtualMethodPrefix of <b>pre_</b></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="40%">


<p>VirtualMethodSuffix of <b>_post</b></p></td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Identifies
and/or transforms virtual method names as follows:</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
public: <br>
virtual int MemberFunction(); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
public: <br>
virtual int pre_member_function_post(); <br>
}</p>

<h3>The default mapping table of Hungarian Notation
<a name="The default mapping table of Hungarian Notation"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">In Hungarian
notation, a variable name starts with a group of lower-case
letters which are mnemonics for the type or purpose of that
variable, followed by whatever name the programmer has
chosen; this last part is sometimes distinguished as the
given name. The first character of the given name can be
capitalized to separate it from the type indicators (see
also CamelCase). Otherwise the case of this character
denotes scope.</p>

<p style="margin-left:9%; margin-top: 1em">The following
table is the default mapping table of Hungarian Notation
which maps Decl to its prefix string. You can also have your
own style in config file. <b><br>
There are more trivial options for Hungarian Notation: <br>
HungarianNotation.General.*</b></p>

<p style="margin-left:18%;">Options are not belonging to
any specific Decl.</p>


<p style="margin-left:9%;"><b>HungarianNotation.CString.*</b></p>

<p style="margin-left:18%;">Options for NULL-terminated
string.</p>


<p style="margin-left:9%;"><b>HungarianNotation.DerivedType.*</b></p>

<p style="margin-left:18%;">Options for derived types.</p>


<p style="margin-left:9%;"><b>HungarianNotation.PrimitiveType.*</b></p>

<p style="margin-left:18%;">Options for primitive
types.</p>


<p style="margin-left:9%;"><b>HungarianNotation.UserDefinedType.*</b></p>

<p style="margin-left:18%;">Options for user-defined
types.</p>

<h3>Options for Hungarian Notation
<a name="Options for Hungarian Notation"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="57%">



<p style="margin-top: 1em"><i>HungarianNotation.General.TreatStructAsClass</i></p> </td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="57%">


<p><i>HungarianNotation.DerivedType.Array</i></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="57%">


<p><i>HungarianNotation.DerivedType.Pointer</i></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="57%">



<p><i>HungarianNotation.DerivedType.FunctionPointer</i></p> </td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="57%">


<p><i>HungarianNotation.CString.CharPointer</i></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="57%">


<p><i>HungarianNotation.CString.CharArray</i></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="57%">


<p><i>HungarianNotation.CString.WideCharPointer</i></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="57%">


<p><i>HungarianNotation.CString.WideCharArray</i></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="57%">


<p><i>HungarianNotation.PrimitiveType.*</i></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="57%">


<p><i>HungarianNotation.UserDefinedType.*</i></p></td>
<td width="31%">
</td></tr>
</table>


<p style="margin-left:9%;"><b>HungarianNotation.General.TreatStructAsClass</b></p>

<p style="margin-left:18%;">When defined, the check will
treat naming of struct as a class. The default value is
<i>false</i>.</p>


<p style="margin-left:9%;"><b>HungarianNotation.DerivedType.Array</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure variable name will add the prefix with the given
string. The default prefix is <i>a</i>.</p>


<p style="margin-left:9%;"><b>HungarianNotation.DerivedType.Pointer</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure variable name will add the prefix with the given
string. The default prefix is <i>p</i>.</p>


<p style="margin-left:9%;"><b>HungarianNotation.DerivedType.FunctionPointer</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure variable name will add the prefix with the given
string. The default prefix is <i>fn</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">// Array <br>
int DataArray[2] = {0};</p>

<p style="margin-left:13%; margin-top: 1em">// Pointer <br>
void *DataBuffer = NULL;</p>

<p style="margin-left:13%; margin-top: 1em">//
FunctionPointer <br>
typedef void (*FUNC_PTR)(); <br>
FUNC_PTR FuncPtr = NULL;</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">// Array <br>
int aDataArray[2] = {0};</p>

<p style="margin-left:13%; margin-top: 1em">// Pointer <br>
void *pDataBuffer = NULL;</p>

<p style="margin-left:13%; margin-top: 1em">//
FunctionPointer <br>
typedef void (*FUNC_PTR)(); <br>
FUNC_PTR fnFuncPtr = NULL;</p>


<p style="margin-left:9%;"><b>HungarianNotation.CString.CharPointer</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure variable name will add the prefix with the given
string. The default prefix is <i>sz</i>.</p>


<p style="margin-left:9%;"><b>HungarianNotation.CString.CharArray</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure variable name will add the prefix with the given
string. The default prefix is <i>sz</i>.</p>


<p style="margin-left:9%;"><b>HungarianNotation.CString.WideCharPointer</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure variable name will add the prefix with the given
string. The default prefix is <i>wsz</i>.</p>


<p style="margin-left:9%;"><b>HungarianNotation.CString.WideCharArray</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure variable name will add the prefix with the given
string. The default prefix is <i>wsz</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">// CharPointer
<br>
const char *NamePtr = &quot;Name&quot;;</p>

<p style="margin-left:13%; margin-top: 1em">// CharArray
<br>
const char NameArray[] = &quot;Name&quot;;</p>

<p style="margin-left:13%; margin-top: 1em">//
WideCharPointer <br>
const wchar_t *WideNamePtr = L&quot;Name&quot;;</p>

<p style="margin-left:13%; margin-top: 1em">//
WideCharArray <br>
const wchar_t WideNameArray[] = L&quot;Name&quot;;</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">// CharPointer
<br>
const char *szNamePtr = &quot;Name&quot;;</p>

<p style="margin-left:13%; margin-top: 1em">// CharArray
<br>
const char szNameArray[] = &quot;Name&quot;;</p>

<p style="margin-left:13%; margin-top: 1em">//
WideCharPointer <br>
const wchar_t *wszWideNamePtr = L&quot;Name&quot;;</p>

<p style="margin-left:13%; margin-top: 1em">//
WideCharArray <br>
const wchar_t wszWideNameArray[] = L&quot;Name&quot;;</p>


<p style="margin-left:9%;"><b>HungarianNotation.PrimitiveType.*</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure variable name of involved primitive types will add
the prefix with the given string. The default prefixes are
defined in the default mapping table.</p>


<p style="margin-left:9%;"><b>HungarianNotation.UserDefinedType.*</b></p>

<p style="margin-left:18%;">When defined, the check will
ensure variable name of involved primitive types will add
the prefix with the given string. The default prefixes are
defined in the default mapping table.</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">int8_t ValueI8
= 0; <br>
int16_t ValueI16 = 0; <br>
int32_t ValueI32 = 0; <br>
int64_t ValueI64 = 0; <br>
uint8_t ValueU8 = 0; <br>
uint16_t ValueU16 = 0; <br>
uint32_t ValueU32 = 0; <br>
uint64_t ValueU64 = 0; <br>
float ValueFloat = 0.0; <br>
double ValueDouble = 0.0; <br>
ULONG ValueUlong = 0; <br>
DWORD ValueDword = 0;</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">int8_t
i8ValueI8 = 0; <br>
int16_t i16ValueI16 = 0; <br>
int32_t i32ValueI32 = 0; <br>
int64_t i64ValueI64 = 0; <br>
uint8_t u8ValueU8 = 0; <br>
uint16_t u16ValueU16 = 0; <br>
uint32_t u32ValueU32 = 0; <br>
uint64_t u64ValueU64 = 0; <br>
float fValueFloat = 0.0; <br>
double dValueDouble = 0.0; <br>
ULONG ulValueUlong = 0; <br>
DWORD dwValueDword = 0;</p>

<h3>readability-implicit-bool-cast
<a name="readability-implicit-bool-cast"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check has
been renamed to
<i>readability-implicit-bool-conversion</i>.</p>

<h3>readability-implicit-bool-conversion
<a name="readability-implicit-bool-conversion"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check can
be used to find implicit conversions between built-in types
and booleans. Depending on use case, it may simply help with
readability of the code, or in some cases, point to
potential bugs which remain unnoticed due to implicit
conversions.</p>

<p style="margin-left:9%; margin-top: 1em">The following is
a real-world example of bug which was hiding behind implicit
<b>bool</b> conversion:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
int m_foo;</p>

<p style="margin-left:13%; margin-top: 1em">public: <br>
void setFoo(bool foo) { m_foo = foo; } // warning: implicit
conversion bool -&gt; int <br>
int getFoo() { return m_foo; } <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">void
use(Foo&amp; foo) { <br>
bool value = foo.getFoo(); // warning: implicit conversion
int -&gt; bool <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">This code is the
result of unsuccessful refactoring, where type of
<b>m_foo</b> changed from <b>bool</b> to <b>int</b>. The
programmer forgot to change all occurrences of <b>bool</b>,
and the remaining code is no longer correct, yet it still
compiles without any visible warnings.</p>

<p style="margin-left:9%; margin-top: 1em">In addition to
issuing warnings, fix-it hints are provided to help solve
the reported issues. This can be used for improving
readability of code, for example:</p>

<p style="margin-left:13%; margin-top: 1em">void
conversionsToBool() { <br>
float floating; <br>
bool boolean = floating; <br>
// &#710; propose replacement: bool boolean = floating !=
0.0f;</p>

<p style="margin-left:13%; margin-top: 1em">int integer;
<br>
if (integer) {} <br>
// &#710; propose replacement: if (integer != 0) {}</p>

<p style="margin-left:13%; margin-top: 1em">int* pointer;
<br>
if (!pointer) {} <br>
// &#710; propose replacement: if (pointer == nullptr)
{}</p>

<p style="margin-left:13%; margin-top: 1em">while (1) {}
<br>
// &#710; propose replacement: while (true) {} <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
functionTakingInt(int param);</p>

<p style="margin-left:13%; margin-top: 1em">void
conversionsFromBool() { <br>
bool boolean; <br>
functionTakingInt(boolean); <br>
// &#710; propose replacement:
functionTakingInt(static_cast&lt;int&gt;(boolean));</p>


<p style="margin-left:13%; margin-top: 1em">functionTakingInt(true);
<br>
// &#710; propose replacement: functionTakingInt(1); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In general, the
following conversion types are checked:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>integer expression/literal to boolean (conversion from a
single bit bitfield to boolean is explicitly allowed, since
there's no ambiguity / information loss in this case),</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>floating expression/literal to boolean,</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>pointer/pointer to member/<b>nullptr</b>/<b>NULL</b> to
boolean,</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>boolean expression/literal to integer (conversion from
boolean to a single bit bitfield is explicitly allowed),</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>boolean expression/literal to floating.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">The rules for
generating fix-it hints are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">in case of conversions from
other built-in type to bool, an explicit comparison is
proposed to make it clear what exactly is being
compared:</p> </td></tr>
</table>

<p style="margin-left:12%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%"></td>
<td width="1%"></td>
<td width="86%">


<p style="margin-top: 1em"><b>bool boolean = floating;</b>
is changed to <b>bool boolean = floating == 0.0f;</b>,</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="86%">


<p>for other types, appropriate literals are used
(<b>0</b>, <b>0u</b>, <b>0.0f</b>, <b>0.0</b>,
<b>nullptr</b>),</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">in case of
negated expressions conversion to bool, the proposed
replacement with comparison is simplified:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="67%">


<p style="margin-top: 1em"><b>if (!pointer)</b> is changed
to <b>if (pointer == nullptr)</b>,</p></td>
<td width="19%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="67%"></td>
<td width="19%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">in case of
conversions from bool to other built-in types, an explicit
<b>static_cast</b> (or a C-style cast since C23) is proposed
to make it clear that a conversion is taking place:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="86%">


<p style="margin-top: 1em"><b>int integer = boolean;</b> is
changed to <b>int integer =
static_cast&lt;int&gt;(boolean);</b>,</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">if the
conversion is performed on type literals, an equivalent
literal is proposed, according to what type is actually
expected, for example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="86%">


<p style="margin-top: 1em"><b>functionTakingBool(0);</b> is
changed to <b>functionTakingBool(false);</b>,</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="86%">


<p><b>functionTakingInt(true);</b> is changed to
<b>functionTakingInt(1);</b>,</p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="86%">


<p>for other types, appropriate literals are used
(<b>false</b>, <b>true</b>, <b>0</b>, <b>1</b>, <b>0u</b>,
<b>1u</b>, <b>0.0f</b>, <b>1.0f</b>, <b>0.0</b>,
<b>1.0f</b>).</p> </td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Some additional
accommodations are made for pre-C++11 dialects:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="73%">


<p style="margin-top: 1em"><b>false</b> literal conversion
to pointer is detected,</p></td>
<td width="15%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="73%">


<p>instead of <b>nullptr</b> literal, <b>0</b> is proposed
as replacement.</p></td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Occurrences of
implicit conversions inside macros and template
instantiations are deliberately ignored, as it is not clear
how to deal with such cases.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>AllowIntegerConditions</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will allow conditional integer conversions. Default is
<i>false</i>.</p>


<p style="margin-left:9%;"><b>AllowPointerConditions</b></p>

<p style="margin-left:18%;">When <i>true</i>, the check
will allow conditional pointer conversions. Default is
<i>false</i>.</p>

<h3>readability-inconsistent-declaration-parameter-name
<a name="readability-inconsistent-declaration-parameter-name"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Find function
declarations which differ in parameter names.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">// in foo.hpp:
<br>
void foo(int a, int b, int c);</p>

<p style="margin-left:13%; margin-top: 1em">// in foo.cpp:
<br>
void foo(int d, int e, int f); // warning</p>

<p style="margin-left:9%; margin-top: 1em">This check
should help to enforce consistency in large projects, where
it often happens that a definition of function is
refactored, changing the parameter names, but its
declaration in header file is not updated. With this check,
we can easily find and correct such inconsistencies, keeping
declaration and definition always in sync.</p>

<p style="margin-left:9%; margin-top: 1em">Unnamed
parameters are allowed and are not taken into account when
comparing function declarations, for example:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(int
a); <br>
void foo(int); // no warning</p>

<p style="margin-left:9%; margin-top: 1em">One name is also
allowed to be a case-insensitive prefix/suffix of the
other:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(int
count); <br>
void foo(int count_input) { // no warning <br>
int count = adjustCount(count_input); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">To help with
refactoring, in some cases fix-it hints are generated to
align parameter names to a single naming convention. This
works with the assumption that the function definition is
the most up-to-date version, as it directly references
parameter names in its body. Example:</p>

<p style="margin-left:13%; margin-top: 1em">void foo(int
a); // warning and fix-it hint (replace &quot;a&quot; to
&quot;b&quot;) <br>
int foo(int b) { return b + 2; } // definition with use of
&quot;b&quot;</p>

<p style="margin-left:9%; margin-top: 1em">In the case of
multiple redeclarations or function template
specializations, a warning is issued for every redeclaration
or specialization inconsistent with the definition or the
first declaration seen in a translation unit. <b><br>
IgnoreMacros</b></p>

<p style="margin-left:18%;">If this option is set to
<i>true</i> (default is <i>true</i>), the check will not
warn about names declared inside macros.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p><b>Strict</b></p></td>
<td width="1%"></td>
<td width="82%">


<p>If this option is set to <i>true</i> (default is
<i>false</i>), then names must match exactly (or be
absent).</p> </td></tr>
</table>

<h3>readability-isolate-declaration
<a name="readability-isolate-declaration"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects local
variable declarations declaring more than one variable and
tries to refactor the code to one statement per
declaration.</p>

<p style="margin-left:9%; margin-top: 1em">The automatic
code-transformation will use the same indentation as the
original for every created statement and add a line break
after each statement. It keeps the order of the variable
declarations consistent, too.</p>

<p style="margin-left:13%; margin-top: 1em">void f() { <br>
int * pointer = nullptr, value = 42, * const const_ptr =
&amp;value; <br>
// This declaration will be diagnosed and transformed into:
<br>
// int * pointer = nullptr; <br>
// int value = 42; <br>
// int * const const_ptr = &amp;value; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The check
excludes places where it is necessary or common to declare
multiple variables in one statement and there is no other
way supported in the language. Please note that structured
bindings are not considered.</p>

<p style="margin-left:13%; margin-top: 1em">// It is not
possible to transform this declaration and doing the
declaration <br>
// before the loop will increase the scope of the variable
'Begin' and 'End' <br>
// which is undesirable. <br>
for (int Begin = 0, End = 100; Begin &lt; End; ++Begin);
<br>
if (int Begin = 42, Result = some_function(Begin); Begin ==
Result);</p>

<p style="margin-left:13%; margin-top: 1em">// It is not
possible to transform this declaration because the result is
<br>
// not functionality preserving as 'j' and 'k' would not be
part of the <br>
// 'if' statement anymore. <br>
if (SomeCondition()) <br>
int i = 42, j = 43, k = function(i,j);</p>

<h3>Limitations
<a name="Limitations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Global variables
and member variables are excluded.</p>

<p style="margin-left:9%; margin-top: 1em">The check
currently does not support the automatic transformation of
member-pointer-types.</p>

<p style="margin-left:13%; margin-top: 1em">struct S { <br>
int a; <br>
const int b; <br>
void f() {} <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">void f() { <br>
// Only a diagnostic message is emitted <br>
int S::*p = &amp;S::a, S::*const q = &amp;S::a; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Furthermore, the
transformation is very cautious when it detects various
kinds of macros or preprocessor directives in the range of
the statement. In this case the transformation will not
happen to avoid unexpected side-effects due to macros.</p>

<p style="margin-left:13%; margin-top: 1em">#define NULL 0
<br>
#define MY_NICE_TYPE int ** <br>
#define VAR_NAME(name) name##__LINE__ <br>
#define A_BUNCH_OF_VARIABLES int m1 = 42, m2 = 43, m3 =
44;</p>

<p style="margin-left:13%; margin-top: 1em">void macros() {
<br>
int *p1 = NULL, *p2 = NULL; <br>
// Will be transformed to <br>
// int *p1 = NULL; <br>
// int *p2 = NULL;</p>

<p style="margin-left:13%; margin-top: 1em">MY_NICE_TYPE
p3, v1, v2; <br>
// Won't be transformed, but a diagnostic is emitted.</p>

<p style="margin-left:13%; margin-top: 1em">int
VAR_NAME(v3), <br>
VAR_NAME(v4), <br>
VAR_NAME(v5); <br>
// Won't be transformed, but a diagnostic is emitted.</p>


<p style="margin-left:13%; margin-top: 1em">A_BUNCH_OF_VARIABLES
<br>
// Won't be transformed, but a diagnostic is emitted.</p>

<p style="margin-left:13%; margin-top: 1em">int
Unconditional, <br>
#if CONFIGURATION <br>
IfConfigured = 42, <br>
#else <br>
IfConfigured = 0; <br>
#endif <br>
// Won't be transformed, but a diagnostic is emitted. <br>
}</p>

<h3>readability-magic-numbers
<a name="readability-magic-numbers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects magic
numbers, integer or floating point literals that are
embedded in code and not introduced via constants or
symbols.</p>

<p style="margin-left:9%; margin-top: 1em">Many coding
guidelines advise replacing the magic values with symbolic
constants to improve readability. Here are a few
references:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em"><i>Rule ES.45: Avoid &quot;magic
constants&quot;; use symbolic constants in C++ Core
Guidelines</i></p> </td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>Rule 5.1.1 Use symbolic names instead of literal
values in code in High Integrity C++</i></p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>Item 17 in &quot;C++ Coding Standards: 101 Rules,
Guidelines and Best Practices&quot; by Herb Sutter and
Andrei Alexandrescu</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>Chapter 17 in &quot;Clean Code - A handbook of agile
software craftsmanship.&quot; by Robert C. Martin</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>Rule 20701 in &quot;TRAIN REAL TIME DATA PROTOCOL Coding
Rules&quot; by Armin-Hagen Weiss, Bombardier</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>http://wiki.c2.com/?MagicNumber</i></p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Examples of
magic values:</p>


<p style="margin-left:13%; margin-top: 1em">template&lt;typename
T, size_t N&gt; <br>
struct CustomType { <br>
T arr[N]; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">struct
OtherType { <br>
CustomType&lt;int, 30&gt; container; <br>
} <br>
CustomType&lt;int, 30&gt; values;</p>

<p style="margin-left:13%; margin-top: 1em">double
circleArea = 3.1415926535 * radius * radius;</p>

<p style="margin-left:13%; margin-top: 1em">double
totalCharge = 1.08 * itemPrice;</p>

<p style="margin-left:13%; margin-top: 1em">int getAnswer()
{ <br>
return -3; // FILENOTFOUND <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">for (int mm =
1; mm &lt;= 12; ++mm) { <br>
std::cout &lt;&lt; month[mm] &lt;&lt; '\n'; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Example with
magic values refactored:</p>


<p style="margin-left:13%; margin-top: 1em">template&lt;typename
T, size_t N&gt; <br>
struct CustomType { <br>
T arr[N]; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">const size_t
NUMBER_OF_ELEMENTS = 30; <br>
using containerType = CustomType&lt;int,
NUMBER_OF_ELEMENTS&gt;;</p>

<p style="margin-left:13%; margin-top: 1em">struct
OtherType { <br>
containerType container; <br>
} <br>
containerType values;</p>

<p style="margin-left:13%; margin-top: 1em">double
circleArea = M_PI * radius * radius;</p>

<p style="margin-left:13%; margin-top: 1em">const double
TAX_RATE = 0.08; // or make it variable and read from a
file</p>

<p style="margin-left:13%; margin-top: 1em">double
totalCharge = (1.0 + TAX_RATE) * itemPrice;</p>

<p style="margin-left:13%; margin-top: 1em">int getAnswer()
{ <br>
return E_FILE_NOT_FOUND; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">for (int mm =
1; mm &lt;= MONTHS_IN_A_YEAR; ++mm) { <br>
std::cout &lt;&lt; month[mm] &lt;&lt; '\n'; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">For integral
literals by default only <i>0</i> and <i>1</i> (and
<i>-1</i>) integer values are accepted without a warning.
This can be overridden with the <i>IgnoredIntegerValues</i>
option. Negative values are accepted if their absolute value
is present in the <i>IgnoredIntegerValues</i> list.</p>

<p style="margin-left:9%; margin-top: 1em">As a special
case for integral values, all powers of two can be accepted
without warning by enabling the
<i>IgnorePowersOf2IntegerValues</i> option.</p>

<p style="margin-left:9%; margin-top: 1em">For floating
point literals by default the <i>0.0</i> floating point
value is accepted without a warning. The set of ignored
floating point literals can be configured using the
<i>IgnoredFloatingPointValues</i> option. For each value in
that set, the given string value is converted to a
floating-point value representation used by the target
architecture. If a floating-point literal value compares
equal to one of the converted values, then that literal is
not diagnosed by this check. Because floating-point equality
is used to determine whether to diagnose or not, the user
needs to be aware of the details of floating-point
representations for any values that cannot be precisely
represented for their target architecture.</p>

<p style="margin-left:9%; margin-top: 1em">For each value
in the <i>IgnoredFloatingPointValues</i> set, both the
single-precision form and double-precision form are accepted
(for example, if 3.14 is in the set, neither 3.14f nor 3.14
will produce a warning).</p>

<p style="margin-left:9%; margin-top: 1em">Scientific
notation is supported for both source code input and option.
Alternatively, the check for the floating point numbers can
be disabled for all floating point values by enabling the
<i>IgnoreAllFloatingPointValues</i> option.</p>

<p style="margin-left:9%; margin-top: 1em">Since values
<i>0</i> and <i>0.0</i> are so common as the base counter of
loops, or initialization values for sums, they are always
accepted without warning, even if not present in the
respective ignored values list.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoredIntegerValues</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
magic positive integers that will be accepted without a
warning. Default values are <i>{1, 2, 3, 4}</i>, and
<i>0</i> is accepted unconditionally.</p>


<p style="margin-left:9%;"><b>IgnorePowersOf2IntegerValues</b></p>

<p style="margin-left:18%;">Boolean value indicating
whether to accept all powers-of-two integer values without
warning. Default value is <i>false</i>.</p>


<p style="margin-left:9%;"><b>IgnoredFloatingPointValues</b></p>

<p style="margin-left:18%;">Semicolon-separated list of
magic positive floating point values that will be accepted
without a warning. Default values are <i>{1.0, 100.0}</i>
and <i>0.0</i> is accepted unconditionally.</p>


<p style="margin-left:9%;"><b>IgnoreAllFloatingPointValues</b></p>

<p style="margin-left:18%;">Boolean value indicating
whether to accept all floating point values without warning.
Default value is <i>false</i>.</p>


<p style="margin-left:9%;"><b>IgnoreBitFieldsWidths</b></p>

<p style="margin-left:18%;">Boolean value indicating
whether to accept magic numbers as bit field widths without
warning. This is useful for example for register definitions
which are generated from hardware specifications. Default
value is <i>true</i>.</p>

<p style="margin-left:9%;"><b>IgnoreTypeAliases</b></p>

<p style="margin-left:18%;">Boolean value indicating
whether to accept magic numbers in <b>typedef</b> or
<b>using</b> declarations. Default value is
<i>false</i>.</p>


<p style="margin-left:9%;"><b>IgnoreUserDefinedLiterals</b></p>

<p style="margin-left:18%;">Boolean value indicating
whether to accept magic numbers in user-defined literals.
Default value is <i>false</i>.</p>

<h3>readability-make-member-function-const
<a name="readability-make-member-function-const"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds non-static
member functions that can be made <b>const</b> because the
functions don't use <b>this</b> in a non-const way.</p>

<p style="margin-left:9%; margin-top: 1em">This check tries
to annotate methods according to <i>logical constness</i>
(not physical constness). Therefore, it will suggest to add
a <b>const</b> qualifier to a non-const method only if this
method does something that is already possible though the
public interface on a <b>const</b> pointer to the
object:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="61%">


<p>reading a public member variable</p></td>
<td width="27%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="61%">


<p>calling a public const-qualified member function</p></td>
<td width="27%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="61%">


<p>returning const-qualified <b>this</b></p></td>
<td width="27%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="61%">


<p>passing const-qualified <b>this</b> as a parameter.</p></td>
<td width="27%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">This check will
also suggest to add a <b>const</b> qualifier to a non-const
method if this method uses private data and functions in a
limited number of ways where logical constness and physical
constness coincide:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p style="margin-top: 1em">reading a member variable of
builtin type</p></td>
<td width="36%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Specifically,
this check will not suggest to add a <b>const</b> to a
non-const method if the method reads a private member
variable of pointer type because that allows to modify the
pointee which might not preserve logical constness. For the
same reason, it does not allow to call private member
functions or member functions on private member
variables.</p>

<p style="margin-left:9%; margin-top: 1em">In addition,
this check ignores functions that</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">are declared <b>virtual</b></p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>contain a <b>const_cast</b></p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>are templated or part of a class template</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>have an empty body</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>do not (implicitly) use <b>this</b> at all (see
<i>readability-convert-member-functions-to-static</i>).</p> </td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">The following
real-world examples will be preserved by the check:</p>

<p style="margin-left:13%; margin-top: 1em">class E1 { <br>
Pimpl &amp;getPimpl() const; <br>
public: <br>
int &amp;get() { <br>
// Calling a private member function disables this check.
<br>
return getPimpl()-&gt;i; <br>
} <br>
... <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">class E2 { <br>
public: <br>
const int *get() const; <br>
// const_cast disables this check. <br>
S *get() { <br>
return const_cast&lt;int*&gt;(const_cast&lt;const
C*&gt;(this)-&gt;get()); <br>
} <br>
... <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">After applying
modifications as suggested by the check, running the check
again might find more opportunities to mark member functions
<b>const</b>.</p>

<h3>readability-math-missing-parentheses
<a name="readability-math-missing-parentheses"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check for
missing parentheses in mathematical expressions that involve
operators of different priorities.</p>

<p style="margin-left:9%; margin-top: 1em">Parentheses in
mathematical expressions clarify the order of operations,
especially with different-priority operators. Lengthy or
multiline expressions can obscure this order, leading to
coding errors. IDEs can aid clarity by highlighting
parentheses. Explicitly using parentheses also clarifies
what the developer had in mind when writing the expression.
Ensuring their presence reduces ambiguity and errors,
promoting clearer and more maintainable code.</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">int x = 1 + 2 *
3 - 4 / 5;</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">int x = 1 + (2
* 3) - (4 / 5);</p>

<h3>readability-misleading-indentation
<a name="readability-misleading-indentation"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Correct
indentation helps to understand code. Mismatch of the
syntactical structure and the indentation of the code may
hide serious problems. Missing braces can also make it
significantly harder to read the code, therefore it is
important to use braces.</p>

<p style="margin-left:9%; margin-top: 1em">The way to avoid
dangling else is to always check that an <b>else</b> belongs
to the <b>if</b> that begins in the same column.</p>

<p style="margin-left:9%; margin-top: 1em">You can omit
braces when your inner part of e.g. an <b>if</b> statement
has only one statement in it. Although in that case you
should begin the next statement in the same column with the
<b>if</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">// Dangling
else: <br>
if (cond1) <br>
if (cond2) <br>
foo1(); <br>
else <br>
foo2(); // Wrong indentation: else belongs to if(cond2)
statement.</p>

<p style="margin-left:13%; margin-top: 1em">// Missing
braces: <br>
if (cond1) <br>
foo1(); <br>
foo2(); // Not guarded by if(cond1).</p>

<h3>Limitations
<a name="Limitations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Note that this
check only works as expected when the tabs or spaces are
used consistently and not mixed.</p>

<h3>readability-misplaced-array-index
<a name="readability-misplaced-array-index"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check warns
for unusual array index syntax.</p>

<p style="margin-left:9%; margin-top: 1em">The following
code has unusual array index syntax:</p>

<p style="margin-left:13%; margin-top: 1em">void f(int *X,
int Y) { <br>
Y[X] = 0; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">becomes</p>

<p style="margin-left:13%; margin-top: 1em">void f(int *X,
int Y) { <br>
X[Y] = 0; <br>
}</p>

<p style="margin-left:9%;"><b>The check warns about such
unusual syntax for readability reasons:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>There are programmers that are not familiar with this
unusual syntax.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>It is possible that variables are mixed up.</p></td></tr>
</table>

<h3>readability-named-parameter
<a name="readability-named-parameter"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Find functions
with unnamed arguments.</p>

<p style="margin-left:9%; margin-top: 1em">The check
implements the following rule originating in the Google C++
Style Guide:</p>

<p style="margin-left:9%; margin-top: 1em">-
<i>https://google.github.io/styleguide/cppguide.html#Function_Declarations_and_Definitions</i></p>

<p style="margin-left:9%; margin-top: 1em">All parameters
should have the same name in both the function declaration
and definition. If a parameter is not utilized, its name can
be commented out in a function definition.</p>

<p style="margin-left:13%; margin-top: 1em">int
doingSomething(int a, int b, int c);</p>

<p style="margin-left:13%; margin-top: 1em">int
doingSomething(int a, int b, int /*c*/) { <br>
// Ok: the third param is not used <br>
return a + b; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Corresponding
cpplint.py check name: <i>readability/function</i>.</p>

<h3>readability-non-const-parameter
<a name="readability-non-const-parameter"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The check finds
function parameters of a pointer type that could be changed
to point to a constant type instead.</p>

<p style="margin-left:9%; margin-top: 1em">When
<b>const</b> is used properly, many mistakes can be avoided.
Advantages when using <b>const</b> properly:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p style="margin-top: 1em">prevent unintentional
modification of data;</p></td>
<td width="13%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>get additional warnings such as using uninitialized
data;</p> </td>
<td width="13%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>make it easier for developers to see possible side
effects.</p> </td>
<td width="13%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">This check is
not strict about constness, it only warns when the constness
will make the function interface safer.</p>

<p style="margin-left:13%; margin-top: 1em">// warning
here; the declaration &quot;const char *p&quot; would make
the function <br>
// interface safer. <br>
char f1(char *p) { <br>
return *p; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// no warning;
the declaration could be more const &quot;const int * const
p&quot; but <br>
// that does not make the function interface safer. <br>
int f2(const int *p) { <br>
return *p; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// no warning;
making x const does not make the function interface safer
<br>
int f3(int x) { <br>
return x; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// no warning;
Technically, *p can be const (&quot;const struct S
*p&quot;). But making <br>
// *p const could be misleading. People might think that
it's safe to pass <br>
// const data to this function. <br>
struct S { int *a; int *b; }; <br>
int f3(struct S *p) { <br>
*(p-&gt;a) = 0; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// no warning;
p is referenced by an lvalue. <br>
void f4(int *p) { <br>
int &amp;x = *p; <br>
}</p>

<h3>readability-operators-representation
<a name="readability-operators-representation"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Enforces
consistent token representation for invoked binary, unary
and overloaded operators in C++ code. The check supports
both traditional and alternative representations of
operators, such as <b>&amp;&amp;</b> and <b>and</b>,
<b>||</b> and <b>or</b>, and so on.</p>

<p style="margin-left:9%; margin-top: 1em">In the realm of
C++ programming, developers have the option to choose
between two distinct representations for operators:
traditional token representation and alternative token
representation. Traditional tokens utilize symbols, such as
<b>&amp;&amp;</b>, <b>||</b>, and <b>!</b>, while
alternative tokens employ more descriptive words like
<b>and</b>, <b>or</b>, and <b>not</b>.</p>

<p style="margin-left:9%; margin-top: 1em">In the following
mapping table, a comprehensive list of traditional and
alternative tokens, along with their corresponding
representations, is presented:</p>

<h3>Token Representation Mapping Table
<a name="Token Representation Mapping Table"></a>
</h3>


<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">// Traditional
Token Representation:</p>

<p style="margin-left:13%; margin-top: 1em">if (!a||!b)
<br>
{ <br>
// do something <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// Alternative
Token Representation:</p>

<p style="margin-left:13%; margin-top: 1em">if (not a or
not b) <br>
{ <br>
// do something <br>
}</p>

<h3>Options
<a name="Options"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Due to the
distinct benefits and drawbacks of each representation, the
default configuration doesn't enforce either. Explicit
configuration is needed.</p>

<p style="margin-left:9%; margin-top: 1em">To configure
check to enforce Traditional Token Representation for all
operators set options to
<i>&amp;&amp;;&amp;=;&amp;;|;&#732;;!;!=;||;|=;&#710;;&#710;=</i>.</p>

<p style="margin-left:9%; margin-top: 1em">To configure
check to enforce Alternative Token Representation for all
operators set options to
<i>and;and_eq;bitand;bitor;compl;not;not_eq;or;or_eq;xor;xor_eq</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Developers do
not need to enforce all operators, and can mix the
representations as desired by specifying a
semicolon-separated list of both traditional and alternative
tokens in the configuration, such as <i>and;||;not</i>.
<b><br>
BinaryOperators</b></p>

<p style="margin-left:18%;">This option allows you to
specify a semicolon-separated list of binary operators for
which you want to enforce specific token representation. The
default value is empty string.</p>

<p style="margin-left:9%;"><b>OverloadedOperators</b></p>

<p style="margin-left:18%;">This option allows you to
specify a semicolon-separated list of overloaded operators
for which you want to enforce specific token representation.
The default value is empty string.</p>

<h3>readability-qualified-auto
<a name="readability-qualified-auto"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Adds pointer
qualifications to <b>auto</b>-typed variables that are
deduced to pointers.</p>

<p style="margin-left:9%; margin-top: 1em"><i>LLVM Coding
Standards</i> advises to make it obvious if a <b>auto</b>
typed variable is a pointer. This check will transform
<b>auto</b> to <b>auto *</b> when the type is deduced to be
a pointer.</p>

<p style="margin-left:13%; margin-top: 1em">for (auto Data
: MutatablePtrContainer) { <br>
change(*Data); <br>
} <br>
for (auto Data : ConstantPtrContainer) { <br>
observe(*Data); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Would be
transformed into:</p>

<p style="margin-left:13%; margin-top: 1em">for (auto *Data
: MutatablePtrContainer) { <br>
change(*Data); <br>
} <br>
for (const auto *Data : ConstantPtrContainer) { <br>
observe(*Data); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Note <b>const
volatile</b> qualified types will retain their <b>const</b>
and <b>volatile</b> qualifiers. Pointers to pointers will
not be fully qualified.</p>

<p style="margin-left:13%; margin-top: 1em">const auto Foo
= cast&lt;int *&gt;(Baz1); <br>
const auto Bar = cast&lt;const int *&gt;(Baz2); <br>
volatile auto FooBar = cast&lt;int *&gt;(Baz3); <br>
auto BarFoo = cast&lt;int **&gt;(Baz4);</p>

<p style="margin-left:9%; margin-top: 1em">Would be
transformed into:</p>

<p style="margin-left:13%; margin-top: 1em">auto *const Foo
= cast&lt;int *&gt;(Baz1); <br>
const auto *const Bar = cast&lt;const int *&gt;(Baz2); <br>
auto *volatile FooBar = cast&lt;int *&gt;(Baz3); <br>
auto *BarFoo = cast&lt;int **&gt;(Baz4);</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>AddConstToQualified</b></p>

<p style="margin-left:18%;">When set to <i>true</i> the
check will add const qualifiers variables defined as <b>auto
*</b> or <b>auto &amp;</b> when applicable. Default value is
<i>true</i>.</p>

<p style="margin-left:13%; margin-top: 1em">auto Foo1 =
cast&lt;const int *&gt;(Bar1); <br>
auto *Foo2 = cast&lt;const int *&gt;(Bar2); <br>
auto &amp;Foo3 = cast&lt;const int &amp;&gt;(Bar3);</p>

<p style="margin-left:9%; margin-top: 1em">If
AddConstToQualified is set to <i>false</i>, it will be
transformed into:</p>

<p style="margin-left:13%; margin-top: 1em">const auto
*Foo1 = cast&lt;const int *&gt;(Bar1); <br>
auto *Foo2 = cast&lt;const int *&gt;(Bar2); <br>
auto &amp;Foo3 = cast&lt;const int &amp;&gt;(Bar3);</p>

<p style="margin-left:9%; margin-top: 1em">Otherwise it
will be transformed into:</p>

<p style="margin-left:13%; margin-top: 1em">const auto
*Foo1 = cast&lt;const int *&gt;(Bar1); <br>
const auto *Foo2 = cast&lt;const int *&gt;(Bar2); <br>
const auto &amp;Foo3 = cast&lt;const int
&amp;&gt;(Bar3);</p>

<p style="margin-left:9%; margin-top: 1em">Note in the LLVM
alias, the default value is <i>false</i>.</p>

<h3>readability-redundant-access-specifiers
<a name="readability-redundant-access-specifiers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds classes,
structs, and unions containing redundant member (field and
method) access specifiers.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
public: <br>
int x; <br>
int y; <br>
public: <br>
int z; <br>
protected: <br>
int a; <br>
public: <br>
int c; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In the example
above, the second <b>public</b> declaration can be removed
without any changes of behavior.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>CheckFirstDeclaration</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, the
check will also diagnose if the first access specifier
declaration is redundant (e.g. <b>private</b> inside
<b>class</b>, or <b>public</b> inside <b>struct</b> or
<b>union</b>). Default is <i>false</i>.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">struct Bar {
<br>
public: <br>
int x; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">If
<i>CheckFirstDeclaration</i> option is enabled, a warning
about redundant access specifier will be emitted, because
<b>public</b> is the default member access for structs.</p>

<h3>readability-redundant-casting
<a name="readability-redundant-casting"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects explicit
type casting operations that involve the same source and
destination types, and subsequently recommend their removal.
Covers a range of explicit casting operations, including
<b>static_cast</b>, <b>const_cast</b>, C-style casts, and
<b>reinterpret_cast</b>. Its primary objective is to enhance
code readability and maintainability by eliminating
unnecessary type casting.</p>

<p style="margin-left:13%; margin-top: 1em">int value = 42;
<br>
int result = static_cast&lt;int&gt;(value);</p>

<p style="margin-left:9%; margin-top: 1em">In this example,
the <b>static_cast&lt;int&gt;(value)</b> is redundant, as it
performs a cast from an <b>int</b> to another
<b>int</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Casting
operations involving constructor conversions, user-defined
conversions, functional casts, type-dependent casts, casts
between distinct type aliases that refer to the same
underlying type, as well as bitfield-related casts and casts
directly from lvalue to rvalue, are all disregarded by the
check.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, the
check will not give warnings inside macros. Default is
<i>true</i>.</p>

<p style="margin-left:9%;"><b>IgnoreTypeAliases</b></p>

<p style="margin-left:18%;">When set to <i>false</i>, the
check will consider type aliases, and when set to
<i>true</i>, it will resolve all type aliases and operate on
the underlying types. Default is <i>false</i>.</p>

<h3>readability-redundant-control-flow
<a name="readability-redundant-control-flow"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check looks
for procedures (functions returning no value) with
<b>return</b> statements at the end of the function. Such
<b>return</b> statements are redundant.</p>

<p style="margin-left:9%; margin-top: 1em">Loop statements
(<b>for</b>, <b>while</b>, <b>do while</b>) are checked for
redundant <b>continue</b> statements at the end of the loop
body.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:9%; margin-top: 1em">The following
function <i>f</i> contains a redundant <b>return</b>
statement:</p>

<p style="margin-left:13%; margin-top: 1em">extern void
g(); <br>
void f() { <br>
g(); <br>
return; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">becomes</p>

<p style="margin-left:13%; margin-top: 1em">extern void
g(); <br>
void f() { <br>
g(); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The following
function <i>k</i> contains a redundant <b>continue</b>
statement:</p>

<p style="margin-left:13%; margin-top: 1em">void k() { <br>
for (int i = 0; i &lt; 10; ++i) { <br>
continue; <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">becomes</p>

<p style="margin-left:13%; margin-top: 1em">void k() { <br>
for (int i = 0; i &lt; 10; ++i) { <br>
} <br>
}</p>

<h3>readability-redundant-declaration
<a name="readability-redundant-declaration"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds redundant
variable and function declarations.</p>

<p style="margin-left:13%; margin-top: 1em">extern int X;
<br>
extern int X;</p>

<p style="margin-left:9%; margin-top: 1em">becomes</p>

<p style="margin-left:13%; margin-top: 1em">extern int
X;</p>

<p style="margin-left:9%; margin-top: 1em">Such redundant
declarations can be removed without changing program
behavior. They can for instance be unintentional left overs
from previous refactorings when code has been moved around.
Having redundant declarations could in worst case mean that
there are typos in the code that cause bugs.</p>

<p style="margin-left:9%; margin-top: 1em">Normally the
code can be automatically fixed, <b>clang-tidy</b> can
remove the second declaration. However there are 2 cases
when you need to fix the code manually:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="66%">


<p>When the declarations are in different header files;</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="66%">


<p>When multiple variables are declared together.</p></td>
<td width="22%">
</td></tr>
</table>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, the
check will not give warnings inside macros. Default is
<i>true</i>.</p>

<h3>readability-redundant-function-ptr-dereference
<a name="readability-redundant-function-ptr-dereference"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds redundant
dereferences of a function pointer.</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">int f(int,int);
<br>
int (*p)(int, int) = &amp;f;</p>

<p style="margin-left:13%; margin-top: 1em">int i =
(**p)(10, 50);</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">int f(int,int);
<br>
int (*p)(int, int) = &amp;f;</p>

<p style="margin-left:13%; margin-top: 1em">int i =
(*p)(10, 50);</p>

<h3>readability-redundant-inline-specifier
<a name="readability-redundant-inline-specifier"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects
redundant <b>inline</b> specifiers on function and variable
declarations.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">constexpr
inline void f() {}</p>

<p style="margin-left:9%; margin-top: 1em">In the example
above the keyword <b>inline</b> is redundant since constexpr
functions are implicitly inlined</p>

<p style="margin-left:13%; margin-top: 1em">class MyClass {
<br>
inline void myMethod() {} <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">In the example
above the keyword <b>inline</b> is redundant since member
functions defined entirely inside a class/struct/union
definition are implicitly inlined.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>StrictMode</b></p>

<p style="margin-left:18%;">If set to <i>true</i>, the
check will also flag functions and variables that already
have internal linkage as redundant.</p>

<h3>readability-redundant-member-init
<a name="readability-redundant-member-init"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds member
initializations that are unnecessary because the same
default constructor would be called if they were not
present.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">// Explicitly
initializing the member s and v is unnecessary. <br>
class Foo { <br>
public: <br>
Foo() : s() {}</p>

<p style="margin-left:13%; margin-top: 1em">private: <br>
std::string s; <br>
std::vector&lt;int&gt; v {}; <br>
};</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreBaseInCopyConstructors</b></p>

<p style="margin-left:18%;">Default is <i>false</i>.</p>

<p style="margin-left:18%; margin-top: 1em">When
<i>true</i>, the check will ignore unnecessary base class
initializations within copy constructors, since some
compilers issue warnings/errors when base classes are not
explicitly initialized in copy constructors. For example,
<b>gcc</b> with <b>-Wextra</b> or <b>-Werror=extra</b>
issues warning or error <b>base class 'Bar' should be
explicitly initialized in the copy constructor</b> if
<b>Bar()</b> were removed in the following example:</p>

<p style="margin-left:13%; margin-top: 1em">// Explicitly
initializing member s and base class Bar is unnecessary.
<br>
struct Foo : public Bar { <br>
// Remove s() below. If IgnoreBaseInCopyConstructors!=0,
keep Bar(). <br>
Foo(const Foo&amp; foo) : Bar(), s() {} <br>
std::string s; <br>
};</p>

<h3>readability-redundant-preprocessor
<a name="readability-redundant-preprocessor"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
potentially redundant preprocessor directives. At the moment
the following cases are detected:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p><i>#ifdef</i> .. <i>#endif</i> pairs which are nested
inside an outer pair with the same condition. For
example:</p> </td></tr>
</table>

<p style="margin-left:13%; margin-top: 1em">#ifdef FOO <br>
#ifdef FOO // inner ifdef is considered redundant <br>
void f(); <br>
#endif <br>
#endif</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="59%">


<p style="margin-top: 1em">Same for <i>#ifndef</i> ..
<i>#endif</i> pairs. For example:</p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:13%; margin-top: 1em">#ifndef FOO
<br>
#ifndef FOO // inner ifndef is considered redundant <br>
void f(); <br>
#endif <br>
#endif</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="62%">


<p style="margin-top: 1em"><i>#ifndef</i> inside an
<i>#ifdef</i> with the same condition:</p></td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:13%; margin-top: 1em">#ifdef FOO <br>
#ifndef FOO // inner ifndef is considered redundant <br>
void f(); <br>
#endif <br>
#endif</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="62%">


<p style="margin-top: 1em"><i>#ifdef</i> inside an
<i>#ifndef</i> with the same condition:</p></td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:13%; margin-top: 1em">#ifndef FOO
<br>
#ifdef FOO // inner ifdef is considered redundant <br>
void f(); <br>
#endif <br>
#endif</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em"><i>#if</i> .. <i>#endif</i>
pairs which are nested inside an outer pair with the same
condition. For example:</p></td></tr>
</table>

<p style="margin-left:13%; margin-top: 1em">#define FOO 4
<br>
#if FOO == 4 <br>
#if FOO == 4 // inner if is considered redundant <br>
void f(); <br>
#endif <br>
#endif</p>

<h3>readability-redundant-smartptr-get
<a name="readability-redundant-smartptr-get"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Find and remove
redundant calls to smart pointer's <b>.get()</b> method.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>


<p style="margin-left:13%; margin-top: 1em">ptr.get()-&gt;Foo()
==&gt; ptr-&gt;Foo() <br>
*ptr.get() ==&gt; *ptr <br>
*ptr-&gt;get() ==&gt; **ptr <br>
if (ptr.get() == nullptr) ... =&gt; if (ptr == nullptr)
...</p>

<p style="margin-left:9%;"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">If this option is set to
<i>true</i> (default is <i>true</i>), the check will not
warn about calls inside macros.</p>

<h3>readability-redundant-string-cstr
<a name="readability-redundant-string-cstr"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
unnecessary calls to <b>std::string::c_str()</b> and
<b>std::string::data()</b>.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>StringParameterFunctions</b></p>

<p style="margin-left:18%;">A semicolon-separated list of
(fully qualified) function/method/operator names, with the
requirement that any parameter currently accepting a
<b>const char*</b> input should also be able to accept
<b>std::string</b> inputs, or proper overload candidates
that can do so should exist. This can be used to configure
functions such as <b>fmt::format</b>,
<b>spdlog::logger::info</b>, or wrappers around these and
similar functions. The default value is the empty
string.</p>

<h3>readability-redundant-string-init
<a name="readability-redundant-string-init"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
unnecessary string initializations.</p>

<h3>Examples
<a name="Examples"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">// Initializing
string with empty string literal is unnecessary. <br>
std::string a = &quot;&quot;; <br>
std::string b(&quot;&quot;);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>

<p style="margin-left:13%; margin-top: 1em">std::string a;
<br>
std::string b;</p>

<p style="margin-left:13%; margin-top: 1em">// Initializing
a string_view with an empty string literal produces an <br>
// instance that compares equal to string_view(). <br>
std::string_view a = &quot;&quot;; <br>
std::string_view b(&quot;&quot;);</p>

<p style="margin-left:13%; margin-top: 1em">// becomes <br>
std::string_view a; <br>
std::string_view b;</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>StringNames</b></p>

<p style="margin-left:18%;">Default is
<i>::std::basic_string;::std::basic_string_view</i>.</p>


<p style="margin-left:18%; margin-top: 1em">Semicolon-delimited
list of class names to apply this check to. By default
<i>::std::basic_string</i> applies to <b>std::string</b> and
<b>std::wstring</b>. Set to e.g.
<i>::std::basic_string;llvm::StringRef;QString</i> to
perform this check on custom classes.</p>

<h3>readability-reference-to-constructed-temporary
<a name="readability-reference-to-constructed-temporary"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Detects C++ code
where a reference variable is used to extend the lifetime of
a temporary object that has just been constructed.</p>

<p style="margin-left:9%; margin-top: 1em">This
construction is often the result of multiple code
refactorings or a lack of developer knowledge, leading to
confusion or subtle bugs. In most cases, what the developer
really wanted to do is create a new variable rather than
extending the lifetime of a temporary object.</p>

<p style="margin-left:9%; margin-top: 1em">Examples of
problematic code include:</p>

<p style="margin-left:13%; margin-top: 1em">const
std::string&amp; str(&quot;hello&quot;);</p>

<p style="margin-left:13%; margin-top: 1em">struct Point {
int x; int y; }; <br>
const Point&amp; p = { 1, 2 };</p>

<p style="margin-left:9%; margin-top: 1em">In the first
example, a <b>const std::string&amp;</b> reference variable
<b>str</b> is assigned a temporary object created by the
<b>std::string(&quot;hello&quot;)</b> constructor. In the
second example, a <b>const Point&amp;</b> reference variable
<b>p</b> is assigned an object that is constructed from an
initializer list <b>{ 1, 2 }</b>. Both of these examples
extend the lifetime of the temporary object to the lifetime
of the reference variable, which can make it difficult to
reason about and may lead to subtle bugs or
misunderstanding.</p>

<p style="margin-left:9%; margin-top: 1em">To avoid these
issues, it is recommended to change the reference variable
to a (<b>const</b>) value variable.</p>

<h3>readability-simplify-boolean-expr
<a name="readability-simplify-boolean-expr"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Looks for
boolean expressions involving boolean constants and
simplifies them to use the appropriate boolean expression
directly. Simplifies boolean expressions by application of
DeMorgan's Theorem.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:
<b><br>
The resulting expression e is modified as follows:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="78%">


<p>Unnecessary parentheses around the expression are
removed.</p> </td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="78%">


<p>Negated applications of <b>!</b> are eliminated.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="78%">


<p>Negated applications of comparison operators are changed
to use the opposite condition.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p>4.</p></td>
<td width="1%"></td>
<td width="78%">


<p>Implicit conversions of pointers, including pointers to
members, to <b>bool</b> are replaced with explicit
comparisons to <b>nullptr</b> in C++11 or <b>NULL</b> in
C++98/03.</p> </td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p>5.</p></td>
<td width="1%"></td>
<td width="78%">


<p>Implicit casts to <b>bool</b> are replaced with explicit
casts to <b>bool</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p>6.</p></td>
<td width="1%"></td>
<td width="78%">


<p>Object expressions with <b>explicit operator bool</b>
conversion operators are replaced with explicit casts to
<b>bool</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p>7.</p></td>
<td width="1%"></td>
<td width="78%">


<p>Implicit conversions of integral types to <b>bool</b>
are replaced with explicit comparisons to <b>0</b>.</p></td></tr>
</table>

<p style="margin-left:9%;"><b>Examples:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="78%">


<p>The ternary assignment <b>bool b = (i &lt; 0) ? true :
false;</b> has redundant parentheses and becomes <b>bool b =
i &lt; 0;</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="78%">


<p>The conditional return <b>if (!b) return false; return
true;</b> has an implied double negation and becomes
<b>return b;</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="78%">


<p>The conditional return <b>if (i &lt; 0) return false;
return true;</b> becomes <b>return i &gt;= 0;</b>.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">The conditional
return <b>if (i != 0) return false; return true;</b> becomes
<b>return i == 0;</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p style="margin-top: 1em">4.</p></td>
<td width="1%"></td>
<td width="78%">


<p style="margin-top: 1em">The conditional return <b>if (p)
return true; return false;</b> has an implicit conversion of
a pointer to <b>bool</b> and becomes <b>return p !=
nullptr;</b>.</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">The ternary
assignment <b>bool b = (i &amp; 1) ? true : false;</b> has
an implicit conversion of <b>i &amp; 1</b> to <b>bool</b>
and becomes <b>bool b = (i &amp; 1) != 0;</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p style="margin-top: 1em">5.</p></td>
<td width="1%"></td>
<td width="78%">


<p style="margin-top: 1em">The conditional return <b>if (i
&amp; 1) return true; else return false;</b> has an implicit
conversion of an integer quantity <b>i &amp; 1</b> to
<b>bool</b> and becomes <b>return (i &amp; 1) != 0;</b></p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p>6.</p></td>
<td width="1%"></td>
<td width="78%">


<p>Given <b>struct X { explicit operator bool(); };</b>,
and an instance <b>x</b> of <b>struct X</b>, the conditional
return <b>if (x) return true; return false;</b> becomes
<b>return static_cast&lt;bool&gt;(x);</b></p></td></tr>
</table>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">If <i>true</i>, ignore boolean
expressions originating from expanded macros. Default is
<i>false</i>.</p>


<p style="margin-left:9%;"><b>ChainedConditionalReturn</b></p>

<p style="margin-left:18%;">If <i>true</i>, conditional
boolean return statements at the end of an <b>if/else if</b>
chain will be transformed. Default is <i>false</i>.</p>


<p style="margin-left:9%;"><b>ChainedConditionalAssignment</b></p>

<p style="margin-left:18%;">If <i>true</i>, conditional
boolean assignments at the end of an <b>if/else if</b> chain
will be transformed. Default is <i>false</i>.</p>

<p style="margin-left:9%;"><b>SimplifyDeMorgan</b></p>

<p style="margin-left:18%;">If <i>true</i>, DeMorgan's
Theorem will be applied to simplify negated conjunctions and
disjunctions. Default is <i>true</i>.</p>


<p style="margin-left:9%;"><b>SimplifyDeMorganRelaxed</b></p>

<p style="margin-left:18%;">If <i>true</i>,
<i>SimplifyDeMorgan</i> will also transform negated
conjunctions and disjunctions where there is no negation on
either operand. This option has no effect if
<i>SimplifyDeMorgan</i> is <i>false</i>. Default is
<i>false</i>.</p>

<p style="margin-left:18%; margin-top: 1em">When
Enabled:</p>

<p style="margin-left:22%; margin-top: 1em">bool X = !(A
&amp;&amp; B) <br>
bool Y = !(A || B)</p>

<p style="margin-left:18%; margin-top: 1em">Would be
transformed to:</p>

<p style="margin-left:22%; margin-top: 1em">bool X = !A ||
!B <br>
bool Y = !A &amp;&amp; !B</p>

<h3>readability-simplify-subscript-expr
<a name="readability-simplify-subscript-expr"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This check
simplifies subscript expressions. Currently this covers
calling <b>.data()</b> and immediately doing an array
subscript operation to obtain a single element, in which
case simply calling <b>operator[]</b> suffice.</p>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:13%; margin-top: 1em">std::string s =
...; <br>
char c = s.data()[i]; // char c = s[i];</p>

<h3>Options
<a name="Options"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>Types</b></p></td>
<td width="3%"></td>
<td width="82%">


<p style="margin-top: 1em">The list of type(s) that
triggers this check. Default is
<i>::std::basic_string;::std::basic_string_view;::std::vector;::std::array;::std::span</i></p> </td></tr>
</table>

<h3>readability-static-accessed-through-instance
<a name="readability-static-accessed-through-instance"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Checks for
member expressions that access static members through
instances, and replaces them with uses of the appropriate
qualified-id.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:9%; margin-top: 1em">The following
code:</p>

<p style="margin-left:13%; margin-top: 1em">struct C { <br>
static void foo(); <br>
static int x; <br>
enum { E1 }; <br>
enum E { E2 }; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">C *c1 = new
C(); <br>
c1-&gt;foo(); <br>
c1-&gt;x; <br>
c1-&gt;E1; <br>
c1-&gt;E2;</p>

<p style="margin-left:9%; margin-top: 1em">is changed
to:</p>

<p style="margin-left:13%; margin-top: 1em">C *c1 = new
C(); <br>
C::foo(); <br>
C::x; <br>
C::E1; <br>
C::E2;</p>

<p style="margin-left:9%; margin-top: 1em">The <i>--fix</i>
commandline option provides default support for safe fixes,
whereas <i>--fix-notes</i> enables fixes that may replace
expressions with side effects, potentially altering the
program's behavior.</p>

<h3>readability-static-definition-in-anonymous-namespace
<a name="readability-static-definition-in-anonymous-namespace"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds static
function and variable definitions in anonymous
namespace.</p>

<p style="margin-left:9%; margin-top: 1em">In this case,
<b>static</b> is redundant, because anonymous namespace
limits the visibility of definitions to a single translation
unit.</p>

<p style="margin-left:13%; margin-top: 1em">namespace {
<br>
static int a = 1; // Warning. <br>
static const int b = 1; // Warning. <br>
namespace inner { <br>
static int c = 1; // Warning. <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The check will
apply a fix by removing the redundant <b>static</b>
qualifier.</p>

<h3>readability-string-compare
<a name="readability-string-compare"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds string
comparisons using the compare method.</p>

<p style="margin-left:9%; margin-top: 1em">A common mistake
is to use the string's <b>compare</b> method instead of
using the equality or inequality operators. The compare
method is intended for sorting functions and thus returns a
negative number, a positive number or zero depending on the
lexicographical relationship between the strings compared.
If an equality or inequality check can suffice, that is
recommended. This is recommended to avoid the risk of
incorrect interpretation of the return value and to simplify
the code. The string equality and inequality operators can
also be faster than the <b>compare</b> method due to early
termination.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">// The same
rules apply to std::string_view. <br>
std::string str1{&quot;a&quot;}; <br>
std::string str2{&quot;b&quot;};</p>

<p style="margin-left:13%; margin-top: 1em">// use str1 !=
str2 instead. <br>
if (str1.compare(str2)) { <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// use str1 ==
str2 instead. <br>
if (!str1.compare(str2)) { <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// use str1 ==
str2 instead. <br>
if (str1.compare(str2) == 0) { <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// use str1 !=
str2 instead. <br>
if (str1.compare(str2) != 0) { <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// use str1 ==
str2 instead. <br>
if (0 == str1.compare(str2)) { <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// use str1 !=
str2 instead. <br>
if (0 != str1.compare(str2)) { <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// Use str1 ==
&quot;foo&quot; instead. <br>
if (str1.compare(&quot;foo&quot;) == 0) { <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The above code
examples show the list of if-statements that this check will
give a warning for. All of them use <b>compare</b> to check
equality or inequality of two strings instead of using the
correct operators.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>StringLikeClasses</b></p>

<p style="margin-left:18%;">A string containing
semicolon-separated names of string-like classes. By default
contains only <b>::std::basic_string</b> and
<b>::std::basic_string_view</b>. If a class from this list
has a <b>compare</b> method similar to that of
<b>std::string</b>, it will be checked in the same way.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:13%; margin-top: 1em">struct
CustomString { <br>
public: <br>
int compare (const CustomString&amp; other) const; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">CustomString
str1; <br>
CustomString str2;</p>

<p style="margin-left:13%; margin-top: 1em">// use str1 !=
str2 instead. <br>
if (str1.compare(str2)) { <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">If
<i>StringLikeClasses</i> contains <b>CustomString</b>, the
check will suggest replacing <b>compare</b> with equality
operator.</p>

<h3>readability-suspicious-call-argument
<a name="readability-suspicious-call-argument"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds function
calls where the arguments passed are provided out of order,
based on the difference between the argument name and the
parameter names of the function.</p>

<p style="margin-left:9%; margin-top: 1em">Given a function
call <b>f(foo, bar);</b> and a function signature <b>void
f(T tvar, U uvar)</b>, the arguments <b>foo</b> and
<b>bar</b> are swapped if <b>foo</b> (the argument name) is
more similar to <b>uvar</b> (the other parameter) than
<b>tvar</b> (the parameter it is currently passed to) <b>and
bar</b> is more similar to <b>tvar</b> than <b>uvar</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Warnings might
indicate either that the arguments are swapped, or that the
names' cross-similarity might hinder code comprehension.</p>

<h3>Heuristics
<a name="Heuristics"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The following
heuristics are implemented in the check. If <b>any</b> of
the enabled heuristics deem the arguments to be provided out
of order, a warning will be issued.</p>

<p style="margin-left:9%; margin-top: 1em">The heuristics
themselves are implemented by considering pairs of strings,
and are symmetric, so in the following there is no
distinction on which string is the argument name and which
string is the parameter name.</p>

<h3>Equality
<a name="Equality"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The most trivial
heuristic, which compares the two strings for
case-insensitive equality.</p>

<h3>Abbreviation
<a name="Abbreviation"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Common
abbreviations can be specified which will deem the strings
similar if the abbreviated and the abbreviation stand
together. For example, if <b>src</b> is registered as an
abbreviation for <b>source</b>, then the following code
example will be warned about.</p>

<p style="margin-left:13%; margin-top: 1em">void foo(int
source, int x);</p>

<p style="margin-left:13%; margin-top: 1em">foo(b,
src);</p>

<p style="margin-left:9%; margin-top: 1em">The
abbreviations to recognise can be configured with the
<i>Abbreviations</i> check option. This heuristic is
case-insensitive.</p>

<h3>Prefix
<a name="Prefix"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>prefix</i> heuristic reports if one of the strings is a
sufficiently long prefix of the other string, e.g.
<b>target</b> to <b>targetPtr</b>. The similarity percentage
is the length ratio of the prefix to the longer string, in
the previous example, it would be <i>6 / 9 =
66.66...</i>%.</p>

<p style="margin-left:9%; margin-top: 1em">This heuristic
can be configured with <i>bounds</i>. The default bounds
are: below <i>25</i>% dissimilar and above <i>30</i>%
similar. This heuristic is case-insensitive.</p>

<h3>Suffix
<a name="Suffix"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Analogous to the
<i>Prefix</i> heuristic. In the case of <b>oldValue</b> and
<b>value</b> compared, the similarity percentage is <i>8 / 5
= 62.5</i>%.</p>

<p style="margin-left:9%; margin-top: 1em">This heuristic
can be configured with <i>bounds</i>. The default bounds
are: below <i>25</i>% dissimilar and above <i>30</i>%
similar. This heuristic is case-insensitive.</p>

<h3>Substring
<a name="Substring"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The substring
heuristic combines the prefix and the suffix heuristic, and
tries to find the <i>longest common substring</i> in the two
strings provided. The similarity percentage is the ratio of
the found longest common substring against the <i>longer</i>
of the two input strings. For example, given <b>val</b> and
<b>rvalue</b>, the similarity is <i>3 / 6 = 50</i>%. If no
characters are common in the two string, <i>0</i>%.</p>

<p style="margin-left:9%; margin-top: 1em">This heuristic
can be configured with <i>bounds</i>. The default bounds
are: below <i>40</i>% dissimilar and above <i>50</i>%
similar. This heuristic is case-insensitive.</p>

<h3>Levenshtein distance (as Levenshtein)
<a name="Levenshtein distance (as Levenshtein)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>Levenshtein distance</i> describes how many
single-character changes (additions, changes, or removals)
must be applied to transform one string into another.</p>

<p style="margin-left:9%; margin-top: 1em">The Levenshtein
distance is translated into a similarity percentage by
dividing it with the length of the <i>longer</i> string, and
taking its complement with regards to <i>100</i>%. For
example, given <b>something</b> and <b>anything</b>, the
distance is <i>4</i> edits, and the similarity percentage is
<i>100</i>% <i>- 4 / 9 = 55.55...</i>%.</p>

<p style="margin-left:9%; margin-top: 1em">This heuristic
can be configured with <i>bounds</i>. The default bounds
are: below <i>50</i>% dissimilar and above <i>66</i>%
similar. This heuristic is case-sensitive.</p>

<h3>Jaro--Winkler distance (as JaroWinkler)
<a name="Jaro--Winkler distance (as JaroWinkler)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>Jaro--Winkler distance</i> is an edit distance like the
Levenshtein distance. It is calculated from the amount of
common characters that are sufficiently close to each other
in position, and to-be-changed characters. The original
definition of Jaro has been extended by Winkler to weigh
prefix similarities more. The similarity percentage is
expressed as an average of the common and non-common
characters against the length of both strings.</p>

<p style="margin-left:9%; margin-top: 1em">This heuristic
can be configured with <i>bounds</i>. The default bounds
are: below <i>75</i>% dissimilar and above <i>85</i>%
similar. This heuristic is case-insensitive.</p>

<h3>S&oslash;rensen--Dice coefficient (as Dice)
<a name="S&oslash;rensen--Dice coefficient (as Dice)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>S&oslash;rensen--Dice coefficient</i> was originally
defined to measure the similarity of two sets. Formally, the
coefficient is calculated by dividing <i>2 *
#(intersection)</i> with <i>#(set1) + #(set2)</i>, where
<i>#()</i> is the cardinality function of sets. This metric
is applied to strings by creating bigrams (substring
sequences of length 2) of the two strings and using the set
of bigrams for the two strings as the two sets.</p>

<p style="margin-left:9%; margin-top: 1em">This heuristic
can be configured with <i>bounds</i>. The default bounds
are: below <i>60</i>% dissimilar and above <i>70</i>%
similar. This heuristic is case-insensitive.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>MinimumIdentifierNameLength</b></p>

<p style="margin-left:18%;">Sets the minimum required
length the argument and parameter names need to have. Names
shorter than this length will be ignored. Defaults to
<i>3</i>.</p>

<p style="margin-left:9%;"><b>Abbreviations</b></p>

<p style="margin-left:18%;">For the <b>Abbreviation</b>
heuristic (<i>see here</i>), this option configures the
abbreviations in the
<i>&quot;abbreviation=abbreviated_value&quot;</i> format.
The option is a string, with each value joined by
<i>&quot;;&quot;</i>.</p>

<p style="margin-left:18%; margin-top: 1em">By default, the
following abbreviations are set:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>addr=address</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>arr=array</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>attr=attribute</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>buf=buffer</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>cl=client</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>cnt=count</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>col=column</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>cpy=copy</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>dest=destination</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>dist=distance</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>dst=distance</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>elem=element</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>hght=height</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>i=index</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>idx=index</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>len=length</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>ln=line</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>lst=list</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>nr=number</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>num=number</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>pos=position</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>ptr=pointer</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>ref=reference</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>src=source</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>srv=server</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>stmt=statement</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>str=string</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>val=value</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>var=variable</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>vec=vector</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="21%">


<p><i>wdth=width</i></p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">The
configuration options for each implemented heuristic (see
above) is constructed dynamically. In the following,
<i>&lt;HeuristicName&gt;</i> refers to one of the keys from
the heuristics implemented. <b><br>
&lt;HeuristicName&gt;</b></p>

<p style="margin-left:18%;"><i>True</i> or <i>False</i>,
whether a particular heuristic, such as <i>Equality</i> or
<i>Levenshtein</i> is enabled.</p>

<p style="margin-left:18%; margin-top: 1em">Defaults to
<i>True</i> for every heuristic.</p>


<p style="margin-left:9%;"><b>&lt;HeuristicName&gt;DissimilarBelow,
&lt;HeuristicName&gt;SimilarAbove</b></p>

<p style="margin-left:18%;">A value between <i>0</i> and
<i>100</i>, expressing a percentage. The bounds set what
percentage of similarity the heuristic must deduce for the
two identifiers to be considered similar or dissimilar by
the check.</p>

<p style="margin-left:18%; margin-top: 1em">Given arguments
<b>arg1</b> and <b>arg2</b> passed to <b>param1</b> and
<b>param2</b>, respectively, the bounds check is performed
in the following way: If the similarity of the currently
passed argument order (<b>arg1</b> to <b>param1</b>) is
<b>below</b> the <i>DissimilarBelow</i> threshold, and the
similarity of the suggested swapped order (<b>arg1</b> to
<b>param2</b>) is <b>above</b> the <i>SimilarAbove</i>
threshold, the swap is reported.</p>

<p style="margin-left:18%; margin-top: 1em">For the
defaults of each heuristic, <i>see above</i>.</p>

<h3>Name synthesis
<a name="Name synthesis"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">When comparing
the argument names and parameter names, the following logic
is used to gather the names for comparison:</p>

<p style="margin-left:9%; margin-top: 1em">Parameter names
are the identifiers as written in the source code.</p>

<p style="margin-left:9%; margin-top: 1em">Argument names
are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>If a variable is passed, the variable's name.</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>If a subsequent function call's return value is used as
argument, the called function's name.</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="85%">


<p>Otherwise, empty string.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Empty argument
or parameter names are ignored by the heuristics.</p>

<h3>readability-uniqueptr-delete-release
<a name="readability-uniqueptr-delete-release"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Replace
<b>delete &lt;unique_ptr&gt;.release()</b> with
<b>&lt;unique_ptr&gt; = nullptr</b>. The latter is shorter,
simpler and does not require use of raw pointer APIs.</p>


<p style="margin-left:13%; margin-top: 1em">std::unique_ptr&lt;int&gt;
P; <br>
delete P.release();</p>

<p style="margin-left:13%; margin-top: 1em">// becomes</p>


<p style="margin-left:13%; margin-top: 1em">std::unique_ptr&lt;int&gt;
P; <br>
P = nullptr;</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>PreferResetCall</b></p>

<p style="margin-left:18%;">If <i>true</i>, refactor by
calling the reset member function instead of assigning to
<b>nullptr</b>. Default value is <i>false</i>.</p>


<p style="margin-left:22%; margin-top: 1em">std::unique_ptr&lt;int&gt;
P; <br>
delete P.release();</p>

<p style="margin-left:22%; margin-top: 1em">// becomes</p>


<p style="margin-left:22%; margin-top: 1em">std::unique_ptr&lt;int&gt;
P; <br>
P.reset();</p>

<h3>readability-uppercase-literal-suffix
<a name="readability-uppercase-literal-suffix"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>cert-dcl16-c</i>
redirects here as an alias for this check. By default, only
the suffixes that begin with <b>l</b> (<b>l</b>, <b>ll</b>,
<b>lu</b>, <b>llu</b>, but not <b>u</b>, <b>ul</b>,
<b>ull</b>) are diagnosed by that alias.</p>


<p style="margin-left:9%; margin-top: 1em"><i>hicpp-uppercase-literal-suffix</i>
redirects here as an alias for this check.</p>

<p style="margin-left:9%; margin-top: 1em">Detects when the
integral literal or floating point (decimal or hexadecimal)
literal has a non-uppercase suffix and provides a fix-it
hint with the uppercase suffix.</p>

<p style="margin-left:9%; margin-top: 1em">All valid
combinations of suffixes are supported.</p>

<p style="margin-left:13%; margin-top: 1em">auto x = 1; //
OK, no suffix.</p>

<p style="margin-left:13%; margin-top: 1em">auto x = 1u; //
warning: integer literal suffix 'u' is not upper-case</p>

<p style="margin-left:13%; margin-top: 1em">auto x = 1U; //
OK, suffix is uppercase.</p>

<p style="margin-left:13%; margin-top: 1em">...</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>NewSuffixes</b></p>

<p style="margin-left:18%;">Optionally, a list of the
destination suffixes can be provided. When the suffix is
found, a case-insensitive lookup in that list is made, and
if a replacement is found that is different from the current
suffix, then the diagnostic is issued. This allows for
fine-grained control of what suffixes to consider and what
their replacements should be.</p>

<h3>Example
<a name="Example"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Given a list
<i>L;uL</i>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="65%">


<p><b>l</b> -&gt; <b>L</b></p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="65%">


<p><b>L</b> will be kept as is.</p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="65%">


<p><b>ul</b> -&gt; <b>uL</b></p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="65%">


<p><b>Ul</b> -&gt; <b>uL</b></p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="65%">


<p><b>UL</b> -&gt; <b>uL</b></p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="65%">


<p><b>uL</b> will be kept as is.</p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="65%">


<p><b>ull</b> will be kept as is, since it is not in the
list</p> </td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="65%">


<p>and so on.</p></td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:9%;"><b>IgnoreMacros</b></p>

<p style="margin-left:18%;">If this option is set to
<i>true</i> (default is <i>true</i>), the check will not
warn about literal suffixes inside macros.</p>

<h3>readability-use-anyofallof
<a name="readability-use-anyofallof"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Finds
range-based for loops that can be replaced by a call to
<b>std::any_of</b> or <b>std::all_of</b>. In C++20 mode,
suggests <b>std::ranges::any_of</b> or
<b>std::ranges::all_of</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Example:</p>

<p style="margin-left:13%; margin-top: 1em">bool
all_even(std::vector&lt;int&gt; V) { <br>
for (int I : V) { <br>
if (I % 2) <br>
return false; <br>
} <br>
return true; <br>
// Replace loop by <br>
// return std::ranges::all_of(V, [](int I) { return I % 2 ==
0; }); <br>
}</p>

<h3>readability-use-std-min-max
<a name="readability-use-std-min-max"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Replaces certain
conditional statements with equivalent calls to
<b>std::min</b> or <b>std::max</b>. Note: This may impact
performance in critical code due to potential additional
stores compared to the original if statement.</p>

<p style="margin-left:9%; margin-top: 1em">Before:</p>

<p style="margin-left:13%; margin-top: 1em">void foo() {
<br>
int a = 2, b = 3; <br>
if (a &lt; b) <br>
a = b; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">After:</p>

<p style="margin-left:13%; margin-top: 1em">void foo() {
<br>
int a = 2, b = 3; <br>
a = std::max(a, b); <br>
}</p>

<h3>zircon-temporary-objects
<a name="zircon-temporary-objects"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Warns on
construction of specific temporary objects in the Zircon
kernel. If the object should be flagged, If the object
should be flagged, the fully qualified type name must be
explicitly passed to the check.</p>

<p style="margin-left:9%; margin-top: 1em">For example,
given the list of classes &quot;Foo&quot; and
&quot;NS::Bar&quot;, all of the following will trigger the
warning:</p>

<p style="margin-left:13%; margin-top: 1em">Foo(); <br>
Foo F = Foo(); <br>
func(Foo());</p>

<p style="margin-left:13%; margin-top: 1em">namespace NS
{</p>

<p style="margin-left:13%; margin-top: 1em">Bar();</p>

<p style="margin-left:13%; margin-top: 1em">}</p>

<p style="margin-left:9%; margin-top: 1em">With the same
list, the following will not trigger the warning:</p>

<p style="margin-left:13%; margin-top: 1em">Foo F; //
Non-temporary construction okay <br>
Foo F(param); // Non-temporary construction okay <br>
Foo *F = new Foo(); // New construction okay</p>

<p style="margin-left:13%; margin-top: 1em">Bar(); // Not
NS::Bar, so okay <br>
NS::Bar B; // Non-temporary construction okay</p>

<p style="margin-left:9%; margin-top: 1em">Note that
objects must be explicitly specified in order to be flagged,
and so objects that inherit a specified object will not be
flagged.</p>

<p style="margin-left:9%; margin-top: 1em">This check
matches temporary objects without regard for inheritance and
so a prohibited base class type does not similarly prohibit
derived class types.</p>

<p style="margin-left:13%; margin-top: 1em">class Derived :
Foo {} // Derived is not explicitly disallowed <br>
Derived(); // and so temporary construction is okay</p>

<h3>Options
<a name="Options"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>Names</b></p></td>
<td width="3%"></td>
<td width="82%">


<p style="margin-top: 1em">A semi-colon-separated list of
fully-qualified names of C++ classes that should not be
constructed as temporaries. Default is empty.</p></td></tr>
</table>

<h3>Check aliases
<a name="Check aliases"></a>
</h3>


<h3>Clang-tidy IDE/Editor Integrations
<a name="Clang-tidy IDE/Editor Integrations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Apart from being
a standalone tool, <b>clang-tidy</b> is integrated into
various IDEs, code analyzers, and editors. We recommend
using <i>clangd</i> which integrates <b>clang-tidy</b> and
<i>is available</i> in most major editors through plugins
(Vim, Emacs, Visual Studio Code, Sublime Text and -
<i>more</i>).</p>

<p style="margin-left:9%; margin-top: 1em">The following
table shows the most well-known <b>clang-tidy</b>
integrations in detail. <b><br>
IDEs</b></p>

<p style="margin-left:9%; margin-top: 1em"><i>CLion</i>
2017.2 and later <i>integrates clang-tidy</i> as an
extension to the built-in code analyzer. Starting from
2018.2 EAP, CLion allows using <b>clang-tidy</b> via Clangd.
Inspections and applicable quick-fixes are performed on the
fly, and checks can be configured in standard command line
format. In this integration, you can switch to the
<b>clang-tidy</b> binary different from the bundled one,
pass the configuration in <b>.clang-tidy</b> files instead
of using the IDE settings, and configure options for
particular checks.</p>

<p style="margin-left:9%; margin-top: 1em"><i>KDevelop</i>
with the <i>kdev-clang-tidy</i> plugin, starting from
version 5.1, performs static analysis using
<b>clang-tidy</b>. The plugin launches the <b>clang-tidy</b>
binary from the specified location and parses its output to
provide a list of issues.</p>


<p style="margin-left:9%; margin-top: 1em"><i>QtCreator</i>
4.6 integrates <b>clang-tidy</b> warnings into the editor
diagnostics under the <i>Clang Code Model</i>. To employ
<b>clang-tidy</b> inspection in QtCreator, you need to
create a copy of one of the presets and choose the checks to
be performed. Since QtCreator 4.7 project-wide analysis is
possible with the <i>Clang Tools</i> analyzer.</p>

<p style="margin-left:9%; margin-top: 1em"><i>MS Visual
Studio</i> can integrate <b>clang-tidy</b> by means of three
different tools. The <i>ReSharper C++</i> extension, version
2017.3 and later, provides seamless <b>clang-tidy</b>
integration: checks and quick-fixes run alongside native
inspections. Apart from that, ReSharper C++ incorporates
<b>clang-tidy</b> as a separate step of its code clean-up
process. <i>Visual Assist</i> build 2210 includes a subset
of <b>clang-tidy</b> checklist to inspect the code as you
edit. Another way to bring <b>clang-tidy</b> functionality
to Visual Studio is the <i>Clang Power Tools</i> plugin,
which includes most of the <b>clang-tidy</b> checks and runs
them during compilation or as a separate step of code
analysis.</p>


<p style="margin-left:9%; margin-top: 1em"><b>Editors</b></p>

<p style="margin-left:9%; margin-top: 1em"><i>Emacs24</i>,
when expanded with the <i>Flycheck</i> plugin, incorporates
the <b>clang-tidy</b> inspection into the syntax analyzer.
For <i>Vim</i>, you can use - <i>Syntastic</i>, which
includes <b>clang-tidy</b>, or <i>A.L.E.</i>, a lint engine
that applies <b>clang-tidy</b> along with other linters.</p>


<p style="margin-left:9%; margin-top: 1em"><b>Analyzers</b></p>


<p style="margin-left:9%; margin-top: 1em"><b>clang-tidy</b>
is integrated in <i>CPPDepend</i> starting from version
2018.1 and <i>CPPCheck</i> 1.82. CPPCheck integration lets
you import Visual Studio solutions and run the
<b>clang-tidy</b> inspection on them. The <i>CodeChecker</i>
application of version 5.3 or later, which also comes as a
<i>plugin</i> for Eclipse, supports <b>clang-tidy</b> as a
static analysis instrument and allows to use a custom
<b>clang-tidy</b> binary.</p>

<h3>Getting Involved
<a name="Getting Involved"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>clang-tidy</b>
has several own checks and can run Clang static analyzer
checks, but its power is in the ability to easily write
custom checks.</p>

<p style="margin-left:9%; margin-top: 1em">Checks are
organized in modules, which can be linked into
<b>clang-tidy</b> with minimal or no code changes in
<b>clang-tidy</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Checks can plug
into the analysis on the preprocessor level using -
<i>PPCallbacks</i> or on the AST level using <i>AST
Matchers</i>. When an error is found, checks can report them
in a way similar to how Clang diagnostics work. A fix-it
hint can be attached to a diagnostic message.</p>

<p style="margin-left:9%; margin-top: 1em">The interface
provided by <b>clang-tidy</b> makes it easy to write useful
and precise checks in just a few lines of code. If you have
an idea for a good check, the rest of this document explains
how to do this. <b><br>
There are a few tools particularly useful when developing
clang-tidy <br>
checks:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><b>add_new_check.py</b> is a script to automate the
process of adding a new check, it will create the check,
update the CMake file and create a test;</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><b>rename_check.py</b> does what the script name
suggests, renames an existing check;</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><b>pp-trace</b> logs method calls on <i>PPCallbacks</i>
for a source file and is invaluable in understanding the
preprocessor mechanism;</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><b>clang-query</b> is invaluable for interactive
prototyping of AST matchers and exploration of the Clang
AST;</p> </td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><i>clang-check</i> with the <b>-ast-dump</b> (and
optionally <b>-ast-dump-filter</b>) provides a convenient
way to dump AST of a C++ program.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">If CMake is
configured with <b>CLANG_TIDY_ENABLE_STATIC_ANALYZER=NO</b>,
<b>clang-tidy</b> will not be built with support for the
<b>clang-analyzer-*</b> checks or the <b>mpi-*</b>
checks.</p>

<h3>Choosing the Right Place for your Check
<a name="Choosing the Right Place for your Check"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">If you have an
idea of a check, you should decide whether it should be
implemented as a:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em"><i>Clang diagnostic</i>: if the
check is generic enough, targets code patterns that most
probably are bugs (rather than style or readability issues),
can be implemented effectively and with extremely low false
positive rate, it may make a good Clang diagnostic.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p><i>Clang static analyzer check</i>: if the check
requires some sort of control flow analysis, it should
probably be implemented as a static analyzer check.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p><i>clang-tidy check</i> is a good choice for
linter-style checks, checks that are related to a certain
coding style, checks that address code readability, etc.</p></td></tr>
</table>

<h3>Preparing your Workspace
<a name="Preparing your Workspace"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">If you are new
to LLVM development, you should read the <i>Getting Started
with the LLVM System</i>, <i>Using Clang Tools</i> and
<i>How To Setup Clang Tooling For LLVM</i> documents to
check out and build LLVM, Clang and Clang Extra Tools with
CMake.</p>

<p style="margin-left:9%; margin-top: 1em">Once you are
done, change to the <b>llvm/clang-tools-extra</b> directory,
and let's start!</p>

<p style="margin-left:9%; margin-top: 1em">When you
<i>configure the CMake build</i>, make sure that you enable
the <b>clang</b> and <b>clang-tools-extra</b> projects to
build <b>clang-tidy</b>. Because your new check will have
associated documentation, you will also want to install
<i>Sphinx</i> and enable it in the CMake configuration. To
save build time of the core Clang libraries you may want to
only enable the <b>X86</b> target in the CMake
configuration.</p>

<h3>The Directory Structure
<a name="The Directory Structure"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>clang-tidy</b>
source code resides in the <b>llvm/clang-tools-extra</b>
directory and is structured as follows:</p>

<p style="margin-left:13%; margin-top: 1em">clang-tidy/ #
Clang-tidy core. <br>
|-- ClangTidy.h # Interfaces for users. <br>
|-- ClangTidyCheck.h # Interfaces for checks. <br>
|-- ClangTidyModule.h # Interface for clang-tidy modules.
<br>
|-- ClangTidyModuleRegistry.h # Interface for registering of
modules. <br>
... <br>
|-- google/ # Google clang-tidy module. <br>
|-+ <br>
|-- GoogleTidyModule.cpp <br>
|-- GoogleTidyModule.h <br>
... <br>
|-- llvm/ # LLVM clang-tidy module. <br>
|-+ <br>
|-- LLVMTidyModule.cpp <br>
|-- LLVMTidyModule.h <br>
... <br>
|-- objc/ # Objective-C clang-tidy module. <br>
|-+ <br>
|-- ObjCTidyModule.cpp <br>
|-- ObjCTidyModule.h <br>
... <br>
|-- tool/ # Sources of the clang-tidy binary. <br>
... <br>
test/clang-tidy/ # Integration tests. <br>
... <br>
unittests/clang-tidy/ # Unit tests. <br>
|-- ClangTidyTest.h <br>
|-- GoogleModuleTest.cpp <br>
|-- LLVMModuleTest.cpp <br>
|-- ObjCModuleTest.cpp <br>
...</p>

<h3>Writing a clang-tidy Check
<a name="Writing a clang-tidy Check"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">So you have an
idea of a useful check for <b>clang-tidy</b>.</p>

<p style="margin-left:9%; margin-top: 1em">First, if you're
not familiar with LLVM development, read through the -
<i>Getting Started with LLVM</i> document for instructions
on setting up your workflow and the <i>LLVM Coding
Standards</i> document to familiarize yourself with the
coding style used in the project. For code reviews we mostly
use <i>LLVM Phabricator</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Next, you need
to decide which module the check belongs to. Modules are
located in subdirectories of <i>clang-tidy/</i> and contain
checks targeting a certain aspect of code quality
(performance, readability, etc.), certain coding style or
standard (Google, LLVM, CERT, etc.) or a widely used API
(e.g. MPI). Their names are the same as the user-facing
check group names described <i>above</i>.</p>

<p style="margin-left:9%; margin-top: 1em">After choosing
the module and the name for the check, run the
<b>clang-tidy/add_new_check.py</b> script to create the
skeleton of the check and plug it to <b>clang-tidy</b>. It's
the recommended way of adding new checks.</p>

<p style="margin-left:9%; margin-top: 1em">If we want to
create a <i>readability-awesome-function-names</i>, we would
run:</p>

<p style="margin-left:13%; margin-top: 1em">$
clang-tidy/add_new_check.py readability
awesome-function-names</p>

<p style="margin-left:9%;"><b>The add_new_check.py script
will:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>create the class for your check inside the specified
module's directory and register it in the module and in the
build system;</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>create a lit test file in the <b>test/clang-tidy/</b>
directory;</p> </td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>create a documentation file and include it into the
<b>docs/clang-tidy/checks/list.rst</b>.</p> </td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Let's see in
more detail at the check class definition:</p>

<p style="margin-left:13%; margin-top: 1em">...</p>

<p style="margin-left:13%; margin-top: 1em">#include
&quot;../ClangTidyCheck.h&quot;</p>

<p style="margin-left:13%; margin-top: 1em">namespace clang
{ <br>
namespace tidy { <br>
namespace readability {</p>

<p style="margin-left:13%; margin-top: 1em">... <br>
class AwesomeFunctionNamesCheck : public ClangTidyCheck {
<br>
public: <br>
AwesomeFunctionNamesCheck(StringRef Name, ClangTidyContext
*Context) <br>
: ClangTidyCheck(Name, Context) {} <br>
void registerMatchers(ast_matchers::MatchFinder *Finder)
override; <br>
void check(const ast_matchers::MatchFinder::MatchResult
&amp;Result) override; <br>
};</p>

<p style="margin-left:13%; margin-top: 1em">} // namespace
readability <br>
} // namespace tidy <br>
} // namespace clang</p>

<p style="margin-left:13%; margin-top: 1em">...</p>

<p style="margin-left:9%; margin-top: 1em">Constructor of
the check receives the <b>Name</b> and <b>Context</b>
parameters, and must forward them to the
<b>ClangTidyCheck</b> constructor.</p>

<p style="margin-left:9%; margin-top: 1em">In our case the
check needs to operate on the AST level and it overrides the
<b>registerMatchers</b> and <b>check</b> methods. If we
wanted to analyze code on the preprocessor level, we'd need
instead to override the <b>registerPPCallbacks</b>
method.</p>

<p style="margin-left:9%; margin-top: 1em">In the
<b>registerMatchers</b> method we create an AST Matcher (see
<i>AST Matchers</i> for more information) that will find the
pattern in the AST that we want to inspect. The results of
the matching are passed to the <b>check</b> method, which
can further inspect them and report diagnostics.</p>

<p style="margin-left:13%; margin-top: 1em">using namespace
ast_matchers;</p>

<p style="margin-left:13%; margin-top: 1em">void
AwesomeFunctionNamesCheck::registerMatchers(MatchFinder
*Finder) { <br>
Finder-&gt;addMatcher(functionDecl().bind(&quot;x&quot;),
this); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
AwesomeFunctionNamesCheck::check(const
MatchFinder::MatchResult &amp;Result) { <br>
const auto *MatchedDecl =
Result.Nodes.getNodeAs&lt;FunctionDecl&gt;(&quot;x&quot;);
<br>
if (!MatchedDecl-&gt;getIdentifier() ||
MatchedDecl-&gt;getName().startswith(&quot;awesome_&quot;))
<br>
return; <br>
diag(MatchedDecl-&gt;getLocation(), &quot;function %0 is
insufficiently awesome&quot;) <br>
&lt;&lt; MatchedDecl <br>
&lt;&lt;
FixItHint::CreateInsertion(MatchedDecl-&gt;getLocation(),
&quot;awesome_&quot;); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">(If you want to
see an example of a useful check, look at -
<i>clang-tidy/google/ExplicitConstructorCheck.h</i> and -
<i>clang-tidy/google/ExplicitConstructorCheck.cpp</i>).</p>

<p style="margin-left:9%; margin-top: 1em">If you need to
interact with macros or preprocessor directives, you will
want to override the method <b>registerPPCallbacks</b>. The
<b>add_new_check.py</b> script does not generate an override
for this method in the starting point for your new
check.</p>

<p style="margin-left:9%; margin-top: 1em">If your check
applies only under a specific set of language options, be
sure to override the method
<b>isLanguageVersionSupported</b> to reflect that.</p>

<h3>Check development tips
<a name="Check development tips"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Writing your
first check can be a daunting task, particularly if you are
unfamiliar with the LLVM and Clang code bases. Here are some
suggestions for orienting yourself in the codebase and
working on your check incrementally.</p>

<h3>Guide to useful documentation
<a name="Guide to useful documentation"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Many of the
support classes created for LLVM are used by Clang, such as
<i>StringRef</i> and <i>SmallVector</i>. These and other
commonly used classes are described in the <i>Important and
useful LLVM APIs</i> and <i>Picking the Right Data Structure
for the Task</i> sections of the <i>LLVM Programmer's
Manual</i>. You don't need to memorize all the details of
these classes; the generated <i>doxygen documentation</i>
has everything if you need it. In the header
<i>LLVM/ADT/STLExtras.h</i> you'll find useful versions of
the STL algorithms that operate on LLVM containers, such as
<i>llvm::all_of</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Clang is
implemented on top of LLVM and introduces its own set of
classes that you will interact with while writing your
check. When a check issues diagnostics and fix-its, these
are associated with locations in the source code. Source
code locations, source files, ranges of source locations and
the <i>SourceManager</i> class provide the mechanisms for
describing such locations. These and other topics are
described in the <i>&quot;Clang&quot; CFE Internals
Manual</i>. Whereas the doxygen generated documentation
serves as a reference to the internals of Clang, this
document serves as a guide to other developers. Topics in
that manual of interest to a check developer are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em"><i>The Clang &quot;Basic&quot;
Library</i> for information about diagnostics, fix-it hints
and source locations.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p><i>The Lexer and Preprocessor Library</i> for
information about tokens, lexing (transforming characters
into tokens) and the preprocessor.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p><i>The AST Library</i> for information about how C++
source statements are represented as an abstract syntax tree
(AST).</p> </td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Most checks will
interact with C++ source code via the AST. Some checks will
interact with the preprocessor. The input source file is
lexed and preprocessed and then parsed into the AST. Once
the AST is fully constructed, the check is run by applying
the check's registered AST matchers against the AST and
invoking the check with the set of matched nodes from the
AST. Monitoring the actions of the preprocessor is detached
from the AST construction, but a check can collect
information during preprocessing for later use by the check
when nodes are matched by the AST.</p>

<p style="margin-left:9%; margin-top: 1em">Every syntactic
(and sometimes semantic) element of the C++ source code is
represented by different classes in the AST. You select the
portions of the AST you're interested in by composing AST
matcher functions. You will want to study carefully the
<i>AST Matcher Reference</i> to understand the relationship
between the different matcher functions.</p>

<h3>Using the Transformer library
<a name="Using the Transformer library"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The Transformer
library allows you to write a check that transforms source
code by expressing the transformation as a
<b>RewriteRule</b>. The Transformer library provides
functions for composing edits to source code to create
rewrite rules. Unless you need to perform low-level source
location manipulation, you may want to consider writing your
check with the Transformer library. The <i>Clang Transformer
Tutorial</i> describes the Transformer library in
detail.</p>

<p style="margin-left:9%; margin-top: 1em">To use the
Transformer library, make the following changes to the code
generated by the <b>add_new_check.py</b> script:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Include
<b>../utils/TransformerClangTidyCheck.h</b> instead of
<b>../ClangTidyCheck.h</b></p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Change the base class of your check from
<b>ClangTidyCheck</b> to
<b>TransformerClangTidyCheck</b></p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Delete the override of the <b>registerMatchers</b> and
<b>check</b> methods in your check class.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Write a function that creates the <b>RewriteRule</b> for
your check.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Call the function in your check's constructor to pass
the rewrite rule to <b>TransformerClangTidyCheck</b>'s
constructor.</p> </td></tr>
</table>

<h3>Developing your check incrementally
<a name="Developing your check incrementally"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The best way to
develop your check is to start with the simple test cases
and increase complexity incrementally. The test file created
by the <b>add_new_check.py</b> script is a starting point
for your test cases. A rough outline of the process looks
like this:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Write a test case for your
check.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Prototype matchers on the test file using
<b>clang-query</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Capture the working matchers in the
<b>registerMatchers</b> method.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Issue the necessary diagnostics and fix-its in the
<b>check</b> method.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Add the necessary <b>CHECK-MESSAGES</b> and
<b>CHECK-FIXES</b> annotations to your test case to validate
the diagnostics and fix-its.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Build the target <b>check-clang-tool</b> to confirm the
test passes.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Repeat the process until all aspects of your check are
covered by tests.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">The quickest way
to prototype your matcher is to use <b>clang-query</b> to
interactively build up your matcher. For complicated
matchers, build up a matching expression incrementally and
use <b>clang-query</b>'s <b>let</b> command to save named
matching expressions to simplify your matcher. Just like
breaking up a huge function into smaller chunks with
intention-revealing names can help you understand a complex
algorithm, breaking up a matcher into smaller matchers with
intention-revealing names can help you understand a
complicated matcher. Once you have a working matcher, the
C++ API will be virtually identical to your interactively
constructed matcher. You can use local variables to preserve
your intention-revealing names that you applied to nested
matchers.</p>

<h3>Creating private matchers
<a name="Creating private matchers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Sometimes you
want to match a specific aspect of the AST that isn't
provided by the existing AST matchers. You can create your
own private matcher using the same infrastructure as the
public matchers. A private matcher can simplify the
processing in your <b>check</b> method by eliminating
complex hand-crafted AST traversal of the matched nodes.
Using the private matcher allows you to select the desired
portions of the AST directly in the matcher and refer to it
by a bound name in the <b>check</b> method.</p>

<h3>Unit testing helper code
<a name="Unit testing helper code"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Private custom
matchers are a good example of auxiliary support code for
your check that can be tested with a unit test. It will be
easier to test your matchers or other support classes by
writing a unit test than by writing a <b>FileCheck</b>
integration test. The <b>ASTMatchersTests</b> target
contains unit tests for the public AST matcher classes and
is a good source of testing idioms for matchers.</p>

<p style="margin-left:9%; margin-top: 1em">You can build
the Clang-tidy unit tests by building the
<b>ClangTidyTests</b> target. Test targets in LLVM and Clang
are excluded from the &quot;build all&quot; style action of
IDE-based CMake generators, so you need to explicitly build
the target for the unit tests to be built.</p>

<h3>Making your check robust
<a name="Making your check robust"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Once you've
covered your check with the basic &quot;happy path&quot;
scenarios, you'll want to torture your check with as many
edge cases as you can cover in order to ensure your check is
robust. Running your check on a large code base, such as
Clang/LLVM, is a good way to catch things you forgot to
account for in your matchers. However, the LLVM code base
may be insufficient for testing purposes as it was developed
against a particular set of coding styles and quality
measures. The larger the corpus of code the check is tested
against, the higher confidence the community will have in
the check's efficacy and false positive rate.</p>

<p style="margin-left:9%; margin-top: 1em">Some suggestions
to ensure your check is robust:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Create header files that contain
code matched by your check.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Validate that fix-its are properly applied to test
header files with <b>clang-tidy</b>. You will need to
perform this test manually until automated support for
checking messages and fix-its is added to the
<b>check_clang_tidy.py</b> script.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Define macros that contain code matched by your
check.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Define template classes that contain code matched by
your check.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Define template specializations that contain code
matched by your check.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Test your check under both Windows and Linux
environments.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Watch out for high false positive rates. Ideally, a
check would have no false positives, but given that matching
against an AST is not control- or data flow- sensitive, a
number of false positives are expected. The higher the false
positive rate, the less likely the check will be adopted in
practice. Mechanisms should be put in place to help the user
manage false positives.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>There are two primary mechanisms for managing false
positives: supporting a code pattern which allows the
programmer to silence the diagnostic in an ad hoc manner and
check configuration options to control the behavior of the
check.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Consider supporting a code pattern to allow the
programmer to silence the diagnostic whenever such a code
pattern can clearly express the programmer's intent. For
example, allowing an explicit cast to <b>void</b> to silence
an unused variable diagnostic.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Consider adding check configuration options to allow the
user to opt into more aggressive checking behavior without
burdening users for the common high-confidence cases.</p></td></tr>
</table>

<h3>Documenting your check
<a name="Documenting your check"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<b>add_new_check.py</b> script creates entries in the
<i>release notes</i>, the list of checks and a new file for
the check documentation itself. It is recommended that you
have a concise summation of what your check does in a single
sentence that is repeated in the release notes, as the first
sentence in the doxygen comments in the header file for your
check class and as the first sentence of the check
documentation. Avoid the phrase &quot;this check&quot; in
your check summation and check documentation.</p>

<p style="margin-left:9%; margin-top: 1em">If your check
relates to a published coding guideline (C++ Core
Guidelines, MISRA, etc.) or style guide, provide links to
the relevant guideline or style guide sections in your check
documentation.</p>

<p style="margin-left:9%; margin-top: 1em">Provide enough
examples of the diagnostics and fix-its provided by the
check so that a user can easily understand what will happen
to their code when the check is run. If there are exceptions
or limitations to your check, document them thoroughly. This
will help users understand the scope of the diagnostics and
fix-its provided by the check.</p>

<p style="margin-left:9%; margin-top: 1em">Building the
target <b>docs-clang-tools-html</b> will run the Sphinx
documentation generator and create documentation HTML files
in the tools/clang/tools/extra/docs/html directory in your
build tree. Make sure that your check is correctly shown in
the release notes and the list of checks. Make sure that the
formatting and structure of your check's documentation looks
correct.</p>

<h3>Registering your Check
<a name="Registering your Check"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">(The
<b>add_new_check.py</b> script takes care of registering the
check in an existing module. If you want to create a new
module or know the details, read on.)</p>

<p style="margin-left:9%; margin-top: 1em">The check should
be registered in the corresponding module with a distinct
name:</p>

<p style="margin-left:13%; margin-top: 1em">class MyModule
: public ClangTidyModule { <br>
public: <br>
void addCheckFactories(ClangTidyCheckFactories
&amp;CheckFactories) override { <br>

CheckFactories.registerCheck&lt;ExplicitConstructorCheck&gt;(
<br>
&quot;my-explicit-constructor&quot;); <br>
} <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">Now we need to
register the module in the <b>ClangTidyModuleRegistry</b>
using a statically initialized variable:</p>

<p style="margin-left:13%; margin-top: 1em">static
ClangTidyModuleRegistry::Add&lt;MyModule&gt;
X(&quot;my-module&quot;, <br>
&quot;Adds my lint checks.&quot;);</p>

<p style="margin-left:9%; margin-top: 1em">When using LLVM
build system, we need to use the following hack to ensure
the module is linked into the <b>clang-tidy</b> binary:</p>

<p style="margin-left:9%; margin-top: 1em">Add this near
the <b>ClangTidyModuleRegistry::Add&lt;MyModule&gt;</b>
variable:</p>

<p style="margin-left:13%; margin-top: 1em">// This anchor
is used to force the linker to link in the generated object
file <br>
// and thus register the MyModule. <br>
volatile int MyModuleAnchorSource = 0;</p>

<p style="margin-left:9%; margin-top: 1em">And this to the
main translation unit of the <b>clang-tidy</b> binary (or
the binary you link the <b>clang-tidy</b> library in)
<b>clang-tidy/ClangTidyForceLinker.h</b>:</p>

<p style="margin-left:13%; margin-top: 1em">// This anchor
is used to force the linker to link the MyModule. <br>
extern volatile int MyModuleAnchorSource; <br>
static int MyModuleAnchorDestination =
MyModuleAnchorSource;</p>

<h3>Configuring Checks
<a name="Configuring Checks"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">If a check needs
configuration options, it can access check-specific options
using the <b>Options.get&lt;Type&gt;(&quot;SomeOption&quot;,
DefaultValue)</b> call in the check constructor. In this
case the check should also override the
<b>ClangTidyCheck::storeOptions</b> method to make the
options provided by the check discoverable. This method lets
<b>clang-tidy</b> know which options the check implements
and what the current values are (e.g. for the
<b>-dump-config</b> command line option).</p>

<p style="margin-left:13%; margin-top: 1em">class MyCheck :
public ClangTidyCheck { <br>
const unsigned SomeOption1; <br>
const std::string SomeOption2;</p>

<p style="margin-left:13%; margin-top: 1em">public: <br>
MyCheck(StringRef Name, ClangTidyContext *Context) <br>
: ClangTidyCheck(Name, Context), <br>
SomeOption(Options.get(&quot;SomeOption1&quot;, -1U)), <br>
SomeOption(Options.get(&quot;SomeOption2&quot;, &quot;some
default&quot;)) {}</p>

<p style="margin-left:13%; margin-top: 1em">void
storeOptions(ClangTidyOptions::OptionMap &amp;Opts) override
{ <br>
Options.store(Opts, &quot;SomeOption1&quot;, SomeOption1);
<br>
Options.store(Opts, &quot;SomeOption2&quot;, SomeOption2);
<br>
} <br>
...</p>

<p style="margin-left:9%; margin-top: 1em">Assuming the
check is registered with the name &quot;my-check&quot;, the
option can then be set in a <b>.clang-tidy</b> file in the
following way:</p>

<p style="margin-left:13%; margin-top: 1em">CheckOptions:
<br>
my-check.SomeOption1: 123 <br>
my-check.SomeOption2: 'some other value'</p>

<p style="margin-left:9%; margin-top: 1em">If you need to
specify check options on a command line, you can use the
inline YAML format:</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-tidy
-config=&quot;{CheckOptions: {a: b, x: y}}&quot; ...</p>

<h3>Testing Checks
<a name="Testing Checks"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">To run tests for
<b>clang-tidy</b>, build the <b>check-clang-tools</b>
target. For instance, if you configured your CMake build
with the ninja project generator, use the command:</p>

<p style="margin-left:13%; margin-top: 1em">$ ninja
check-clang-tools</p>


<p style="margin-left:9%; margin-top: 1em"><b>clang-tidy</b>
checks can be tested using either unit tests or <i>lit</i>
tests. Unit tests may be more convenient to test complex
replacements with strict checks. <i>Lit</i> tests allow
using partial text matching and regular expressions which
makes them more suitable for writing compact tests for
diagnostic messages.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>check_clang_tidy.py</b> script provides an easy way to
test both diagnostic messages and fix-its. It filters out
<b>CHECK</b> lines from the test file, runs
<b>clang-tidy</b> and verifies messages and fixes with two
separate <i>FileCheck</i> invocations: once with FileCheck's
directive prefix set to <b>CHECK-MESSAGES</b>, validating
the diagnostic messages, and once with the directive prefix
set to <b>CHECK-FIXES</b>, running against the fixed code
(i.e., the code after generated fix-its are applied). In
particular, <b>CHECK-FIXES:</b> can be used to check that
code was not modified by fix-its, by checking that it is
present unchanged in the fixed code. The full set of
<i>FileCheck</i> directives is available (e.g.,
<b>CHECK-MESSAGES-SAME:</b>, <b>CHECK-MESSAGES-NOT:</b>),
though typically the basic <b>CHECK</b> forms
(<b>CHECK-MESSAGES</b> and <b>CHECK-FIXES</b>) are
sufficient for clang-tidy tests. Note that the
<i>FileCheck</i> documentation mostly assumes the default
prefix (<b>CHECK</b>), and hence describes the directive as
<b>CHECK:</b>, <b>CHECK-SAME:</b>, <b>CHECK-NOT:</b>, etc.
Replace <b>CHECK</b> by either <b>CHECK-FIXES</b> or
<b>CHECK-MESSAGES</b> for clang-tidy tests.</p>

<p style="margin-left:9%; margin-top: 1em">An additional
check enabled by <b>check_clang_tidy.py</b> ensures that if
<i>CHECK-MESSAGES:</i> is used in a file then every warning
or error must have an associated CHECK in that file. Or, you
can use <b>CHECK-NOTES:</b> instead, if you want to
<b>also</b> ensure that all the notes are checked.</p>

<p style="margin-left:9%; margin-top: 1em">To use the
<b>check_clang_tidy.py</b> script, put a .cpp file with the
appropriate <b>RUN</b> line in the <b>test/clang-tidy</b>
directory. Use <b>CHECK-MESSAGES:</b> and
<b>CHECK-FIXES:</b> lines to write checks against diagnostic
messages and fixed code.</p>

<p style="margin-left:9%; margin-top: 1em">It's advised to
make the checks as specific as possible to avoid checks
matching to incorrect parts of the input. Use
<b>[[@LINE+X]]</b>/<b>[[@LINE-X]]</b> substitutions and
distinct function and variable names in the test code.</p>

<p style="margin-left:9%; margin-top: 1em">Here's an
example of a test using the <b>check_clang_tidy.py</b>
script (the full source code is at -
<i>test/clang-tidy/checkers/google/readability-casting.cpp</i>):</p>

<p style="margin-left:13%; margin-top: 1em">// RUN:
%check_clang_tidy %s google-readability-casting %t</p>

<p style="margin-left:13%; margin-top: 1em">void f(int a) {
<br>
int b = (int)a; <br>
// CHECK-MESSAGES: :[[@LINE-1]]:11: warning: redundant cast
to the same type [google-readability-casting] <br>
// CHECK-FIXES: int b = a; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">To check more
than one scenario in the same test file use
<b>-check-suffix=SUFFIX-NAME</b> on
<b>check_clang_tidy.py</b> command line or
<b>-check-suffixes=SUFFIX-NAME-1,SUFFIX-NAME-2,...</b>. With
<b>-check-suffix[es]=SUFFIX-NAME</b> you need to replace
your <b>CHECK-*</b> directives with
<b>CHECK-MESSAGES-SUFFIX-NAME</b> and
<b>CHECK-FIXES-SUFFIX-NAME</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Here's an
example:</p>

<p style="margin-left:13%; margin-top: 1em">// RUN:
%check_clang_tidy -check-suffix=USING-A %s
misc-unused-using-decls %t -- -- -DUSING_A <br>
// RUN: %check_clang_tidy -check-suffix=USING-B %s
misc-unused-using-decls %t -- -- -DUSING_B <br>
// RUN: %check_clang_tidy %s misc-unused-using-decls %t <br>
... <br>
// CHECK-MESSAGES-USING-A: :[[@LINE-8]]:10: warning: using
decl 'A' {{.*}} <br>
// CHECK-MESSAGES-USING-B: :[[@LINE-7]]:10: warning: using
decl 'B' {{.*}} <br>
// CHECK-MESSAGES: :[[@LINE-6]]:10: warning: using decl 'C'
{{.*}} <br>
// CHECK-FIXES-USING-A-NOT: using a::A;$ <br>
// CHECK-FIXES-USING-B-NOT: using a::B;$ <br>
// CHECK-FIXES-NOT: using a::C;$</p>

<p style="margin-left:9%; margin-top: 1em">There are many
dark corners in the C++ language, and it may be difficult to
make your check work perfectly in all cases, especially if
it issues fix-it hints. The most frequent pitfalls are
macros and templates:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="1%"></td>
<td width="87%">


<p style="margin-top: 1em">code written in a macro
body/template definition may have a different meaning
depending on the macro expansion/template instantiation;</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="87%">


<p>multiple macro expansions/template instantiations may
result in the same code being inspected by the check
multiple times (possibly, with different meanings, see 1),
and the same warning (or a slightly different one) may be
issued by the check multiple times; <b>clang-tidy</b> will
deduplicate _identical_ warnings, but if the warnings are
slightly different, all of them will be shown to the user
(and used for applying fixes, if any);</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="87%">


<p>making replacements to a macro body/template definition
may be fine for some macro expansions/template
instantiations, but easily break some other
expansions/instantiations.</p> </td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">If you need
multiple files to exercise all the aspects of your check, it
is recommended you place them in a subdirectory named for
the check under the <b>Inputs</b> directory for the module
containing your check. This keeps the test directory from
getting cluttered.</p>

<p style="margin-left:9%; margin-top: 1em">If you need to
validate how your check interacts with system header files,
a set of simulated system header files is located in the
<b>checkers/Inputs/Headers</b> directory. The path to this
directory is available in a lit test with the variable
<b>%clang_tidy_headers</b>.</p>

<h3>Out-of-tree check plugins
<a name="Out-of-tree check plugins"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Developing an
out-of-tree check as a plugin largely follows the steps
outlined above. The plugin is a shared library whose code
lives outside the clang-tidy build system. Build and link
this shared library against LLVM as done for other kinds of
Clang plugins.</p>

<p style="margin-left:9%; margin-top: 1em">The plugin can
be loaded by passing <i>-load</i> to <i>clang-tidy</i> in
addition to the names of the checks to enable.</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-tidy
--checks=-*,my-explicit-constructor -list-checks -load
myplugin.so</p>

<p style="margin-left:9%; margin-top: 1em">There is no
expectations regarding ABI and API stability, so the plugin
must be compiled against the version of clang-tidy that will
be loading the plugin.</p>

<p style="margin-left:9%; margin-top: 1em">The plugins can
use threads, TLS, or any other facilities available to
in-tree code which is accessible from the external
headers.</p>

<h3>Running clang-tidy on LLVM
<a name="Running clang-tidy on LLVM"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">To test a check
it's best to try it out on a larger code base. LLVM and
Clang are the natural targets as you already have the source
code around. The most convenient way to run
<b>clang-tidy</b> is with a compile command database; CMake
can automatically generate one, for a description of how to
enable it see <i>How To Setup Clang Tooling For LLVM</i>.
Once <b>compile_commands.json</b> is in place and a working
version of <b>clang-tidy</b> is in <b>PATH</b> the entire
code base can be analyzed with
<b>clang-tidy/tool/run-clang-tidy.py</b>. The script
executes <b>clang-tidy</b> with the default set of checks on
every translation unit in the compile command database and
displays the resulting warnings and errors. The script
provides multiple configuration flags.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">The default set of checks can be
overridden using the <b>-checks</b> argument, taking the
identical format as <b>clang-tidy</b> does. For example
<b>-checks=-*,modernize-use-override</b> will run the
<b>modernize-use-override</b> check only.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>To restrict the files examined you can provide one or
more regex arguments that the file names are matched
against. <b>run-clang-tidy.py clang-tidy/.*Check\.cpp</b>
will only analyze clang-tidy checks. It may also be
necessary to restrict the header files that warnings are
displayed from using the <b>-header-filter</b> flag. It has
the same behavior as the corresponding <b>clang-tidy</b>
flag.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>To apply suggested fixes <b>-fix</b> can be passed as an
argument. This gathers all changes in a temporary directory
and applies them. Passing <b>-format</b> will run
clang-format over changed lines.</p></td></tr>
</table>

<h3>On checks profiling
<a name="On checks profiling"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>clang-tidy</b>
can collect per-check profiling info, and output it for each
processed source file (translation unit).</p>

<p style="margin-left:9%; margin-top: 1em">To enable
profiling info collection, use the
<b>-enable-check-profile</b> argument. The timings will be
output to <b>stderr</b> as a table. Example output:</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-tidy
-enable-check-profile -checks=-*,readability-function-size
source.cpp <br>

===-------------------------------------------------------------------------===
<br>
clang-tidy checks profiling <br>

===-------------------------------------------------------------------------===
<br>
Total Execution Time: 1.0282 seconds (1.0258 wall clock)</p>

<p style="margin-left:13%; margin-top: 1em">---User Time---
--System Time-- --User+System-- ---Wall Time--- --- Name ---
<br>
0.9136 (100.0%) 0.1146 (100.0%) 1.0282 (100.0%) 1.0258
(100.0%) readability-function-size <br>
0.9136 (100.0%) 0.1146 (100.0%) 1.0282 (100.0%) 1.0258
(100.0%) Total</p>

<p style="margin-left:9%; margin-top: 1em">It can also
store that data as JSON files for further processing.
Example output:</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-tidy
-enable-check-profile -store-check-profile=.
-checks=-*,readability-function-size source.cpp <br>
$ # Note that there won't be timings table printed to the
console. <br>
$ ls /tmp/out/ <br>
20180516161318717446360-source.cpp.json <br>
$ cat 20180516161318717446360-source.cpp.json <br>
{ <br>
&quot;file&quot;: &quot;/path/to/source.cpp&quot;, <br>
&quot;timestamp&quot;: &quot;2018-05-16
16:13:18.717446360&quot;, <br>
&quot;profile&quot;: { <br>
&quot;time.clang-tidy.readability-function-size.wall&quot;:
1.0421266555786133e+00, <br>
&quot;time.clang-tidy.readability-function-size.user&quot;:
9.2088400000005421e-01, <br>
&quot;time.clang-tidy.readability-function-size.sys&quot;:
1.2418899999999974e-01 <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">There is only
one argument that controls profile storage:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">



<p style="margin-top: 1em"><b>-store-check-profile=&lt;prefix&gt;</b></p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">By default
reports are printed in tabulated format to stderr. When this
option is passed, these per-TU profiles are instead stored
as JSON. If the prefix is not an absolute path, it is
considered to be relative to the directory from where you
have run <b>clang-tidy</b>. All <b>.</b> and <b>..</b>
patterns in the path are collapsed, and symlinks are
resolved.</p>

<p style="margin-left:12%; margin-top: 1em">Example: Let's
suppose you have a source file named <b>example.cpp</b>,
located in the <b>/source</b> directory. Only the input
filename is used, not the full path to the source file.
Additionally, it is prefixed with the current timestamp.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="86%">


<p style="margin-top: 1em">If you specify
<b>-store-check-profile=/tmp</b>, then the profile will be
saved to <b>/tmp/&lt;ISO8601-like
timestamp&gt;-example.cpp.json</b></p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="86%">


<p>If you run <b>clang-tidy</b> from within <b>/foo</b>
directory, and specify <b>-store-check-profile=.</b>, then
the profile will still be saved to <b>/foo/&lt;ISO8601-like
timestamp&gt;-example.cpp.json</b></p> </td></tr>
</table>


<p style="margin-left:9%; margin-top: 1em"><b>clang-tidy</b>
is a clang-based C++ &quot;linter&quot; tool. Its purpose is
to provide an extensible framework for diagnosing and fixing
typical programming errors, like style violations, interface
misuse, or bugs that can be deduced via static analysis.
<b>clang-tidy</b> is modular and provides a convenient
interface for writing new checks.</p>

<h3>Using clang-tidy
<a name="Using clang-tidy"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>clang-tidy</b>
is a <i>LibTooling</i>-based tool, and it's easier to work
with if you set up a compile command database for your
project (for an example of how to do this, see <i>How To
Setup Tooling For LLVM</i>). You can also specify
compilation options on the command line after <b>--</b>:</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-tidy
test.cpp -- -Imy_project/include -DMY_DEFINES ...</p>


<p style="margin-left:9%; margin-top: 1em"><b>clang-tidy</b>
has its own checks and can also run Clang Static Analyzer
checks. Each check has a name and the checks to run can be
chosen using the <b>-checks=</b> option, which specifies a
comma-separated list of positive and negative (prefixed with
<b>-</b>) globs. Positive globs add subsets of checks, and
negative globs remove them. For example,</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-tidy
test.cpp
-checks=-*,clang-analyzer-*,-clang-analyzer-cplusplus*</p>

<p style="margin-left:9%; margin-top: 1em">will disable all
default checks (<b>-*</b>) and enable all
<b>clang-analyzer-*</b> checks except for
<b>clang-analyzer-cplusplus*</b> ones.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>-list-checks</b> option lists all the enabled checks.
When used without <b>-checks=</b>, it shows checks enabled
by default. Use <b>-checks=*</b> to see all available checks
or with any other value of <b>-checks=</b> to see which
checks are enabled by this value.</p>

<p style="margin-left:9%; margin-top: 1em">There are
currently the following groups of checks: <br>
Clang diagnostics are treated in a similar way as check
diagnostics. Clang diagnostics are displayed by
<b>clang-tidy</b> and can be filtered out using the
<b>-checks=</b> option. However, the <b>-checks=</b> option
does not affect compilation arguments, so it cannot turn on
Clang warnings which are not already turned on in the build
configuration. The <b>-warnings-as-errors=</b> option
upgrades any warnings emitted under the <b>-checks=</b> flag
to errors (but it does not enable any checks itself).</p>

<p style="margin-left:9%; margin-top: 1em">Clang
diagnostics have check names starting with
<b>clang-diagnostic-</b>. Diagnostics which have a
corresponding warning option, are named
<b>clang-diagnostic-&lt;warning-option&gt;</b>, e.g. Clang
warning controlled by <b>-Wliteral-conversion</b> will be
reported with check name
<b>clang-diagnostic-literal-conversion</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The <b>-fix</b>
flag instructs <b>clang-tidy</b> to fix found errors if
supported by corresponding checks.</p>

<p style="margin-left:9%; margin-top: 1em">An overview of
all the command-line options:</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-tidy
--help <br>
USAGE: clang-tidy [options] &lt;source0&gt; [...
&lt;sourceN&gt;]</p>

<p style="margin-left:13%; margin-top: 1em">OPTIONS:</p>

<p style="margin-left:13%; margin-top: 1em">Generic
Options:</p>

<p style="margin-left:13%; margin-top: 1em">--help -
Display available options (--help-hidden for more) <br>
--help-list - Display list of available options
(--help-list-hidden for more) <br>
--version - Display the version of this program</p>

<p style="margin-left:13%; margin-top: 1em">clang-tidy
options:</p>


<p style="margin-left:13%; margin-top: 1em">--checks=&lt;string&gt;
- Comma-separated list of globs with optional '-' <br>
prefix. Globs are processed in order of <br>
appearance in the list. Globs without '-' <br>
prefix add checks with matching names to the <br>
set, globs with the '-' prefix remove checks <br>
with matching names from the set of enabled <br>
checks. This option's value is appended to the <br>
value of the 'Checks' option in .clang-tidy <br>
file, if any. <br>
--config=&lt;string&gt; - Specifies a configuration in
YAML/JSON format: <br>
-config=&quot;{Checks: '*', <br>
CheckOptions: {x: y}}&quot; <br>
When the value is empty, clang-tidy will <br>
attempt to find a file named .clang-tidy for <br>
each source file in its parent directories. <br>
--config-file=&lt;string&gt; - Specify the path of
.clang-tidy or custom config file: <br>
e.g. --config-file=/some/path/myTidyConfigFile <br>
This option internally works exactly the same way as <br>
--config option after reading specified config file. <br>
Use either --config-file or --config, not both. <br>
--dump-config - Dumps configuration in the YAML format to
<br>
stdout. This option can be used along with a <br>
file name (and '--' if the file is outside of a <br>
project with configured compilation database). <br>
The configuration used for this file will be <br>
printed. <br>
Use along with -checks=* to include <br>
configuration of all checks. <br>
--enable-check-profile - Enable per-check timing profiles,
and print a <br>
report to stderr. <br>
--enable-module-headers-parsing - Enables preprocessor-level
module header parsing <br>
for C++20 and above, empowering specific checks <br>
to detect macro definitions within modules. This <br>
feature may cause performance and parsing issues <br>
and is therefore considered experimental. <br>
--exclude-header-filter=&lt;string&gt; - Regular expression
matching the names of the <br>
headers to exclude diagnostics from. Diagnostics <br>
from the main file of each translation unit are <br>
always displayed. <br>
Must be used together with --header-filter. <br>
Can be used together with -line-filter. <br>
This option overrides the 'ExcludeHeaderFilterRegex' <br>
option in .clang-tidy file, if any. <br>
--explain-config - For each enabled check explains, where it
is <br>
enabled, i.e. in clang-tidy binary, command <br>
line or a specific configuration file. <br>
--export-fixes=&lt;filename&gt; - YAML file to store
suggested fixes in. The <br>
stored fixes can be applied to the input source <br>
code with clang-apply-replacements. <br>
--extra-arg=&lt;string&gt; - Additional argument to append
to the compiler command line <br>
--extra-arg-before=&lt;string&gt; - Additional argument to
prepend to the compiler command line <br>
--fix - Apply suggested fixes. Without -fix-errors <br>
clang-tidy will bail out if any compilation <br>
errors were found. <br>
--fix-errors - Apply suggested fixes even if compilation
<br>
errors were found. If compiler errors have <br>
attached fix-its, clang-tidy will apply them as <br>
well. <br>
--fix-notes - If a warning has no fix, but a single fix can
<br>
be found through an associated diagnostic note, <br>
apply the fix. <br>
Specifying this flag will implicitly enable the <br>
'--fix' flag. <br>
--format-style=&lt;string&gt; - Style for formatting code
around applied fixes: <br>
- 'none' (default) turns off formatting <br>
- 'file' (literally 'file', not a placeholder) <br>
uses .clang-format file in the closest parent <br>
directory <br>
- '{ &lt;json&gt; }' specifies options inline, e.g. <br>
-format-style='{BasedOnStyle: llvm, IndentWidth: 8}' <br>
- 'llvm', 'google', 'webkit', 'mozilla' <br>
See clang-format documentation for the up-to-date <br>
information about formatting styles and options. <br>
This option overrides the 'FormatStyle` option in <br>
.clang-tidy file, if any. <br>
--header-filter=&lt;string&gt; - Regular expression matching
the names of the <br>
headers to output diagnostics from. Diagnostics <br>
from the main file of each translation unit are <br>
always displayed. <br>
Can be used together with -line-filter. <br>
This option overrides the 'HeaderFilterRegex' <br>
option in .clang-tidy file, if any. <br>
--line-filter=&lt;string&gt; - List of files with line
ranges to filter the <br>
warnings. Can be used together with <br>
-header-filter. The format of the list is a <br>
JSON array of objects: <br>
[ <br>

{&quot;name&quot;:&quot;file1.cpp&quot;,&quot;lines&quot;:[[1,3],[5,7]]},
<br>
{&quot;name&quot;:&quot;file2.h&quot;} <br>
] <br>
--list-checks - List all enabled checks and exit. Use with
<br>
-checks=* to list all available checks. <br>
--load=&lt;pluginfilename&gt; - Load the specified plugin
<br>
-p &lt;string&gt; - Build path <br>
--quiet - Run clang-tidy in quiet mode. This suppresses <br>
printing statistics about ignored warnings and <br>
warnings treated as errors if the respective <br>
options are specified. <br>
--store-check-profile=&lt;prefix&gt; - By default reports
are printed in tabulated <br>
format to stderr. When this option is passed, <br>
these per-TU profiles are instead stored as JSON. <br>
--system-headers - Display the errors from system headers.
<br>
This option overrides the 'SystemHeaders' option <br>
in .clang-tidy file, if any. <br>
--use-color - Use colors in diagnostics. If not set, colors
<br>
will be used if the terminal connected to <br>
standard output supports colors. <br>
This option overrides the 'UseColor' option in <br>
.clang-tidy file, if any. <br>
--verify-config - Check the config files to ensure each
check and <br>
option is recognized. <br>
--vfsoverlay=&lt;filename&gt; - Overlay the virtual
filesystem described by file <br>
over the real file system. <br>
--warnings-as-errors=&lt;string&gt; - Upgrades warnings to
errors. Same format as <br>
'-checks'. <br>
This option's value is appended to the value of <br>
the 'WarningsAsErrors' option in .clang-tidy <br>
file, if any. <br>
--allow-no-checks - Allow empty enabled checks. This
suppresses <br>
the &quot;no checks enabled&quot; error when disabling <br>
all of the checks.</p>

<p style="margin-left:13%; margin-top: 1em">-p
&lt;build-path&gt; is used to read a compile command
database.</p>

<p style="margin-left:13%; margin-top: 1em">For example, it
can be a CMake build directory in which a file named <br>
compile_commands.json exists (use
-DCMAKE_EXPORT_COMPILE_COMMANDS=ON <br>
CMake option to get this output). When no build path is
specified, <br>
a search for compile_commands.json will be attempted through
all <br>
parent paths of the first input file . See: <br>
https://clang.llvm.org/docs/HowToSetupToolingForLLVM.html
for an <br>
example of setting up Clang Tooling on a source tree.</p>


<p style="margin-left:13%; margin-top: 1em">&lt;source0&gt;
... specify the paths of source files. These paths are <br>
looked up in the compile command database. If the path of a
file is <br>
absolute, it needs to point into CMake's source tree. If the
path is <br>
relative, the current working directory needs to be in the
CMake <br>
source tree and the file must be in a subdirectory of the
current <br>
working directory. &quot;./&quot; prefixes in the relative
files will be <br>
automatically removed, but the rest of a relative path must
be a <br>
suffix of a path in the compile command database.</p>

<p style="margin-left:13%; margin-top: 1em">Configuration
files: <br>
clang-tidy attempts to read configuration for each source
file from a <br>
.clang-tidy file located in the closest parent directory of
the source <br>
file. The .clang-tidy file is specified in YAML format. If
any configuration <br>
options have a corresponding command-line option,
command-line option takes <br>
precedence.</p>

<p style="margin-left:13%; margin-top: 1em">The following
configuration options may be used in a .clang-tidy file:</p>

<p style="margin-left:13%; margin-top: 1em">CheckOptions -
List of key-value pairs defining check-specific <br>
options. Example: <br>
CheckOptions: <br>
some-check.SomeOption: 'some value' <br>
Checks - Same as '--checks'. Additionally, the list of <br>
globs can be specified as a list instead of a <br>
string. <br>
ExcludeHeaderFilterRegex - Same as
'--exclude-header-filter'. <br>
ExtraArgs - Same as '--extra-args'. <br>
ExtraArgsBefore - Same as '--extra-args-before'. <br>
FormatStyle - Same as '--format-style'. <br>
HeaderFileExtensions - File extensions to consider to
determine if a <br>
given diagnostic is located in a header file. <br>
HeaderFilterRegex - Same as '--header-filter-regex'. <br>
ImplementationFileExtensions - File extensions to consider
to determine if a <br>
given diagnostic is located in an <br>
implementation file. <br>
InheritParentConfig - If this option is true in a config
file, the <br>
configuration file in the parent directory <br>
(if any exists) will be taken and the current <br>
config file will be applied on top of the <br>
parent one. <br>
SystemHeaders - Same as '--system-headers'. <br>
UseColor - Same as '--use-color'. <br>
User - Specifies the name or e-mail of the user <br>
running clang-tidy. This option is used, for <br>
example, to place the correct user name in <br>
TODO() comments in the relevant check. <br>
WarningsAsErrors - Same as '--warnings-as-errors'.</p>

<p style="margin-left:13%; margin-top: 1em">The effective
configuration can be inspected using --dump-config:</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-tidy
--dump-config <br>
--- <br>
Checks: '-*,some-check' <br>
WarningsAsErrors: '' <br>
HeaderFileExtensions: ['', 'h','hh','hpp','hxx'] <br>
ImplementationFileExtensions: ['c','cc','cpp','cxx'] <br>
HeaderFilterRegex: '' <br>
FormatStyle: none <br>
InheritParentConfig: true <br>
User: user <br>
CheckOptions: <br>
some-check.SomeOption: 'some value' <br>
...</p>

<h3>Suppressing Undesired Diagnostics
<a name="Suppressing Undesired Diagnostics"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>clang-tidy</b>
diagnostics are intended to call out code that does not
adhere to a coding standard, or is otherwise problematic in
some way. However, if the code is known to be correct, it
may be useful to silence the warning. Some clang-tidy checks
provide a check-specific way to silence the diagnostics,
e.g. <i>bugprone-use-after-move</i> can be silenced by
re-initializing the variable after it has been moved out,
<i>bugprone-string-integer-assignment</i> can be suppressed
by explicitly casting the integer to <b>char</b>,
<i>readability-implicit-bool-conversion</i> can also be
suppressed by using explicit casts, etc.</p>

<p style="margin-left:9%; margin-top: 1em">If a specific
suppression mechanism is not available for a certain
warning, or its use is not desired for some reason,
<b>clang-tidy</b> has a generic mechanism to suppress
diagnostics using <b>NOLINT</b>, <b>NOLINTNEXTLINE</b>, and
<b>NOLINTBEGIN</b> ... <b>NOLINTEND</b> comments.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>NOLINT</b> comment instructs <b>clang-tidy</b> to ignore
warnings on the <i>same line</i> (it doesn't apply to a
function, a block of code or any other language construct;
it applies to the line of code it is on). If introducing the
comment on the same line would change the formatting in an
undesired way, the <b>NOLINTNEXTLINE</b> comment allows
suppressing clang-tidy warnings on the <i>next line</i>. The
<b>NOLINTBEGIN</b> and <b>NOLINTEND</b> comments allow
suppressing clang-tidy warnings on <i>multiple lines</i>
(affecting all lines between the two comments).</p>

<p style="margin-left:9%; margin-top: 1em">All comments can
be followed by an optional list of check names in
parentheses (see below for the formal syntax). The list of
check names supports globbing, with the same format and
semantics as for enabling checks. Note: negative globs are
ignored here, as they would effectively re-activate the
warning.</p>

<p style="margin-left:9%; margin-top: 1em">For example:</p>

<p style="margin-left:13%; margin-top: 1em">class Foo {
<br>
// Suppress all the diagnostics for the line <br>
Foo(int param); // NOLINT</p>

<p style="margin-left:13%; margin-top: 1em">// Consider
explaining the motivation to suppress the warning <br>
Foo(char param); // NOLINT: Allow implicit conversion from
`char`, because &lt;some valid reason&gt;</p>

<p style="margin-left:13%; margin-top: 1em">// Silence only
the specified checks for the line <br>
Foo(double param); // NOLINT(google-explicit-constructor,
google-runtime-int)</p>

<p style="margin-left:13%; margin-top: 1em">// Silence all
checks from the `google` module <br>
Foo(bool param); // NOLINT(google*)</p>

<p style="margin-left:13%; margin-top: 1em">// Silence all
checks ending with `-avoid-c-arrays` <br>
int array[10]; // NOLINT(*-avoid-c-arrays)</p>

<p style="margin-left:13%; margin-top: 1em">// Silence only
the specified diagnostics for the next line <br>
// NOLINTNEXTLINE(google-explicit-constructor,
google-runtime-int) <br>
Foo(bool param);</p>

<p style="margin-left:13%; margin-top: 1em">// Silence all
checks from the `google` module for the next line <br>
// NOLINTNEXTLINE(google*) <br>
Foo(bool param);</p>

<p style="margin-left:13%; margin-top: 1em">// Silence all
checks ending with `-avoid-c-arrays` for the next line <br>
// NOLINTNEXTLINE(*-avoid-c-arrays) <br>
int array[10];</p>

<p style="margin-left:13%; margin-top: 1em">// Silence only
the specified checks for all lines between the BEGIN and END
<br>
// NOLINTBEGIN(google-explicit-constructor,
google-runtime-int) <br>
Foo(short param); <br>
Foo(long param); <br>
// NOLINTEND(google-explicit-constructor,
google-runtime-int)</p>

<p style="margin-left:13%; margin-top: 1em">// Silence all
checks from the `google` module for all lines between the
BEGIN and END <br>
// NOLINTBEGIN(google*) <br>
Foo(bool param); <br>
// NOLINTEND(google*)</p>

<p style="margin-left:13%; margin-top: 1em">// Silence all
checks ending with `-avoid-c-arrays` for all lines between
the BEGIN and END <br>
// NOLINTBEGIN(*-avoid-c-arrays) <br>
int array[10]; <br>
// NOLINTEND(*-avoid-c-arrays) <br>
};</p>

<p style="margin-left:9%; margin-top: 1em">The formal
syntax of <b>NOLINT</b>, <b>NOLINTNEXTLINE</b>, and
<b>NOLINTBEGIN</b> ... <b>NOLINTEND</b> is the
following:</p>

<p style="margin-left:13%; margin-top: 1em">lint-comment:
<br>
lint-command <br>
lint-command lint-args</p>

<p style="margin-left:13%; margin-top: 1em">lint-args:
<b><br>
(</b> check-name-list <b>)</b></p>


<p style="margin-left:13%; margin-top: 1em">check-name-list:
<i><br>
check-name</i> <br>
check-name-list <b>,</b> <i>check-name</i></p>

<p style="margin-left:13%; margin-top: 1em">lint-command:
<b><br>
NOLINT <br>
NOLINTNEXTLINE <br>
NOLINTBEGIN <br>
NOLINTEND</b></p>

<p style="margin-left:9%; margin-top: 1em">Note that
whitespaces between
<b>NOLINT</b>/<b>NOLINTNEXTLINE</b>/<b>NOLINTBEGIN</b>/<b>NOLINTEND</b>
and the opening parenthesis are not allowed (in this case
the comment will be treated just as
<b>NOLINT</b>/<b>NOLINTNEXTLINE</b>/<b>NOLINTBEGIN</b>/<b>NOLINTEND</b>),
whereas in the check names list (inside the parentheses),
whitespaces can be used and will be ignored.</p>

<p style="margin-left:9%; margin-top: 1em">All
<b>NOLINTBEGIN</b> comments must be paired by an equal
number of <b>NOLINTEND</b> comments. Moreover, a pair of
comments must have matching arguments -- for example,
<b>NOLINTBEGIN(check-name)</b> can be paired with
<b>NOLINTEND(check-name)</b> but not with <b>NOLINTEND</b>
<i>(zero arguments)</i>. <b>clang-tidy</b> will generate a
<b>clang-tidy-nolint</b> error diagnostic if any
<b>NOLINTBEGIN</b>/<b>NOLINTEND</b> comment violates these
requirements.</p>

<h2>CLANG-INCLUDE-FIXER
<a name="CLANG-INCLUDE-FIXER"></a>
</h2>


<h3>Contents
<a name="Contents"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="24%">


<p style="margin-top: 1em"><i>Clang-Include-Fixer</i></p></td>
<td width="64%">
</td></tr>
</table>

<p style="margin-left:12%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="7%">


<p style="margin-top: 1em"><i>Setup</i></p></td>
<td width="79%">
</td></tr>
</table>

<p style="margin-left:14%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%"></td>
<td width="2%"></td>
<td width="65%">


<p style="margin-top: 1em"><i>Creating a Symbol Index From
a Compilation Database</i></p></td>
<td width="18%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="65%">


<p><i>Integrate with Vim</i></p></td>
<td width="18%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="65%">


<p><i>Integrate with Emacs</i></p></td>
<td width="18%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="65%"></td>
<td width="18%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em"><i>How it
Works</i></p>

<p style="margin-left:9%; margin-top: 1em">One of the major
nuisances of C++ compared to other languages is the manual
management of <b>#include</b> directives in any file.
<b>clang-include-fixer</b> addresses one aspect of this
problem by providing an automated way of adding
<b>#include</b> directives for missing symbols in one
translation unit.</p>

<p style="margin-left:9%; margin-top: 1em">While inserting
missing <b>#include</b>, <b>clang-include-fixer</b> adds
missing namespace qualifiers to all instances of an
unidentified symbol if the symbol is missing some prefix
namespace qualifiers.</p>

<h3>Setup
<a name="Setup"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">To use
<b>clang-include-fixer</b> two databases are required. Both
can be generated with existing tools.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Compilation database. Contains
the compiler commands for any given file in a project and
can be generated by CMake, see <i>How To Setup Tooling For
LLVM</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Symbol index. Contains all symbol information in a
project to match a given identifier to a header file.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Ideally both
databases (<b>compile_commands.json</b> and
<b>find_all_symbols_db.yaml</b>) are linked into the root of
the source tree they correspond to. Then the
<b>clang-include-fixer</b> can automatically pick them up if
called with a source file from that tree. Note that by
default <b>compile_commands.json</b> as generated by CMake
does not include header files, so only implementation files
can be handled by tools.</p>

<h3>Creating a Symbol Index From a Compilation Database
<a name="Creating a Symbol Index From a Compilation Database"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The include
fixer contains <b>find-all-symbols</b>, a tool to create a
symbol database in YAML format from a compilation database
by parsing all source files listed in it. The following list
of commands shows how to set up a database for LLVM, any
project built by CMake should follow similar steps.</p>

<p style="margin-left:13%; margin-top: 1em">$ cd
path/to/llvm-build <br>
$ ninja find-all-symbols // build find-all-symbols tool.
<br>
$ ninja clang-include-fixer // build clang-include-fixer
tool. <br>
$ ls compile_commands.json # Make sure compile_commands.json
exists. <br>
compile_commands.json <br>
$
path/to/llvm/source/clang-tools-extra/clang-include-fixer/find-all-symbols/tool/run-find-all-symbols.py
<br>
... wait as clang indexes the code base ... <br>
$ ln -s $PWD/find_all_symbols_db.yaml path/to/llvm/source/ #
Link database into the source tree. <br>
$ ln -s $PWD/compile_commands.json path/to/llvm/source/ #
Also link compilation database if it's not there already.
<br>
$ cd path/to/llvm/source <br>
$ /path/to/clang-include-fixer -db=yaml
path/to/file/with/missing/include.cpp <br>
Added #include &quot;foo.h&quot;</p>

<h3>Integrate with Vim
<a name="Integrate with Vim"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">To run
<i>clang-include-fixer</i> on a potentially unsaved buffer
in Vim. Add the following key binding to your
<b>.vimrc</b>:</p>

<p style="margin-left:13%; margin-top: 1em">noremap
&lt;leader&gt;cf :pyf
path/to/llvm/source/clang-tools-extra/clang-include-fixer/tool/clang-include-fixer.py&lt;cr&gt;</p>

<p style="margin-left:9%; margin-top: 1em">This enables
<i>clang-include-fixer</i> for NORMAL and VISUAL mode.
Change <i>&lt;leader&gt;cf</i> to another binding if you
need clang-include-fixer on a different key. The
<i>&lt;leader&gt; key</i> is a reference to a specific key
defined by the mapleader variable and is bound to backslash
by default.</p>

<p style="margin-left:9%; margin-top: 1em">Make sure vim
can find <b>clang-include-fixer</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Add the path to
<b>clang-include-fixer</b> to the PATH environment
variable.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Or set <b>g:clang_include_fixer_path</b> in vimrc:
<b>let
g:clang_include_fixer_path=path/to/clang-include-fixer</b></p> </td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">You can
customize the number of headers being shown by setting
<b>let
g:clang_include_fixer_maximum_suggested_headers=5</b></p>

<p style="margin-left:9%; margin-top: 1em">Customized
settings in <i>.vimrc</i>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p style="margin-top: 1em"><b>let
g:clang_include_fixer_path =
&quot;clang-include-fixer&quot;</b></p> </td>
<td width="19%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Set
clang-include-fixer binary file path.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="70%">


<p style="margin-top: 1em"><b>let
g:clang_include_fixer_maximum_suggested_headers = 3</b></p></td>
<td width="18%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Set the maximum
number of <b>#includes</b> to show. Default is 3.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="55%">


<p style="margin-top: 1em"><b>let
g:clang_include_fixer_increment_num = 5</b></p></td>
<td width="33%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Set the
increment number of #includes to show every time when
pressing <b>m</b>. Default is 5.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="57%">


<p style="margin-top: 1em"><b>let
g:clang_include_fixer_jump_to_include = 0</b></p></td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Set to 1 if you
want to jump to the new inserted <b>#include</b> line.
Default is 0.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="51%">


<p style="margin-top: 1em"><b>let
g:clang_include_fixer_query_mode = 0</b></p></td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:12%; margin-top: 1em">Set to 1 if you
want to insert <b>#include</b> for the symbol under the
cursor. Default is 0. Compared to normal mode, this mode
won't parse the source file and only search the symbol from
database, which is faster than normal mode.</p>

<p style="margin-left:9%; margin-top: 1em">See
<b>clang-include-fixer.py</b> for more details.</p>

<h3>Integrate with Emacs
<a name="Integrate with Emacs"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">To run
<i>clang-include-fixer</i> on a potentially unsaved buffer
in Emacs. Ensure that Emacs finds
<b>clang-include-fixer.el</b> by adding the directory
containing the file to the <b>load-path</b> and requiring
the <i>clang-include-fixer</i> in your <b>.emacs</b>:</p>

<p style="margin-left:13%; margin-top: 1em">(add-to-list
'load-path
&quot;path/to/llvm/source/clang-tools-extra/clang-include-fixer/tool/&quot;
<br>
(require 'clang-include-fixer)</p>

<p style="margin-left:9%; margin-top: 1em">Within Emacs the
tool can be invoked with the command <b>M-x
clang-include-fixer</b>. This will insert the header that
defines the first undefined symbol; if there is more than
one header that would define the symbol, the user is
prompted to select one.</p>

<p style="margin-left:9%; margin-top: 1em">To include the
header that defines the symbol at point, run <b>M-x
clang-include-fixer-at-point</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Make sure Emacs
can find <b>clang-include-fixer</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Either add the parent directory
of <b>clang-include-fixer</b> to the PATH environment
variable, or customize the Emacs user option
<b>clang-include-fixer-executable</b> to point to the file
name of the program.</p></td></tr>
</table>

<h3>How it Works
<a name="How it Works"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">To get the most
information out of Clang at parse time,
<b>clang-include-fixer</b> runs in tandem with the parse and
receives callbacks from Clang's semantic analysis. In
particular it reuses the existing support for typo
corrections. Whenever Clang tries to correct a potential
typo it emits a callback to the include fixer which then
looks for a corresponding file. At this point rich lookup
information is still available, which is not available in
the AST at a later stage.</p>

<p style="margin-left:9%; margin-top: 1em">The identifier
that should be typo corrected is then sent to the database,
if a header file is returned it is added as an include
directive at the top of the file.</p>

<p style="margin-left:9%; margin-top: 1em">Currently
<b>clang-include-fixer</b> only inserts a single include at
a time to avoid getting caught in follow-up errors. If
multiple <i>#include</i> additions are desired the program
can be rerun until a fix-point is reached.</p>

<h2>MODULARIZE USER&rsquo;S MANUAL
<a name="MODULARIZE USER&rsquo;S MANUAL"></a>
</h2>


<h3>Modularize Usage
<a name="Modularize Usage"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>modularize
[&lt;modularize-options&gt;]
[&lt;module-map&gt;|&lt;include-files-list&gt;]*
[&lt;front-end-options&gt;...]</b></p>


<p style="margin-left:9%; margin-top: 1em"><b>&lt;modularize-options&gt;</b>
is a place-holder for options specific to modularize, which
are described below in <i>Modularize Command Line
Options</i>.</p>


<p style="margin-left:9%; margin-top: 1em"><b>&lt;module-map&gt;</b>
specifies the path of a file name for an existing module
map. The module map must be well-formed in terms of syntax.
Modularize will extract the header file names from the map.
Only normal headers are checked, assuming headers marked
&quot;private&quot;, &quot;textual&quot;, or
&quot;exclude&quot; are not to be checked as a top-level
include, assuming they either are included by other headers
which are checked, or they are not suitable for modules.</p>


<p style="margin-left:9%; margin-top: 1em"><b>&lt;include-files-list&gt;</b>
specifies the path of a file name for a file containing the
newline-separated list of headers to check with respect to
each other. Lines beginning with '#' and empty lines are
ignored. Header file names followed by a colon and other
space-separated file names will include those extra files as
dependencies. The file names can be relative or full paths,
but must be on the same line. For example:</p>

<p style="margin-left:13%; margin-top: 1em">header1.h <br>
header2.h <br>
header3.h: header1.h header2.h</p>

<p style="margin-left:9%; margin-top: 1em">Note that unless
a <b>-prefix (header path)</b> option is specified,
non-absolute file paths in the header list file will be
relative to the header list file directory. Use -prefix to
specify a different directory.</p>


<p style="margin-left:9%; margin-top: 1em"><b>&lt;front-end-options&gt;</b>
is a place-holder for regular Clang front-end arguments,
which must follow the &lt;include-files-list&gt;. Note that
by default, modularize assumes .h files contain C++ source,
so if you are using a different language, you might need to
use a <b>-x</b> option to tell Clang that the header
contains another language, i.e.: <b>-x c</b></p>

<p style="margin-left:9%; margin-top: 1em">Note also that
because modularize does not use the clang driver, you will
likely need to pass in additional compiler front-end
arguments to match those passed in by default by the
driver.</p>

<h3>Modularize Command Line Options
<a name="Modularize Command Line Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>-prefix=&lt;header-path&gt;</b></p>

<p style="margin-left:18%;">Prepend the given path to
non-absolute file paths in the header list file. By default,
headers are assumed to be relative to the header list file
directory. Use <b>-prefix</b> to specify a different
directory.</p>


<p style="margin-left:9%;"><b>-module-map-path=&lt;module-map-path&gt;</b></p>

<p style="margin-left:18%;">Generate a module map and
output it to the given file. See the description in
<i>Module Map Generation</i>.</p>


<p style="margin-left:9%;"><b>-problem-files-list=&lt;problem-files-list-file-name&gt;</b></p>

<p style="margin-left:18%;">For use only with module map
assistant. Input list of files that have problems with
respect to modules. These will still be included in the
generated module map, but will be marked as
&quot;excluded&quot; headers.</p>


<p style="margin-left:9%;"><b>-root-module=&lt;root-name&gt;</b></p>

<p style="margin-left:18%;">Put modules generated by the
-module-map-path option in an enclosing module with the
given name. See the description in <i>Module Map
Generation</i>.</p>


<p style="margin-left:9%;"><b>-block-check-header-list-only</b></p>

<p style="margin-left:18%;">Limit the
#include-inside-extern-or-namespace-block check to only
those headers explicitly listed in the header list. This is
a work-around for avoiding error messages for private
includes that purposefully get included inside blocks.</p>

<p style="margin-left:9%;"><b>-no-coverage-check</b></p>

<p style="margin-left:18%;">Don't do the coverage check for
a module map.</p>

<p style="margin-left:9%;"><b>-coverage-check-only</b></p>

<p style="margin-left:18%;">Only do the coverage check for
a module map.</p>

<p style="margin-left:9%;"><b>-display-file-lists</b></p>

<p style="margin-left:18%;">Display lists of good files (no
compile errors), problem files, and a combined list with
problem files preceded by a '#'. This can be used to quickly
determine which files have problems. The latter combined
list might be useful in starting to modularize a set of
headers. You can start with a full list of headers, use
-display-file-lists option, and then use the combined list
as your intermediate list, uncommenting-out headers as you
fix them.</p>


<p style="margin-left:9%; margin-top: 1em"><b>modularize</b>
is a standalone tool that checks whether a set of headers
provides the consistent definitions required to use modules.
For example, it detects whether the same entity (say, a NULL
macro or size_t typedef) is defined in multiple headers or
whether a header produces different definitions under
different circumstances. These conditions cause modules
built from the headers to behave poorly, and should be fixed
before introducing a module map.</p>


<p style="margin-left:9%; margin-top: 1em"><b>modularize</b>
also has an assistant mode option for generating a module
map file based on the provided header list. The generated
file is a functional module map that can be used as a
starting point for a module.modulemap file.</p>

<h3>Getting Started
<a name="Getting Started"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">To build from
source:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="87%">


<p>Read <i>Getting Started with the LLVM System</i> and
<i>Clang Tools Documentation</i> for information on getting
sources for LLVM, Clang, and Clang Extra Tools.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="87%">


<p><i>Getting Started with the LLVM System</i> and
<i>Building LLVM with CMake</i> give directions for how to
build. With sources all checked out into the right place the
LLVM build will build Clang Extra Tools and their
dependencies automatically.</p></td></tr>
</table>

<p style="margin-left:13%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="85%">


<p style="margin-top: 1em">If using CMake, you can also use
the <b>modularize</b> target to build just the modularize
tool and its dependencies.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Before
continuing, take a look at <i>Modularize Usage</i> to see
how to invoke modularize.</p>

<h3>What Modularize Checks
<a name="What Modularize Checks"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Modularize will
check for the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Duplicate global type and
variable definitions</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Duplicate macro definitions</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Macro instances, 'defined(macro)', or #if, #elif,
#ifdef, #ifndef conditions that evaluate differently in a
header</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>#include directives inside 'extern &quot;C/C++&quot; {}'
or 'namespace (name) {}' blocks</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Module map header coverage completeness (in the case of
a module map input only)</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Modularize will
do normal C/C++ parsing, reporting normal errors and
warnings, but will also report special error messages like
the following:</p>

<p style="margin-left:13%; margin-top: 1em">error:
'(symbol)' defined at multiple locations: <br>
(file):(row):(column) <br>
(file):(row):(column)</p>

<p style="margin-left:13%; margin-top: 1em">error: header
'(file)' has different contents depending on how it was
included</p>

<p style="margin-left:9%; margin-top: 1em">The latter might
be followed by messages like the following:</p>

<p style="margin-left:13%; margin-top: 1em">note:
'(symbol)' in (file) at (row):(column) not always
provided</p>

<p style="margin-left:9%; margin-top: 1em">Checks will also
be performed for macro expansions, defined(macro)
expressions, and preprocessor conditional directives that
evaluate inconsistently, and can produce error messages like
the following:</p>


<p style="margin-left:13%; margin-top: 1em">(...)/SubHeader.h:11:5:
<br>
#if SYMBOL == 1 <br>
&#710; <br>
error: Macro instance 'SYMBOL' has different values in this
header, <br>
depending on how it was included. <br>
'SYMBOL' expanded to: '1' with respect to these inclusion
paths: <br>
(...)/Header1.h <br>
(...)/SubHeader.h <br>
(...)/SubHeader.h:3:9: <br>
#define SYMBOL 1 <br>
&#710; <br>
Macro defined here. <br>
'SYMBOL' expanded to: '2' with respect to these inclusion
paths: <br>
(...)/Header2.h <br>
(...)/SubHeader.h <br>
(...)/SubHeader.h:7:9: <br>
#define SYMBOL 2 <br>
&#710; <br>
Macro defined here.</p>

<p style="margin-left:9%; margin-top: 1em">Checks will also
be performed for '#include' directives that are nested
inside 'extern &quot;C/C++&quot; {}' or 'namespace (name)
{}' blocks, and can produce error message like the
following:</p>


<p style="margin-left:13%; margin-top: 1em">IncludeInExtern.h:2:3:
<br>
#include &quot;Empty.h&quot; <br>
&#710; <br>
error: Include directive within extern &quot;C&quot; {}.
<br>
IncludeInExtern.h:1:1: <br>
extern &quot;C&quot; { <br>
&#710; <br>
The &quot;extern &quot;C&quot; {}&quot; block is here.</p>

<h3>Module Map Coverage Check
<a name="Module Map Coverage Check"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The coverage
check uses the Clang library to read and parse the module
map file. Starting at the module map file directory, or just
the include paths, if specified, it will collect the names
of all the files it considers headers (no extension, .h, or
.inc--if you need more, modify the isHeader function). It
then compares the headers against those referenced in the
module map, either explicitly named, or implicitly named via
an umbrella directory or umbrella file, as parsed by the
ModuleMap object. If headers are found which are not
referenced or covered by an umbrella directory or file,
warning messages will be produced, and this program will
return an error code of 1. If no problems are found, an
error code of 0 is returned.</p>

<p style="margin-left:9%; margin-top: 1em">Note that in the
case of umbrella headers, this tool invokes the compiler to
preprocess the file, and uses a callback to collect the
header files included by the umbrella header or any of its
nested includes. If any front end options are needed for
these compiler invocations, these can be included on the
command line after the module map file argument.</p>

<p style="margin-left:9%; margin-top: 1em">Warning message
have the form:</p>

<p style="margin-left:13%;">warning: module.modulemap does
not account for file: Level3A.h</p>

<p style="margin-left:9%; margin-top: 1em">Note that for
the case of the module map referencing a file that does not
exist, the module map parser in Clang will (at the time of
this writing) display an error message.</p>

<p style="margin-left:9%; margin-top: 1em">To limit the
checks <b>modularize</b> does to just the module map
coverage check, use the <b>-coverage-check-only
option</b>.</p>

<p style="margin-left:9%; margin-top: 1em">For example:</p>

<p style="margin-left:13%; margin-top: 1em">modularize
-coverage-check-only module.modulemap</p>

<h3>Module Map Generation
<a name="Module Map Generation"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">If you specify
the <b>-module-map-path=&lt;module map file&gt;</b>,
<b>modularize</b> will output a module map based on the
input header list. A module will be created for each header.
Also, if the header in the header list is a partial path, a
nested module hierarchy will be created in which a module
will be created for each subdirectory component in the
header path, with the header itself represented by the
innermost module. If other headers use the same
subdirectories, they will be enclosed in these same modules
also.</p>

<p style="margin-left:9%; margin-top: 1em">For example, for
the header list:</p>

<p style="margin-left:13%; margin-top: 1em">SomeTypes.h
<br>
SomeDecls.h <br>
SubModule1/Header1.h <br>
SubModule1/Header2.h <br>
SubModule2/Header3.h <br>
SubModule2/Header4.h <br>
SubModule2.h</p>

<p style="margin-left:9%; margin-top: 1em">The following
module map will be generated:</p>

<p style="margin-left:13%; margin-top: 1em">//
Output/NoProblemsAssistant.txt <br>
// Generated by: modularize
-module-map-path=Output/NoProblemsAssistant.txt \ <br>
-root-module=Root NoProblemsAssistant.modularize</p>

<p style="margin-left:13%; margin-top: 1em">module
SomeTypes { <br>
header &quot;SomeTypes.h&quot; <br>
export * <br>
} <br>
module SomeDecls { <br>
header &quot;SomeDecls.h&quot; <br>
export * <br>
} <br>
module SubModule1 { <br>
module Header1 { <br>
header &quot;SubModule1/Header1.h&quot; <br>
export * <br>
} <br>
module Header2 { <br>
header &quot;SubModule1/Header2.h&quot; <br>
export * <br>
} <br>
} <br>
module SubModule2 { <br>
module Header3 { <br>
header &quot;SubModule2/Header3.h&quot; <br>
export * <br>
} <br>
module Header4 { <br>
header &quot;SubModule2/Header4.h&quot; <br>
export * <br>
} <br>
header &quot;SubModule2.h&quot; <br>
export * <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">An optional
<b>-root-module=&lt;root-name&gt;</b> option can be used to
cause a root module to be created which encloses all the
modules.</p>

<p style="margin-left:9%; margin-top: 1em">An optional
<b>-problem-files-list=&lt;problem-file-name&gt;</b> can be
used to input a list of files to be excluded, perhaps as a
temporary stop-gap measure until problem headers can be
fixed.</p>

<p style="margin-left:9%; margin-top: 1em">For example,
with the same header list from above:</p>

<p style="margin-left:13%; margin-top: 1em">//
Output/NoProblemsAssistant.txt <br>
// Generated by: modularize
-module-map-path=Output/NoProblemsAssistant.txt \ <br>
-root-module=Root NoProblemsAssistant.modularize</p>

<p style="margin-left:13%; margin-top: 1em">module Root {
<br>
module SomeTypes { <br>
header &quot;SomeTypes.h&quot; <br>
export * <br>
} <br>
module SomeDecls { <br>
header &quot;SomeDecls.h&quot; <br>
export * <br>
} <br>
module SubModule1 { <br>
module Header1 { <br>
header &quot;SubModule1/Header1.h&quot; <br>
export * <br>
} <br>
module Header2 { <br>
header &quot;SubModule1/Header2.h&quot; <br>
export * <br>
} <br>
} <br>
module SubModule2 { <br>
module Header3 { <br>
header &quot;SubModule2/Header3.h&quot; <br>
export * <br>
} <br>
module Header4 { <br>
header &quot;SubModule2/Header4.h&quot; <br>
export * <br>
} <br>
header &quot;SubModule2.h&quot; <br>
export * <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Note that
headers with dependents will be ignored with a warning, as
the Clang module mechanism doesn't support headers that rely
on other headers being included first.</p>

<p style="margin-left:9%; margin-top: 1em">The module map
format defines some keywords which can't be used in module
names. If a header has one of these names, an underscore
('_') will be prepended to the name. For example, if the
header name is <b>header.h</b>, because <b>header</b> is a
keyword, the module name will be <b>_header</b>. For a list
of the module map keywords, please see: <i>Lexical
structure</i></p>

<h2>PP-TRACE USER&rsquo;S MANUAL
<a name="PP-TRACE USER&rsquo;S MANUAL"></a>
</h2>



<p style="margin-left:9%; margin-top: 1em"><i><b>pp-trace</b></i>
is a standalone tool that traces preprocessor activity. It's
also used as a test of Clang's PPCallbacks interface. It
runs a given source file through the Clang preprocessor,
displaying selected information from callback functions
overridden in a <i>PPCallbacks</i> derivation. The output is
in a high-level YAML format, described in <i>pp-trace Output
Format</i>.</p>

<h3>pp-trace Usage
<a name="pp-trace Usage"></a>
</h3>


<h3>Command Line Format
<a name="Command Line Format"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>pp-trace
[&lt;pp-trace-options&gt;] &lt;source-file&gt; [--
&lt;front-end-options&gt;]</b></p>


<p style="margin-left:9%; margin-top: 1em"><b>&lt;pp-trace-options&gt;</b>
is a place-holder for options specific to pp-trace, which
are described below in <i>Command Line Options</i>.</p>


<p style="margin-left:9%; margin-top: 1em"><b>&lt;source-file&gt;</b>
specifies the source file to run through the
preprocessor.</p>


<p style="margin-left:9%; margin-top: 1em"><b>&lt;front-end-options&gt;</b>
is a place-holder for regular <i>Clang Compiler Options</i>,
which must follow the &lt;source-file&gt;.</p>

<h3>Command Line Options
<a name="Command Line Options"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>-callbacks
&lt;comma-separated-globs&gt;</b></p>

<p style="margin-left:18%;">This option specifies a
comma-separated list of globs describing the list of
callbacks that should be traced. Globs are processed in
order of appearance. Positive globs add matched callbacks to
the set, negative globs (those with the '-' prefix) remove
callacks from the set.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>FileChanged</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>FileSkipped</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>InclusionDirective</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>moduleImport</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>EndOfMainFile</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>Ident</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>PragmaDirective</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>PragmaComment</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>PragmaDetectMismatch</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>PragmaDebug</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>PragmaMessage</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>PragmaDiagnosticPush</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>PragmaDiagnosticPop</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>PragmaDiagnostic</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>PragmaOpenCLExtension</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>PragmaWarning</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>PragmaWarningPush</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>PragmaWarningPop</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>MacroExpands</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>MacroDefined</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>MacroUndefined</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>Defined</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>SourceRangeSkipped</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>If</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>Elif</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>Ifdef</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>Ifndef</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>Else</p></td>
<td width="53%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p>Endif</p></td>
<td width="53%">
</td></tr>
</table>

<p style="margin-left:9%;"><b>-output
&lt;output-file&gt;</b></p>

<p style="margin-left:18%;">By default, pp-trace outputs
the trace information to stdout. Use this option to output
the trace information to a file.</p>

<h3>pp-trace Output Format
<a name="pp-trace Output Format"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The pp-trace
output is formatted as YAML. See <i>https://yaml.org/</i>
for general YAML information. It's arranged as a sequence of
information about the callback call, including the callback
name and argument information, for example::</p>

<p style="margin-left:13%; margin-top: 1em">--- <br>
- Callback: Name <br>
Argument1: Value1 <br>
Argument2: Value2 <br>
(etc.) <br>
...</p>

<p style="margin-left:9%; margin-top: 1em">With real
data::</p>

<p style="margin-left:13%; margin-top: 1em">--- <br>
- Callback: FileChanged <br>
Loc:
&quot;c:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-include.cpp:1:1&quot;
<br>
Reason: EnterFile <br>
FileType: C_User <br>
PrevFID: (invalid) <br>
(etc.) <br>
- Callback: FileChanged <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-include.cpp:5:1&quot;
<br>
Reason: ExitFile <br>
FileType: C_User <br>
PrevFID:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/Input/Level1B.h&quot;
<br>
- Callback: EndOfMainFile <br>
...</p>

<p style="margin-left:9%; margin-top: 1em">In all but one
case (MacroDirective) the &quot;Argument&quot; scalars have
the same name as the argument in the corresponding
PPCallbacks callback function.</p>

<h3>Callback Details
<a name="Callback Details"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The following
sections describe the purpose and output format for each
callback.</p>

<p style="margin-left:9%; margin-top: 1em">Click on the
callback name in the section heading to see the Doxygen
documentation for the callback.</p>

<p style="margin-left:9%; margin-top: 1em">The argument
descriptions table describes the callback argument
information displayed.</p>

<p style="margin-left:9%; margin-top: 1em">The Argument
Name field in most (but not all) cases is the same name as
the callback function parameter.</p>

<p style="margin-left:9%; margin-top: 1em">The Argument
Value Syntax field describes the values that will be
displayed for the argument value. It uses an ad hoc
representation that mixes literal and symbolic
representations. Enumeration member symbols are shown as the
actual enum member in a (member1|member2|...) form. A name
in parentheses can either represent a place holder for the
described value, or confusingly, it might be a literal, such
as (null), for a null pointer. Locations are shown as quoted
only to avoid confusing the documentation generator.</p>

<p style="margin-left:9%; margin-top: 1em">The Clang C++
Type field is the type from the callback function
declaration.</p>

<p style="margin-left:9%; margin-top: 1em">The description
describes the argument or what is displayed for it.</p>

<p style="margin-left:9%; margin-top: 1em">Note that in
some cases, such as when a structure pointer is an argument
value, only some key member or members are shown to
represent the value, instead of trying to display all
members of the structure.</p>

<h3>FileChanged Callback
<a name="FileChanged Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">FileChanged is
called when the preprocessor enters or exits a file, both
the top level file being compiled, as well as any #include
directives. It will also be called as a result of a system
header pragma or in internal renaming of a file.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
FileChanged <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-include.cpp:1:1&quot;
<br>
Reason: EnterFile <br>
FileType: C_User <br>
PrevFID: (invalid)</p>

<h3>FileSkipped Callback
<a name="FileSkipped Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">FileSkipped is
called when a source file is skipped as the result of header
guard optimization.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
FileSkipped <br>
ParentFile: &quot;/path/filename.h&quot; <br>
FilenameTok: &quot;filename.h&quot; <br>
FileType: C_User</p>

<h3>InclusionDirective Callback
<a name="InclusionDirective Callback"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em">InclusionDirective
is called when an inclusion directive of any kind
(#include&lt;/code&gt;, #import&lt;/code&gt;, etc.) has been
processed, regardless of whether the inclusion will actually
result in an inclusion.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
InclusionDirective <br>
HashLoc:
&quot;D:/Clang/llvmnewmod/clang-tools-extra/test/pp-trace/pp-trace-include.cpp:4:1&quot;
<br>
IncludeTok: include <br>
FileName: &quot;Input/Level1B.h&quot; <br>
IsAngled: false <br>
FilenameRange: &quot;Input/Level1B.h&quot; <br>
File:
&quot;D:/Clang/llvmnewmod/clang-tools-extra/test/pp-trace/Input/Level1B.h&quot;
<br>
SearchPath:
&quot;D:/Clang/llvmnewmod/clang-tools-extra/test/pp-trace&quot;
<br>
RelativePath: &quot;Input/Level1B.h&quot; <br>
Imported: (null)</p>

<h3>moduleImport Callback
<a name="moduleImport Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">moduleImport is
called when there was an explicit module-import syntax.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
moduleImport <br>
ImportLoc:
&quot;d:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-modules.cpp:4:2&quot;
<br>
Path: [{Name: Level1B, Loc:
&quot;d:/Clang/llvmnewmod/clang-tools-extra/test/pp-trace/pp-trace-modules.cpp:4:9&quot;},
{Name: Level2B, Loc:
&quot;d:/Clang/llvmnewmod/clang-tools-extra/test/pp-trace/pp-trace-modules.cpp:4:17&quot;}]
<br>
Imported: Level2B</p>

<h3>EndOfMainFile Callback
<a name="EndOfMainFile Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">EndOfMainFile is
called when the end of the main file is reached.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
EndOfMainFile</p>

<h3>Ident Callback
<a name="Ident Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Ident is called
when a #ident or #sccs directive is read.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
Ident <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-ident.cpp:3:1&quot;
<br>
str: &quot;$Id$&quot;</p>

<h3>PragmaDirective Callback
<a name="PragmaDirective Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">PragmaDirective
is called when start reading any pragma directive.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
PragmaDirective <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-pragma.cpp:3:1&quot;
<br>
Introducer: PIK_HashPragma</p>

<h3>PragmaComment Callback
<a name="PragmaComment Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">PragmaComment is
called when a #pragma comment directive is read.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
PragmaComment <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-pragma.cpp:3:1&quot;
<br>
Kind: library <br>
Str: kernel32.lib</p>

<h3>PragmaDetectMismatch Callback
<a name="PragmaDetectMismatch Callback"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em">PragmaDetectMismatch
is called when a #pragma detect_mismatch directive is
read.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
PragmaDetectMismatch <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-pragma.cpp:3:1&quot;
<br>
Name: name <br>
Value: value</p>

<h3>PragmaDebug Callback
<a name="PragmaDebug Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">PragmaDebug is
called when a #pragma clang __debug directive is read.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
PragmaDebug <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-pragma.cpp:3:1&quot;
<br>
DebugType: warning</p>

<h3>PragmaMessage Callback
<a name="PragmaMessage Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">PragmaMessage is
called when a #pragma message directive is read.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
PragmaMessage <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-pragma.cpp:3:1&quot;
<br>
Namespace: &quot;GCC&quot; <br>
Kind: PMK_Message <br>
Str: The message text.</p>

<h3>PragmaDiagnosticPush Callback
<a name="PragmaDiagnosticPush Callback"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em">PragmaDiagnosticPush
is called when a #pragma gcc diagnostic push directive is
read.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
PragmaDiagnosticPush <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-pragma.cpp:3:1&quot;
<br>
Namespace: &quot;GCC&quot;</p>

<h3>PragmaDiagnosticPop Callback
<a name="PragmaDiagnosticPop Callback"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em">PragmaDiagnosticPop
is called when a #pragma gcc diagnostic pop directive is
read.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
PragmaDiagnosticPop <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-pragma.cpp:3:1&quot;
<br>
Namespace: &quot;GCC&quot;</p>

<h3>PragmaDiagnostic Callback
<a name="PragmaDiagnostic Callback"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em">PragmaDiagnostic
is called when a #pragma gcc diagnostic directive is
read.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
PragmaDiagnostic <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-pragma.cpp:3:1&quot;
<br>
Namespace: &quot;GCC&quot; <br>
mapping: MAP_WARNING <br>
Str: WarningName</p>

<h3>PragmaOpenCLExtension Callback
<a name="PragmaOpenCLExtension Callback"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em">PragmaOpenCLExtension
is called when OpenCL extension is either disabled or
enabled with a pragma.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
PragmaOpenCLExtension <br>
NameLoc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-pragma.cpp:3:10&quot;
<br>
Name: Name <br>
StateLoc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-pragma.cpp:3:18&quot;
<br>
State: 1</p>

<h3>PragmaWarning Callback
<a name="PragmaWarning Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">PragmaWarning is
called when a #pragma warning directive is read.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
PragmaWarning <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-pragma.cpp:3:1&quot;
<br>
WarningSpec: disable <br>
Ids: 1,2,3</p>

<h3>PragmaWarningPush Callback
<a name="PragmaWarningPush Callback"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em">PragmaWarningPush
is called when a #pragma warning(push) directive is
read.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
PragmaWarningPush <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-pragma.cpp:3:1&quot;
<br>
Level: 1</p>

<h3>PragmaWarningPop Callback
<a name="PragmaWarningPop Callback"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em">PragmaWarningPop
is called when a #pragma warning(pop) directive is read.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
PragmaWarningPop <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-pragma.cpp:3:1&quot;</p>

<h3>MacroExpands Callback
<a name="MacroExpands Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">MacroExpands is
called when ::HandleMacroExpandedIdentifier when a macro
invocation is found.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
MacroExpands <br>
MacroNameTok: X_IMPL <br>
MacroDirective: MD_Define <br>
Range: [(nonfile), (nonfile)] <br>
Args: [a &lt;plus&gt; y, b]</p>

<h3>MacroDefined Callback
<a name="MacroDefined Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">MacroDefined is
called when a macro definition is seen.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
MacroDefined <br>
MacroNameTok: X_IMPL <br>
MacroDirective: MD_Define</p>

<h3>MacroUndefined Callback
<a name="MacroUndefined Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">MacroUndefined
is called when a macro #undef is seen.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
MacroUndefined <br>
MacroNameTok: X_IMPL <br>
MacroDirective: MD_Define</p>

<h3>Defined Callback
<a name="Defined Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Defined is
called when the 'defined' operator is seen.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
Defined <br>
MacroNameTok: MACRO <br>
MacroDirective: (null) <br>
Range:
[&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-macro.cpp:8:5&quot;,
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-macro.cpp:8:19&quot;]</p>

<h3>SourceRangeSkipped Callback
<a name="SourceRangeSkipped Callback"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em">SourceRangeSkipped
is called when a source range is skipped.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
SourceRangeSkipped <br>
Range:
[&quot;:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-macro.cpp:8:2&quot;,
&quot;:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-macro.cpp:9:2&quot;]</p>

<h3>If Callback
<a name="If Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">If is called
when an #if is seen.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback: If
<br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-macro.cpp:8:2&quot;
<br>
ConditionRange:
[&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-macro.cpp:8:4&quot;,
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-macro.cpp:9:1&quot;]
<br>
ConditionValue: false</p>

<h3>Elif Callback
<a name="Elif Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Elif is called
when an #elif is seen.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
Elif <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-macro.cpp:10:2&quot;
<br>
ConditionRange:
[&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-macro.cpp:10:4&quot;,
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-macro.cpp:11:1&quot;]
<br>
ConditionValue: false <br>
IfLoc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-macro.cpp:8:2&quot;</p>

<h3>Ifdef Callback
<a name="Ifdef Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Ifdef is called
when an #ifdef is seen.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
Ifdef <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-conditional.cpp:3:1&quot;
<br>
MacroNameTok: MACRO <br>
MacroDirective: MD_Define</p>

<h3>Ifndef Callback
<a name="Ifndef Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Ifndef is called
when an #ifndef is seen.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
Ifndef <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-conditional.cpp:3:1&quot;
<br>
MacroNameTok: MACRO <br>
MacroDirective: MD_Define</p>

<h3>Else Callback
<a name="Else Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Else is called
when an #else is seen.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
Else <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-macro.cpp:10:2&quot;
<br>
IfLoc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-macro.cpp:8:2&quot;</p>

<h3>Endif Callback
<a name="Endif Callback"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Endif is called
when an #endif is seen.</p>

<p style="margin-left:9%; margin-top: 1em">Argument
descriptions: <br>
Example::</p>

<p style="margin-left:13%; margin-top: 1em">- Callback:
Endif <br>
Loc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-macro.cpp:10:2&quot;
<br>
IfLoc:
&quot;D:/Clang/llvm/clang-tools-extra/test/pp-trace/pp-trace-macro.cpp:8:2&quot;</p>

<h3>Building pp-trace
<a name="Building pp-trace"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">To build from
source:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="87%">


<p>Read <i>Getting Started with the LLVM System</i> and
<i>Clang Tools Documentation</i> for information on getting
sources for LLVM, Clang, and Clang Extra Tools.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="87%">


<p><i>Getting Started with the LLVM System</i> and
<i>Building LLVM with CMake</i> give directions for how to
build. With sources all checked out into the right place the
LLVM build will build Clang Extra Tools and their
dependencies automatically.</p></td></tr>
</table>

<p style="margin-left:13%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="85%">


<p style="margin-top: 1em">If using CMake, you can also use
the <b>pp-trace</b> target to build just the pp-trace tool
and its dependencies.</p></td></tr>
</table>

<h2>CLANG-RENAME
<a name="CLANG-RENAME"></a>
</h2>


<h3>Contents
<a name="Contents"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="15%">


<p style="margin-top: 1em"><i>Clang-Rename</i></p></td>
<td width="73%">
</td></tr>
</table>

<p style="margin-left:12%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%"></td>
<td width="1%"></td>
<td width="23%">


<p style="margin-top: 1em"><i>Using Clang-Rename</i></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%">


<p><i>Vim Integration</i></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="23%">


<p><i>Emacs Integration</i></p></td>
<td width="63%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">See also:</p>


<p style="margin-left:9%; margin-top: 1em"><b>clang-rename</b>
is a C++ refactoring tool. Its purpose is to perform
efficient renaming actions in large-scale projects such as
renaming classes, functions, variables, arguments,
namespaces etc.</p>

<p style="margin-left:9%; margin-top: 1em">The tool is in a
very early development stage, so you might encounter bugs
and crashes. Submitting reports with information about how
to reproduce the issue to <i>the LLVM bugtracker</i> will
definitely help the project. If you have any ideas or
suggestions, you might want to put a feature request
there.</p>

<h3>Using Clang-Rename
<a name="Using Clang-Rename"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>clang-rename</b>
is a <i>LibTooling</i>-based tool, and it's easier to work
with if you set up a compile command database for your
project (for an example of how to do this see <i>How To
Setup Tooling For LLVM</i>). You can also specify
compilation options on the command line after <i>--</i>:</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-rename
-offset=42 -new-name=foo test.cpp -- -Imy_project/include
-DMY_DEFINES ...</p>

<p style="margin-left:9%; margin-top: 1em">To get an offset
of a symbol in a file run</p>

<p style="margin-left:13%; margin-top: 1em">$ grep -FUbo
'foo' file.cpp</p>

<p style="margin-left:9%; margin-top: 1em">The tool
currently supports renaming actions inside a single
translation unit only. It is planned to extend the tool's
functionality to support multi-TU renaming actions in the
future.</p>


<p style="margin-left:9%; margin-top: 1em"><b>clang-rename</b>
also aims to be easily integrated into popular text editors,
such as Vim and Emacs, and improve the workflow of
users.</p>

<p style="margin-left:9%; margin-top: 1em">Although a
command line interface exists, it is highly recommended to
use the text editor interface instead for better
experience.</p>

<p style="margin-left:9%; margin-top: 1em">You can also
identify one or more symbols to be renamed by giving the
fully qualified name:</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-rename
-qualified-name=foo -new-name=bar test.cpp</p>

<p style="margin-left:9%; margin-top: 1em">Renaming
multiple symbols at once is supported, too. However,
<b>clang-rename</b> doesn't accept both <i>-offset</i> and
<i>-qualified-name</i> at the same time. So, you can either
specify multiple <i>-offset</i> or
<i>-qualified-name</i>.</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-rename
-offset=42 -new-name=bar1 -offset=150 -new-name=bar2
test.cpp</p>

<p style="margin-left:9%; margin-top: 1em">or</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-rename
-qualified-name=foo1 -new-name=bar1 -qualified-name=foo2
-new-name=bar2 test.cpp</p>

<p style="margin-left:9%; margin-top: 1em">Alternatively,
{offset | qualified-name} / new-name pairs can be put into a
YAML file:</p>

<p style="margin-left:13%; margin-top: 1em">--- <br>
- Offset: 42 <br>
NewName: bar1 <br>
- Offset: 150 <br>
NewName: bar2 <br>
...</p>

<p style="margin-left:9%; margin-top: 1em">or</p>

<p style="margin-left:13%; margin-top: 1em">--- <br>
- QualifiedName: foo1 <br>
NewName: bar1 <br>
- QualifiedName: foo2 <br>
NewName: bar2 <br>
...</p>

<p style="margin-left:9%; margin-top: 1em">That way you can
avoid spelling out all the names as command line
arguments:</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-rename
-input=test.yaml test.cpp</p>


<p style="margin-left:9%; margin-top: 1em"><b>clang-rename</b>
offers the following options:</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-rename
--help <br>
USAGE: clang-rename [subcommand] [options] &lt;source0&gt;
[... &lt;sourceN&gt;]</p>

<p style="margin-left:13%; margin-top: 1em">OPTIONS:</p>

<p style="margin-left:13%; margin-top: 1em">Generic
Options:</p>

<p style="margin-left:13%; margin-top: 1em">-help - Display
available options (-help-hidden for more) <br>
-help-list - Display list of available options
(-help-list-hidden for more) <br>
-version - Display the version of this program</p>

<p style="margin-left:13%; margin-top: 1em">clang-rename
common options:</p>


<p style="margin-left:13%; margin-top: 1em">-export-fixes=&lt;filename&gt;
- YAML file to store suggested fixes in. <br>
-extra-arg=&lt;string&gt; - Additional argument to append to
the compiler command line <br>
Can be used several times. <br>
-extra-arg-before=&lt;string&gt; - Additional argument to
prepend to the compiler command line <br>
Can be used several times. <br>
-force - Ignore nonexistent qualified names. <br>
-i - Overwrite edited &lt;file&gt;s. <br>
-input=&lt;string&gt; - YAML file to load oldname-newname
pairs from. <br>
-new-name=&lt;string&gt; - The new name to change the symbol
to. <br>
-offset=&lt;uint&gt; - Locates the symbol by offset as
opposed to &lt;line&gt;:&lt;column&gt;. <br>
-p &lt;string&gt; - Build path <br>
-pl - Print the locations affected by renaming to stderr.
<br>
-pn - Print the found symbol's name prior to renaming to
stderr. <br>
-qualified-name=&lt;string&gt; - The fully qualified name of
the symbol.</p>

<h3>Vim Integration
<a name="Vim Integration"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">You can call
<b>clang-rename</b> directly from Vim! To set up
<b>clang-rename</b> integration for Vim see
<i>clang/tools/clang-rename/clang-rename.py</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Please note that
<b>you have to save all buffers, in which the replacement
will happen before running the tool</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Once installed,
you can point your cursor to symbols you want to rename,
press <i>&lt;leader&gt;cr</i> and type new desired name. The
<i>&lt;leader&gt; key</i> is a reference to a specific key
defined by the mapleader variable and is bound to backslash
by default.</p>

<h3>Emacs Integration
<a name="Emacs Integration"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">You can also use
<b>clang-rename</b> while using Emacs! To set up
<b>clang-rename</b> integration for Emacs see
<i>clang-rename/tool/clang-rename.el</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Once installed,
you can point your cursor to symbols you want to rename,
press <i>M-X</i>, type <i>clang-rename</i> and new desired
name.</p>

<p style="margin-left:9%; margin-top: 1em">Please note that
<b>you have to save all buffers, in which the replacement
will happen before running the tool</b>.</p>

<h2>CLANG-DOC
<a name="CLANG-DOC"></a>
</h2>


<h3>Contents
<a name="Contents"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="11%">


<p style="margin-top: 1em"><i>Clang-Doc</i></p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:12%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%"></td>
<td width="1%"></td>
<td width="17%">


<p style="margin-top: 1em"><i>Use</i></p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="17%">


<p><i>Output</i></p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="17%">


<p><i>Configuration</i></p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:14%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="9%">


<p style="margin-top: 1em"><i>Options</i></p></td>
<td width="74%">
</td></tr>
</table>


<p style="margin-left:9%; margin-top: 1em"><b>clang-doc</b>
is a tool for generating C and C++ documentation from source
code and comments.</p>

<p style="margin-left:9%; margin-top: 1em">The tool is in a
very early development stage, so you might encounter bugs
and crashes. Submitting reports with information about how
to reproduce the issue to <i>the LLVM bug tracker</i> will
definitely help the project. If you have any ideas or
suggestions, please to put a feature request there.</p>

<h3>Use
<a name="Use"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>clang-doc</b>
is a <i>LibTooling</i>-based tool, and so requires a compile
command database for your project (for an example of how to
do this see <i>How To Setup Tooling For LLVM</i>).</p>

<p style="margin-left:9%; margin-top: 1em">The tool will
process a list of files by default:</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-doc
File1.cpp File2.cpp ... FileN.cpp</p>

<p style="margin-left:9%; margin-top: 1em">The tool can be
also used with a compile commands database:</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-doc
--executor=all-TUs compile_commands.json</p>

<p style="margin-left:9%; margin-top: 1em">To select only a
subset of files from the database, use the <b>--filter</b>
flag:</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-doc
--executor=all-TUs --filter=File[0-9]+.cpp
compile_commands.json</p>

<h3>Output
<a name="Output"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>clang-doc</b>
produces a directory of documentation. One file is produced
for each namespace and record in the project source code,
containing all documentation (including contained functions,
methods, and enums) for that item.</p>

<p style="margin-left:9%; margin-top: 1em">The top-level
directory is configurable through the <b>output</b>
flag:</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-doc
--output=output/directory/ compile_commands.json</p>

<h3>Configuration
<a name="Configuration"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Configuration
for <b>clang-doc</b> is currently limited to command-line
options. In the future, it may develop the ability to use a
configuration file, but no such efforts are currently in
progress.</p>

<h3>Options
<a name="Options"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>clang-doc</b>
offers the following options:</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-doc
--help <br>
OVERVIEW: Generates documentation from source code and
comments.</p>

<p style="margin-left:13%; margin-top: 1em">Example usage
for files without flags (default):</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-doc
File1.cpp File2.cpp ... FileN.cpp</p>

<p style="margin-left:13%; margin-top: 1em">Example usage
for a project using a compile commands database:</p>

<p style="margin-left:13%; margin-top: 1em">$ clang-doc
--executor=all-TUs compile_commands.json</p>

<p style="margin-left:13%; margin-top: 1em">USAGE:
clang-doc [options] &lt;source0&gt; [...
&lt;sourceN&gt;]</p>

<p style="margin-left:13%; margin-top: 1em">OPTIONS:</p>

<p style="margin-left:13%; margin-top: 1em">Generic
Options:</p>

<p style="margin-left:13%; margin-top: 1em">-help - Display
available options (-help-hidden for more) <br>
-help-list - Display list of available options
(-help-list-hidden for more) <br>
-version - Display the version of this program</p>

<p style="margin-left:13%; margin-top: 1em">clang-doc
options:</p>

<p style="margin-left:13%; margin-top: 1em">--doxygen - Use
only doxygen-style comments to generate docs. <br>
--extra-arg=&lt;string&gt; - Additional argument to append
to the compiler command line <br>
Can be used several times. <br>
--extra-arg-before=&lt;string&gt; - Additional argument to
prepend to the compiler command line <br>
Can be used several times. <br>
--format=&lt;value&gt; - Format for outputted docs. <br>
=yaml - Documentation in YAML format. <br>
=md - Documentation in MD format. <br>
=html - Documentation in HTML format. <br>
--ignore-map-errors - Continue if files are not mapped
correctly. <br>
--output=&lt;string&gt; - Directory for outputting generated
files. <br>
-p &lt;string&gt; - Build path <br>
--project-name=&lt;string&gt; - Name of project. <br>
--public - Document only public declarations. <br>
--repository=&lt;string&gt; - <br>
URL of repository that hosts code. <br>
Used for links to definition locations. <br>
--source-root=&lt;string&gt; - <br>
Directory where processed files are stored. <br>
Links to definition locations will only be <br>
generated if the file is in this dir. <br>
--stylesheets=&lt;string&gt; - CSS stylesheets to extend the
default styles.</p>

<p style="margin-left:9%; margin-top: 1em">The following
flags should only be used if <b>format</b> is set to
<b>html</b>: - <b>repository</b> - <b>source-root</b> -
<b>stylesheets</b></p>

<p style="margin-left:9%; margin-top: 1em">The Doxygen
documentation describes the <b>internal</b> software that
makes up the tools of clang-tools-extra, not the
<b>external</b> use of these tools. The Doxygen
documentation contains no instructions about how to use the
tools, only the APIs that make up the software. For usage
instructions, please see the user's guide or reference
manual for each tool.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p style="margin-top: 1em"><i>Doxygen documentation</i></p></td>
<td width="62%">
</td></tr>
</table>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">This documentation is generated
directly from the source code with doxygen. Since the tools
of clang-tools-extra are constantly under active
development, what you're about to read is out of date!</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="14%">


<p style="margin-top: 1em"><i>Index</i></p></td>
<td width="74%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="14%">


<p><i>Search Page</i></p></td>
<td width="74%">
</td></tr>
</table>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">The Clang
Team</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">2007-2025, The
Clang Team</p>
<hr>
</body>
</html>
