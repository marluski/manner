<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Mon Apr  7 17:29:56 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>QEMU-IMG</title>

</head>
<body>

<h1 align="center">QEMU-IMG</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">qemu-img - QEMU
disk image utility</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em"><b>qemu-img</b>
[<i>standard options</i>] <i>command</i> [<i>command
options</i>]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">qemu-img allows
you to create, convert and modify images offline. It can
handle all image formats supported by QEMU.</p>

<p style="margin-left:9%; margin-top: 1em"><b>Warning:</b>
Never use qemu-img to modify images in use by a running
virtual machine or any other process; this may destroy the
image. Also, be aware that querying an image that is being
modified by another process may encounter inconsistent
state.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">Standard
options: <b><br>
-h, --help</b></p>

<p style="margin-left:18%;">Display this help and exit</p>

<p style="margin-left:9%;"><b>-V, --version</b></p>

<p style="margin-left:18%;">Display version information and
exit</p>

<p style="margin-left:9%;"><b>-T, --trace
[[enable=]PATTERN][,events=FILE][,file=FILE]</b></p>

<p style="margin-left:18%;">Specify tracing options.</p>


<p style="margin-left:18%; margin-top: 1em"><b>[enable=]PATTERN</b></p>

<p style="margin-left:22%;">Immediately enable events
matching <i>PATTERN</i> (either event name or a globbing
pattern). This option is only available if QEMU has been
compiled with the <b>simple</b>, <b>log</b> or <b>ftrace</b>
tracing backend. To specify multiple events or patterns,
specify the <b>-trace</b> option multiple times.</p>

<p style="margin-left:22%; margin-top: 1em">Use <b>-trace
help</b> to print a list of names of trace points.</p>


<p style="margin-left:18%; margin-top: 1em"><b>events=FILE</b></p>

<p style="margin-left:22%;">Immediately enable events
listed in <i>FILE</i>. The file must contain one event name
(as listed in the <b>trace-events-all</b> file) per line;
globbing patterns are accepted too. This option is only
available if QEMU has been compiled with the <b>simple</b>,
<b>log</b> or <b>ftrace</b> tracing backend.</p>


<p style="margin-left:18%; margin-top: 1em"><b>file=FILE</b></p>

<p style="margin-left:22%;">Log output traces to
<i>FILE</i>. This option is only available if QEMU has been
compiled with the <b>simple</b> tracing backend.</p>

<p style="margin-left:9%; margin-top: 1em">The following
commands are supported: <b><br>
amend [--object OBJECTDEF] [--image-opts] [-p] [-q] [-f FMT]
[-t CACHE] <br>
[--force] -o OPTIONS FILENAME <br>
bench [-c COUNT] [-d DEPTH] [-f FMT]
[--flush-interval=FLUSH_INTERVAL] <br>
[-i AIO] [-n] [--no-drain] [-o OFFSET] [--pattern=PATTERN]
[-q] [-s <br>
BUFFER_SIZE] [-S STEP_SIZE] [-t CACHE] [-w] [-U] FILENAME
<br>
bitmap (--merge SOURCE | --add | --remove | --clear |
--enable | <br>
--disable)... [-b SOURCE_FILE [-F SOURCE_FMT]] [-g
GRANULARITY] <br>
[--object OBJECTDEF] [--image-opts | -f FMT] FILENAME BITMAP
<br>
check [--object OBJECTDEF] [--image-opts] [-q] [-f FMT]
[--output=OFMT] <br>
[-r [leaks | all]] [-T SRC_CACHE] [-U] FILENAME <br>
commit [--object OBJECTDEF] [--image-opts] [-q] [-f FMT] [-t
CACHE] [-b <br>
BASE] [-r RATE_LIMIT] [-d] [-p] FILENAME <br>
compare [--object OBJECTDEF] [--image-opts] [-f FMT] [-F
FMT] [-T <br>
SRC_CACHE] [-p] [-q] [-s] [-U] FILENAME1 FILENAME2 <br>
convert [--object OBJECTDEF] [--image-opts]
[--target-image-opts] <br>
[--target-is-zero] [--bitmaps] [-U] [-C] [-c] [-p] [-q] [-n]
[-f FMT] <br>
[-t CACHE] [-T SRC_CACHE] [-O OUTPUT_FMT] [-B BACKING_FILE
[-F <br>
BACKING_FMT]] [-o OPTIONS] [-l SNAPSHOT_PARAM] [-S
SPARSE_SIZE] [-r <br>
RATE_LIMIT] [-m NUM_COROUTINES] [-W] [--salvage] FILENAME
[FILENAME2 <br>
[...]] OUTPUT_FILENAME <br>
create [--object OBJECTDEF] [-q] [-f FMT] [-b BACKING_FILE
[-F <br>
BACKING_FMT]] [-u] [-o OPTIONS] FILENAME [SIZE] <br>
dd [--image-opts] [-U] [-f FMT] [-O OUTPUT_FMT]
[bs=BLOCK_SIZE] <br>
[count=BLOCKS] [skip=BLOCKS] if=INPUT of=OUTPUT <br>
info [--object OBJECTDEF] [--image-opts] [-f FMT]
[--output=OFMT] <br>
[--backing-chain] [-U] FILENAME <br>
map [--object OBJECTDEF] [--image-opts] [-f FMT] <br>
[--start-offset=OFFSET] [--max-length=LEN] [--output=OFMT]
[-U] <br>
FILENAME <br>
measure [--output=OFMT] [-O OUTPUT_FMT] [-o OPTIONS] [--size
N | <br>
[--object OBJECTDEF] [--image-opts] [-f FMT] [-l
SNAPSHOT_PARAM] <br>
FILENAME] <br>
snapshot [--object OBJECTDEF] [--image-opts] [-U] [-q] [-l |
-a <br>
SNAPSHOT | -c SNAPSHOT | -d SNAPSHOT] FILENAME <br>
rebase [--object OBJECTDEF] [--image-opts] [-U] [-q] [-f
FMT] [-t <br>
CACHE] [-T SRC_CACHE] [-p] [-u] [-c] -b BACKING_FILE [-F
BACKING_FMT] <br>
FILENAME <br>
resize [--object OBJECTDEF] [--image-opts] [-f FMT] <br>
[--preallocation=PREALLOC] [-q] [--shrink] FILENAME [+ |
-]SIZE</b></p>

<p style="margin-left:9%; margin-top: 1em">Command
parameters:</p>

<p style="margin-left:9%; margin-top: 1em"><i>FILENAME</i>
is a disk image filename.</p>

<p style="margin-left:9%; margin-top: 1em"><i>FMT</i> is
the disk image format. It is guessed automatically in most
cases. See below for a description of the supported disk
formats.</p>

<p style="margin-left:9%; margin-top: 1em"><i>SIZE</i> is
the disk image size in bytes. Optional suffixes <b>k</b> or
<b>K</b> (kilobyte, 1024) <b>M</b> (megabyte, 1024k) and
<b>G</b> (gigabyte, 1024M) and T (terabyte, 1024G) are
supported. <b>b</b> is ignored.</p>


<p style="margin-left:9%; margin-top: 1em"><i>OUTPUT_FILENAME</i>
is the destination disk image filename.</p>


<p style="margin-left:9%; margin-top: 1em"><i>OUTPUT_FMT</i>
is the destination format.</p>

<p style="margin-left:9%; margin-top: 1em"><i>OPTIONS</i>
is a comma separated list of format specific options in a
name=value format. Use <b>-o help</b> for an overview of the
options supported by the used format or see the format
descriptions below for details.</p>


<p style="margin-left:9%; margin-top: 1em"><i>SNAPSHOT_PARAM</i>
is param used for internal snapshot, format is
'snapshot.id=[ID],snapshot.name=[NAME]' or '[ID_OR_NAME]'.
<b><br>
--object OBJECTDEF</b></p>

<p style="margin-left:18%;">is a QEMU user creatable object
definition. See the <b>qemu(1)</b> manual page for a
description of the object properties. The most common object
type is a <b>secret</b>, which is used to supply passwords
and/or encryption keys.</p>

<p style="margin-left:9%;"><b>--image-opts</b></p>

<p style="margin-left:18%;">Indicates that the source
<i>FILENAME</i> parameter is to be interpreted as a full
option string, not a plain filename. This parameter is
mutually exclusive with the <i>-f</i> parameter.</p>

<p style="margin-left:9%;"><b>--target-image-opts</b></p>

<p style="margin-left:18%;">Indicates that the
OUTPUT_FILENAME parameter(s) are to be interpreted as a full
option string, not a plain filename. This parameter is
mutually exclusive with the <i>-O</i> parameters. It is
currently required to also use the <i>-n</i> parameter to
skip image creation. This restriction may be relaxed in a
future release.</p>

<p style="margin-left:9%;"><b>--force-share (-U)</b></p>

<p style="margin-left:18%;">If specified, <b>qemu-img</b>
will open the image in shared mode, allowing other QEMU
processes to open it in write mode. For example, this can be
used to get the image information (with 'info' subcommand)
when the image is used by a running guest. Note that this
could produce inconsistent results because of concurrent
metadata changes, etc. This option is only allowed when
opening images in read-only mode.</p>

<p style="margin-left:9%;"><b>--backing-chain</b></p>

<p style="margin-left:18%;">Will enumerate information
about backing files in a disk image chain. Refer below for
further description.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p><b>-c</b></p></td>
<td width="6%"></td>
<td width="82%">


<p>Indicates that target image must be compressed
(qcow/qcow2 and vmdk with streamOptimized subformat
only).</p> </td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">For qcow2, the
compression algorithm can be specified with the <b>-o
compression_type=...</b> option (see below).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>-h</b></p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">With or without a command, shows
help and lists the supported formats.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p><b>-p</b></p></td>
<td width="6%"></td>
<td width="82%">


<p>Display progress bar (compare, convert and rebase
commands only). If the <i>-p</i> option is not used for a
command that supports it, the progress is reported when the
process receives a <b>SIGUSR1</b> or <b>SIGINFO</b>
signal.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p><b>-q</b></p></td>
<td width="6%"></td>
<td width="82%">


<p>Quiet mode - do not print any output (except errors).
There's no progress bar in case both <i>-q</i> and <i>-p</i>
options are used.</p></td></tr>
</table>

<p style="margin-left:9%;"><b>-S SIZE</b></p>

<p style="margin-left:18%;">Indicates the consecutive
number of bytes that must contain only zeros for
<b>qemu-img</b> to create a sparse image during conversion.
This value is rounded down to the nearest 512 bytes. You may
use the common size suffixes like <b>k</b> for
kilobytes.</p>

<p style="margin-left:9%;"><b>-t CACHE</b></p>

<p style="margin-left:18%;">Specifies the cache mode that
should be used with the (destination) file. See the
documentation of the emulator's <b>-drive cache=...</b>
option for allowed values.</p>

<p style="margin-left:9%;"><b>-T SRC_CACHE</b></p>

<p style="margin-left:18%;">Specifies the cache mode that
should be used with the source file(s). See the
documentation of the emulator's <b>-drive cache=...</b>
option for allowed values.</p>

<p style="margin-left:9%; margin-top: 1em">Parameters to
compare subcommand:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p><b>-f</b></p></td>
<td width="6%"></td>
<td width="81%">


<p>First image format</p></td>
<td width="1%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p><b>-F</b></p></td>
<td width="6%"></td>
<td width="81%">


<p>Second image format</p></td>
<td width="1%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p><b>-s</b></p></td>
<td width="6%"></td>
<td width="81%">


<p>Strict mode - fail on different image size or sector
allocation</p> </td>
<td width="1%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Parameters to
convert subcommand: <b><br>
--bitmaps</b></p>

<p style="margin-left:18%;">Additionally copy all
persistent bitmaps from the top layer of the source</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p><b>-n</b></p></td>
<td width="6%"></td>
<td width="82%">


<p>Skip the creation of the target volume</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p><b>-m</b></p></td>
<td width="6%"></td>
<td width="82%">


<p>Number of parallel coroutines for the convert
process</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p><b>-W</b></p></td>
<td width="6%"></td>
<td width="82%">


<p>Allow out-of-order writes to the destination. This
option improves performance, but is only recommended for
preallocated devices like host devices or other raw block
devices.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p><b>-C</b></p></td>
<td width="6%"></td>
<td width="82%">


<p>Try to use copy offloading to move data from source
image to target. This may improve performance if the data is
remote, such as with NFS or iSCSI backends, but will not
automatically sparsify zero sectors, and may result in a
fully allocated target image depending on the host support
for getting allocation information.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p><b>-r</b></p></td>
<td width="6%"></td>
<td width="82%">


<p>Rate limit for the convert process</p></td></tr>
</table>

<p style="margin-left:9%;"><b>--salvage</b></p>

<p style="margin-left:18%;">Try to ignore I/O errors when
reading. Unless in quiet mode (<b>-q</b>), errors will still
be printed. Areas that cannot be read from the source will
be treated as containing only zeroes.</p>

<p style="margin-left:9%;"><b>--target-is-zero</b></p>

<p style="margin-left:18%;">Assume that reading the
destination image will always return zeros. This parameter
is mutually exclusive with a destination image that has a
backing file. It is required to also use the <b>-n</b>
parameter to skip image creation.</p>

<p style="margin-left:9%; margin-top: 1em">Parameters to dd
subcommand: <b><br>
bs=BLOCK_SIZE</b></p>

<p style="margin-left:18%;">Defines the block size</p>

<p style="margin-left:9%;"><b>count=BLOCKS</b></p>

<p style="margin-left:18%;">Sets the number of input blocks
to copy</p>

<p style="margin-left:9%;"><b>if=INPUT</b></p>

<p style="margin-left:18%;">Sets the input file</p>

<p style="margin-left:9%;"><b>of=OUTPUT</b></p>

<p style="margin-left:18%;">Sets the output file</p>

<p style="margin-left:9%;"><b>skip=BLOCKS</b></p>

<p style="margin-left:18%;">Sets the number of input blocks
to skip</p>

<p style="margin-left:9%; margin-top: 1em">Parameters to
snapshot subcommand: <b><br>
snapshot</b></p>

<p style="margin-left:18%;">Is the name of the snapshot to
create, apply or delete</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p><b>-a</b></p></td>
<td width="6%"></td>
<td width="60%">


<p>Applies a snapshot (revert disk to saved state)</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p><b>-c</b></p></td>
<td width="6%"></td>
<td width="60%">


<p>Creates a snapshot</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p><b>-d</b></p></td>
<td width="6%"></td>
<td width="60%">


<p>Deletes a snapshot</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p><b>-l</b></p></td>
<td width="6%"></td>
<td width="60%">


<p>Lists all snapshots in the given image</p></td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Command
description: <b><br>
amend [--object OBJECTDEF] [--image-opts] [-p] [-q] [-f FMT]
[-t CACHE] <br>
[--force] -o OPTIONS FILENAME</b></p>

<p style="margin-left:18%;">Amends the image format
specific <i>OPTIONS</i> for the image file <i>FILENAME</i>.
Not all file formats support this operation.</p>

<p style="margin-left:18%; margin-top: 1em">The set of
options that can be amended are dependent on the image
format, but note that amending the backing chain
relationship should instead be performed with <b>qemu-img
rebase</b>.</p>

<p style="margin-left:18%; margin-top: 1em">--force allows
some unsafe operations. Currently for -f luks, it allows to
erase the last encryption key, and to overwrite an active
encryption key.</p>

<p style="margin-left:9%;"><b>bench [-c COUNT] [-d DEPTH]
[-f FMT] [--flush-interval=FLUSH_INTERVAL] <br>
[-i AIO] [-n] [--no-drain] [-o OFFSET] [--pattern=PATTERN]
[-q] [-s <br>
BUFFER_SIZE] [-S STEP_SIZE] [-t CACHE] [-w] [-U]
FILENAME</b></p>

<p style="margin-left:18%;">Run a simple sequential I/O
benchmark on the specified image. If <b>-w</b> is specified,
a write test is performed, otherwise a read test is
performed.</p>

<p style="margin-left:18%; margin-top: 1em">A total number
of <i>COUNT</i> I/O requests is performed, each
<i>BUFFER_SIZE</i> bytes in size, and with <i>DEPTH</i>
requests in parallel. The first request starts at the
position given by <i>OFFSET</i>, each following request
increases the current position by <i>STEP_SIZE</i>. If
<i>STEP_SIZE</i> is not given, <i>BUFFER_SIZE</i> is used
for its value.</p>

<p style="margin-left:18%; margin-top: 1em">If
<i>FLUSH_INTERVAL</i> is specified for a write test, the
request queue is drained and a flush is issued before new
writes are made whenever the number of remaining requests is
a multiple of <i>FLUSH_INTERVAL</i>. If additionally
<b>--no-drain</b> is specified, a flush is issued without
draining the request queue first.</p>

<p style="margin-left:18%; margin-top: 1em">if <b>-i</b> is
specified, <i>AIO</i> option can be used to specify
different AIO backends: <b>threads</b>, <b>native</b> or
<b>io_uring</b>.</p>

<p style="margin-left:18%; margin-top: 1em">If <b>-n</b> is
specified, the native AIO backend is used if possible. On
Linux, this option only works if <b>-t none</b> or <b>-t
directsync</b> is specified as well.</p>

<p style="margin-left:18%; margin-top: 1em">For write
tests, by default a buffer filled with zeros is written.
This can be overridden with a pattern byte specified by
<i>PATTERN</i>.</p>

<p style="margin-left:9%;"><b>bitmap (--merge SOURCE |
--add | --remove | --clear | --enable | <br>
--disable)... [-b SOURCE_FILE [-F SOURCE_FMT]] [-g
GRANULARITY] <br>
[--object OBJECTDEF] [--image-opts | -f FMT] FILENAME
BITMAP</b></p>

<p style="margin-left:18%;">Perform one or more
modifications of the persistent bitmap <i>BITMAP</i> in the
disk image <i>FILENAME</i>. The various modifications
are:</p>

<p style="margin-left:18%; margin-top: 1em"><b>--add</b> to
create <i>BITMAP</i>, enabled to record future edits.</p>


<p style="margin-left:18%; margin-top: 1em"><b>--remove</b>
to remove <i>BITMAP</i>.</p>

<p style="margin-left:18%; margin-top: 1em"><b>--clear</b>
to clear <i>BITMAP</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>--enable</b>
to change <i>BITMAP</i> to start recording future edits.</p>


<p style="margin-left:18%; margin-top: 1em"><b>--disable</b>
to change <i>BITMAP</i> to stop recording future edits.</p>

<p style="margin-left:18%; margin-top: 1em"><b>--merge</b>
to merge the contents of the <i>SOURCE</i> bitmap into
<i>BITMAP</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Additional
options include <b>-g</b> which sets a non-default
<i>GRANULARITY</i> for <b>--add</b>, and <b>-b</b> and
<b>-F</b> which select an alternative source file for all
<i>SOURCE</i> bitmaps used by <b>--merge</b>.</p>

<p style="margin-left:18%; margin-top: 1em">To see what
bitmaps are present in an image, use <b>qemu-img
info</b>.</p>

<p style="margin-left:9%;"><b>check [--object OBJECTDEF]
[--image-opts] [-q] [-f FMT] [--output=OFMT] <br>
[-r [leaks | all]] [-T SRC_CACHE] [-U] FILENAME</b></p>

<p style="margin-left:18%;">Perform a consistency check on
the disk image <i>FILENAME</i>. The command can output in
the format <i>OFMT</i> which is either <b>human</b> or
<b>json</b>. The JSON output is an object of QAPI type
<b>ImageCheck</b>.</p>

<p style="margin-left:18%; margin-top: 1em">If <b>-r</b> is
specified, qemu-img tries to repair any inconsistencies
found during the check. <b>-r leaks</b> repairs only cluster
leaks, whereas <b>-r all</b> fixes all kinds of errors, with
a higher risk of choosing the wrong fix or hiding corruption
that has already occurred.</p>

<p style="margin-left:18%; margin-top: 1em">Only the
formats <b>qcow2</b>, <b>qed</b>, <b>parallels</b>,
<b>vhdx</b>, <b>vmdk</b> and <b>vdi</b> support consistency
checks.</p>

<p style="margin-left:18%; margin-top: 1em">In case the
image does not have any inconsistencies, check exits with
<b>0</b>. Other exit codes indicate the kind of
inconsistency found or if another error occurred. The
following table summarizes all exit codes of the check
subcommand:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p><b>0</b></p></td>
<td width="6%"></td>
<td width="73%">


<p>Check completed, the image is (now) consistent</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p><b>1</b></p></td>
<td width="6%"></td>
<td width="73%">


<p>Check not completed because of internal errors</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p><b>2</b></p></td>
<td width="6%"></td>
<td width="73%">


<p>Check completed, image is corrupted</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p><b>3</b></p></td>
<td width="6%"></td>
<td width="73%">


<p>Check completed, image has leaked clusters, but is not
corrupted</p> </td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="3%">


<p><b>63</b></p></td>
<td width="6%"></td>
<td width="73%">


<p>Checks are not supported by the image format</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">If <b>-r</b> is
specified, exit codes representing the image state refer to
the state after (the attempt at) repairing it. That is, a
successful <b>-r all</b> will yield the exit code 0,
independently of the image state before.</p>

<p style="margin-left:9%;"><b>commit [--object OBJECTDEF]
[--image-opts] [-q] [-f FMT] [-t CACHE] [-b <br>
BASE] [-r RATE_LIMIT] [-d] [-p] FILENAME</b></p>

<p style="margin-left:18%;">Commit the changes recorded in
<i>FILENAME</i> in its base image or backing file. If the
backing file is smaller than the snapshot, then the backing
file will be resized to be the same size as the snapshot. If
the snapshot is smaller than the backing file, the backing
file will not be truncated. If you want the backing file to
match the size of the smaller snapshot, you can safely
truncate it yourself once the commit operation successfully
completes.</p>

<p style="margin-left:18%; margin-top: 1em">The image
<i>FILENAME</i> is emptied after the operation has
succeeded. If you do not need <i>FILENAME</i> afterwards and
intend to drop it, you may skip emptying <i>FILENAME</i> by
specifying the <b>-d</b> flag.</p>

<p style="margin-left:18%; margin-top: 1em">If the backing
chain of the given image file <i>FILENAME</i> has more than
one layer, the backing file into which the changes will be
committed may be specified as <i>BASE</i> (which has to be
part of <i>FILENAME</i>'s backing chain). If <i>BASE</i> is
not specified, the immediate backing file of the top image
(which is <i>FILENAME</i>) will be used. Note that after a
commit operation all images between <i>BASE</i> and the top
image will be invalid and may return garbage data when read.
For this reason, <b>-b</b> implies <b>-d</b> (so that the
top image stays valid).</p>

<p style="margin-left:18%; margin-top: 1em">The rate limit
for the commit process is specified by <b>-r</b>.</p>

<p style="margin-left:9%;"><b>compare [--object OBJECTDEF]
[--image-opts] [-f FMT] [-F FMT] [-T <br>
SRC_CACHE] [-p] [-q] [-s] [-U] FILENAME1 FILENAME2</b></p>

<p style="margin-left:18%;">Check if two images have the
same content. You can compare images with different format
or settings.</p>

<p style="margin-left:18%; margin-top: 1em">The format is
probed unless you specify it by <b>-f</b> (used for
<i>FILENAME1</i>) and/or <b>-F</b> (used for
<i>FILENAME2</i>) option.</p>

<p style="margin-left:18%; margin-top: 1em">By default,
images with different size are considered identical if the
larger image contains only unallocated and/or zeroed sectors
in the area after the end of the other image. In addition,
if any sector is not allocated in one image and contains
only zero bytes in the second one, it is evaluated as equal.
You can use Strict mode by specifying the <b>-s</b> option.
When compare runs in Strict mode, it fails in case image
size differs or a sector is allocated in one image and is
not allocated in the second one.</p>

<p style="margin-left:18%; margin-top: 1em">By default,
compare prints out a result message. This message displays
information that both images are same or the position of the
first different byte. In addition, result message can report
different image size in case Strict mode is used.</p>

<p style="margin-left:18%; margin-top: 1em">Compare exits
with <b>0</b> in case the images are equal and with <b>1</b>
in case the images differ. Other exit codes mean an error
occurred during execution and standard error output should
contain an error message. The following table summarizes all
exit codes of the compare subcommand:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p><b>0</b></p></td>
<td width="8%"></td>
<td width="67%">


<p>Images are identical (or requested help was printed)</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p><b>1</b></p></td>
<td width="8%"></td>
<td width="67%">


<p>Images differ</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p><b>2</b></p></td>
<td width="8%"></td>
<td width="67%">


<p>Error on opening an image</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p><b>3</b></p></td>
<td width="8%"></td>
<td width="67%">


<p>Error on checking a sector allocation</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p><b>4</b></p></td>
<td width="8%"></td>
<td width="67%">


<p>Error on reading data</p></td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:9%;"><b>convert [--object OBJECTDEF]
[--image-opts] [--target-image-opts] <br>
[--target-is-zero] [--bitmaps [--skip-broken-bitmaps]] [-U]
[-C] [-c] <br>
[-p] [-q] [-n] [-f FMT] [-t CACHE] [-T SRC_CACHE] [-O
OUTPUT_FMT] [-B <br>
BACKING_FILE [-F BACKING_FMT]] [-o OPTIONS] [-l
SNAPSHOT_PARAM] [-S <br>
SPARSE_SIZE] [-r RATE_LIMIT] [-m NUM_COROUTINES] [-W]
FILENAME <br>
[FILENAME2 [...]] OUTPUT_FILENAME</b></p>

<p style="margin-left:18%;">Convert the disk image
<i>FILENAME</i> or a snapshot <i>SNAPSHOT_PARAM</i> to disk
image <i>OUTPUT_FILENAME</i> using format <i>OUTPUT_FMT</i>.
It can be optionally compressed (<b>-c</b> option) or use
any format specific options like encryption (<b>-o</b>
option).</p>

<p style="margin-left:18%; margin-top: 1em">Only the
formats <b>qcow</b> and <b>qcow2</b> support compression.
The compression is read-only. It means that if a compressed
sector is rewritten, then it is rewritten as uncompressed
data.</p>

<p style="margin-left:18%; margin-top: 1em">Image
conversion is also useful to get smaller image when using a
growable format such as <b>qcow</b>: the empty sectors are
detected and suppressed from the destination image.</p>


<p style="margin-left:18%; margin-top: 1em"><i>SPARSE_SIZE</i>
indicates the consecutive number of bytes (defaults to 4k)
that must contain only zeros for <b>qemu-img</b> to create a
sparse image during conversion. If <i>SPARSE_SIZE</i> is 0,
the source will not be scanned for unallocated or zero
sectors, and the destination image will always be fully
allocated.</p>

<p style="margin-left:18%; margin-top: 1em">You can use the
<i>BACKING_FILE</i> option to force the output image to be
created as a copy on write image of the specified base
image; the <i>BACKING_FILE</i> should have the same content
as the input's base image, however the path, image format
(as given by <i>BACKING_FMT</i>), etc may differ.</p>

<p style="margin-left:18%; margin-top: 1em">If a relative
path name is given, the backing file is looked up relative
to the directory containing <i>OUTPUT_FILENAME</i>.</p>

<p style="margin-left:18%; margin-top: 1em">If the
<b>-n</b> option is specified, the target volume creation
will be skipped. This is useful for formats such as
<b>rbd</b> if the target volume has already been created
with site specific options that cannot be supplied through
<b>qemu-img</b>.</p>

<p style="margin-left:18%; margin-top: 1em">Out of order
writes can be enabled with <b>-W</b> to improve performance.
This is only recommended for preallocated devices like host
devices or other raw block devices. Out of order write does
not work in combination with creating compressed images.</p>


<p style="margin-left:18%; margin-top: 1em"><i>NUM_COROUTINES</i>
specifies how many coroutines work in parallel during the
convert process (defaults to 8).</p>

<p style="margin-left:18%; margin-top: 1em">Use of
<b>--bitmaps</b> requests that any persistent bitmaps
present in the original are also copied to the destination.
If any bitmap is inconsistent in the source, the conversion
will fail unless <b>--skip-broken-bitmaps</b> is also
specified to copy only the consistent bitmaps.</p>

<p style="margin-left:9%;"><b>create [--object OBJECTDEF]
[-q] [-f FMT] [-b BACKING_FILE [-F <br>
BACKING_FMT]] [-u] [-o OPTIONS] FILENAME [SIZE]</b></p>

<p style="margin-left:18%;">Create the new disk image
<i>FILENAME</i> of size <i>SIZE</i> and format <i>FMT</i>.
Depending on the file format, you can add one or more
<i>OPTIONS</i> that enable additional features of this
format.</p>

<p style="margin-left:18%; margin-top: 1em">If the option
<i>BACKING_FILE</i> is specified, then the image will record
only the differences from <i>BACKING_FILE</i>. No size needs
to be specified in this case. <i>BACKING_FILE</i> will never
be modified unless you use the <b>commit</b> monitor command
(or <b>qemu-img commit</b>).</p>

<p style="margin-left:18%; margin-top: 1em">If a relative
path name is given, the backing file is looked up relative
to the directory containing <i>FILENAME</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Note that a
given backing file will be opened to check that it is valid.
Use the <b>-u</b> option to enable unsafe backing file mode,
which means that the image will be created even if the
associated backing file cannot be opened. A matching backing
file must be created or additional options be used to make
the backing file specification valid when you want to use an
image created this way.</p>

<p style="margin-left:18%; margin-top: 1em">The size can
also be specified using the <i>SIZE</i> option with
<b>-o</b>, it doesn't need to be specified separately in
this case.</p>

<p style="margin-left:9%;"><b>dd [--image-opts] [-U] [-f
FMT] [-O OUTPUT_FMT] [bs=BLOCK_SIZE] <br>
[count=BLOCKS] [skip=BLOCKS] if=INPUT of=OUTPUT</b></p>

<p style="margin-left:18%;">dd copies from <i>INPUT</i>
file to <i>OUTPUT</i> file converting it from <i>FMT</i>
format to <i>OUTPUT_FMT</i> format.</p>

<p style="margin-left:18%; margin-top: 1em">The data is by
default read and written using blocks of 512 bytes but can
be modified by specifying <i>BLOCK_SIZE</i>. If
count=<i>BLOCKS</i> is specified dd will stop reading input
after reading <i>BLOCKS</i> input blocks.</p>

<p style="margin-left:18%; margin-top: 1em">The size syntax
is similar to <b>dd(1)</b>'s size syntax.</p>

<p style="margin-left:9%;"><b>info [--object OBJECTDEF]
[--image-opts] [-f FMT] [--output=OFMT] <br>
[--backing-chain] [-U] FILENAME</b></p>

<p style="margin-left:18%;">Give information about the disk
image <i>FILENAME</i>. Use it in particular to know the size
reserved on disk which can be different from the displayed
size. If VM snapshots are stored in the disk image, they are
displayed too.</p>

<p style="margin-left:18%; margin-top: 1em">If a disk image
has a backing file chain, information about each disk image
in the chain can be recursively enumerated by using the
option <b>--backing-chain</b>.</p>

<p style="margin-left:18%; margin-top: 1em">For instance,
if you have an image chain like:</p>

<p style="margin-left:22%; margin-top: 1em">base.qcow2
&lt;- snap1.qcow2 &lt;- snap2.qcow2</p>

<p style="margin-left:18%; margin-top: 1em">To enumerate
information about each disk image in the above chain,
starting from top to base, do:</p>

<p style="margin-left:22%; margin-top: 1em">qemu-img info
--backing-chain snap2.qcow2</p>

<p style="margin-left:18%; margin-top: 1em">The command can
output in the format <i>OFMT</i> which is either
<b>human</b> or <b>json</b>. The JSON output is an object of
QAPI type <b>ImageInfo</b>; with <b>--backing-chain</b>, it
is an array of <b>ImageInfo</b> objects.</p>


<p style="margin-left:18%; margin-top: 1em"><b>--output=human</b>
reports the following information (for every image in the
chain):</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="6%">


<p><i>image</i></p></td>
<td width="3%"></td>
<td width="24%">


<p>The image file name</p></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:18%;"><i>file format</i></p>

<p style="margin-left:27%;">The image format</p>

<p style="margin-left:18%;"><i>virtual size</i></p>

<p style="margin-left:27%;">The size of the guest disk</p>

<p style="margin-left:18%;"><i>disk size</i></p>

<p style="margin-left:27%;">How much space the image file
occupies on the host file system (may be shown as 0 if this
information is unavailable, e.g. because there is no file
system)</p>

<p style="margin-left:18%;"><i>cluster_size</i></p>

<p style="margin-left:27%;">Cluster size of the image
format, if applicable</p>

<p style="margin-left:18%;"><i>encrypted</i></p>

<p style="margin-left:27%;">Whether the image is encrypted
(only present if so)</p>

<p style="margin-left:18%;"><i>cleanly shut down</i></p>

<p style="margin-left:27%;">This is shown as <b>no</b> if
the image is dirty and will have to be auto-repaired the
next time it is opened in qemu.</p>

<p style="margin-left:18%;"><i>backing file</i></p>

<p style="margin-left:27%;">The backing file name, if
present</p>

<p style="margin-left:18%;"><i>backing file format</i></p>

<p style="margin-left:27%;">The format of the backing file,
if the image enforces it</p>

<p style="margin-left:18%;"><i>Snapshot list</i></p>

<p style="margin-left:27%;">A list of all internal
snapshots</p>

<p style="margin-left:18%;"><i>Format specific
information</i></p>

<p style="margin-left:27%;">Further information whose
structure depends on the image format. This section is a
textual representation of the respective
<b>ImageInfoSpecific*</b> QAPI object (e.g.
<b>ImageInfoSpecificQCow2</b> for qcow2 images).</p>

<p style="margin-left:9%;"><b>map [--object OBJECTDEF]
[--image-opts] [-f FMT] <br>
[--start-offset=OFFSET] [--max-length=LEN] [--output=OFMT]
[-U] <br>
FILENAME</b></p>

<p style="margin-left:18%;">Dump the metadata of image
<i>FILENAME</i> and its backing file chain. In particular,
this commands dumps the allocation state of every sector of
<i>FILENAME</i>, together with the topmost file that
allocates it in the backing file chain.</p>

<p style="margin-left:18%; margin-top: 1em">Two option
formats are possible. The default format (<b>human</b>) only
dumps known-nonzero areas of the file. Known-zero parts of
the file are omitted altogether, and likewise for parts that
are not allocated throughout the chain. <b>qemu-img</b>
output will identify a file from where the data can be read,
and the offset in the file. Each line will include four
fields, the first three of which are hexadecimal numbers.
For example the first line of:</p>

<p style="margin-left:22%; margin-top: 1em">Offset Length
Mapped to File <br>
0 0x20000 0x50000 /tmp/overlay.qcow2 <br>
0x100000 0x10000 0x95380000 /tmp/backing.qcow2</p>

<p style="margin-left:18%; margin-top: 1em">means that
0x20000 (131072) bytes starting at offset 0 in the image are
available in /tmp/overlay.qcow2 (opened in <b>raw</b>
format) starting at offset 0x50000 (327680). Data that is
compressed, encrypted, or otherwise not available in raw
format will cause an error if <b>human</b> format is in use.
Note that file names can include newlines, thus it is not
safe to parse this output format in scripts.</p>

<p style="margin-left:18%; margin-top: 1em">The alternative
format <b>json</b> will return an array of dictionaries in
JSON format. It will include similar information in the
<b>start</b>, <b>length</b>, <b>offset</b> fields; it will
also include other more specific information:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>boolean field <b>data</b>: true if the sectors contain
actual data, false if the sectors are either unallocated or
stored as optimized all-zero clusters</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>boolean field <b>zero</b>: true if the data is known to
read as zero</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>boolean field <b>present</b>: true if the data belongs
to the backing chain, false if rebasing the backing chain
onto a deeper file would pick up data from the deeper
file;</p> </td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>integer field <b>depth</b>: the depth within the backing
chain at which the data was resolved; for example, a depth
of 2 refers to the backing file of the backing file of
<i>FILENAME</i>.</p> </td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">In JSON format,
the <b>offset</b> field is optional; it is absent in cases
where <b>human</b> format would omit the entry or exit with
an error. If <b>data</b> is false and the <b>offset</b>
field is present, the corresponding sectors in the file are
not yet in use, but they are preallocated.</p>

<p style="margin-left:18%; margin-top: 1em">For more
information, consult <b>include/block/block.h</b> in QEMU's
source code.</p>

<p style="margin-left:9%;"><b>measure [--output=OFMT] [-O
OUTPUT_FMT] [-o OPTIONS] [--size N | <br>
[--object OBJECTDEF] [--image-opts] [-f FMT] [-l
SNAPSHOT_PARAM] <br>
FILENAME]</b></p>

<p style="margin-left:18%;">Calculate the file size
required for a new image. This information can be used to
size logical volumes or SAN LUNs appropriately for the image
that will be placed in them. The values reported are
guaranteed to be large enough to fit the image. The command
can output in the format <i>OFMT</i> which is either
<b>human</b> or <b>json</b>. The JSON output is an object of
QAPI type <b>BlockMeasureInfo</b>.</p>

<p style="margin-left:18%; margin-top: 1em">If the size
<i>N</i> is given then act as if creating a new empty image
file using <b>qemu-img create</b>. If <i>FILENAME</i> is
given then act as if converting an existing image file using
<b>qemu-img convert</b>. The format of the new file is given
by <i>OUTPUT_FMT</i> while the format of an existing file is
given by <i>FMT</i>.</p>

<p style="margin-left:18%; margin-top: 1em">A snapshot in
an existing image can be specified using
<i>SNAPSHOT_PARAM</i>.</p>

<p style="margin-left:18%; margin-top: 1em">The following
fields are reported:</p>

<p style="margin-left:22%; margin-top: 1em">required size:
524288 <br>
fully allocated size: 1074069504 <br>
bitmaps size: 0</p>

<p style="margin-left:18%; margin-top: 1em">The <b>required
size</b> is the file size of the new image. It may be
smaller than the virtual disk size if the image format
supports compact representation.</p>

<p style="margin-left:18%; margin-top: 1em">The <b>fully
allocated size</b> is the file size of the new image once
data has been written to all sectors. This is the maximum
size that the image file can occupy with the exception of
internal snapshots, dirty bitmaps, vmstate data, and other
advanced image format features.</p>

<p style="margin-left:18%; margin-top: 1em">The <b>bitmaps
size</b> is the additional size required in order to copy
bitmaps from a source image in addition to the guest-visible
data; the line is omitted if either source or destination
lacks bitmap support, or 0 if bitmaps are supported but
there is nothing to copy.</p>

<p style="margin-left:9%;"><b>snapshot [--object OBJECTDEF]
[--image-opts] [-U] [-q] [-l | -a <br>
SNAPSHOT | -c SNAPSHOT | -d SNAPSHOT] FILENAME</b></p>

<p style="margin-left:18%;">List, apply, create or delete
snapshots in image <i>FILENAME</i>.</p>

<p style="margin-left:9%;"><b>rebase [--object OBJECTDEF]
[--image-opts] [-U] [-q] [-f FMT] [-t <br>
CACHE] [-T SRC_CACHE] [-p] [-u] [-c] -b BACKING_FILE [-F
BACKING_FMT] <br>
FILENAME</b></p>

<p style="margin-left:18%;">Changes the backing file of an
image. Only the formats <b>qcow2</b> and <b>qed</b> support
changing the backing file.</p>

<p style="margin-left:18%; margin-top: 1em">The backing
file is changed to <i>BACKING_FILE</i> and (if the image
format of <i>FILENAME</i> supports this) the backing file
format is changed to <i>BACKING_FMT</i>. If
<i>BACKING_FILE</i> is specified as &quot;&quot; (the empty
string), then the image is rebased onto no backing file
(i.e. it will exist independently of any backing file).</p>

<p style="margin-left:18%; margin-top: 1em">If a relative
path name is given, the backing file is looked up relative
to the directory containing <i>FILENAME</i>.</p>

<p style="margin-left:18%; margin-top: 1em"><i>CACHE</i>
specifies the cache mode to be used for <i>FILENAME</i>,
whereas <i>SRC_CACHE</i> specifies the cache mode for
reading backing files.</p>

<p style="margin-left:18%; margin-top: 1em">There are two
different modes in which <b>rebase</b> can operate: <b><br>
Safe mode</b></p>

<p style="margin-left:27%;">This is the default mode and
performs a real rebase operation. The new backing file may
differ from the old one and <b>qemu-img rebase</b> will take
care of keeping the guest-visible content of <i>FILENAME</i>
unchanged.</p>

<p style="margin-left:27%; margin-top: 1em">In order to
achieve this, any clusters that differ between
<i>BACKING_FILE</i> and the old backing file of
<i>FILENAME</i> are merged into <i>FILENAME</i> before
actually changing the backing file. With the <b>-c</b>
option specified, the clusters which are being merged (but
not the entire <i>FILENAME</i> image) are compressed when
written.</p>

<p style="margin-left:27%; margin-top: 1em">Note that the
safe mode is an expensive operation, comparable to
converting an image. It only works if the old backing file
still exists.</p>

<p style="margin-left:18%;"><b>Unsafe mode</b></p>

<p style="margin-left:27%;"><b>qemu-img</b> uses the unsafe
mode if <b>-u</b> is specified. In this mode, only the
backing file name and format of <i>FILENAME</i> is changed
without any checks on the file contents. The user must take
care of specifying the correct new backing file, or the
guest-visible content of the image will be corrupted.</p>

<p style="margin-left:27%; margin-top: 1em">This mode is
useful for renaming or moving the backing file to somewhere
else. It can be used without an accessible old backing file,
i.e. you can use it to fix an image whose backing file has
already been moved/renamed.</p>

<p style="margin-left:18%; margin-top: 1em">You can use
<b>rebase</b> to perform a &quot;diff&quot; operation on two
disk images. This can be useful when you have copied or
cloned a guest, and you want to get back to a thin image on
top of a template or base image.</p>

<p style="margin-left:18%; margin-top: 1em">Say that
<b>base.img</b> has been cloned as <b>modified.img</b> by
copying it, and that the <b>modified.img</b> guest has run
so there are now some changes compared to <b>base.img</b>.
To construct a thin image called <b>diff.qcow2</b> that
contains just the differences, do:</p>

<p style="margin-left:22%; margin-top: 1em">qemu-img create
-f qcow2 -b modified.img diff.qcow2 <br>
qemu-img rebase -b base.img diff.qcow2</p>

<p style="margin-left:18%; margin-top: 1em">At this point,
<b>modified.img</b> can be discarded, since <b>base.img +
diff.qcow2</b> contains the same information.</p>

<p style="margin-left:9%;"><b>resize [--object OBJECTDEF]
[--image-opts] [-f FMT] <br>
[--preallocation=PREALLOC] [-q] [--shrink] FILENAME [+ |
-]SIZE</b></p>

<p style="margin-left:18%;">Change the disk image as if it
had been created with <i>SIZE</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Before using
this command to shrink a disk image, you MUST use file
system and partitioning tools inside the VM to reduce
allocated file systems and partition sizes accordingly.
Failure to do so will result in data loss!</p>

<p style="margin-left:18%; margin-top: 1em">When shrinking
images, the <b>--shrink</b> option must be given. This
informs <b>qemu-img</b> that the user acknowledges all loss
of data beyond the truncated image's end.</p>

<p style="margin-left:18%; margin-top: 1em">After using
this command to grow a disk image, you must use file system
and partitioning tools inside the VM to actually begin using
the new space on the device.</p>

<p style="margin-left:18%; margin-top: 1em">When growing an
image, the <b>--preallocation</b> option may be used to
specify how the additional image area should be allocated on
the host. See the format description in the <i>Notes</i>
section which values are allowed. Using this option may
result in slightly more data being allocated than
necessary.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">Supported image
file formats:</p>

<p style="margin-left:9%; margin-top: 1em"><b>raw</b></p>

<p style="margin-left:13%;">Raw disk image format
(default). This format has the advantage of being simple and
easily exportable to all other emulators. If your file
system supports <i>holes</i> (for example in ext2 or ext3 on
Linux or NTFS on Windows), then only the written sectors
will reserve space. Use <b>qemu-img info</b> to know the
real size used by the image or <b>ls -ls</b> on
Unix/Linux.</p>

<p style="margin-left:13%; margin-top: 1em">Supported
options: <b><br>
preallocation</b></p>

<p style="margin-left:22%;">Preallocation mode (allowed
values: <b>off</b>, <b>falloc</b>, <b>full</b>).
<b>falloc</b> mode preallocates space for image by calling
<b>posix_fallocate()</b>. <b>full</b> mode preallocates
space for image by writing data to underlying storage. This
data may or may not be zero, depending on the storage
location.</p>


<p style="margin-left:9%; margin-top: 1em"><b>qcow2</b></p>

<p style="margin-left:13%;">QEMU image format, the most
versatile format. Use it to have smaller images (useful if
your filesystem does not supports holes, for example on
Windows), optional AES encryption, zlib or zstd based
compression and support of multiple VM snapshots.</p>

<p style="margin-left:13%; margin-top: 1em">Supported
options:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="8%">


<p><b>compat</b></p></td>
<td width="1%"></td>
<td width="78%">


<p>Determines the qcow2 version to use. <b>compat=0.10</b>
uses the traditional image format that can be read by any
QEMU since 0.10. <b>compat=1.1</b> enables image format
extensions that only QEMU 1.1 and newer understand (this is
the default). Amongst others, this includes zero clusters,
which allow efficient copy-on-read for sparse images.</p></td></tr>
</table>

<p style="margin-left:13%;"><b>backing_file</b></p>

<p style="margin-left:22%;">File name of a base image (see
<b>create</b> subcommand)</p>

<p style="margin-left:13%;"><b>backing_fmt</b></p>

<p style="margin-left:22%;">Image format of the base
image</p>

<p style="margin-left:13%;"><b>compression_type</b></p>

<p style="margin-left:22%;">This option configures which
compression algorithm will be used for compressed clusters
on the image. Note that setting this option doesn't yet
cause the image to actually receive compressed writes. It is
most commonly used with the <b>-c</b> option of <b>qemu-img
convert</b>, but can also be used with the <b>compress</b>
filter driver or backup block jobs with compression
enabled.</p>

<p style="margin-left:22%; margin-top: 1em">Valid values
are <b>zlib</b> and <b>zstd</b>. For images that use
<b>compat=0.10</b>, only <b>zlib</b> compression is
available.</p>

<p style="margin-left:13%;"><b>encryption</b></p>

<p style="margin-left:22%;">If this option is set to
<b>on</b>, the image is encrypted with 128-bit AES-CBC.</p>

<p style="margin-left:22%; margin-top: 1em">The use of
encryption in qcow and qcow2 images is considered to be
flawed by modern cryptography standards, suffering from a
number of design problems:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="76%">


<p>The AES-CBC cipher is used with predictable
initialization vectors based on the sector number. This
makes it vulnerable to chosen plaintext attacks which can
reveal the existence of encrypted data.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="76%">


<p>The user passphrase is directly used as the encryption
key. A poorly chosen or short passphrase will compromise the
security of the encryption.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="76%">


<p>In the event of the passphrase being compromised there
is no way to change the passphrase to protect data in any
qcow images. The files must be cloned, using a different
encryption passphrase in the new file. The original file
must then be securely erased using a program like shred,
though even this is ineffective with many modern storage
technologies.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="76%">


<p>Initialization vectors used to encrypt sectors are based
on the guest virtual sector number, instead of the host
physical sector. When a disk image has multiple internal
snapshots this means that data in multiple physical sectors
is encrypted with the same initialization vector. With the
CBC mode, this opens the possibility of watermarking attacks
if the attack can collect multiple sectors encrypted with
the same IV and some predictable data. Having multiple qcow2
images with the same passphrase also exposes this weakness
since the passphrase is directly used as the key.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Use of qcow /
qcow2 encryption is thus strongly discouraged. Users are
recommended to use an alternative encryption technology such
as the Linux dm-crypt / LUKS system.</p>

<p style="margin-left:13%;"><b>cluster_size</b></p>

<p style="margin-left:22%;">Changes the qcow2 cluster size
(must be between 512 and 2M). Smaller cluster sizes can
improve the image file size whereas larger cluster sizes
generally provide better performance.</p>

<p style="margin-left:13%;"><b>preallocation</b></p>

<p style="margin-left:22%;">Preallocation mode (allowed
values: <b>off</b>, <b>metadata</b>, <b>falloc</b>,
<b>full</b>). An image with preallocated metadata is
initially larger but can improve performance when the image
needs to grow. <b>falloc</b> and <b>full</b> preallocations
are like the same options of <b>raw</b> format, but sets up
metadata also.</p>

<p style="margin-left:13%;"><b>lazy_refcounts</b></p>

<p style="margin-left:22%;">If this option is set to
<b>on</b>, reference count updates are postponed with the
goal of avoiding metadata I/O and improving performance.
This is particularly interesting with
<b>cache=writethrough</b> which doesn't batch metadata
updates. The tradeoff is that after a host crash, the
reference count tables must be rebuilt, i.e. on the next
open an (automatic) <b>qemu-img check -r all</b> is
required, which may take some time.</p>

<p style="margin-left:22%; margin-top: 1em">This option can
only be enabled if <b>compat=1.1</b> is specified.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">


<p><b>nocow</b></p></td>
<td width="3%"></td>
<td width="78%">


<p>If this option is set to <b>on</b>, it will turn off COW
of the file. It's only valid on btrfs, no effect on other
file systems.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Btrfs has low
performance when hosting a VM image file, even more when the
guest on the VM also using btrfs as file system. Turning off
COW is a way to mitigate this bad performance. Generally
there are two ways to turn off COW on btrfs:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="76%">


<p style="margin-top: 1em">Disable it by mounting with
nodatacow, then all newly created files will be NOCOW</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="76%">


<p>For an empty file, add the NOCOW file attribute. That's
what this option does.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Note: this
option is only valid to new or empty files. If there is an
existing file which is COW and has data blocks already, it
couldn't be changed to NOCOW by setting <b>nocow=on</b>. One
can issue <b>lsattr filename</b> to check if the NOCOW flag
is set or not (Capital 'C' is NOCOW flag).</p>

<p style="margin-left:13%;"><b>data_file</b></p>

<p style="margin-left:22%;">Filename where all guest data
will be stored. If this option is used, the qcow2 file will
only contain the image's metadata.</p>

<p style="margin-left:22%; margin-top: 1em">Note: Data loss
will occur if the given filename already exists when using
this option with <b>qemu-img create</b> since
<b>qemu-img</b> will create the data file anew, overwriting
the file's original contents. To simply update the reference
to point to the given pre-existing file, use <b>qemu-img
amend</b>.</p>

<p style="margin-left:13%;"><b>data_file_raw</b></p>

<p style="margin-left:22%;">If this option is set to
<b>on</b>, QEMU will always keep the external data file
consistent as a standalone read-only raw image.</p>

<p style="margin-left:22%; margin-top: 1em">It does this by
forwarding all write accesses to the qcow2 file through to
the raw data file, including their offsets. Therefore, data
that is visible on the qcow2 node (i.e., to the guest) at
some offset is visible at the same offset in the raw data
file. This results in a read-only raw image. Writes that
bypass the qcow2 metadata may corrupt the qcow2 metadata
because the out-of-band writes may result in the metadata
falling out of sync with the raw image.</p>

<p style="margin-left:22%; margin-top: 1em">If this option
is <b>off</b>, QEMU will use the data file to store data in
an arbitrary manner. The file&rsquo;s content will not make
sense without the accompanying qcow2 metadata. Where data is
written will have no relation to its offset as seen by the
guest, and some writes (specifically zero writes) may not be
forwarded to the data file at all, but will only be handled
by modifying qcow2 metadata.</p>

<p style="margin-left:22%; margin-top: 1em">This option can
only be enabled if <b>data_file</b> is set.</p>


<p style="margin-left:9%; margin-top: 1em"><b>Other</b></p>

<p style="margin-left:13%;">QEMU also supports various
other image file formats for compatibility with older QEMU
versions or other hypervisors, including VMDK, VDI, VHD
(vpc), VHDX, qcow1 and QED. For a full list of supported
formats see <b>qemu-img --help</b>. For a more detailed
description of these formats, see the QEMU block drivers
reference documentation.</p>

<p style="margin-left:13%; margin-top: 1em">The main
purpose of the block drivers for these formats is image
conversion. For running VMs, it is recommended to convert
the disk images to either raw or qcow2 in order to achieve
good performance.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">Fabrice
Bellard</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">2024, The QEMU
Project Developers</p>
<hr>
</body>
</html>
