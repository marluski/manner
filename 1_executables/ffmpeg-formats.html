<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Mon Apr  7 17:24:24 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>FFMPEG-FORMATS</title>

</head>
<body>

<h1 align="center">FFMPEG-FORMATS</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#FORMAT OPTIONS">FORMAT OPTIONS</a><br>
<a href="#Format stream specifiers">Format stream specifiers</a><br>
<a href="#DEMUXERS">DEMUXERS</a><br>
<a href="#aa">aa</a><br>
<a href="#aac">aac</a><br>
<a href="#apng">apng</a><br>
<a href="#asf">asf</a><br>
<a href="#concat">concat</a><br>
<a href="#dash">dash</a><br>
<a href="#dvdvideo">dvdvideo</a><br>
<a href="#ea">ea</a><br>
<a href="#imf">imf</a><br>
<a href="#flv, live_flv, kux">flv, live_flv, kux</a><br>
<a href="#gif">gif</a><br>
<a href="#hls">hls</a><br>
<a href="#image2">image2</a><br>
<a href="#libgme">libgme</a><br>
<a href="#libmodplug">libmodplug</a><br>
<a href="#libopenmpt">libopenmpt</a><br>
<a href="#mov/mp4/3gp">mov/mp4/3gp</a><br>
<a href="#mpegts">mpegts</a><br>
<a href="#mpjpeg">mpjpeg</a><br>
<a href="#rawvideo">rawvideo</a><br>
<a href="#rcwt">rcwt</a><br>
<a href="#sbg">sbg</a><br>
<a href="#tedcaptions">tedcaptions</a><br>
<a href="#vapoursynth">vapoursynth</a><br>
<a href="#w64">w64</a><br>
<a href="#wav">wav</a><br>
<a href="#MUXERS">MUXERS</a><br>
<a href="#Raw muxers">Raw muxers</a><br>
<a href="#Raw PCM muxers">Raw PCM muxers</a><br>
<a href="#MPEG-1/MPEG-2 program stream muxers">MPEG-1/MPEG-2 program stream muxers</a><br>
<a href="#MOV/MPEG-4/ISOMBFF muxers">MOV/MPEG-4/ISOMBFF muxers</a><br>
<a href="#a64">a64</a><br>
<a href="#ac4">ac4</a><br>
<a href="#adts">adts</a><br>
<a href="#aea">aea</a><br>
<a href="#aiff">aiff</a><br>
<a href="#alp">alp</a><br>
<a href="#amr">amr</a><br>
<a href="#amv">amv</a><br>
<a href="#apm">apm</a><br>
<a href="#apng">apng</a><br>
<a href="#argo_asf">argo_asf</a><br>
<a href="#argo_cvg">argo_cvg</a><br>
<a href="#asf, asf_stream">asf, asf_stream</a><br>
<a href="#ass">ass</a><br>
<a href="#ast">ast</a><br>
<a href="#au">au</a><br>
<a href="#avi">avi</a><br>
<a href="#avif">avif</a><br>
<a href="#avm2">avm2</a><br>
<a href="#bit">bit</a><br>
<a href="#caf">caf</a><br>
<a href="#codec2">codec2</a><br>
<a href="#chromaprint">chromaprint</a><br>
<a href="#crc">crc</a><br>
<a href="#dash">dash</a><br>
<a href="#daud">daud</a><br>
<a href="#dv">dv</a><br>
<a href="#ffmetadata">ffmetadata</a><br>
<a href="#fifo">fifo</a><br>
<a href="#film_cpk">film_cpk</a><br>
<a href="#filmstrip">filmstrip</a><br>
<a href="#fits">fits</a><br>
<a href="#flac">flac</a><br>
<a href="#flv">flv</a><br>
<a href="#framecrc">framecrc</a><br>
<a href="#framehash">framehash</a><br>
<a href="#framemd5">framemd5</a><br>
<a href="#gif">gif</a><br>
<a href="#gxf">gxf</a><br>
<a href="#hash">hash</a><br>
<a href="#hds">hds</a><br>
<a href="#hls">hls</a><br>
<a href="#iamf">iamf</a><br>
<a href="#ico">ico</a><br>
<a href="#ilbc">ilbc</a><br>
<a href="#image2, image2pipe">image2, image2pipe</a><br>
<a href="#ircam">ircam</a><br>
<a href="#ivf">ivf</a><br>
<a href="#jacosub">jacosub</a><br>
<a href="#kvag">kvag</a><br>
<a href="#lc3">lc3</a><br>
<a href="#lrc">lrc</a><br>
<a href="#matroska">matroska</a><br>
<a href="#md5">md5</a><br>
<a href="#microdvd">microdvd</a><br>
<a href="#mmf">mmf</a><br>
<a href="#mp3">mp3</a><br>
<a href="#mpegts">mpegts</a><br>
<a href="#mxf, mxf_d10, mxf_opatom">mxf, mxf_d10, mxf_opatom</a><br>
<a href="#null">null</a><br>
<a href="#nut">nut</a><br>
<a href="#ogg">ogg</a><br>
<a href="#rcwt">rcwt</a><br>
<a href="#segment, stream_segment, ssegment">segment, stream_segment, ssegment</a><br>
<a href="#smoothstreaming">smoothstreaming</a><br>
<a href="#streamhash">streamhash</a><br>
<a href="#tee">tee</a><br>
<a href="#webm_chunk">webm_chunk</a><br>
<a href="#webm_dash_manifest">webm_dash_manifest</a><br>
<a href="#METADATA">METADATA</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHORS">AUTHORS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">ffmpeg-formats -
FFmpeg formats</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">This document
describes the supported formats (muxers and demuxers)
provided by the libavformat library.</p>

<h2>FORMAT OPTIONS
<a name="FORMAT OPTIONS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">The libavformat
library provides some generic global options, which can be
set on all the muxers and demuxers. In addition each muxer
or demuxer may support so-called private options, which are
specific for that component.</p>

<p style="margin-left:9%; margin-top: 1em">Options may be
set by specifying -<i>option value</i> in the FFmpeg tools,
or by setting the value explicitly in the
&quot;AVFormatContext&quot; options or using the
<i>libavutil/opt.h</i> API for programmatic use.</p>

<p style="margin-left:9%; margin-top: 1em">The list of
supported options follows: <b><br>
avioflags</b> <i>flags</i>
<b>(</b><i>input/output</i><b>)</b></p>

<p style="margin-left:14%;">Possible values: <b><br>
direct</b></p>

<p style="margin-left:19%;">Reduce buffering.</p>

<p style="margin-left:9%;"><b>probesize</b> <i>integer</i>
<b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:14%;">Set probing size in bytes, i.e.
the size of the data to analyze to get stream information. A
higher value will enable detecting more information in case
it is dispersed into the stream, but will increase latency.
Must be an integer not lesser than 32. It is 5000000 by
default.</p>

<p style="margin-left:9%;"><b>max_probe_packets</b>
<i>integer</i> <b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:14%;">Set the maximum number of
buffered packets when probing a codec. Default is 2500
packets.</p>

<p style="margin-left:9%;"><b>packetsize</b> <i>integer</i>
<b>(</b><i>output</i><b>)</b></p>

<p style="margin-left:14%;">Set packet size.</p>

<p style="margin-left:9%;"><b>fflags</b> <i>flags</i></p>

<p style="margin-left:14%;">Set format flags. Some are
implemented for a limited number of formats.</p>

<p style="margin-left:14%; margin-top: 1em">Possible values
for input files: <b><br>
discardcorrupt</b></p>

<p style="margin-left:19%;">Discard corrupted packets.</p>

<p style="margin-left:14%;"><b>fastseek</b></p>

<p style="margin-left:19%;">Enable fast, but inaccurate
seeks for some formats.</p>

<p style="margin-left:14%;"><b>genpts</b></p>

<p style="margin-left:19%;">Generate missing PTS if DTS is
present.</p>

<p style="margin-left:14%;"><b>igndts</b></p>

<p style="margin-left:19%;">Ignore DTS if PTS is also set.
In case the PTS is set, the DTS value is set to NOPTS. This
is ignored when the &quot;nofillin&quot; flag is set.</p>

<p style="margin-left:14%;"><b>ignidx</b></p>

<p style="margin-left:19%;">Ignore index.</p>

<p style="margin-left:14%;"><b>nobuffer</b></p>

<p style="margin-left:19%;">Reduce the latency introduced
by buffering during initial input streams analysis.</p>

<p style="margin-left:14%;"><b>nofillin</b></p>

<p style="margin-left:19%;">Do not fill in missing values
in packet fields that can be exactly calculated.</p>

<p style="margin-left:14%;"><b>noparse</b></p>

<p style="margin-left:19%;">Disable AVParsers, this needs
&quot;+nofillin&quot; too.</p>

<p style="margin-left:14%;"><b>sortdts</b></p>

<p style="margin-left:19%;">Try to interleave output
packets by DTS. At present, available only for AVIs with an
index.</p>

<p style="margin-left:14%; margin-top: 1em">Possible values
for output files: <b><br>
autobsf</b></p>

<p style="margin-left:19%;">Automatically apply bitstream
filters as required by the output format. Enabled by
default.</p>

<p style="margin-left:14%;"><b>bitexact</b></p>

<p style="margin-left:19%;">Only write platform-, build-
and time-independent data. This ensures that file and data
checksums are reproducible and match between platforms. Its
primary use is for regression testing.</p>

<p style="margin-left:14%;"><b>flush_packets</b></p>

<p style="margin-left:19%;">Write out packets
immediately.</p>

<p style="margin-left:14%;"><b>shortest</b></p>

<p style="margin-left:19%;">Stop muxing at the end of the
shortest stream. It may be needed to increase
max_interleave_delta to avoid flushing the longer streams
before EOF.</p>

<p style="margin-left:9%;"><b>seek2any</b> <i>integer</i>
<b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:14%;">Allow seeking to non-keyframes
on demuxer level when supported if set to 1. Default is
0.</p>

<p style="margin-left:9%;"><b>analyzeduration</b>
<i>integer</i> <b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:14%;">Specify how many microseconds
are analyzed to probe the input. A higher value will enable
detecting more accurate information, but will increase
latency. It defaults to 5,000,000 microseconds = 5
seconds.</p>

<p style="margin-left:9%;"><b>cryptokey</b> <i>hexadecimal
string</i> <b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:14%;">Set decryption key.</p>

<p style="margin-left:9%;"><b>indexmem</b> <i>integer</i>
<b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:14%;">Set max memory used for
timestamp index (per stream).</p>

<p style="margin-left:9%;"><b>rtbufsize</b> <i>integer</i>
<b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:14%;">Set max memory used for
buffering real-time frames.</p>

<p style="margin-left:9%;"><b>fdebug</b> <i>flags</i>
<b>(</b><i>input/output</i><b>)</b></p>

<p style="margin-left:14%;">Print specific debug info.</p>

<p style="margin-left:14%; margin-top: 1em">Possible
values:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="3%">


<p><b>ts</b></p></td>
<td width="83%">
</td></tr>
</table>


<p style="margin-left:9%; margin-top: 1em"><b>max_delay</b>
<i>integer</i> <b>(</b><i>input/output</i><b>)</b></p>

<p style="margin-left:14%;">Set maximum muxing or demuxing
delay in microseconds.</p>

<p style="margin-left:9%;"><b>fpsprobesize</b>
<i>integer</i> <b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:14%;">Set number of frames used to
probe fps.</p>

<p style="margin-left:9%;"><b>audio_preload</b>
<i>integer</i> <b>(</b><i>output</i><b>)</b></p>

<p style="margin-left:14%;">Set microseconds by which audio
packets should be interleaved earlier.</p>

<p style="margin-left:9%;"><b>chunk_duration</b>
<i>integer</i> <b>(</b><i>output</i><b>)</b></p>

<p style="margin-left:14%;">Set microseconds for each
chunk.</p>

<p style="margin-left:9%;"><b>chunk_size</b> <i>integer</i>
<b>(</b><i>output</i><b>)</b></p>

<p style="margin-left:14%;">Set size in bytes for each
chunk.</p>

<p style="margin-left:9%;"><b>err_detect, f_err_detect</b>
<i>flags</i> <b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:14%;">Set error detection flags.
&quot;f_err_detect&quot; is deprecated and should be used
only via the <b>ffmpeg</b> tool.</p>

<p style="margin-left:14%; margin-top: 1em">Possible
values: <b><br>
crccheck</b></p>

<p style="margin-left:19%;">Verify embedded CRCs.</p>

<p style="margin-left:14%;"><b>bitstream</b></p>

<p style="margin-left:19%;">Detect bitstream specification
deviations.</p>

<p style="margin-left:14%;"><b>buffer</b></p>

<p style="margin-left:19%;">Detect improper bitstream
length.</p>

<p style="margin-left:14%;"><b>explode</b></p>

<p style="margin-left:19%;">Abort decoding on minor error
detection.</p>

<p style="margin-left:14%;"><b>careful</b></p>

<p style="margin-left:19%;">Consider things that violate
the spec and have not been seen in the wild as errors.</p>

<p style="margin-left:14%;"><b>compliant</b></p>

<p style="margin-left:19%;">Consider all spec non
compliancies as errors.</p>

<p style="margin-left:14%;"><b>aggressive</b></p>

<p style="margin-left:19%;">Consider things that a sane
encoder should not do as an error.</p>

<p style="margin-left:9%;"><b>max_interleave_delta</b>
<i>integer</i> <b>(</b><i>output</i><b>)</b></p>

<p style="margin-left:14%;">Set maximum buffering duration
for interleaving. The duration is expressed in microseconds,
and defaults to 10000000 (10 seconds).</p>

<p style="margin-left:14%; margin-top: 1em">To ensure all
the streams are interleaved correctly, libavformat will wait
until it has at least one packet for each stream before
actually writing any packets to the output file. When some
streams are &quot;sparse&quot; (i.e. there are large gaps
between successive packets), this can result in excessive
buffering.</p>

<p style="margin-left:14%; margin-top: 1em">This field
specifies the maximum difference between the timestamps of
the first and the last packet in the muxing queue, above
which libavformat will output a packet regardless of whether
it has queued a packet for all the streams.</p>

<p style="margin-left:14%; margin-top: 1em">If set to 0,
libavformat will continue buffering packets until it has a
packet for each stream, regardless of the maximum timestamp
difference between the buffered packets.</p>


<p style="margin-left:9%;"><b>use_wallclock_as_timestamps</b>
<i>integer</i> <b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:14%;">Use wallclock as timestamps if
set to 1. Default is 0.</p>

<p style="margin-left:9%;"><b>avoid_negative_ts</b>
<i>integer</i> <b>(</b><i>output</i><b>)</b></p>

<p style="margin-left:14%;">Possible values: <b><br>
make_non_negative</b></p>

<p style="margin-left:19%;">Shift timestamps to make them
non-negative. Also note that this affects only leading
negative timestamps, and not non-monotonic negative
timestamps.</p>

<p style="margin-left:14%;"><b>make_zero</b></p>

<p style="margin-left:19%;">Shift timestamps so that the
first timestamp is 0.</p>

<p style="margin-left:14%;"><b>auto (default)</b></p>

<p style="margin-left:19%;">Enables shifting when required
by the target format.</p>

<p style="margin-left:14%;"><b>disabled</b></p>

<p style="margin-left:19%;">Disables shifting of
timestamp.</p>

<p style="margin-left:14%; margin-top: 1em">When shifting
is enabled, all output timestamps are shifted by the same
amount. Audio, video, and subtitles desynching and relative
timestamp differences are preserved compared to how they
would have been without shifting.</p>

<p style="margin-left:9%;"><b>skip_initial_bytes</b>
<i>integer</i> <b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:14%;">Set number of bytes to skip
before reading header and frames if set to 1. Default is
0.</p>

<p style="margin-left:9%;"><b>correct_ts_overflow</b>
<i>integer</i> <b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:14%;">Correct single timestamp
overflows if set to 1. Default is 1.</p>

<p style="margin-left:9%;"><b>flush_packets</b>
<i>integer</i> <b>(</b><i>output</i><b>)</b></p>

<p style="margin-left:14%;">Flush the underlying I/O stream
after each packet. Default is -1 (auto), which means that
the underlying protocol will decide, 1 enables it, and has
the effect of reducing the latency, 0 disables it and may
increase IO throughput in some cases.</p>

<p style="margin-left:9%;"><b>output_ts_offset</b>
<i>offset</i> <b>(</b><i>output</i><b>)</b></p>

<p style="margin-left:14%;">Set the output time offset.</p>

<p style="margin-left:14%; margin-top: 1em"><i>offset</i>
must be a time duration specification, see <b>the Time
duration section in the ffmpeg-utils(1) manual</b>.</p>

<p style="margin-left:14%; margin-top: 1em">The offset is
added by the muxer to the output timestamps.</p>

<p style="margin-left:14%; margin-top: 1em">Specifying a
positive offset means that the corresponding streams are
delayed bt the time duration specified in <i>offset</i>.
Default value is 0 (meaning that no offset is applied).</p>

<p style="margin-left:9%;"><b>format_whitelist</b>
<i>list</i> <b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:14%;">&quot;,&quot; separated list of
allowed demuxers. By default all are allowed.</p>

<p style="margin-left:9%;"><b>dump_separator</b>
<i>string</i> <b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:14%;">Separator used to separate the
fields printed on the command line about the Stream
parameters. For example, to separate the fields with
newlines and indentation:</p>

<p style="margin-left:14%; margin-top: 1em">ffprobe
-dump_separator &quot; <br>
&quot; -i &#732;/videos/matrixbench_mpeg2.mpg</p>

<p style="margin-left:9%;"><b>max_streams</b>
<i>integer</i> <b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:14%;">Specifies the maximum number of
streams. This can be used to reject files that would require
too many resources due to a large number of streams.</p>


<p style="margin-left:9%;"><b>skip_estimate_duration_from_pts</b>
<i>bool</i> <b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:14%;">Skip estimation of input
duration if it requires an additional probing for PTS at end
of file. At present, applicable for MPEG-PS and MPEG-TS.</p>

<p style="margin-left:9%;"><b>duration_probesize</b>
<i>integer</i> <b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:14%;">Set probing size, in bytes, for
input duration estimation when it actually requires an
additional probing for PTS at end of file (at present:
MPEG-PS and MPEG-TS). It is aimed at users interested in
better durations probing for itself, or indirectly because
using the concat demuxer, for example. The typical use case
is an MPEG-TS CBR with a high bitrate, high video buffering
and ending cleaning with similar PTS for video and audio: in
such a scenario, the large physical gap between the last
video packet and the last audio packet makes it necessary to
read many bytes in order to get the video stream duration.
Another use case is where the default probing behaviour only
reaches a single video frame which is not the last one of
the stream due to frame reordering, so the duration is not
accurate. Setting this option has a performance impact even
for small files because the probing size is fixed. Default
behaviour is a general purpose trade-off, largely adaptive,
but the probing size will not be extended to get streams
durations at all costs. Must be an integer not lesser than
1, or 0 for default behaviour.</p>

<p style="margin-left:9%;"><b>strict, f_strict</b>
<i>integer</i> <b>(</b><i>input/output</i><b>)</b></p>

<p style="margin-left:14%;">Specify how strictly to follow
the standards. &quot;f_strict&quot; is deprecated and should
be used only via the <b>ffmpeg</b> tool.</p>

<p style="margin-left:14%; margin-top: 1em">Possible
values: <b><br>
very</b></p>

<p style="margin-left:19%;">strictly conform to an older
more strict version of the spec or reference software</p>

<p style="margin-left:14%;"><b>strict</b></p>

<p style="margin-left:19%;">strictly conform to all the
things in the spec no matter what consequences</p>

<p style="margin-left:14%;"><b>normal <br>
unofficial</b></p>

<p style="margin-left:19%;">allow unofficial extensions</p>

<p style="margin-left:14%;"><b>experimental</b></p>

<p style="margin-left:19%;">allow non standardized
experimental things, experimental (unfinished/work in
progress/not well tested) decoders and encoders. Note:
experimental decoders can pose a security risk, do not use
this for decoding untrusted input.</p>

<h3>Format stream specifiers
<a name="Format stream specifiers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Format stream
specifiers allow selection of one or more streams that match
specific properties.</p>

<p style="margin-left:9%; margin-top: 1em">The exact
semantics of stream specifiers is defined by the
avformat_match_stream_specifier() function declared in the
<i>libavformat/avformat.h</i> header and documented in the
<b>Stream specifiers section in the ffmpeg(1)
manual</b>.</p>

<h2>DEMUXERS
<a name="DEMUXERS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">Demuxers are
configured elements in FFmpeg that can read the multimedia
streams from a particular type of file.</p>

<p style="margin-left:9%; margin-top: 1em">When you
configure your FFmpeg build, all the supported demuxers are
enabled by default. You can list all available ones using
the configure option &quot;--list-demuxers&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">You can disable
all the demuxers using the configure option
&quot;--disable-demuxers&quot;, and selectively enable a
single demuxer with the option
&quot;--enable-demuxer=<i>DEMUXER</i>&quot;, or disable it
with the option
&quot;--disable-demuxer=<i>DEMUXER</i>&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">The option
&quot;-demuxers&quot; of the ff* tools will display the list
of enabled demuxers. Use &quot;-formats&quot; to view a
combined list of enabled demuxers and muxers.</p>

<p style="margin-left:9%; margin-top: 1em">The description
of some of the currently available demuxers follows.</p>

<h3>aa
<a name="aa"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Audible Format
2, 3, and 4 demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer is
used to demux Audible Format 2, 3, and 4 (.aa) files.</p>

<h3>aac
<a name="aac"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Raw Audio Data
Transport Stream AAC demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer is
used to demux an ADTS input containing a single AAC stream
alongwith any ID3v1/2 or APE tags in it.</p>

<h3>apng
<a name="apng"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Animated
Portable Network Graphics demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer is
used to demux APNG files. All headers, but the PNG
signature, up to (but not including) the first fcTL chunk
are transmitted as extradata. Frames are then split as being
all the chunks between two fcTL ones, or between the last
fcTL and IEND chunks. <b><br>
-ignore_loop</b> <i>bool</i></p>

<p style="margin-left:14%;">Ignore the loop variable in the
file if set. Default is enabled.</p>

<p style="margin-left:9%;"><b>-max_fps</b> <i>int</i></p>

<p style="margin-left:14%;">Maximum framerate in frames per
second. Default of 0 imposes no limit.</p>

<p style="margin-left:9%;"><b>-default_fps</b>
<i>int</i></p>

<p style="margin-left:14%;">Default framerate in frames per
second when none is specified in the file (0 meaning as fast
as possible). Default is 15.</p>

<h3>asf
<a name="asf"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Advanced Systems
Format demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer is
used to demux ASF files and MMS network streams. <b><br>
-no_resync_search</b> <i>bool</i></p>

<p style="margin-left:14%;">Do not try to resynchronize by
looking for a certain optional start code.</p>

<h3>concat
<a name="concat"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Virtual
concatenation script demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
reads a list of files and other directives from a text file
and demuxes them one after the other, as if all their
packets had been muxed together.</p>

<p style="margin-left:9%; margin-top: 1em">The timestamps
in the files are adjusted so that the first file starts at 0
and each next file starts where the previous one finishes.
Note that it is done globally and may cause gaps if all
streams do not have exactly the same length.</p>

<p style="margin-left:9%; margin-top: 1em">All files must
have the same streams (same codecs, same time base,
etc.).</p>

<p style="margin-left:9%; margin-top: 1em">The duration of
each file is used to adjust the timestamps of the next file:
if the duration is incorrect (because it was computed using
the bit-rate or because the file is truncated, for example),
it can cause artifacts. The &quot;duration&quot; directive
can be used to override the duration stored in each
file.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Syntax</i></p>

<p style="margin-left:9%; margin-top: 1em">The script is a
text file in extended-ASCII, with one directive per line.
Empty lines, leading spaces and lines starting with
&rsquo;#&rsquo; are ignored. The following directive is
recognized: <b><br>
&quot;file path&quot;</b></p>

<p style="margin-left:14%;">Path to a file to read; special
characters and spaces must be escaped with backslash or
single quotes.</p>

<p style="margin-left:14%; margin-top: 1em">All subsequent
file-related directives apply to that file.</p>

<p style="margin-left:9%;"><b>&quot;ffconcat version
1.0&quot;</b></p>

<p style="margin-left:14%;">Identify the script type and
version.</p>

<p style="margin-left:14%; margin-top: 1em">To make FFmpeg
recognize the format automatically, this directive must
appear exactly as is (no extra space or byte-order-mark) on
the very first line of the script.</p>

<p style="margin-left:9%;"><b>&quot;duration
dur&quot;</b></p>

<p style="margin-left:14%;">Duration of the file. This
information can be specified from the file; specifying it
here may be more efficient or help if the information from
the file is not available or accurate.</p>

<p style="margin-left:14%; margin-top: 1em">If the duration
is set for all files, then it is possible to seek in the
whole concatenated video.</p>

<p style="margin-left:9%;"><b>&quot;inpoint
timestamp&quot;</b></p>

<p style="margin-left:14%;">In point of the file. When the
demuxer opens the file it instantly seeks to the specified
timestamp. Seeking is done so that all streams can be
presented successfully at In point.</p>

<p style="margin-left:14%; margin-top: 1em">This directive
works best with intra frame codecs, because for non-intra
frame ones you will usually get extra packets before the
actual In point and the decoded content will most likely
contain frames before In point too.</p>

<p style="margin-left:14%; margin-top: 1em">For each file,
packets before the file In point will have timestamps less
than the calculated start timestamp of the file (negative in
case of the first file), and the duration of the files (if
not specified by the &quot;duration&quot; directive) will be
reduced based on their specified In point.</p>

<p style="margin-left:14%; margin-top: 1em">Because of
potential packets before the specified In point, packet
timestamps may overlap between two concatenated files.</p>

<p style="margin-left:9%;"><b>&quot;outpoint
timestamp&quot;</b></p>

<p style="margin-left:14%;">Out point of the file. When the
demuxer reaches the specified decoding timestamp in any of
the streams, it handles it as an end of file condition and
skips the current and all the remaining packets from all
streams.</p>

<p style="margin-left:14%; margin-top: 1em">Out point is
exclusive, which means that the demuxer will not output
packets with a decoding timestamp greater or equal to Out
point.</p>

<p style="margin-left:14%; margin-top: 1em">This directive
works best with intra frame codecs and formats where all
streams are tightly interleaved. For non-intra frame codecs
you will usually get additional packets with presentation
timestamp after Out point therefore the decoded content will
most likely contain frames after Out point too. If your
streams are not tightly interleaved you may not get all the
packets from all streams before Out point and you may only
will be able to decode the earliest stream until Out
point.</p>

<p style="margin-left:14%; margin-top: 1em">The duration of
the files (if not specified by the &quot;duration&quot;
directive) will be reduced based on their specified Out
point.</p>

<p style="margin-left:9%;"><b>&quot;file_packet_metadata
key=value&quot;</b></p>

<p style="margin-left:14%;">Metadata of the packets of the
file. The specified metadata will be set for each file
packet. You can specify this directive multiple times to add
multiple metadata entries. This directive is deprecated, use
&quot;file_packet_meta&quot; instead.</p>

<p style="margin-left:9%;"><b>&quot;file_packet_meta key
value&quot;</b></p>

<p style="margin-left:14%;">Metadata of the packets of the
file. The specified metadata will be set for each file
packet. You can specify this directive multiple times to add
multiple metadata entries.</p>

<p style="margin-left:9%;"><b>&quot;option key
value&quot;</b></p>

<p style="margin-left:14%;">Option to access, open and
probe the file. Can be present multiple times.</p>

<p style="margin-left:9%;"><b>&quot;stream&quot;</b></p>

<p style="margin-left:14%;">Introduce a stream in the
virtual file. All subsequent stream-related directives apply
to the last introduced stream. Some streams properties must
be set in order to allow identifying the matching streams in
the subfiles. If no streams are defined in the script, the
streams from the first file are copied.</p>

<p style="margin-left:9%;"><b>&quot;exact_stream_id
id&quot;</b></p>

<p style="margin-left:14%;">Set the id of the stream. If
this directive is given, the string with the corresponding
id in the subfiles will be used. This is especially useful
for MPEG-PS (VOB) files, where the order of the streams is
not reliable.</p>

<p style="margin-left:9%;"><b>&quot;stream_meta key
value&quot;</b></p>

<p style="margin-left:14%;">Metadata for the stream. Can be
present multiple times.</p>

<p style="margin-left:9%;"><b>&quot;stream_codec
value&quot;</b></p>

<p style="margin-left:14%;">Codec for the stream.</p>

<p style="margin-left:9%;"><b>&quot;stream_extradata
hex_string&quot;</b></p>

<p style="margin-left:14%;">Extradata for the string,
encoded in hexadecimal.</p>

<p style="margin-left:9%;"><b>&quot;chapter id start
end&quot;</b></p>

<p style="margin-left:14%;">Add a chapter. <i>id</i> is an
unique identifier, possibly small and consecutive.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Options</i></p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
accepts the following option: <b><br>
safe</b></p>

<p style="margin-left:14%;">If set to 1, reject unsafe file
paths and directives. A file path is considered safe if it
does not contain a protocol specification and is relative
and all components only contain characters from the portable
character set (letters, digits, period, underscore and
hyphen) and have no period at the beginning of a
component.</p>

<p style="margin-left:14%; margin-top: 1em">If set to 0,
any file name is accepted.</p>

<p style="margin-left:14%; margin-top: 1em">The default is
1.</p>

<p style="margin-left:9%;"><b>auto_convert</b></p>

<p style="margin-left:14%;">If set to 1, try to perform
automatic conversions on packet data to make the streams
concatenable. The default is 1.</p>

<p style="margin-left:14%; margin-top: 1em">Currently, the
only conversion is adding the h264_mp4toannexb bitstream
filter to H.264 streams in MP4 format. This is necessary in
particular if there are resolution changes.</p>


<p style="margin-left:9%;"><b>segment_time_metadata</b></p>

<p style="margin-left:14%;">If set to 1, every packet will
contain the <i>lavf.concat.start_time</i> and the
<i>lavf.concat.duration</i> packet metadata values which are
the start_time and the duration of the respective file
segments in the concatenated output expressed in
microseconds. The duration metadata is only set if it is
known based on the concat file. The default is 0.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="63%">


<p>Use absolute filenames and include some comments:</p></td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em"># my first
filename <br>
file /mnt/share/file-1.wav <br>
# my second filename including whitespace <br>
file '/mnt/share/file 2.wav' <br>
# my third filename including whitespace plus single quote
<br>
file '/mnt/share/file 3'\''.wav'</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">Allow for input format
auto-probing, use safe filenames and set the duration of the
first file:</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffconcat
version 1.0 <br>
file file-1.wav <br>
duration 20.0 <br>
file subdir/file-2.wav</p>

<h3>dash
<a name="dash"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Dynamic Adaptive
Streaming over HTTP demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
presents all AVStreams found in the manifest. By setting the
discard flags on AVStreams the caller can decide which
streams to actually receive. Each stream mirrors the
&quot;id&quot; and &quot;bandwidth&quot; properties from the
&quot;&lt;Representation&gt;&quot; as metadata keys named
&quot;id&quot; and &quot;variant_bitrate&quot;
respectively.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Options</i></p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
accepts the following option: <b><br>
cenc_decryption_key</b></p>

<p style="margin-left:14%;">16-byte key, in hex, to decrypt
files encrypted using ISO Common Encryption (CENC/AES-128
CTR; ISO/IEC 23001-7).</p>

<h3>dvdvideo
<a name="dvdvideo"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">DVD-Video
demuxer, powered by libdvdnav and libdvdread.</p>

<p style="margin-left:9%; margin-top: 1em">Can directly
ingest DVD titles, specifically sequential PGCs, into a
conversion pipeline. Menu assets, such as background video
or audio, can also be demuxed given the menu&rsquo;s
coordinates (at best effort). Seeking is not supported at
this time.</p>

<p style="margin-left:9%; margin-top: 1em">Block devices
(DVD drives), ISO files, and directory structures are
accepted. Activate with &quot;-f dvdvideo&quot; in front of
one of these inputs.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
does NOT have decryption code of any kind. You are on your
own working with encrypted DVDs, and should not expect
support on the matter.</p>

<p style="margin-left:9%; margin-top: 1em">Underlying
playback is handled by libdvdnav, and structure parsing by
libdvdread. FFmpeg must be built with GPL library support
available as well as the configure switches
&quot;--enable-libdvdnav&quot; and
&quot;--enable-libdvdread&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">You will need to
provide either the desired &quot;title number&quot; or exact
PGC/PG coordinates. Many open-source DVD players and tools
can aid in providing this information. If not specified, the
demuxer will default to title 1 which works for many discs.
However, due to the flexibility of the format, it is
recommended to check manually. There are many discs that are
authored strangely or with invalid headers.</p>

<p style="margin-left:9%; margin-top: 1em">If the input is
a real DVD drive, please note that there are some drives
which may silently fail on reading bad sectors from the
disc, returning random bits instead which is effectively
corrupt data. This is especially prominent on aging or
rotting discs. A second pass and integrity checks would be
needed to detect the corruption. This is not an FFmpeg
issue.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Background</i></p>

<p style="margin-left:9%; margin-top: 1em">DVD-Video is not
a directly accessible, linear container format in the
traditional sense. Instead, it allows for complex and
programmatic playback of carefully muxed MPEG-PS streams
that are stored in headerless VOB files. To the end-user,
these streams are known simply as &quot;titles&quot;, but
the actual logical playback sequence is defined by one or
more &quot;PGCs&quot;, or Program Group Chains, within the
title. The PGC is in turn comprised of multiple
&quot;PGs&quot;, or Programs&quot;, which are the actual
video segments (and for a typical video feature,
sequentially ordered). The PGC structure, along with stream
layout and metadata, are stored in IFO files that need to be
parsed. PGCs can be thought of as playlists in easier
terms.</p>

<p style="margin-left:9%; margin-top: 1em">An actual DVD
player relies on user GUI interaction via menus and an
internal VM to drive the direction of demuxing. Generally,
the user would either navigate (via menus) or automatically
be redirected to the PGC of their choice. During this
process and the subsequent playback, the DVD player&rsquo;s
internal VM also maintains a state and executes instructions
that can create jumps to different sectors during playback.
This is why libdvdnav is involved, as a linear read of the
MPEG-PS blobs on the disc (VOBs) is not enough to produce
the right sequence in many cases.</p>

<p style="margin-left:9%; margin-top: 1em">There are many
other DVD structures (a long subject) that will not be
discussed here. NAV packets, in particular, are handled by
this demuxer to build accurate timing but not emitted as a
stream. For a good high-level understanding, refer to:
&lt;<b>https://code.videolan.org/videolan/libdvdnav/-/blob/master/doc/dvd_structures</b>&gt;</p>


<p style="margin-left:9%; margin-top: 1em"><i>Options</i></p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
accepts the following options: <b><br>
title</b> <i>int</i></p>

<p style="margin-left:14%;">The title number to play. Must
be set if <b>pgc</b> and <b>pg</b> are not set. Not
applicable to menus. Default is 0 (auto), which currently
only selects the first available title (title 1) and
notifies the user about the implications.</p>

<p style="margin-left:9%;"><b>chapter_start</b>
<i>int</i></p>

<p style="margin-left:14%;">The chapter, or PTT
(part-of-title), number to start at. Not applicable to
menus. Default is 1.</p>

<p style="margin-left:9%;"><b>chapter_end</b>
<i>int</i></p>

<p style="margin-left:14%;">The chapter, or PTT
(part-of-title), number to end at. Not applicable to menus.
Default is 0, which is a special value to signal end at the
last possible chapter.</p>

<p style="margin-left:9%;"><b>angle</b> <i>int</i></p>

<p style="margin-left:14%;">The video angle number,
referring to what is essentially an additional video stream
that is composed from alternate frames interleaved in the
VOBs. Not applicable to menus. Default is 1.</p>

<p style="margin-left:9%;"><b>region</b> <i>int</i></p>

<p style="margin-left:14%;">The region code to use for
playback. Some discs may use this to default playback at a
particular angle in different regions. This option will not
affect the region code of a real DVD drive, if used as an
input. Not applicable to menus. Default is 0,
&quot;world&quot;.</p>

<p style="margin-left:9%;"><b>menu</b> <i>bool</i></p>

<p style="margin-left:14%;">Demux menu assets instead of
navigating a title. Requires exact coordinates of the menu
(<b>menu_lu</b>, <b>menu_vts</b>, <b>pgc</b>, <b>pg</b>).
Default is false.</p>

<p style="margin-left:9%;"><b>menu_lu</b> <i>int</i></p>

<p style="margin-left:14%;">The menu language to demux. In
DVD, menus are grouped by language. Default is 0, the first
language unit.</p>

<p style="margin-left:9%;"><b>menu_vts</b> <i>int</i></p>

<p style="margin-left:14%;">The VTS where the menu lives,
or 0 if it is a VMG menu (root-level). Default is 0, VMG
menu.</p>

<p style="margin-left:9%;"><b>pgc</b> <i>int</i></p>

<p style="margin-left:14%;">The entry PGC to start
playback, in conjunction with <b>pg</b>. Alternative to
setting <b>title</b>. Chapter markers are not supported at
this time. Must be explicitly set for menus. Default is 0,
automatically resolve from value of <b>title</b>.</p>

<p style="margin-left:9%;"><b>pg</b> <i>int</i></p>

<p style="margin-left:14%;">The entry PG to start playback,
in conjunction with <b>pgc</b>. Alternative to setting
<b>title</b>. Chapter markers are not supported at this
time. Default is 0, automatically resolve from value of
<b>title</b>, or start from the beginning (PG 1) of the
menu.</p>

<p style="margin-left:9%;"><b>preindex</b> <i>bool</i></p>

<p style="margin-left:14%;">Enable this to have accurate
chapter (PTT) markers and duration measurement, which
requires a slow second pass read in order to index the
chapter marker timestamps from NAV packets. This is
non-ideal extra work for real optical drives. It is
recommended and faster to use this option with a backup of
the DVD structure stored on a hard drive. Not compatible
with <b>pgc</b> and <b>pg</b>. Not applicable to menus.
Default is 0, false.</p>

<p style="margin-left:9%;"><b>trim</b> <i>bool</i></p>

<p style="margin-left:14%;">Skip padding cells (i.e. cells
shorter than 1 second) from the beginning. There exist many
discs with filler segments at the beginning of the PGC,
often with junk data intended for controlling a real DVD
player&rsquo;s buffering speed and with no other material
data value. Not applicable to menus. Default is 1, true.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="51%">


<p>Open title 3 from a given DVD structure:</p></td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -f
dvdvideo -title 3 -i &lt;path to DVD&gt; ...</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="74%">


<p style="margin-top: 1em">Open chapters 3-6 from title 1
from a given DVD structure:</p></td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -f
dvdvideo -chapter_start 3 -chapter_end 6 -title 1 -i
&lt;path to DVD&gt; ...</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="77%">


<p style="margin-top: 1em">Open only chapter 5 from title 1
from a given DVD structure:</p></td>
<td width="9%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -f
dvdvideo -chapter_start 5 -chapter_end 5 -title 1 -i
&lt;path to DVD&gt; ...</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="81%">


<p style="margin-top: 1em">Demux menu with language 1 from
VTS 1, PGC 1, starting at PG 1:</p></td>
<td width="5%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -f
dvdvideo -menu 1 -menu_lu 1 -menu_vts 1 -pgc 1 -pg 1 -i
&lt;path to DVD&gt; ...</p>

<h3>ea
<a name="ea"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Electronic Arts
Multimedia format demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">This format is
used by various Electronic Arts games.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
merge_alpha</b> <i>bool</i></p>

<p style="margin-left:14%;">Normally the VP6 alpha channel
(if exists) is returned as a secondary video stream, by
setting this option you can make the demuxer return a single
video stream which contains the alpha channel in addition to
the ordinary video.</p>

<h3>imf
<a name="imf"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Interoperable
Master Format demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
presents audio and video streams found in an IMF
Composition, as specified in
&lt;<b>https://doi.org/10.5594/SMPTE.ST2067-2.2020</b>&gt;.</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg
[-assetmaps &lt;path of ASSETMAP1&gt;,&lt;path of
ASSETMAP2&gt;,...] -i &lt;path of CPL&gt; ...</p>

<p style="margin-left:9%; margin-top: 1em">If
&quot;-assetmaps&quot; is not specified, the demuxer looks
for a file called <i>ASSETMAP.xml</i> in the same directory
as the CPL.</p>

<h3>flv, live_flv, kux
<a name="flv, live_flv, kux"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Adobe Flash
Video Format demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer is
used to demux FLV files and RTMP network streams. In case of
live network streams, if you force format, you may use
live_flv option instead of flv to survive timestamp
discontinuities. KUX is a flv variant used on the Youku
platform.</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -f flv -i
myfile.flv ... <br>
ffmpeg -f live_flv -i rtmp://&lt;any.server&gt;/anything/key
.... <b><br>
-flv_metadata</b> <i>bool</i></p>

<p style="margin-left:14%;">Allocate the streams according
to the onMetaData array content.</p>

<p style="margin-left:9%;"><b>-flv_ignore_prevtag</b>
<i>bool</i></p>

<p style="margin-left:14%;">Ignore the size of previous tag
value.</p>

<p style="margin-left:9%;"><b>-flv_full_metadata</b>
<i>bool</i></p>

<p style="margin-left:14%;">Output all context of the
onMetadata.</p>

<h3>gif
<a name="gif"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Animated GIF
demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts the
following options: <b><br>
min_delay</b></p>

<p style="margin-left:14%;">Set the minimum valid delay
between frames in hundredths of seconds. Range is 0 to 6000.
Default value is 2.</p>

<p style="margin-left:9%;"><b>max_gif_delay</b></p>

<p style="margin-left:14%;">Set the maximum valid delay
between frames in hundredth of seconds. Range is 0 to 65535.
Default value is 65535 (nearly eleven minutes), the maximum
value allowed by the specification.</p>

<p style="margin-left:9%;"><b>default_delay</b></p>

<p style="margin-left:14%;">Set the default delay between
frames in hundredths of seconds. Range is 0 to 6000. Default
value is 10.</p>

<p style="margin-left:9%;"><b>ignore_loop</b></p>

<p style="margin-left:14%;">GIF files can contain
information to loop a certain number of times (or
infinitely). If <b>ignore_loop</b> is set to 1, then the
loop setting from the input will be ignored and looping will
not occur. If set to 0, then looping will occur and will
cycle the number of times according to the GIF. Default
value is 1.</p>

<p style="margin-left:9%; margin-top: 1em">For example,
with the overlay filter, place an infinitely looping GIF
over another video:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i
input.mp4 -ignore_loop 0 -i input.gif -filter_complex
overlay=shortest=1 out.mkv</p>

<p style="margin-left:9%; margin-top: 1em">Note that in the
above example the shortest option for overlay filter is used
to end the output video at the length of the shortest input
file, which in this case is <i>input.mp4</i> as the GIF in
this example loops infinitely.</p>

<h3>hls
<a name="hls"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">HLS demuxer</p>

<p style="margin-left:9%; margin-top: 1em">Apple HTTP Live
Streaming demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
presents all AVStreams from all variant streams. The id
field is set to the bitrate variant index number. By setting
the discard flags on AVStreams (by pressing &rsquo;a&rsquo;
or &rsquo;v&rsquo; in ffplay), the caller can decide which
variant streams to actually receive. The total bitrate of
the variant that the stream belongs to is available in a
metadata key named &quot;variant_bitrate&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts the
following options: <b><br>
live_start_index</b></p>

<p style="margin-left:14%;">segment index to start live
streams at (negative values are from the end).</p>

<p style="margin-left:9%;"><b>prefer_x_start</b></p>

<p style="margin-left:14%;">prefer to use #EXT-X-START if
it&rsquo;s in playlist instead of live_start_index.</p>

<p style="margin-left:9%;"><b>allowed_extensions</b></p>

<p style="margin-left:14%;">&rsquo;,&rsquo; separated list
of file extensions that hls is allowed to access.</p>

<p style="margin-left:9%;"><b>max_reload</b></p>

<p style="margin-left:14%;">Maximum number of times a
insufficient list is attempted to be reloaded. Default value
is 1000.</p>

<p style="margin-left:9%;"><b>m3u8_hold_counters</b></p>

<p style="margin-left:14%;">The maximum number of times to
load m3u8 when it refreshes without new segments. Default
value is 1000.</p>

<p style="margin-left:9%;"><b>http_persistent</b></p>

<p style="margin-left:14%;">Use persistent HTTP
connections. Applicable only for HTTP streams. Enabled by
default.</p>

<p style="margin-left:9%;"><b>http_multiple</b></p>

<p style="margin-left:14%;">Use multiple HTTP connections
for downloading HTTP segments. Enabled by default for
HTTP/1.1 servers.</p>

<p style="margin-left:9%;"><b>http_seekable</b></p>

<p style="margin-left:14%;">Use HTTP partial requests for
downloading HTTP segments. 0 = disable, 1 = enable, -1 =
auto, Default is auto.</p>

<p style="margin-left:9%;"><b>seg_format_options</b></p>

<p style="margin-left:14%;">Set options for the demuxer of
media segments using a list of key=value pairs separated by
&quot;:&quot;.</p>

<p style="margin-left:9%;"><b>seg_max_retry</b></p>

<p style="margin-left:14%;">Maximum number of times to
reload a segment on error, useful when segment skip on
network error is not desired. Default value is 0.</p>

<h3>image2
<a name="image2"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Image file
demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
reads from a list of image files specified by a pattern. The
syntax and meaning of the pattern is specified by the option
<i>pattern_type</i>.</p>

<p style="margin-left:9%; margin-top: 1em">The pattern may
contain a suffix which is used to automatically determine
the format of the images contained in the files.</p>

<p style="margin-left:9%; margin-top: 1em">The size, the
pixel format, and the format of each image must be the same
for all the files in the sequence.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
accepts the following options: <b><br>
framerate</b></p>

<p style="margin-left:14%;">Set the frame rate for the
video stream. It defaults to 25.</p>

<p style="margin-left:9%;"><b>loop</b></p>

<p style="margin-left:14%;">If set to 1, loop over the
input. Default value is 0.</p>

<p style="margin-left:9%;"><b>pattern_type</b></p>

<p style="margin-left:14%;">Select the pattern type used to
interpret the provided filename.</p>


<p style="margin-left:14%; margin-top: 1em"><i>pattern_type</i>
accepts one of the following values. <b><br>
none</b></p>

<p style="margin-left:19%;">Disable pattern matching,
therefore the video will only contain the specified image.
You should use this option if you do not want to create
sequences from multiple images and your filenames may
contain special pattern characters.</p>

<p style="margin-left:14%;"><b>sequence</b></p>

<p style="margin-left:19%;">Select a sequence pattern type,
used to specify a sequence of files indexed by sequential
numbers.</p>

<p style="margin-left:19%; margin-top: 1em">A sequence
pattern may contain the string &quot;%d&quot; or
&quot;%0<i>N</i>d&quot;, which specifies the position of the
characters representing a sequential number in each filename
matched by the pattern. If the form &quot;%d0<i>N</i>d&quot;
is used, the string representing the number in each filename
is 0-padded and <i>N</i> is the total number of 0-padded
digits representing the number. The literal character
&rsquo;%&rsquo; can be specified in the pattern with the
string &quot;%%&quot;.</p>

<p style="margin-left:19%; margin-top: 1em">If the sequence
pattern contains &quot;%d&quot; or &quot;%0<i>N</i>d&quot;,
the first filename of the file list specified by the pattern
must contain a number inclusively contained between
<i>start_number</i> and
<i>start_number</i>+<i>start_number_range</i>-1, and all the
following numbers must be sequential.</p>

<p style="margin-left:19%; margin-top: 1em">For example the
pattern &quot;img-%03d.bmp&quot; will match a sequence of
filenames of the form <i>img-001.bmp</i>,
<i>img-002.bmp</i>, ..., <i>img-010.bmp</i>, etc.; the
pattern &quot;i%%m%%g-%d.jpg&quot; will match a sequence of
filenames of the form <i>i%m%g-1.jpg</i>,
<i>i%m%g-2.jpg</i>, ..., <i>i%m%g-10.jpg</i>, etc.</p>

<p style="margin-left:19%; margin-top: 1em">Note that the
pattern must not necessarily contain &quot;%d&quot; or
&quot;%0<i>N</i>d&quot;, for example to convert a single
image file <i>img.jpeg</i> you can employ the command:</p>

<p style="margin-left:19%; margin-top: 1em">ffmpeg -i
img.jpeg img.png</p>

<p style="margin-left:14%;"><b>glob</b></p>

<p style="margin-left:19%;">Select a glob wildcard pattern
type.</p>

<p style="margin-left:19%; margin-top: 1em">The pattern is
interpreted like a glob() pattern. This is only selectable
if libavformat was compiled with globbing support.</p>

<p style="margin-left:14%;"><b>glob_sequence</b>
<i>(deprecated, will be removed)</i></p>

<p style="margin-left:19%;">Select a mixed glob
wildcard/sequence pattern.</p>

<p style="margin-left:19%; margin-top: 1em">If your version
of libavformat was compiled with globbing support, and the
provided pattern contains at least one glob meta character
among &quot;%*?[]{}&quot; that is preceded by an unescaped
&quot;%&quot;, the pattern is interpreted like a glob()
pattern, otherwise it is interpreted like a sequence
pattern.</p>

<p style="margin-left:19%; margin-top: 1em">All glob
special characters &quot;%*?[]{}&quot; must be prefixed with
&quot;%&quot;. To escape a literal &quot;%&quot; you shall
use &quot;%%&quot;.</p>

<p style="margin-left:19%; margin-top: 1em">For example the
pattern &quot;foo-%*.jpeg&quot; will match all the filenames
prefixed by &quot;foo-&quot; and terminating with
&quot;.jpeg&quot;, and &quot;foo-%?%?%?.jpeg&quot; will
match all the filenames prefixed with &quot;foo-&quot;,
followed by a sequence of three characters, and terminating
with &quot;.jpeg&quot;.</p>

<p style="margin-left:19%; margin-top: 1em">This pattern
type is deprecated in favor of <i>glob</i> and
<i>sequence</i>.</p>

<p style="margin-left:14%; margin-top: 1em">Default value
is <i>glob_sequence</i>.</p>

<p style="margin-left:9%;"><b>pixel_format</b></p>

<p style="margin-left:14%;">Set the pixel format of the
images to read. If not specified the pixel format is guessed
from the first image file in the sequence.</p>

<p style="margin-left:9%;"><b>start_number</b></p>

<p style="margin-left:14%;">Set the index of the file
matched by the image file pattern to start to read from.
Default value is 0.</p>

<p style="margin-left:9%;"><b>start_number_range</b></p>

<p style="margin-left:14%;">Set the index interval range to
check when looking for the first image file in the sequence,
starting from <i>start_number</i>. Default value is 5.</p>

<p style="margin-left:9%;"><b>ts_from_file</b></p>

<p style="margin-left:14%;">If set to 1, will set frame
timestamp to modification time of image file. Note that
monotonity of timestamps is not provided: images go in the
same order as without this option. Default value is 0. If
set to 2, will set frame timestamp to the modification time
of the image file in nanosecond precision.</p>

<p style="margin-left:9%;"><b>video_size</b></p>

<p style="margin-left:14%;">Set the video size of the
images to read. If not specified the video size is guessed
from the first image file in the sequence.</p>

<p style="margin-left:9%;"><b>export_path_metadata</b></p>

<p style="margin-left:14%;">If set to 1, will add two extra
fields to the metadata found in input, making them also
available for other filters (see <i>drawtext</i> filter for
examples). Default value is 0. The extra fields are
described below: <b><br>
lavf.image2dec.source_path</b></p>

<p style="margin-left:19%;">Corresponds to the full path to
the input file being read.</p>


<p style="margin-left:14%;"><b>lavf.image2dec.source_basename</b></p>

<p style="margin-left:19%;">Corresponds to the name of the
file being read.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>Use <b>ffmpeg</b> for creating a video from the images
in the file sequence <i>img-001.jpeg</i>,
<i>img-002.jpeg</i>, ..., assuming an input frame rate of 10
frames per second:</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg
-framerate 10 -i 'img-%03d.jpeg' out.mkv</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">As above, but start by reading
from a file with index 100 in the sequence:</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg
-framerate 10 -start_number 100 -i 'img-%03d.jpeg'
out.mkv</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">Read images matching the
&quot;*.png&quot; glob pattern , that is all the files
terminating with the &quot;.png&quot; suffix:</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg
-framerate 10 -pattern_type glob -i &quot;*.png&quot;
out.mkv</p>

<h3>libgme
<a name="libgme"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The Game Music
Emu library is a collection of video game music file
emulators.</p>

<p style="margin-left:9%; margin-top: 1em">See
&lt;<b>https://bitbucket.org/mpyne/game-music-emu/overview</b>&gt;
for more information.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts the
following options: <b><br>
track_index</b></p>

<p style="margin-left:14%;">Set the index of which track to
demux. The demuxer can only export one track. Track indexes
start at 0. Default is to pick the first track. Number of
tracks is exported as <i>tracks</i> metadata entry.</p>

<p style="margin-left:9%;"><b>sample_rate</b></p>

<p style="margin-left:14%;">Set the sampling rate of the
exported track. Range is 1000 to 999999. Default is
44100.</p>

<p style="margin-left:9%;"><b>max_size</b>
<i>(bytes)</i></p>

<p style="margin-left:14%;">The demuxer buffers the entire
file into memory. Adjust this value to set the maximum
buffer size, which in turn, acts as a ceiling for the size
of files that can be read. Default is 50 MiB.</p>

<h3>libmodplug
<a name="libmodplug"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">ModPlug based
module demuxer</p>

<p style="margin-left:9%; margin-top: 1em">See
&lt;<b>https://github.com/Konstanty/libmodplug</b>&gt;</p>

<p style="margin-left:9%; margin-top: 1em">It will export
one 2-channel 16-bit 44.1 kHz audio stream. Optionally, a
&quot;pal8&quot; 16-color video stream can be exported with
or without printed metadata.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts the
following options: <b><br>
noise_reduction</b></p>

<p style="margin-left:14%;">Apply a simple low-pass filter.
Can be 1 (on) or 0 (off). Default is 0.</p>

<p style="margin-left:9%;"><b>reverb_depth</b></p>

<p style="margin-left:14%;">Set amount of reverb. Range
0-100. Default is 0.</p>

<p style="margin-left:9%;"><b>reverb_delay</b></p>

<p style="margin-left:14%;">Set delay in ms, clamped to
40-250 ms. Default is 0.</p>

<p style="margin-left:9%;"><b>bass_amount</b></p>

<p style="margin-left:14%;">Apply bass expansion a.k.a.
XBass or megabass. Range is 0 (quiet) to 100 (loud). Default
is 0.</p>

<p style="margin-left:9%;"><b>bass_range</b></p>

<p style="margin-left:14%;">Set cutoff i.e. upper-bound for
bass frequencies. Range is 10-100 Hz. Default is 0.</p>

<p style="margin-left:9%;"><b>surround_depth</b></p>

<p style="margin-left:14%;">Apply a Dolby Pro-Logic
surround effect. Range is 0 (quiet) to 100 (heavy). Default
is 0.</p>

<p style="margin-left:9%;"><b>surround_delay</b></p>

<p style="margin-left:14%;">Set surround delay in ms,
clamped to 5-40 ms. Default is 0.</p>

<p style="margin-left:9%;"><b>max_size</b></p>

<p style="margin-left:14%;">The demuxer buffers the entire
file into memory. Adjust this value to set the maximum
buffer size, which in turn, acts as a ceiling for the size
of files that can be read. Range is 0 to 100 MiB. 0 removes
buffer size limit (not recommended). Default is 5 MiB.</p>

<p style="margin-left:9%;"><b>video_stream_expr</b></p>

<p style="margin-left:14%;">String which is evaluated using
the eval API to assign colors to the generated video stream.
Variables which can be used are &quot;x&quot;,
&quot;y&quot;, &quot;w&quot;, &quot;h&quot;, &quot;t&quot;,
&quot;speed&quot;, &quot;tempo&quot;, &quot;order&quot;,
&quot;pattern&quot; and &quot;row&quot;.</p>

<p style="margin-left:9%;"><b>video_stream</b></p>

<p style="margin-left:14%;">Generate video stream. Can be 1
(on) or 0 (off). Default is 0.</p>

<p style="margin-left:9%;"><b>video_stream_w</b></p>

<p style="margin-left:14%;">Set video frame width in
&rsquo;chars&rsquo; where one char indicates 8 pixels. Range
is 20-512. Default is 30.</p>

<p style="margin-left:9%;"><b>video_stream_h</b></p>

<p style="margin-left:14%;">Set video frame height in
&rsquo;chars&rsquo; where one char indicates 8 pixels. Range
is 20-512. Default is 30.</p>

<p style="margin-left:9%;"><b>video_stream_ptxt</b></p>

<p style="margin-left:14%;">Print metadata on video stream.
Includes &quot;speed&quot;, &quot;tempo&quot;,
&quot;order&quot;, &quot;pattern&quot;, &quot;row&quot; and
&quot;ts&quot; (time in ms). Can be 1 (on) or 0 (off).
Default is 1.</p>

<h3>libopenmpt
<a name="libopenmpt"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libopenmpt based
module demuxer</p>

<p style="margin-left:9%; margin-top: 1em">See
&lt;<b>https://lib.openmpt.org/libopenmpt/</b>&gt; for more
information.</p>

<p style="margin-left:9%; margin-top: 1em">Some files have
multiple subsongs (tracks) this can be set with the
<b>subsong</b> option.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts the
following options: <b><br>
subsong</b></p>

<p style="margin-left:14%;">Set the subsong index. This can
be either &rsquo;all&rsquo;, &rsquo;auto&rsquo;, or the
index of the subsong. Subsong indexes start at 0. The
default is &rsquo;auto&rsquo;.</p>

<p style="margin-left:14%; margin-top: 1em">The default
value is to let libopenmpt choose.</p>

<p style="margin-left:9%;"><b>layout</b></p>

<p style="margin-left:14%;">Set the channel layout. Valid
values are 1, 2, and 4 channel layouts. The default value is
STEREO.</p>

<p style="margin-left:9%;"><b>sample_rate</b></p>

<p style="margin-left:14%;">Set the sample rate for
libopenmpt to output. Range is from 1000 to INT_MAX. The
value default is 48000.</p>

<h3>mov/mp4/3gp
<a name="mov/mp4/3gp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Demuxer for
Quicktime File Format &amp; ISO/IEC Base Media File Format
(ISO/IEC 14496-12 or MPEG-4 Part 12, ISO/IEC 15444-12 or
JPEG 2000 Part 12).</p>

<p style="margin-left:9%; margin-top: 1em">Registered
extensions: mov, mp4, m4a, 3gp, 3g2, mj2, psp, m4b, ism,
ismv, isma, f4v</p>


<p style="margin-left:9%; margin-top: 1em"><i>Options</i></p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
accepts the following options: <b><br>
enable_drefs</b></p>

<p style="margin-left:14%;">Enable loading of external
tracks, disabled by default. Enabling this can theoretically
leak information in some use cases.</p>

<p style="margin-left:9%;"><b>use_absolute_path</b></p>

<p style="margin-left:14%;">Allows loading of external
tracks via absolute paths, disabled by default. Enabling
this poses a security risk. It should only be enabled if the
source is known to be non-malicious.</p>


<p style="margin-left:9%;"><b>seek_streams_individually</b></p>

<p style="margin-left:14%;">When seeking, identify the
closest point in each stream individually and demux packets
in that stream from identified point. This can lead to a
different sequence of packets compared to demuxing linearly
from the beginning. Default is true.</p>

<p style="margin-left:9%;"><b>ignore_editlist</b></p>

<p style="margin-left:14%;">Ignore any edit list atoms. The
demuxer, by default, modifies the stream index to reflect
the timeline described by the edit list. Default is
false.</p>

<p style="margin-left:9%;"><b>advanced_editlist</b></p>

<p style="margin-left:14%;">Modify the stream index to
reflect the timeline described by the edit list.
&quot;ignore_editlist&quot; must be set to false for this
option to be effective. If both &quot;ignore_editlist&quot;
and this option are set to false, then only the start of the
stream index is modified to reflect initial dwell time or
starting timestamp described by the edit list. Default is
true.</p>

<p style="margin-left:9%;"><b>ignore_chapters</b></p>

<p style="margin-left:14%;">Don&rsquo;t parse chapters.
This includes GoPro &rsquo;HiLight&rsquo; tags/moments. Note
that chapters are only parsed when input is seekable.
Default is false.</p>

<p style="margin-left:9%;"><b>use_mfra_for</b></p>

<p style="margin-left:14%;">For seekable fragmented input,
set fragment&rsquo;s starting timestamp from media fragment
random access box, if present.</p>

<p style="margin-left:14%; margin-top: 1em">Following
options are available: <b><br>
auto</b></p>

<p style="margin-left:19%;">Auto-detect whether to set mfra
timestamps as PTS or DTS <i>(default)</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p><b>dts</b></p></td>
<td width="1%"></td>
<td width="46%">


<p>Set mfra timestamps as DTS</p></td>
<td width="35%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p><b>pts</b></p></td>
<td width="1%"></td>
<td width="46%">


<p>Set mfra timestamps as PTS</p></td>
<td width="35%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p><b>0</b></p></td>
<td width="1%"></td>
<td width="46%">


<p>Don&rsquo;t use mfra box to set timestamps</p></td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:9%;"><b>use_tfdt</b></p>

<p style="margin-left:14%;">For fragmented input, set
fragment&rsquo;s starting timestamp to
&quot;baseMediaDecodeTime&quot; from the &quot;tfdt&quot;
box. Default is enabled, which will prefer to use the
&quot;tfdt&quot; box to set DTS. Disable to use the
&quot;earliest_presentation_time&quot; from the
&quot;sidx&quot; box. In either case, the timestamp from the
&quot;mfra&quot; box will be used if it&rsquo;s available
and &quot;use_mfra_for&quot; is set to pts or dts.</p>

<p style="margin-left:9%;"><b>export_all</b></p>

<p style="margin-left:14%;">Export unrecognized boxes
within the <i>udta</i> box as metadata entries. The first
four characters of the box type are set as the key. Default
is false.</p>

<p style="margin-left:9%;"><b>export_xmp</b></p>

<p style="margin-left:14%;">Export entire contents of
<i>XMP_</i> box and <i>uuid</i> box as a string with key
&quot;xmp&quot;. Note that if &quot;export_all&quot; is set
and this option isn&rsquo;t, the contents of <i>XMP_</i> box
are still exported but with key &quot;XMP_&quot;. Default is
false.</p>

<p style="margin-left:9%;"><b>activation_bytes</b></p>

<p style="margin-left:14%;">4-byte key required to decrypt
Audible AAX and AAX+ files. See Audible AAX subsection
below.</p>

<p style="margin-left:9%;"><b>audible_fixed_key</b></p>

<p style="margin-left:14%;">Fixed key used for handling
Audible AAX/AAX+ files. It has been pre-set so should not be
necessary to specify.</p>

<p style="margin-left:9%;"><b>decryption_key</b></p>

<p style="margin-left:14%;">16-byte key, in hex, to decrypt
files encrypted using ISO Common Encryption (CENC/AES-128
CTR; ISO/IEC 23001-7).</p>

<p style="margin-left:9%;"><b>max_stts_delta</b></p>

<p style="margin-left:14%;">Very high sample deltas written
in a trak&rsquo;s stts box may occasionally be intended but
usually they are written in error or used to store a
negative value for dts correction when treated as signed
32-bit integers. This option lets the user set an upper
limit, beyond which the delta is clamped to 1. Values
greater than the limit if negative when cast to int32 are
used to adjust onward dts.</p>

<p style="margin-left:14%; margin-top: 1em">Unit is the
track time scale. Range is 0 to UINT_MAX. Default is
&quot;UINT_MAX - 48000*10&quot; which allows up to a 10
second dts correction for 48 kHz audio streams while
accommodating 99.9% of &quot;uint32&quot; range.</p>

<p style="margin-left:9%;"><b>interleaved_read</b></p>

<p style="margin-left:14%;">Interleave packets from
multiple tracks at demuxer level. For badly interleaved
files, this prevents playback issues caused by large gaps
between packets in different tracks, as MOV/MP4 do not have
packet placement requirements. However, this can cause
excessive seeking on very badly interleaved files, due to
seeking between tracks, so disabling it may prevent I/O
issues, at the expense of playback.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Audible
AAX</i></p>

<p style="margin-left:9%; margin-top: 1em">Audible AAX
files are encrypted M4B files, and they can be decrypted by
specifying a 4 byte activation secret.</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg
-activation_bytes 1CEB00DA -i test.aax -vn -c:a copy
output.mp4</p>

<h3>mpegts
<a name="mpegts"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">MPEG-2 transport
stream demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
accepts the following options: <b><br>
resync_size</b></p>

<p style="margin-left:14%;">Set size limit for looking up a
new synchronization. Default value is 65536.</p>

<p style="margin-left:9%;"><b>skip_unknown_pmt</b></p>

<p style="margin-left:14%;">Skip PMTs for programs not
defined in the PAT. Default value is 0.</p>

<p style="margin-left:9%;"><b>fix_teletext_pts</b></p>

<p style="margin-left:14%;">Override teletext packet PTS
and DTS values with the timestamps calculated from the PCR
of the first program which the teletext stream is part of
and is not discarded. Default value is 1, set this option to
0 if you want your teletext packet PTS and DTS values
untouched.</p>

<p style="margin-left:9%;"><b>ts_packetsize</b></p>

<p style="margin-left:14%;">Output option carrying the raw
packet size in bytes. Show the detected raw packet size,
cannot be set by the user.</p>

<p style="margin-left:9%;"><b>scan_all_pmts</b></p>

<p style="margin-left:14%;">Scan and combine all PMTs. The
value is an integer with value from -1 to 1 (-1 means
automatic setting, 1 means enabled, 0 means disabled).
Default value is -1.</p>

<p style="margin-left:9%;"><b>merge_pmt_versions</b></p>

<p style="margin-left:14%;">Re-use existing streams when a
PMT&rsquo;s version is updated and elementary streams move
to different PIDs. Default value is 0.</p>

<p style="margin-left:9%;"><b>max_packet_size</b></p>

<p style="margin-left:14%;">Set maximum size, in bytes, of
packet emitted by the demuxer. Payloads above this size are
split across multiple packets. Range is 1 to INT_MAX/2.
Default is 204800 bytes.</p>

<h3>mpjpeg
<a name="mpjpeg"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">MJPEG
encapsulated in multi-part MIME demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
allows reading of MJPEG, where each frame is represented as
a part of multipart/x-mixed-replace stream. <b><br>
strict_mime_boundary</b></p>

<p style="margin-left:14%;">Default implementation applies
a relaxed standard to multi-part MIME boundary detection, to
prevent regression with numerous existing endpoints not
generating a proper MIME MJPEG stream. Turning this option
on by setting it to 1 will result in a stricter check of the
boundary value.</p>

<h3>rawvideo
<a name="rawvideo"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Raw video
demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
allows one to read raw video data. Since there is no header
specifying the assumed video parameters, the user must
specify them in order to be able to decode the data
correctly.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
accepts the following options: <b><br>
framerate</b></p>

<p style="margin-left:14%;">Set input video frame rate.
Default value is 25.</p>

<p style="margin-left:9%;"><b>pixel_format</b></p>

<p style="margin-left:14%;">Set the input video pixel
format. Default value is &quot;yuv420p&quot;.</p>

<p style="margin-left:9%;"><b>video_size</b></p>

<p style="margin-left:14%;">Set the input video size. This
value must be specified explicitly.</p>

<p style="margin-left:9%; margin-top: 1em">For example to
read a rawvideo file <i>input.raw</i> with <b>ffplay</b>,
assuming a pixel format of &quot;rgb24&quot;, a video size
of &quot;320x240&quot;, and a frame rate of 10 images per
second, use the command:</p>

<p style="margin-left:9%; margin-top: 1em">ffplay -f
rawvideo -pixel_format rgb24 -video_size 320x240 -framerate
10 input.raw</p>

<h3>rcwt
<a name="rcwt"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">RCWT (Raw
Captions With Time) is a format native to ccextractor, a
commonly used open source tool for processing 608/708 Closed
Captions (CC) sources. For more information on the format,
see .</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
implements the specification as of March 2024, which has
been stable and unchanged since April 2014.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="57%">


<p>Render CC to ASS using the built-in decoder:</p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
CC.rcwt.bin CC.ass</p>

<p style="margin-left:14%; margin-top: 1em">Note that if
your output appears to be empty, you may have to manually
set the decoder&rsquo;s <b>data_field</b> option to pick the
desired CC substream.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="63%">


<p style="margin-top: 1em">Convert an RCWT backup to
Scenarist (SCC) format:</p></td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
CC.rcwt.bin -c:s copy CC.scc</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
SCC format does not support all of the possible CC
extensions that can be stored in RCWT (such as EIA-708).</p>

<h3>sbg
<a name="sbg"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">SBaGen script
demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
reads the script language used by SBaGen
&lt;<b>http://uazu.net/sbagen/</b>&gt; to generate binaural
beats sessions. A SBG script looks like that:</p>

<p style="margin-left:9%; margin-top: 1em">-SE <br>
a: 300-2.5/3 440+4.5/0 <br>
b: 300-2.5/0 440+4.5/3 <br>
off: - <br>
NOW == a <br>
+0:07:00 == b <br>
+0:14:00 == a <br>
+0:21:00 == b <br>
+0:30:00 off</p>

<p style="margin-left:9%; margin-top: 1em">A SBG script can
mix absolute and relative timestamps. If the script uses
either only absolute timestamps (including the script start
time) or only relative ones, then its layout is fixed, and
the conversion is straightforward. On the other hand, if the
script mixes both kind of timestamps, then the <i>NOW</i>
reference for relative timestamps will be taken from the
current time of day at the time the script is read, and the
script layout will be frozen according to that reference.
That means that if the script is directly played, the actual
times will match the absolute timestamps up to the sound
controller&rsquo;s clock accuracy, but if the user somehow
pauses the playback or seeks, all times will be shifted
accordingly.</p>

<h3>tedcaptions
<a name="tedcaptions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">JSON captions
used for &lt;<b>http://www.ted.com/</b>&gt;.</p>

<p style="margin-left:9%; margin-top: 1em">TED does not
provide links to the captions, but they can be guessed from
the page. The file <i>tools/bookmarklets.html</i> from the
FFmpeg source tree contains a bookmarklet to expose
them.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
accepts the following option: <b><br>
start_time</b></p>

<p style="margin-left:14%;">Set the start time of the TED
talk, in milliseconds. The default is 15000 (15s). It is
used to sync the captions with the downloadable videos,
because they include a 15s intro.</p>

<p style="margin-left:9%; margin-top: 1em">Example: convert
the captions to a format most players understand:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i
http://www.ted.com/talks/subtitles/id/1/lang/en
talk1-en.srt</p>

<h3>vapoursynth
<a name="vapoursynth"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Vapoursynth
wrapper.</p>

<p style="margin-left:9%; margin-top: 1em">Due to security
concerns, Vapoursynth scripts will not be autodetected so
the input format has to be forced. For ff* CLI tools, add
&quot;-f vapoursynth&quot; before the input &quot;-i
yourscript.vpy&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
accepts the following option: <b><br>
max_script_size</b></p>

<p style="margin-left:14%;">The demuxer buffers the entire
script into memory. Adjust this value to set the maximum
buffer size, which in turn, acts as a ceiling for the size
of scripts that can be read. Default is 1 MiB.</p>

<h3>w64
<a name="w64"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Sony Wave64
Audio demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
accepts the following options: <b><br>
max_size</b></p>

<p style="margin-left:14%;">See the same option for the
<b>wav</b> demuxer.</p>

<h3>wav
<a name="wav"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">RIFF Wave Audio
demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">This demuxer
accepts the following options: <b><br>
max_size</b></p>

<p style="margin-left:14%;">Specify the maximum packet size
in bytes for the demuxed packets. By default this is set to
0, which means that a sensible value is chosen based on the
input format.</p>

<h2>MUXERS
<a name="MUXERS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">Muxers are
configured elements in FFmpeg which allow writing multimedia
streams to a particular type of file.</p>

<p style="margin-left:9%; margin-top: 1em">When you
configure your FFmpeg build, all the supported muxers are
enabled by default. You can list all available muxers using
the configure option &quot;--list-muxers&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">You can disable
all the muxers with the configure option
&quot;--disable-muxers&quot; and selectively enable /
disable single muxers with the options
&quot;--enable-muxer=<i>MUXER</i>&quot; /
&quot;--disable-muxer=<i>MUXER</i>&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">The option
&quot;-muxers&quot; of the ff* tools will display the list
of enabled muxers. Use &quot;-formats&quot; to view a
combined list of enabled demuxers and muxers.</p>

<p style="margin-left:9%; margin-top: 1em">A description of
some of the currently available muxers follows.</p>

<h3>Raw muxers
<a name="Raw muxers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This section
covers raw muxers. They accept a single stream matching the
designated codec. They do not store timestamps or metadata.
The recognized extension is the same as the muxer name
unless indicated otherwise.</p>

<p style="margin-left:9%; margin-top: 1em">It comprises the
following muxers. The media type and the eventual extensions
used to automatically selects the muxer from the output
extensions are also shown. <b><br>
ac3</b> <i>audio</i></p>

<p style="margin-left:14%;">Dolby Digital, also known as
AC-3.</p>

<p style="margin-left:9%;"><b>adx</b> <i>audio</i></p>

<p style="margin-left:14%;">CRI Middleware ADX audio.</p>

<p style="margin-left:14%; margin-top: 1em">This muxer will
write out the total sample count near the start of the first
packet when the output is seekable and the count can be
stored in 32 bits.</p>

<p style="margin-left:9%;"><b>aptx</b> <i>audio</i></p>

<p style="margin-left:14%;">aptX (Audio Processing
Technology for Bluetooth)</p>

<p style="margin-left:9%;"><b>aptx_hd</b> <i>audio</i>
<b>(aptxdh)</b></p>

<p style="margin-left:14%;">aptX HD (Audio Processing
Technology for Bluetooth) audio</p>

<p style="margin-left:9%;"><b>avs2</b> <i>video</i>
<b>(avs, avs2)</b></p>

<p style="margin-left:14%;">AVS2-P2 (Audio Video Standard -
Second generation - Part 2) / IEEE 1857.4 video</p>

<p style="margin-left:9%;"><b>avs3</b> <i>video</i>
<b>(avs3)</b></p>

<p style="margin-left:14%;">AVS3-P2 (Audio Video Standard -
Third generation - Part 2) / IEEE 1857.10 video</p>

<p style="margin-left:9%;"><b>cavsvideo</b> <i>video</i>
<b>(cavs)</b></p>

<p style="margin-left:14%;">Chinese AVS (Audio Video
Standard - First generation)</p>

<p style="margin-left:9%;"><b>codec2raw</b>
<i>audio</i></p>

<p style="margin-left:14%;">Codec 2 audio.</p>

<p style="margin-left:14%; margin-top: 1em">No extension is
registered so format name has to be supplied e.g. with the
ffmpeg CLI tool &quot;-f codec2raw&quot;.</p>

<p style="margin-left:9%;"><b>data</b> <i>any</i></p>

<p style="margin-left:14%;">Generic data muxer.</p>

<p style="margin-left:14%; margin-top: 1em">This muxer
accepts a single stream with any codec of any type. The
input stream has to be selected using the &quot;-map&quot;
option with the <b>ffmpeg</b> CLI tool.</p>

<p style="margin-left:14%; margin-top: 1em">No extension is
registered so format name has to be supplied e.g. with the
<b>ffmpeg</b> CLI tool &quot;-f data&quot;.</p>

<p style="margin-left:9%;"><b>dfpwm</b> <i>audio</i>
<b>(dfpwm)</b></p>

<p style="margin-left:14%;">Raw DFPWM1a (Dynamic Filter
Pulse With Modulation) audio muxer.</p>

<p style="margin-left:9%;"><b>dirac</b> <i>video</i>
<b>(drc, vc2)</b></p>

<p style="margin-left:14%;">BBC Dirac video.</p>

<p style="margin-left:14%; margin-top: 1em">The Dirac Pro
codec is a subset and is standardized as SMPTE VC-2.</p>

<p style="margin-left:9%;"><b>dnxhd</b> <i>video</i>
<b>(dnxhd, dnxhr)</b></p>

<p style="margin-left:14%;">Avid DNxHD video.</p>

<p style="margin-left:14%; margin-top: 1em">It is
standardized as SMPTE VC-3. Accepts DNxHR streams.</p>

<p style="margin-left:9%;"><b>dts</b> <i>audio</i></p>

<p style="margin-left:14%;">DTS Coherent Acoustics (DCA)
audio</p>

<p style="margin-left:9%;"><b>eac3</b> <i>audio</i></p>

<p style="margin-left:14%;">Dolby Digital Plus, also known
as Enhanced AC-3</p>

<p style="margin-left:9%;"><b>evc</b> <i>video</i>
<b>(evc)</b></p>

<p style="margin-left:14%;">MPEG-5 Essential Video Coding
(EVC) / EVC / MPEG-5 Part 1 EVC video</p>

<p style="margin-left:9%;"><b>g722</b> <i>audio</i></p>

<p style="margin-left:14%;">ITU-T G.722 audio</p>

<p style="margin-left:9%;"><b>g723_1</b> <i>audio</i>
<b>(tco, rco)</b></p>

<p style="margin-left:14%;">ITU-T G.723.1 audio</p>

<p style="margin-left:9%;"><b>g726</b> <i>audio</i></p>

<p style="margin-left:14%;">ITU-T G.726 big-endian
(&quot;left-justified&quot;) audio.</p>

<p style="margin-left:14%; margin-top: 1em">No extension is
registered so format name has to be supplied e.g. with the
<b>ffmpeg</b> CLI tool &quot;-f g726&quot;.</p>

<p style="margin-left:9%;"><b>g726le</b> <i>audio</i></p>

<p style="margin-left:14%;">ITU-T G.726 little-endian
(&quot;right-justified&quot;) audio.</p>

<p style="margin-left:14%; margin-top: 1em">No extension is
registered so format name has to be supplied e.g. with the
<b>ffmpeg</b> CLI tool &quot;-f g726le&quot;.</p>

<p style="margin-left:9%;"><b>gsm</b> <i>audio</i></p>

<p style="margin-left:14%;">Global System for Mobile
Communications audio</p>

<p style="margin-left:9%;"><b>h261</b> <i>video</i></p>

<p style="margin-left:14%;">ITU-T H.261 video</p>

<p style="margin-left:9%;"><b>h263</b> <i>video</i></p>

<p style="margin-left:14%;">ITU-T H.263 / H.263-1996,
H.263+ / H.263-1998 / H.263 version 2 video</p>

<p style="margin-left:9%;"><b>h264</b> <i>video</i>
<b>(h264, 264)</b></p>

<p style="margin-left:14%;">ITU-T H.264 / MPEG-4 Part 10
AVC video. Bitstream shall be converted to Annex B syntax if
it&rsquo;s in length-prefixed mode.</p>

<p style="margin-left:9%;"><b>hevc</b> <i>video</i>
<b>(hevc, h265, 265)</b></p>

<p style="margin-left:14%;">ITU-T H.265 / MPEG-H Part 2
HEVC video. Bitstream shall be converted to Annex B syntax
if it&rsquo;s in length-prefixed mode.</p>

<p style="margin-left:9%;"><b>m4v</b> <i>video</i></p>

<p style="margin-left:14%;">MPEG-4 Part 2 video</p>

<p style="margin-left:9%;"><b>mjpeg</b> <i>video</i>
<b>(mjpg, mjpeg)</b></p>

<p style="margin-left:14%;">Motion JPEG video</p>

<p style="margin-left:9%;"><b>mlp</b> <i>audio</i></p>

<p style="margin-left:14%;">Meridian Lossless Packing, also
known as Packed PCM</p>

<p style="margin-left:9%;"><b>mp2</b> <i>audio</i> <b>(mp2,
m2a, mpa)</b></p>

<p style="margin-left:14%;">MPEG-1 Audio Layer II audio</p>

<p style="margin-left:9%;"><b>mpeg1video</b> <i>video</i>
<b>(mpg, mpeg, m1v)</b></p>

<p style="margin-left:14%;">MPEG-1 Part 2 video.</p>

<p style="margin-left:9%;"><b>mpeg2video</b> <i>video</i>
<b>(m2v)</b></p>

<p style="margin-left:14%;">ITU-T H.262 / MPEG-2 Part 2
video</p>

<p style="margin-left:9%;"><b>obu</b> <i>video</i></p>

<p style="margin-left:14%;">AV1 low overhead Open Bitstream
Units muxer.</p>

<p style="margin-left:14%; margin-top: 1em">Temporal
delimiter OBUs will be inserted in all temporal units of the
stream.</p>

<p style="margin-left:9%;"><b>rawvideo</b> <i>video</i>
<b>(yuv, rgb)</b></p>

<p style="margin-left:14%;">Raw uncompressed video.</p>

<p style="margin-left:9%;"><b>sbc</b> <i>audio</i> <b>(sbc,
msbc)</b></p>

<p style="margin-left:14%;">Bluetooth SIG low-complexity
subband codec audio</p>

<p style="margin-left:9%;"><b>truehd</b> <i>audio</i>
<b>(thd)</b></p>

<p style="margin-left:14%;">Dolby TrueHD audio</p>

<p style="margin-left:9%;"><b>vc1</b> <i>video</i></p>

<p style="margin-left:14%;">SMPTE 421M / VC-1 video</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="77%">


<p>Store raw video frames with the <b>rawvideo</b> muxer
using <b>ffmpeg</b>:</p></td>
<td width="9%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -f lavfi
-i testsrc -t 10 -s hd1080p testsrc.yuv</p>

<p style="margin-left:14%; margin-top: 1em">Since the
rawvideo muxer do not store the information related to size
and format, this information must be provided when demuxing
the file:</p>

<p style="margin-left:14%; margin-top: 1em">ffplay
-video_size 1920x1080 -pixel_format rgb24 -f rawvideo
testsrc.rgb</p>

<h3>Raw PCM muxers
<a name="Raw PCM muxers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This section
covers raw PCM (Pulse-Code Modulation) audio muxers.</p>

<p style="margin-left:9%; margin-top: 1em">They accept a
single stream matching the designated codec. They do not
store timestamps or metadata. The recognized extension is
the same as the muxer name.</p>

<p style="margin-left:9%; margin-top: 1em">It comprises the
following muxers. The optional additional extension used to
automatically select the muxer from the output extension is
also shown in parentheses. <b><br>
alaw (al)</b></p>

<p style="margin-left:14%;">PCM A-law</p>

<p style="margin-left:9%;"><b>f32be</b></p>

<p style="margin-left:14%;">PCM 32-bit floating-point
big-endian</p>

<p style="margin-left:9%;"><b>f32le</b></p>

<p style="margin-left:14%;">PCM 32-bit floating-point
little-endian</p>

<p style="margin-left:9%;"><b>f64be</b></p>

<p style="margin-left:14%;">PCM 64-bit floating-point
big-endian</p>

<p style="margin-left:9%;"><b>f64le</b></p>

<p style="margin-left:14%;">PCM 64-bit floating-point
little-endian</p>

<p style="margin-left:9%;"><b>mulaw (ul)</b></p>

<p style="margin-left:14%;">PCM mu-law</p>

<p style="margin-left:9%;"><b>s16be</b></p>

<p style="margin-left:14%;">PCM signed 16-bit
big-endian</p>

<p style="margin-left:9%;"><b>s16le</b></p>

<p style="margin-left:14%;">PCM signed 16-bit
little-endian</p>

<p style="margin-left:9%;"><b>s24be</b></p>

<p style="margin-left:14%;">PCM signed 24-bit
big-endian</p>

<p style="margin-left:9%;"><b>s24le</b></p>

<p style="margin-left:14%;">PCM signed 24-bit
little-endian</p>

<p style="margin-left:9%;"><b>s32be</b></p>

<p style="margin-left:14%;">PCM signed 32-bit
big-endian</p>

<p style="margin-left:9%;"><b>s32le</b></p>

<p style="margin-left:14%;">PCM signed 32-bit
little-endian</p>

<p style="margin-left:9%;"><b>s8 (sb)</b></p>

<p style="margin-left:14%;">PCM signed 8-bit</p>

<p style="margin-left:9%;"><b>u16be</b></p>

<p style="margin-left:14%;">PCM unsigned 16-bit
big-endian</p>

<p style="margin-left:9%;"><b>u16le</b></p>

<p style="margin-left:14%;">PCM unsigned 16-bit
little-endian</p>

<p style="margin-left:9%;"><b>u24be</b></p>

<p style="margin-left:14%;">PCM unsigned 24-bit
big-endian</p>

<p style="margin-left:9%;"><b>u24le</b></p>

<p style="margin-left:14%;">PCM unsigned 24-bit
little-endian</p>

<p style="margin-left:9%;"><b>u32be</b></p>

<p style="margin-left:14%;">PCM unsigned 32-bit
big-endian</p>

<p style="margin-left:9%;"><b>u32le</b></p>

<p style="margin-left:14%;">PCM unsigned 32-bit
little-endian</p>

<p style="margin-left:9%;"><b>u8 (ub)</b></p>

<p style="margin-left:14%;">PCM unsigned 8-bit</p>

<p style="margin-left:9%;"><b>vidc</b></p>

<p style="margin-left:14%;">PCM Archimedes VIDC</p>

<h3>MPEG-1/MPEG-2 program stream muxers
<a name="MPEG-1/MPEG-2 program stream muxers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This section
covers formats belonging to the MPEG-1 and MPEG-2 Systems
family.</p>

<p style="margin-left:9%; margin-top: 1em">The MPEG-1
Systems format (also known as ISO/IEEC 11172-1 or MPEG-1
program stream) has been adopted for the format of media
track stored in VCD (Video Compact Disc).</p>

<p style="margin-left:9%; margin-top: 1em">The MPEG-2
Systems standard (also known as ISO/IEEC 13818-1) covers two
containers formats, one known as transport stream and one
known as program stream; only the latter is covered
here.</p>

<p style="margin-left:9%; margin-top: 1em">The MPEG-2
program stream format (also known as VOB due to the
corresponding file extension) is an extension of MPEG-1
program stream: in addition to support different codecs for
the audio and video streams, it also stores subtitles and
navigation metadata. MPEG-2 program stream has been adopted
for storing media streams in SVCD and DVD storage
devices.</p>

<p style="margin-left:9%; margin-top: 1em">This section
comprises the following muxers. <b><br>
mpeg (mpg,mpeg)</b></p>

<p style="margin-left:14%;">MPEG-1 Systems / MPEG-1 program
stream muxer.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p><b>vcd</b></p></td>
<td width="1%"></td>
<td width="65%">


<p>MPEG-1 Systems / MPEG-1 program stream (VCD) muxer.</p></td>
<td width="21%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This muxer can
be used to generate tracks in the format accepted by the VCD
(Video Compact Disc) storage devices.</p>

<p style="margin-left:14%; margin-top: 1em">It is the same
as the <b>mpeg</b> muxer with a few differences.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p style="margin-top: 1em"><b>vob</b></p></td>
<td width="1%"></td>
<td width="49%">


<p style="margin-top: 1em">MPEG-2 program stream (VOB)
muxer.</p> </td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p><b>dvd</b></p></td>
<td width="1%"></td>
<td width="49%">


<p>MPEG-2 program stream (DVD VOB) muxer.</p></td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This muxer can
be used to generate tracks in the format accepted by the DVD
(Digital Versatile Disc) storage devices.</p>

<p style="margin-left:14%; margin-top: 1em">This is the
same as the <b>vob</b> muxer with a few differences.</p>

<p style="margin-left:9%;"><b>svcd (vob)</b></p>

<p style="margin-left:14%;">MPEG-2 program stream (SVCD
VOB) muxer.</p>

<p style="margin-left:14%; margin-top: 1em">This muxer can
be used to generate tracks in the format accepted by the
SVCD (Super Video Compact Disc) storage devices.</p>

<p style="margin-left:14%; margin-top: 1em">This is the
same as the <b>vob</b> muxer with a few differences.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
muxrate</b> <i>rate</i></p>

<p style="margin-left:14%;">Set user-defined mux rate
expressed as a number of bits/s. If not specied the
automatically computed mux rate is employed. Default value
is 0.</p>

<p style="margin-left:9%;"><b>preload</b> <i>delay</i></p>

<p style="margin-left:14%;">Set initial demux-decode delay
in microseconds. Default value is 500000.</p>

<h3>MOV/MPEG-4/ISOMBFF muxers
<a name="MOV/MPEG-4/ISOMBFF muxers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This section
covers formats belonging to the QuickTime / MOV family,
including the MPEG-4 Part 14 format and ISO base media file
format (ISOBMFF). These formats share a common structure
based on the ISO base media file format (ISOBMFF).</p>

<p style="margin-left:9%; margin-top: 1em">The MOV format
was originally developed for use with Apple QuickTime. It
was later used as the basis for the MPEG-4 Part 1 (later
Part 14) format, also known as ISO/IEC 14496-1. That format
was then generalized into ISOBMFF, also named MPEG-4 Part 12
format, ISO/IEC 14496-12, or ISO/IEC 15444-12.</p>

<p style="margin-left:9%; margin-top: 1em">It comprises the
following muxers.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p><b>3gp</b></p></td>
<td width="1%"></td>
<td width="86%">


<p>Third Generation Partnership Project (3GPP) format for
3G UMTS multimedia services</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p><b>3g2</b></p></td>
<td width="1%"></td>
<td width="86%">


<p>Third Generation Partnership Project 2 (3GP2 or 3GPP2)
format for 3G CDMA2000 multimedia services, similar to
<b>3gp</b> with extensions and limitations</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p><b>f4v</b></p></td>
<td width="1%"></td>
<td width="86%">


<p>Adobe Flash Video format</p></td></tr>
</table>

<p style="margin-left:9%;"><b>ipod</b></p>

<p style="margin-left:14%;">MPEG-4 audio file format, as
MOV/MP4 but limited to contain only audio streams, typically
played with the Apple ipod device</p>

<p style="margin-left:9%;"><b>ismv</b></p>

<p style="margin-left:14%;">Microsoft IIS (Internet
Information Services) Smooth Streaming Audio/Video (ISMV or
ISMA) format. This is based on MPEG-4 Part 14 format with a
few incompatible variants, used to stream media files for
the Microsoft IIS server.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p><b>mov</b></p></td>
<td width="1%"></td>
<td width="86%">


<p>QuickTime player format identified by the
&quot;.mov&quot; extension</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p><b>mp4</b></p></td>
<td width="1%"></td>
<td width="86%">


<p>MP4 or MPEG-4 Part 14 format</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p><b>psp</b></p></td>
<td width="1%"></td>
<td width="86%">


<p>PlayStation Portable MP4/MPEG-4 Part 14 format variant.
This is based on MPEG-4 Part 14 format with a few
incompatible variants, used to play files on PlayStation
devices.</p> </td></tr>
</table>


<p style="margin-left:9%; margin-top: 1em"><i>Fragmentation</i></p>

<p style="margin-left:9%; margin-top: 1em">The <b>mov</b>,
<b>mp4</b>, and <b>ismv</b> muxers support fragmentation.
Normally, a MOV/MP4 file has all the metadata about all
packets stored in one location.</p>

<p style="margin-left:9%; margin-top: 1em">This data is
usually written at the end of the file, but it can be moved
to the start for better playback by adding
&quot;+faststart&quot; to the &quot;-movflags&quot;, or
using the <b>qt-faststart</b> tool).</p>

<p style="margin-left:9%; margin-top: 1em">A fragmented
file consists of a number of fragments, where packets and
metadata about these packets are stored together. Writing a
fragmented file has the advantage that the file is decodable
even if the writing is interrupted (while a normal MOV/MP4
is undecodable if it is not properly finished), and it
requires less memory when writing very long files (since
writing normal MOV/MP4 files stores info about every single
packet in memory until the file is closed). The downside is
that it is less compatible with other applications.</p>

<p style="margin-left:9%; margin-top: 1em">Fragmentation is
enabled by setting one of the options that define how to cut
the file into fragments: <b><br>
frag_duration <br>
frag_size <br>
min_frag_duration <br>
movflags +frag_keyframe <br>
movflags +frag_custom</b></p>

<p style="margin-left:9%; margin-top: 1em">If more than one
condition is specified, fragments are cut when one of the
specified conditions is fulfilled. The exception to this is
the option <b>min_frag_duration</b>, which has to be
fulfilled for any of the other conditions to apply.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
brand</b> <i>brand_string</i></p>

<p style="margin-left:14%;">Override major brand.</p>

<p style="margin-left:9%;"><b>empty_hdlr_name</b>
<i>bool</i></p>

<p style="margin-left:14%;">Enable to skip writing the name
inside a &quot;hdlr&quot; box. Default is
&quot;false&quot;.</p>

<p style="margin-left:9%;"><b>encryption_key</b>
<i>key</i></p>

<p style="margin-left:14%;">set the media encryption key in
hexadecimal format</p>

<p style="margin-left:9%;"><b>encryption_kid</b>
<i>kid</i></p>

<p style="margin-left:14%;">set the media encryption key
identifier in hexadecimal format</p>

<p style="margin-left:9%;"><b>encryption_scheme</b>
<i>scheme</i></p>

<p style="margin-left:14%;">configure the encryption
scheme, allowed values are <b>none</b>, and
<b>cenc-aes-ctr</b></p>

<p style="margin-left:9%;"><b>frag_duration</b>
<i>duration</i></p>

<p style="margin-left:14%;">Create fragments that are
<i>duration</i> microseconds long.</p>

<p style="margin-left:9%;"><b>frag_interleave</b>
<i>number</i></p>

<p style="margin-left:14%;">Interleave samples within
fragments (max number of consecutive samples, lower is
tighter interleaving, but with more overhead. It is set to 0
by default.</p>

<p style="margin-left:9%;"><b>frag_size</b> <i>size</i></p>

<p style="margin-left:14%;">create fragments that contain
up to <i>size</i> bytes of payload data</p>

<p style="margin-left:9%;"><b>iods_audio_profile</b>
<i>profile</i></p>

<p style="margin-left:14%;">specify iods number for the
audio profile atom (from -1 to 255), default is -1</p>

<p style="margin-left:9%;"><b>iods_video_profile</b>
<i>profile</i></p>

<p style="margin-left:14%;">specify iods number for the
video profile atom (from -1 to 255), default is -1</p>

<p style="margin-left:9%;"><b>ism_lookahead</b>
<i>num_entries</i></p>

<p style="margin-left:14%;">specify number of lookahead
entries for ISM files (from 0 to 255), default is 0</p>

<p style="margin-left:9%;"><b>min_frag_duration</b>
<i>duration</i></p>

<p style="margin-left:14%;">do not create fragments that
are shorter than <i>duration</i> microseconds long</p>

<p style="margin-left:9%;"><b>moov_size</b>
<i>bytes</i></p>

<p style="margin-left:14%;">Reserves space for the moov
atom at the beginning of the file instead of placing the
moov atom at the end. If the space reserved is insufficient,
muxing will fail.</p>

<p style="margin-left:9%;"><b>mov_gamma</b>
<i>gamma</i></p>

<p style="margin-left:14%;">specify gamma value for gama
atom (as a decimal number from 0 to 10), default is 0.0,
must be set together with &quot;+ movflags&quot;</p>

<p style="margin-left:9%;"><b>movflags</b> <i>flags</i></p>

<p style="margin-left:14%;">Set various muxing switches.
The following flags can be used: <b><br>
cmaf</b></p>

<p style="margin-left:19%;">write CMAF (Common Media
Application Format) compatible fragmented MP4 output</p>

<p style="margin-left:14%;"><b>dash</b></p>

<p style="margin-left:19%;">write DASH (Dynamic Adaptive
Streaming over HTTP) compatible fragmented MP4 output</p>

<p style="margin-left:14%;"><b>default_base_moof</b></p>

<p style="margin-left:19%;">Similarly to the
<b>omit_tfhd_offset</b> flag, this flag avoids writing the
absolute base_data_offset field in tfhd atoms, but does so
by using the new default-base-is-moof flag instead. This
flag is new from 14496-12:2012. This may make the fragments
easier to parse in certain circumstances (avoiding basing
track fragment location calculations on the implicit end of
the previous track fragment).</p>

<p style="margin-left:14%;"><b>delay_moov</b></p>

<p style="margin-left:19%;">delay writing the initial moov
until the first fragment is cut, or until the first fragment
flush</p>

<p style="margin-left:14%;"><b>disable_chpl</b></p>

<p style="margin-left:19%;">Disable Nero chapter markers
(chpl atom). Normally, both Nero chapters and a QuickTime
chapter track are written to the file. With this option set,
only the QuickTime chapter track will be written. Nero
chapters can cause failures when the file is reprocessed
with certain tagging programs, like mp3Tag 2.61a and iTunes
11.3, most likely other versions are affected as well.</p>

<p style="margin-left:14%;"><b>faststart</b></p>

<p style="margin-left:19%;">Run a second pass moving the
index (moov atom) to the beginning of the file. This
operation can take a while, and will not work in various
situations such as fragmented output, thus it is not enabled
by default.</p>

<p style="margin-left:14%;"><b>frag_custom</b></p>

<p style="margin-left:19%;">Allow the caller to manually
choose when to cut fragments, by calling
&quot;av_write_frame(ctx, NULL)&quot; to write a fragment
with the packets written so far. (This is only useful with
other applications integrating libavformat, not from
<b>ffmpeg</b>.)</p>

<p style="margin-left:14%;"><b>frag_discont</b></p>

<p style="margin-left:19%;">signal that the next fragment
is discontinuous from earlier ones</p>

<p style="margin-left:14%;"><b>frag_every_frame</b></p>

<p style="margin-left:19%;">fragment at every frame</p>

<p style="margin-left:14%;"><b>frag_keyframe</b></p>

<p style="margin-left:19%;">start a new fragment at each
video keyframe</p>

<p style="margin-left:14%;"><b>global_sidx</b></p>

<p style="margin-left:19%;">write a global sidx index at
the start of the file</p>

<p style="margin-left:14%;"><b>isml</b></p>

<p style="margin-left:19%;">create a live smooth streaming
feed (for pushing to a publishing point)</p>


<p style="margin-left:14%;"><b>negative_cts_offsets</b></p>

<p style="margin-left:19%;">Enables utilization of version
1 of the CTTS box, in which the CTS offsets can be negative.
This enables the initial sample to have DTS/CTS of zero, and
reduces the need for edit lists for some cases such as video
tracks with B-frames. Additionally, eases conformance with
the DASH-IF interoperability guidelines.</p>

<p style="margin-left:19%; margin-top: 1em">This option is
implicitly set when writing <b>ismv</b> (Smooth Streaming)
files.</p>

<p style="margin-left:14%;"><b>omit_tfhd_offset</b></p>

<p style="margin-left:19%;">Do not write any absolute
base_data_offset in tfhd atoms. This avoids tying fragments
to absolute byte positions in the file/streams.</p>

<p style="margin-left:14%;"><b>prefer_icc</b></p>

<p style="margin-left:19%;">If writing colr atom prioritise
usage of ICC profile if it exists in stream packet side
data.</p>

<p style="margin-left:14%;"><b>rtphint</b></p>

<p style="margin-left:19%;">add RTP hinting tracks to the
output file</p>

<p style="margin-left:14%;"><b>separate_moof</b></p>

<p style="margin-left:19%;">Write a separate moof (movie
fragment) atom for each track. Normally, packets for all
tracks are written in a moof atom (which is slightly more
efficient), but with this option set, the muxer writes one
moof/mdat pair for each track, making it easier to separate
tracks.</p>

<p style="margin-left:14%;"><b>skip_sidx</b></p>

<p style="margin-left:19%;">Skip writing of sidx atom. When
bitrate overhead due to sidx atom is high, this option could
be used for cases where sidx atom is not mandatory. When the
<b>global_sidx</b> flag is enabled, this option is
ignored.</p>

<p style="margin-left:14%;"><b>skip_trailer</b></p>

<p style="margin-left:19%;">skip writing the mfra/tfra/mfro
trailer for fragmented files</p>

<p style="margin-left:14%;"><b>use_metadata_tags</b></p>

<p style="margin-left:19%;">use mdta atom for metadata</p>

<p style="margin-left:14%;"><b>write_colr</b></p>

<p style="margin-left:19%;">write colr atom even if the
color info is unspecified. This flag is experimental, may be
renamed or changed, do not use from scripts.</p>

<p style="margin-left:14%;"><b>write_gama</b></p>

<p style="margin-left:19%;">write deprecated gama atom</p>

<p style="margin-left:14%;"><b>hybrid_fragmented</b></p>

<p style="margin-left:19%;">For recoverability - write the
output file as a fragmented file. This allows the
intermediate file to be read while being written (in
particular, if the writing process is aborted uncleanly).
When writing is finished, the file is converted to a
regular, non-fragmented file, which is more compatible and
allows easier and quicker seeking.</p>

<p style="margin-left:19%; margin-top: 1em">If writing is
aborted, the intermediate file can manually be remuxed to
get a regular, non-fragmented file of what had been written
into the unfinished file.</p>

<p style="margin-left:9%;"><b>movie_timescale</b>
<i>scale</i></p>

<p style="margin-left:14%;">Set the timescale written in
the movie header box (&quot;mvhd&quot;). Range is 1 to
INT_MAX. Default is 1000.</p>

<p style="margin-left:9%;"><b>rtpflags</b> <i>flags</i></p>

<p style="margin-left:14%;">Add RTP hinting tracks to the
output file.</p>

<p style="margin-left:14%; margin-top: 1em">The following
flags can be used: <b><br>
h264_mode0</b></p>

<p style="margin-left:19%;">use mode 0 for H.264 in RTP</p>

<p style="margin-left:14%;"><b>latm</b></p>

<p style="margin-left:19%;">use MP4A-LATM packetization
instead of MPEG4-GENERIC for AAC</p>

<p style="margin-left:14%;"><b>rfc2190</b></p>

<p style="margin-left:19%;">use RFC 2190 packetization
instead of RFC 4629 for H.263</p>

<p style="margin-left:14%;"><b>send_bye</b></p>

<p style="margin-left:19%;">send RTCP BYE packets when
finishing</p>

<p style="margin-left:14%;"><b>skip_rtcp</b></p>

<p style="margin-left:19%;">do not send RTCP sender
reports</p>

<p style="margin-left:9%;"><b>skip_iods</b> <i>bool</i></p>

<p style="margin-left:14%;">skip writing iods atom (default
value is &quot;true&quot;)</p>

<p style="margin-left:9%;"><b>use_editlist</b>
<i>bool</i></p>

<p style="margin-left:14%;">use edit list (default value is
&quot;auto&quot;)</p>


<p style="margin-left:9%;"><b>use_stream_ids_as_track_ids</b>
<i>bool</i></p>

<p style="margin-left:14%;">use stream ids as track ids
(default value is &quot;false&quot;)</p>

<p style="margin-left:9%;"><b>video_track_timescale</b>
<i>scale</i></p>

<p style="margin-left:14%;">Set the timescale used for
video tracks. Range is 0 to INT_MAX. If set to 0, the
timescale is automatically set based on the native stream
time base. Default is 0.</p>

<p style="margin-left:9%;"><b>write_btrt</b>
<i>bool</i></p>

<p style="margin-left:14%;">Force or disable writing
bitrate box inside stsd box of a track. The box contains
decoding buffer size (in bytes), maximum bitrate and average
bitrate for the track. The box will be skipped if none of
these values can be computed. Default is -1 or
&quot;auto&quot;, which will write the box only in MP4
mode.</p>

<p style="margin-left:9%;"><b>write_prft</b>
<i>option</i></p>

<p style="margin-left:14%;">Write producer time reference
box (PRFT) with a specified time source for the NTP field in
the PRFT box. Set value as <b>wallclock</b> to specify
timesource as wallclock time and <b>pts</b> to specify
timesource as input packets&rsquo; PTS values.</p>

<p style="margin-left:9%;"><b>write_tmcd</b>
<i>bool</i></p>

<p style="margin-left:14%;">Specify &quot;on&quot; to force
writing a timecode track, &quot;off&quot; to disable it and
&quot;auto&quot; to write a timecode track only for mov and
mp4 output (default).</p>

<p style="margin-left:14%; margin-top: 1em">Setting value
to <b>pts</b> is applicable only for a live encoding use
case, where PTS values are set as as wallclock time at the
source. For example, an encoding use case with decklink
capture source where <b>video_pts</b> and <b>audio_pts</b>
are set to <b>abs_wallclock</b>.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>Push Smooth Streaming content in real time to a
publishing point on IIS with the <b>ismv</b> muxer using
<b>ffmpeg</b>:</p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -re
&lt;&lt;normal input/transcoding options&gt;&gt; -movflags
isml+frag_keyframe -f ismv
http://server/publishingpoint.isml/Streams(Encoder1)</p>

<h3>a64
<a name="a64"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">A64 Commodore 64
video muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
accepts a single &quot;a64_multi&quot; or
&quot;a64_multi5&quot; codec video stream.</p>

<h3>ac4
<a name="ac4"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Raw AC-4 audio
muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
accepts a single &quot;ac4&quot; audio stream.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
write_crc</b> <i>bool</i></p>

<p style="margin-left:14%;">when enabled, write a CRC
checksum for each packet to the output, default is
&quot;false&quot;</p>

<h3>adts
<a name="adts"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Audio Data
Transport Stream muxer.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts a
single AAC stream.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
write_id3v2</b> <i>bool</i></p>

<p style="margin-left:14%;">Enable to write ID3v2.4 tags at
the start of the stream. Default is disabled.</p>

<p style="margin-left:9%;"><b>write_apetag</b>
<i>bool</i></p>

<p style="margin-left:14%;">Enable to write APE tags at the
end of the stream. Default is disabled.</p>

<p style="margin-left:9%;"><b>write_mpeg2</b>
<i>bool</i></p>

<p style="margin-left:14%;">Enable to set MPEG version bit
in the ADTS frame header to 1 which indicates MPEG-2.
Default is 0, which indicates MPEG-4.</p>

<h3>aea
<a name="aea"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">MD STUDIO audio
muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
accepts a single ATRAC1 audio stream with either one or two
channels and a sample rate of 44100Hz.</p>

<p style="margin-left:9%; margin-top: 1em">As AEA supports
storing the track title, this muxer will also write the
title from stream&rsquo;s metadata to the container.</p>

<h3>aiff
<a name="aiff"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Audio
Interchange File Format muxer.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
write_id3v2</b> <i>bool</i></p>

<p style="margin-left:14%;">Enable ID3v2 tags writing when
set to 1. Default is 0 (disabled).</p>

<p style="margin-left:9%;"><b>id3v2_version</b>
<i>bool</i></p>

<p style="margin-left:14%;">Select ID3v2 version to write.
Currently only version 3 and 4 (aka. ID3v2.3 and ID3v2.4)
are supported. The default is version 4.</p>

<h3>alp
<a name="alp"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">High Voltage
Software&rsquo;s Lego Racers game audio muxer.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts a
single ADPCM_IMA_ALP stream with no more than 2 channels and
a sample rate not greater than 44100 Hz.</p>

<p style="margin-left:9%; margin-top: 1em">Extensions:
&quot;tun&quot;, &quot;pcm&quot;</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
type</b> <i>type</i></p>

<p style="margin-left:14%;">Set file type.</p>

<p style="margin-left:14%; margin-top: 1em"><i>type</i>
accepts the following values:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p><b>tun</b></p></td>
<td width="1%"></td>
<td width="77%">


<p>Set file type as music. Must have a sample rate of 22050
Hz.</p> </td>
<td width="4%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p><b>pcm</b></p></td>
<td width="1%"></td>
<td width="77%">


<p>Set file type as sfx.</p></td>
<td width="4%">
</td></tr>
</table>

<p style="margin-left:14%;"><b>auto</b></p>

<p style="margin-left:19%;">Set file type as per output
file extension. &quot;.pcm&quot; results in type
&quot;pcm&quot; else type &quot;tun&quot; is set.
<i>(default)</i></p>

<h3>amr
<a name="amr"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">3GPP AMR
(Adaptive Multi-Rate) audio muxer.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts a
single audio stream containing an AMR NB stream.</p>

<h3>amv
<a name="amv"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">AMV (Actions
Media Video) format muxer.</p>

<h3>apm
<a name="apm"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Ubisoft Rayman 2
APM audio muxer.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts a
single ADPCM IMA APM audio stream.</p>

<h3>apng
<a name="apng"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Animated
Portable Network Graphics muxer.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts a
single APNG video stream.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
final_delay</b> <i>delay</i></p>

<p style="margin-left:14%;">Force a delay expressed in
seconds after the last frame of each repetition. Default
value is 0.0.</p>

<p style="margin-left:9%;"><b>plays</b>
<i>repetitions</i></p>

<p style="margin-left:14%;">specify how many times to play
the content, 0 causes an infinte loop, with 1 there is no
loop</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>Use <b>ffmpeg</b> to generate an APNG output with 2
repetitions, and with a delay of half a second after the
first repetition:</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i INPUT
-final_delay 0.5 -plays 2 out.apng</p>

<h3>argo_asf
<a name="argo_asf"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Argonaut Games
ASF audio muxer.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts a
single ADPCM audio stream.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
version_major</b> <i>version</i></p>

<p style="margin-left:14%;">override file major version,
specified as an integer, default value is 2</p>

<p style="margin-left:9%;"><b>version_minor</b>
<i>version</i></p>

<p style="margin-left:14%;">override file minor version,
specified as an integer, default value is 1</p>

<p style="margin-left:9%;"><b>name</b> <i>name</i></p>

<p style="margin-left:14%;">Embed file name into file, if
not specified use the output file name. The name is
truncated to 8 characters.</p>

<h3>argo_cvg
<a name="argo_cvg"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Argonaut Games
CVG audio muxer.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts a
single one-channel ADPCM 22050Hz audio stream.</p>

<p style="margin-left:9%; margin-top: 1em">The <b>loop</b>
and <b>reverb</b> options set the corresponding flags in the
header which can be later retrieved to process the audio
stream accordingly.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
skip_rate_check</b> <i>bool</i></p>

<p style="margin-left:14%;">skip sample rate check (default
is &quot;false&quot;)</p>

<p style="margin-left:9%;"><b>loop</b> <i>bool</i></p>

<p style="margin-left:14%;">set loop flag (default is
&quot;false&quot;)</p>

<p style="margin-left:9%;"><b>reverb</b> <i>boolean</i></p>

<p style="margin-left:14%;">set reverb flag (default is
&quot;true&quot;)</p>

<h3>asf, asf_stream
<a name="asf, asf_stream"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Advanced /
Active Systems (or Streaming) Format audio muxer.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>asf_stream</b> variant should be selected for
streaming.</p>

<p style="margin-left:9%; margin-top: 1em">Note that
Windows Media Audio (wma) and Windows Media Video (wmv) use
this muxer too.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
packet_size</b> <i>size</i></p>

<p style="margin-left:14%;">Set the muxer packet size as a
number of bytes. By tuning this setting you may reduce data
fragmentation or muxer overhead depending on your source.
Default value is 3200, minimum is 100, maximum is
&quot;64Ki&quot;.</p>

<h3>ass
<a name="ass"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">ASS/SSA
(SubStation Alpha) subtitles muxer.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts a
single ASS subtitles stream.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
ignore_readorder</b> <i>bool</i></p>

<p style="margin-left:14%;">Write dialogue events
immediately, even if they are out-of-order, default is
&quot;false&quot;, otherwise they are cached until the
expected time event is found.</p>

<h3>ast
<a name="ast"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">AST (Audio
Stream) muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This format is
used to play audio on some Nintendo Wii games.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts a
single audio stream.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>loopstart</b> and <b>loopend</b> options can be used to
define a section of the file to loop for players honoring
such options.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
loopstart</b> <i>start</i></p>

<p style="margin-left:14%;">Specify loop start position
expressesd in milliseconds, from -1 to &quot;INT_MAX&quot;,
in case -1 is set then no loop is specified (default -1) and
the <b>loopend</b> value is ignored.</p>

<p style="margin-left:9%;"><b>loopend</b> <i>end</i></p>

<p style="margin-left:14%;">Specify loop end position
expressed in milliseconds, from 0 to &quot;INT_MAX&quot;,
default is 0, in case 0 is set it assumes the total stream
duration.</p>

<h3>au
<a name="au"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">SUN AU audio
muxer.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts a
single audio stream.</p>

<h3>avi
<a name="avi"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Audio Video
Interleaved muxer.</p>

<p style="margin-left:9%; margin-top: 1em">AVI is a
proprietary format developed by Microsoft, and later
formally specified through the Open DML specification.</p>

<p style="margin-left:9%; margin-top: 1em">Because of
differences in players implementations, it might be required
to set some options to make sure that the generated output
can be correctly played by the target player.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
flipped_raw_rgb</b> <i>bool</i></p>

<p style="margin-left:14%;">If set to &quot;true&quot;,
store positive height for raw RGB bitmaps, which indicates
bitmap is stored bottom-up. Note that this option does not
flip the bitmap which has to be done manually beforehand,
e.g. by using the <b>vflip</b> filter. Default is
&quot;false&quot; and indicates bitmap is stored top
down.</p>

<p style="margin-left:9%;"><b>reserve_index_space</b>
<i>size</i></p>

<p style="margin-left:14%;">Reserve the specified amount of
bytes for the OpenDML master index of each stream within the
file header. By default additional master indexes are
embedded within the data packets if there is no space left
in the first master index and are linked together as a chain
of indexes. This index structure can cause problems for some
use cases, e.g. third-party software strictly relying on the
OpenDML index specification or when file seeking is slow.
Reserving enough index space in the file header avoids these
problems.</p>

<p style="margin-left:14%; margin-top: 1em">The required
index space depends on the output file size and should be
about 16 bytes per gigabyte. When this option is omitted or
set to zero the necessary index space is guessed.</p>

<p style="margin-left:14%; margin-top: 1em">Default value
is 0.</p>

<p style="margin-left:9%;"><b>write_channel_mask</b>
<i>bool</i></p>

<p style="margin-left:14%;">Write the channel layout mask
into the audio stream header.</p>

<p style="margin-left:14%; margin-top: 1em">This option is
enabled by default. Disabling the channel mask can be useful
in specific scenarios, e.g. when merging multiple audio
streams into one for compatibility with software that only
supports a single audio stream in AVI (see <b>the
&quot;amerge&quot; section in the ffmpeg-filters
manual</b>).</p>

<h3>avif
<a name="avif"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">AV1 (Alliance
for Open Media Video codec 1) image format muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This muxers
stores images encoded using the AV1 codec.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts one
or two video streams. In case two video streams are
provided, the second one shall contain a single plane
storing the alpha mask.</p>

<p style="margin-left:9%; margin-top: 1em">In case more
than one image is provided, the generated output is
considered an animated AVIF and the number of loops can be
specified with the <b>loop</b> option.</p>

<p style="margin-left:9%; margin-top: 1em">This is based on
the specification by Alliance for Open Media at url
&lt;<b>https://aomediacodec.github.io/av1-avif</b>&gt;.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
loop</b> <i>count</i></p>

<p style="margin-left:14%;">number of times to loop an
animated AVIF, 0 specify an infinite loop, default is 0</p>

<p style="margin-left:9%;"><b>movie_timescale</b>
<i>timescale</i></p>

<p style="margin-left:14%;">Set the timescale written in
the movie header box (&quot;mvhd&quot;). Range is 1 to
INT_MAX. Default is 1000.</p>

<h3>avm2
<a name="avm2"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">ShockWave Flash
(SWF) / ActionScript Virtual Machine 2 (AVM2) format
muxer.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts one
audio stream, one video stream, or both.</p>

<h3>bit
<a name="bit"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">G.729 (.bit)
file format muxer.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts a
single G.729 audio stream.</p>

<h3>caf
<a name="caf"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Apple CAF (Core
Audio Format) muxer.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts a
single audio stream.</p>

<h3>codec2
<a name="codec2"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Codec2 audio
audio muxer.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts a
single codec2 audio stream.</p>

<h3>chromaprint
<a name="chromaprint"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Chromaprint
fingerprinter muxers.</p>

<p style="margin-left:9%; margin-top: 1em">To enable
compilation of this filter you need to configure FFmpeg with
&quot;--enable-chromaprint&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer feeds
audio data to the Chromaprint library, which generates a
fingerprint for the provided audio data. See:
&lt;<b>https://acoustid.org/chromaprint</b>&gt;</p>

<p style="margin-left:9%; margin-top: 1em">It takes a
single signed native-endian 16-bit raw audio stream of at
most 2 channels.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
algorithm</b> <i>version</i></p>

<p style="margin-left:14%;">Select version of algorithm to
fingerprint with. Range is 0 to 4. Version 3 enables silence
detection. Default is 1.</p>

<p style="margin-left:9%;"><b>fp_format</b>
<i>format</i></p>

<p style="margin-left:14%;">Format to output the
fingerprint as. Accepts the following options: <b><br>
base64</b></p>

<p style="margin-left:19%;">Base64 compressed fingerprint
<i>(default)</i></p>

<p style="margin-left:14%;"><b>compressed</b></p>

<p style="margin-left:19%;">Binary compressed
fingerprint</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p><b>raw</b></p></td>
<td width="1%"></td>
<td width="28%">


<p>Binary raw fingerprint</p></td>
<td width="53%">
</td></tr>
</table>

<p style="margin-left:9%;"><b>silence_threshold</b>
<i>threshold</i></p>

<p style="margin-left:14%;">Threshold for detecting
silence. Range is from -1 to 32767, where -1 disables
silence detection. Silence detection can only be used with
version 3 of the algorithm.</p>

<p style="margin-left:14%; margin-top: 1em">Silence
detection must be disabled for use with the AcoustID
service. Default is -1.</p>

<h3>crc
<a name="crc"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">CRC (Cyclic
Redundancy Check) muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
computes and prints the Adler-32 CRC of all the input audio
and video frames. By default audio frames are converted to
signed 16-bit raw audio and video frames to raw video before
computing the CRC.</p>

<p style="margin-left:9%; margin-top: 1em">The output of
the muxer consists of a single line of the form:
CRC=0x<i>CRC</i>, where <i>CRC</i> is a hexadecimal number
0-padded to 8 digits containing the CRC for all the decoded
input frames.</p>

<p style="margin-left:9%; margin-top: 1em">See also the
<b>framecrc</b> muxer.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>Use <b>ffmpeg</b> to compute the CRC of the input, and
store it in the file <i>out.crc</i>:</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i INPUT
-f crc out.crc</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="71%">


<p style="margin-top: 1em">Use <b>ffmpeg</b> to print the
CRC to stdout with the command:</p></td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i INPUT
-f crc -</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">You can select the output format
of each frame with <b>ffmpeg</b> by specifying the audio and
video codec and format. For example, to compute the CRC of
the input audio converted to PCM unsigned 8-bit and the
input video converted to MPEG-2 video, use the command:</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i INPUT
-c:a pcm_u8 -c:v mpeg2video -f crc -</p>

<h3>dash
<a name="dash"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Dynamic Adaptive
Streaming over HTTP (DASH) muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
creates segments and manifest files according to the
MPEG-DASH standard ISO/IEC 23009-1:2014 and following
standard updates.</p>

<p style="margin-left:9%; margin-top: 1em">For more
information see:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">ISO DASH Specification:
&lt;<b>http://standards.iso.org/ittf/PubliclyAvailableStandards/c065274_ISO_IEC_23009-1_2014.zip</b>&gt;</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>WebM DASH Specification:
&lt;<b>https://sites.google.com/a/webmproject.org/wiki/adaptive-streaming/webm-dash-specification</b>&gt;</p> </td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">This muxer
creates an MPD (Media Presentation Description) manifest
file and segment files for each stream. Segment files are
placed in the same directory of the MPD manifest file.</p>

<p style="margin-left:9%; margin-top: 1em">The segment
filename might contain pre-defined identifiers used in the
manifest &quot;SegmentTemplate&quot; section as defined in
section 5.3.9.4.4 of the standard.</p>

<p style="margin-left:9%; margin-top: 1em">Available
identifiers are &quot;$RepresentationID$&quot;,
&quot;$Number$&quot;, &quot;$Bandwidth$&quot;, and
&quot;$Time$&quot;. In addition to the standard identifiers,
an ffmpeg-specific &quot;$ext$&quot; identifier is also
supported. When specified, <b>ffmpeg</b> will replace
&quot;$ext$&quot; in the file name with muxing
format&rsquo;s extensions such as &quot;mp4&quot;,
&quot;webm&quot; etc.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
adaptation_sets</b> <i>adaptation_sets</i></p>

<p style="margin-left:14%;">Assign streams to adaptation
sets, specified in the MPD manifest
&quot;AdaptationSets&quot; section.</p>

<p style="margin-left:14%; margin-top: 1em">An adaptation
set contains a set of one or more streams accessed as a
single subset, e.g. corresponding streams encoded at
different size selectable by the user depending on the
available bandwidth, or to different audio streams with a
different language.</p>

<p style="margin-left:14%; margin-top: 1em">Each adaptation
set is specified with the syntax:</p>


<p style="margin-left:14%; margin-top: 1em">id=&lt;index&gt;,streams=&lt;streams&gt;</p>

<p style="margin-left:14%; margin-top: 1em">where
<i>index</i> must be a numerical index, and <i>streams</i>
is a sequence of &quot;,&quot;-separated stream indices.
Multiple adaptation sets can be specified, separated by
spaces.</p>

<p style="margin-left:14%; margin-top: 1em">To map all
video (or audio) streams to an adaptation set, &quot;v&quot;
(or &quot;a&quot;) can be used as stream identifier instead
of IDs.</p>

<p style="margin-left:14%; margin-top: 1em">When no
assignment is defined, this defaults to an adaptation set
for each stream.</p>

<p style="margin-left:14%; margin-top: 1em">The following
optional fields can also be specified: <b><br>
descriptor</b></p>

<p style="margin-left:19%;">Define the descriptor as
defined by ISO/IEC 23009-1:2014/Amd.2:2015.</p>

<p style="margin-left:19%; margin-top: 1em">For
example:</p>


<p style="margin-left:19%; margin-top: 1em">&lt;SupplementalProperty
schemeIdUri=\&quot;urn:mpeg:dash:srd:2014\&quot;
value=\&quot;0,0,0,1,1,2,2\&quot;/&gt;</p>

<p style="margin-left:19%; margin-top: 1em">The descriptor
string should be a self-closing XML tag.</p>

<p style="margin-left:14%;"><b>frag_duration</b></p>

<p style="margin-left:19%;">Override the global fragment
duration specified with the <b>frag_duration</b> option.</p>

<p style="margin-left:14%;"><b>frag_type</b></p>

<p style="margin-left:19%;">Override the global fragment
type specified with the <b>frag_type</b> option.</p>

<p style="margin-left:14%;"><b>seg_duration</b></p>

<p style="margin-left:19%;">Override the global segment
duration specified with the <b>seg_duration</b> option.</p>

<p style="margin-left:14%;"><b>trick_id</b></p>

<p style="margin-left:19%;">Mark an adaptation set as
containing streams meant to be used for Trick Mode for the
referenced adaptation set.</p>

<p style="margin-left:14%; margin-top: 1em">A few examples
of possible values for the <b>adaptation_sets</b> option
follow:</p>


<p style="margin-left:14%; margin-top: 1em">id=0,seg_duration=2,frag_duration=1,frag_type=duration,streams=v
id=1,seg_duration=2,frag_type=none,streams=a <br>
id=0,seg_duration=2,frag_type=none,streams=0
id=1,seg_duration=10,frag_type=none,trick_id=0,streams=1</p>

<p style="margin-left:9%;"><b>dash_segment_type</b>
<i>type</i></p>

<p style="margin-left:14%;">Set DASH segment files
type.</p>

<p style="margin-left:14%; margin-top: 1em">Possible
values: <b><br>
auto</b></p>

<p style="margin-left:19%;">The dash segment files format
will be selected based on the stream codec. This is the
default mode.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p><b>mp4</b></p></td>
<td width="1%"></td>
<td width="67%">


<p>the dash segment files will be in ISOBMFF/MP4 format</p></td>
<td width="14%">
</td></tr>
</table>

<p style="margin-left:14%;"><b>webm</b></p>

<p style="margin-left:19%;">the dash segment files will be
in WebM format</p>

<p style="margin-left:9%;"><b>extra_window_size</b>
<i>size</i></p>

<p style="margin-left:14%;">Set the maximum number of
segments kept outside of the manifest before removing from
disk.</p>

<p style="margin-left:9%;"><b>format_options</b>
<i>options_list</i></p>

<p style="margin-left:14%;">Set container format (mp4/webm)
options using a &quot;:&quot;-separated list of key=value
parameters. Values containing &quot;:&quot; special
characters must be escaped.</p>

<p style="margin-left:9%;"><b>frag_duration</b>
<i>duration</i></p>

<p style="margin-left:14%;">Set the length in seconds of
fragments within segments, fractional value can also be
set.</p>

<p style="margin-left:9%;"><b>frag_type</b> <i>type</i></p>

<p style="margin-left:14%;">Set the type of interval for
fragmentation.</p>

<p style="margin-left:14%; margin-top: 1em">Possible
values: <b><br>
auto</b></p>

<p style="margin-left:19%;">set one fragment per
segment</p>

<p style="margin-left:14%;"><b>every_frame</b></p>

<p style="margin-left:19%;">fragment at every frame</p>

<p style="margin-left:14%;"><b>duration</b></p>

<p style="margin-left:19%;">fragment at specific time
intervals</p>

<p style="margin-left:14%;"><b>pframes</b></p>

<p style="margin-left:19%;">fragment at keyframes and
following P-Frame reordering (Video only, experimental)</p>

<p style="margin-left:9%;"><b>global_sidx</b>
<i>bool</i></p>

<p style="margin-left:14%;">Write global &quot;SIDX&quot;
atom. Applicable only for single file, mp4 output,
non-streaming mode.</p>

<p style="margin-left:9%;"><b>hls_master_name</b>
<i>file_name</i></p>

<p style="margin-left:14%;">HLS master playlist name.
Default is <i>master.m3u8</i>.</p>

<p style="margin-left:9%;"><b>hls_playlist</b>
<i>bool</i></p>

<p style="margin-left:14%;">Generate HLS playlist files.
The master playlist is generated with filename specified by
the <b>hls_master_name</b> option. One media playlist file
is generated for each stream with filenames
<i>media_0.m3u8</i>, <i>media_1.m3u8</i>, etc.</p>

<p style="margin-left:9%;"><b>http_opts</b>
<i>http_opts</i></p>

<p style="margin-left:14%;">Specify a list of
&quot;:&quot;-separated key=value options to pass to the
underlying HTTP protocol. Applicable only for HTTP
output.</p>

<p style="margin-left:9%;"><b>http_persistent</b>
<i>bool</i></p>

<p style="margin-left:14%;">Use persistent HTTP
connections. Applicable only for HTTP output.</p>

<p style="margin-left:9%;"><b>http_user_agent</b>
<i>user_agent</i></p>

<p style="margin-left:14%;">Override User-Agent field in
HTTP header. Applicable only for HTTP output.</p>

<p style="margin-left:9%;"><b>ignore_io_errors</b>
<i>bool</i></p>

<p style="margin-left:14%;">Ignore IO errors during open
and write. Useful for long-duration runs with network
output. This is disabled by default.</p>

<p style="margin-left:9%;"><b>index_correction</b>
<i>bool</i></p>

<p style="margin-left:14%;">Enable or disable segment index
correction logic. Applicable only when <b>use_template</b>
is enabled and <b>use_timeline</b> is disabled. This is
disabled by default.</p>

<p style="margin-left:14%; margin-top: 1em">When enabled,
the logic monitors the flow of segment indexes. If a
streams&rsquo;s segment index value is not at the expected
real time position, then the logic corrects that index
value.</p>

<p style="margin-left:14%; margin-top: 1em">Typically this
logic is needed in live streaming use cases. The network
bandwidth fluctuations are common during long run streaming.
Each fluctuation can cause the segment indexes fall behind
the expected real time position.</p>

<p style="margin-left:9%;"><b>init_seg_name</b>
<i>init_name</i></p>

<p style="margin-left:14%;">DASH-templated name to use for
the initialization segment. Default is
&quot;init-stream$RepresentationID$.$ext$&quot;.
&quot;$ext$&quot; is replaced with the file name extension
specific for the segment format.</p>

<p style="margin-left:9%;"><b>ldash</b> <i>bool</i></p>

<p style="margin-left:14%;">Enable Low-latency Dash by
constraining the presence and values of some elements. This
is disabled by default.</p>

<p style="margin-left:9%;"><b>lhls</b> <i>bool</i></p>

<p style="margin-left:14%;">Enable Low-latency HLS (LHLS).
Add &quot;#EXT-X-PREFETCH&quot; tag with current
segment&rsquo;s URI. hls.js player folks are trying to
standardize an open LHLS spec. The draft spec is available
at
&lt;<b>https://github.com/video-dev/hlsjs-rfcs/blob/lhls-spec/proposals/0001-lhls.md</b>&gt;.</p>

<p style="margin-left:14%; margin-top: 1em">This option
tries to comply with the above open spec. It enables
<b>streaming</b> and <b>hls_playlist</b> options
automatically. This is an experimental feature.</p>

<p style="margin-left:14%; margin-top: 1em">Note: This is
not Apple&rsquo;s version LHLS. See
&lt;<b>https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis</b>&gt;</p>

<p style="margin-left:9%;"><b>master_m3u8_publish_rate</b>
<i>segment_intervals_count</i></p>

<p style="margin-left:14%;">Publish master playlist
repeatedly every after specified number of segment
intervals.</p>

<p style="margin-left:9%;"><b>max_playback_rate</b>
<i>rate</i></p>

<p style="margin-left:14%;">Set the maximum playback rate
indicated as appropriate for the purposes of automatically
adjusting playback latency and buffer occupancy during
normal playback by clients.</p>

<p style="margin-left:9%;"><b>media_seg_name</b>
<i>segment_name</i></p>

<p style="margin-left:14%;">DASH-templated name to use for
the media segments. Default is
&quot;chunk-stream$RepresentationID$-$Number%05d$.$ext$&quot;.
&quot;$ext$&quot; is replaced with the file name extension
specific for the segment format.</p>

<p style="margin-left:9%;"><b>method</b> <i>method</i></p>

<p style="margin-left:14%;">Use the given HTTP method to
create output files. Generally set to &quot;PUT&quot; or
&quot;POST&quot;.</p>

<p style="margin-left:9%;"><b>min_playback_rate</b>
<i>rate</i></p>

<p style="margin-left:14%;">Set the minimum playback rate
indicated as appropriate for the purposes of automatically
adjusting playback latency and buffer occupancy during
normal playback by clients.</p>

<p style="margin-left:9%;"><b>mpd_profile</b>
<i>flags</i></p>

<p style="margin-left:14%;">Set one or more MPD manifest
profiles.</p>

<p style="margin-left:14%; margin-top: 1em">Possible
values: <b><br>
dash</b></p>

<p style="margin-left:19%;">MPEG-DASH ISO Base media file
format live profile</p>

<p style="margin-left:14%;"><b>dvb_dash</b></p>

<p style="margin-left:19%;">DVB-DASH profile</p>

<p style="margin-left:14%; margin-top: 1em">Default value
is &quot;dash&quot;.</p>

<p style="margin-left:9%;"><b>remove_at_exit</b>
<i>bool</i></p>

<p style="margin-left:14%;">Enable or disable removal of
all segments when finished. This is disabled by default.</p>

<p style="margin-left:9%;"><b>seg_duration</b>
<i>duration</i></p>

<p style="margin-left:14%;">Set the segment length in
seconds (fractional value can be set). The value is treated
as average segment duration when the <b>use_template</b>
option is enabled and the <b>use_timeline</b> option is
disabled and as minimum segment duration for all the other
use cases.</p>

<p style="margin-left:14%; margin-top: 1em">Default value
is 5.</p>

<p style="margin-left:9%;"><b>single_file</b>
<i>bool</i></p>

<p style="margin-left:14%;">Enable or disable storing all
segments in one file, accessed using byte ranges. This is
disabled by default.</p>

<p style="margin-left:14%; margin-top: 1em">The name of the
single file can be specified with the
<b>single_file_name</b> option, if not specified assume the
basename of the manifest file with the output format
extension.</p>

<p style="margin-left:9%;"><b>single_file_name</b>
<i>file_name</i></p>

<p style="margin-left:14%;">DASH-templated name to use for
the manifest &quot;baseURL&quot; element. Imply that the
<b>single_file</b> option is set to <i>true</i>. In the
template, &quot;$ext$&quot; is replaced with the file name
extension specific for the segment format.</p>

<p style="margin-left:9%;"><b>streaming</b> <i>bool</i></p>

<p style="margin-left:14%;">Enable or disable chunk
streaming mode of output. In chunk streaming mode, each
frame will be a &quot;moof&quot; fragment which forms a
chunk. This is disabled by default.</p>

<p style="margin-left:9%;"><b>target_latency</b>
<i>target_latency</i></p>

<p style="margin-left:14%;">Set an intended target latency
in seconds for serving (fractional value can be set).
Applicable only when the <b>streaming</b> and
<b>write_prft</b> options are enabled. This is an
informative fields clients can use to measure the latency of
the service.</p>

<p style="margin-left:9%;"><b>timeout</b>
<i>timeout</i></p>

<p style="margin-left:14%;">Set timeout for socket I/O
operations expressed in seconds (fractional value can be
set). Applicable only for HTTP output.</p>

<p style="margin-left:9%;"><b>update_period</b>
<i>period</i></p>

<p style="margin-left:14%;">Set the MPD update period, for
dynamic content. The unit is second. If set to 0, the period
is automatically computed.</p>

<p style="margin-left:14%; margin-top: 1em">Default value
is 0.</p>

<p style="margin-left:9%;"><b>use_template</b>
<i>bool</i></p>

<p style="margin-left:14%;">Enable or disable use of
&quot;SegmentTemplate&quot; instead of
&quot;SegmentList&quot; in the manifest. This is enabled by
default.</p>

<p style="margin-left:9%;"><b>use_timeline</b>
<i>bool</i></p>

<p style="margin-left:14%;">Enable or disable use of
&quot;SegmentTimeline&quot; within the
&quot;SegmentTemplate&quot; manifest section. This is
enabled by default.</p>

<p style="margin-left:9%;"><b>utc_timing_url</b>
<i>url</i></p>

<p style="margin-left:14%;">URL of the page that will
return the UTC timestamp in ISO format, for example
&quot;https://time.akamai.com/?iso&quot;</p>

<p style="margin-left:9%;"><b>window_size</b>
<i>size</i></p>

<p style="margin-left:14%;">Set the maximum number of
segments kept in the manifest, discard the oldest one. This
is useful for live streaming.</p>

<p style="margin-left:14%; margin-top: 1em">If the value is
0, all segments are kept in the manifest. Default value is
0.</p>

<p style="margin-left:9%;"><b>write_prft</b>
<i>write_prft</i></p>

<p style="margin-left:14%;">Write Producer Reference Time
elements on supported streams. This also enables writing
prft boxes in the underlying muxer. Applicable only when the
<i>utc_url</i> option is enabled. It is set to <i>auto</i>
by default, in which case the muxer will attempt to enable
it only in modes that require it.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Example</i></p>

<p style="margin-left:9%; margin-top: 1em">Generate a DASH
output reading from an input source in realtime using
<b>ffmpeg</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Two multimedia
streams are generated from the input file, both containing a
video stream encoded through <b>libx264</b>, and an audio
stream encoded with <b>libfdk_aac</b>. The first multimedia
stream contains video with a bitrate of 800k and audio at
the default rate, the second with video scaled to 320x170
pixels at 300k and audio resampled at 22005 Hz.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>window_size</b> option keeps only the latest 5 segments
with the default duration of 5 seconds.</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -re -i
&lt;input&gt; -map 0 -map 0 -c:a libfdk_aac -c:v libx264 \
<br>
-b:v:0 800k -profile:v:0 main \ <br>
-b:v:1 300k -s:v:1 320x170 -profile:v:1 baseline -ar:a:1
22050 \ <br>
-bf 1 -keyint_min 120 -g 120 -sc_threshold 0 -b_strategy 0 \
<br>
-use_timeline 1 -use_template 1 -window_size 5 \ <br>
-adaptation_sets &quot;id=0,streams=v id=1,streams=a&quot; \
<br>
-f dash /path/to/out.mpd</p>

<h3>daud
<a name="daud"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">D-Cinema audio
muxer.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts a
single 6-channels audio stream resampled at 96000 Hz encoded
with the <b>pcm_24daud</b> codec.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Example</i></p>

<p style="margin-left:9%; margin-top: 1em">Use
<b>ffmpeg</b> to mux input audio to a <b>5.1</b> channel
layout resampled at 96000Hz:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-af aresample=96000,pan=5.1 slow.302</p>

<p style="margin-left:9%; margin-top: 1em">For ffmpeg
versions before 7.0 you might have to use the
<b>asetnsamples</b> filter to limit the muxed packet size,
because this format does not support muxing packets larger
than 65535 bytes (3640 samples). For newer ffmpeg versions
audio is automatically packetized to 36000 byte (2000
sample) packets.</p>

<h3>dv
<a name="dv"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">DV (Digital
Video) muxer.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts
exactly one <b>dvvideo</b> video stream and at most two
<b>pcm_s16</b> audio streams. More constraints are defined
by the property of the video, which must correspond to a DV
video supported profile, and on the framerate.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Example</i></p>

<p style="margin-left:9%; margin-top: 1em">Use
<b>ffmpeg</b> to convert the input:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-s:v 720x480 -pix_fmt yuv411p -r 29.97 -ac 2 -ar 48000 -y
out.dv</p>

<h3>ffmetadata
<a name="ffmetadata"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">FFmpeg metadata
muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
writes the streams metadata in the <b>ffmetadata</b>
format.</p>

<p style="margin-left:9%; margin-top: 1em">See <b>the
Metadata chapter</b> for information about the format.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Example</i></p>

<p style="margin-left:9%; margin-top: 1em">Use
<b>ffmpeg</b> to extract metadata from an input file to a
<i>metadata.ffmeta</i> file in <b>ffmetadata</b> format:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-f ffmetadata metadata.ffmeta</p>

<h3>fifo
<a name="fifo"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">FIFO (First-In
First-Out) muxer.</p>

<p style="margin-left:9%; margin-top: 1em">The <b>fifo</b>
pseudo-muxer allows the separation of encoding and muxing by
using a first-in-first-out queue and running the actual
muxer in a separate thread.</p>

<p style="margin-left:9%; margin-top: 1em">This is
especially useful in combination with the <b>tee</b> muxer
and can be used to send data to several destinations with
different reliability/writing speed/latency.</p>

<p style="margin-left:9%; margin-top: 1em">The target muxer
is either selected from the output name or specified through
the <b>fifo_format</b> option.</p>

<p style="margin-left:9%; margin-top: 1em">The behavior of
the <b>fifo</b> muxer if the queue fills up or if the output
fails (e.g. if a packet cannot be written to the output) is
selectable:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>Output can be transparently restarted with configurable
delay between retries based on real time or time of the
processed stream.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>Encoding can be blocked during temporary failure, or
continue transparently dropping packets in case the FIFO
queue fills up.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">API users should
be aware that callback functions
(&quot;interrupt_callback&quot;, &quot;io_open&quot; and
&quot;io_close&quot;) used within its
&quot;AVFormatContext&quot; must be thread-safe.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
attempt_recovery</b> <i>bool</i></p>

<p style="margin-left:14%;">If failure occurs, attempt to
recover the output. This is especially useful when used with
network output, since it makes it possible to restart
streaming transparently. By default this option is set to
&quot;false&quot;.</p>

<p style="margin-left:9%;"><b>drop_pkts_on_overflow</b>
<i>bool</i></p>

<p style="margin-left:14%;">If set to &quot;true&quot;, in
case the fifo queue fills up, packets will be dropped rather
than blocking the encoder. This makes it possible to
continue streaming without delaying the input, at the cost
of omitting part of the stream. By default this option is
set to &quot;false&quot;, so in such cases the encoder will
be blocked until the muxer processes some of the packets and
none of them is lost.</p>

<p style="margin-left:9%;"><b>fifo_format</b>
<i>format_name</i></p>

<p style="margin-left:14%;">Specify the format name. Useful
if it cannot be guessed from the output name suffix.</p>

<p style="margin-left:9%;"><b>format_opts</b>
<i>options</i></p>

<p style="margin-left:14%;">Specify format options for the
underlying muxer. Muxer options can be specified as a list
of <i>key</i>=<i>value</i> pairs separated by
&rsquo;:&rsquo;.</p>

<p style="margin-left:9%;"><b>max_recovery_attempts</b>
<i>count</i></p>

<p style="margin-left:14%;">Set maximum number of
successive unsuccessful recovery attempts after which the
output fails permanently. By default this option is set to 0
(unlimited).</p>

<p style="margin-left:9%;"><b>queue_size</b>
<i>size</i></p>

<p style="margin-left:14%;">Specify size of the queue as a
number of packets. Default value is 60.</p>

<p style="margin-left:9%;"><b>recover_any_error</b>
<i>bool</i></p>

<p style="margin-left:14%;">If set to &quot;true&quot;,
recovery will be attempted regardless of type of the error
causing the failure. By default this option is set to
&quot;false&quot; and in case of certain (usually permanent)
errors the recovery is not attempted even when the
<b>attempt_recovery</b> option is set to
&quot;true&quot;.</p>

<p style="margin-left:9%;"><b>recovery_wait_streamtime</b>
<i>bool</i></p>

<p style="margin-left:14%;">If set to &quot;false&quot;,
the real time is used when waiting for the recovery attempt
(i.e. the recovery will be attempted after the time
specified by the <b>recovery_wait_time</b> option).</p>

<p style="margin-left:14%; margin-top: 1em">If set to
&quot;true&quot;, the time of the processed stream is taken
into account instead (i.e. the recovery will be attempted
after discarding the packets corresponding to the
<b>recovery_wait_time</b> option).</p>

<p style="margin-left:14%; margin-top: 1em">By default this
option is set to &quot;false&quot;.</p>

<p style="margin-left:9%;"><b>recovery_wait_time</b>
<i>duration</i></p>

<p style="margin-left:14%;">Specify waiting time in seconds
before the next recovery attempt after previous unsuccessful
recovery attempt. Default value is 5.</p>

<p style="margin-left:9%;"><b>restart_with_keyframe</b>
<i>bool</i></p>

<p style="margin-left:14%;">Specify whether to wait for the
keyframe after recovering from queue overflow or failure.
This option is set to &quot;false&quot; by default.</p>

<p style="margin-left:9%;"><b>timeshift</b>
<i>duration</i></p>

<p style="margin-left:14%;">Buffer the specified amount of
packets and delay writing the output. Note that the value of
the <b>queue_size</b> option must be big enough to store the
packets for timeshift. At the end of the input the fifo
buffer is flushed at realtime speed.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Example</i></p>

<p style="margin-left:9%; margin-top: 1em">Use
<b>ffmpeg</b> to stream to an RTMP server, continue
processing the stream at real-time rate even in case of
temporary failure (network outage) and attempt to recover
streaming every second indefinitely:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -re -i
... -c:v libx264 -c:a aac -f fifo -fifo_format flv \ <br>
-drop_pkts_on_overflow 1 -attempt_recovery 1
-recovery_wait_time 1 \ <br>
-map 0:v -map 0:a rtmp://example.com/live/stream_name</p>

<h3>film_cpk
<a name="film_cpk"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Sega film (.cpk)
muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This format was
used as internal format for several Sega games.</p>

<p style="margin-left:9%; margin-top: 1em">For more
information regarding the Sega film file format, visit
&lt;<b>http://wiki.multimedia.cx/index.php?title=Sega_FILM</b>&gt;.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts at
maximum one <b>cinepak</b> or raw video stream, and at
maximum one audio stream.</p>

<h3>filmstrip
<a name="filmstrip"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Adobe Filmstrip
muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This format is
used by several Adobe tools to store a generated filmstrip
export. It accepts a single raw video stream.</p>

<h3>fits
<a name="fits"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Flexible Image
Transport System (FITS) muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This image
format is used to store astronomical data.</p>

<p style="margin-left:9%; margin-top: 1em">For more
information regarding the format, visit
&lt;<b>https://fits.gsfc.nasa.gov</b>&gt;.</p>

<h3>flac
<a name="flac"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Raw FLAC audio
muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
accepts exactly one FLAC audio stream. Additionally, it is
possible to add images with disposition
<b>attached_pic</b>.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
write_header</b> <i>bool</i></p>

<p style="margin-left:14%;">write the file header if set to
&quot;true&quot;, default is &quot;true&quot;</p>


<p style="margin-left:9%; margin-top: 1em"><i>Example</i></p>

<p style="margin-left:9%; margin-top: 1em">Use
<b>ffmpeg</b> to store the audio stream from an input file,
together with several pictures used with <b>attached_pic</b>
disposition:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-i pic1.png -i pic2.jpg -map 0:a -map 1 -map 2
-disposition:v attached_pic OUTPUT</p>

<h3>flv
<a name="flv"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Adobe Flash
Video Format muxer.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
flvflags</b> <i>flags</i></p>

<p style="margin-left:14%;">Possible values: <b><br>
aac_seq_header_detect</b></p>

<p style="margin-left:19%;">Place AAC sequence header based
on audio stream data.</p>

<p style="margin-left:14%;"><b>no_sequence_end</b></p>

<p style="margin-left:19%;">Disable sequence end tag.</p>

<p style="margin-left:14%;"><b>no_metadata</b></p>

<p style="margin-left:19%;">Disable metadata tag.</p>


<p style="margin-left:14%;"><b>no_duration_filesize</b></p>

<p style="margin-left:19%;">Disable duration and filesize
in metadata when they are equal to zero at the end of
stream. (Be used to non-seekable living stream).</p>

<p style="margin-left:14%;"><b>add_keyframe_index</b></p>

<p style="margin-left:19%;">Used to facilitate seeking;
particularly for HTTP pseudo streaming.</p>

<h3>framecrc
<a name="framecrc"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Per-packet CRC
(Cyclic Redundancy Check) testing format.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
computes and prints the Adler-32 CRC for each audio and
video packet. By default audio frames are converted to
signed 16-bit raw audio and video frames to raw video before
computing the CRC.</p>

<p style="margin-left:9%; margin-top: 1em">The output of
the muxer consists of a line for each audio and video packet
of the form:</p>


<p style="margin-left:9%; margin-top: 1em">&lt;stream_index&gt;,
&lt;packet_dts&gt;, &lt;packet_pts&gt;,
&lt;packet_duration&gt;, &lt;packet_size&gt;,
0x&lt;CRC&gt;</p>

<p style="margin-left:9%; margin-top: 1em"><i>CRC</i> is a
hexadecimal number 0-padded to 8 digits containing the CRC
of the packet.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<p style="margin-left:9%; margin-top: 1em">For example to
compute the CRC of the audio and video frames in
<i>INPUT</i>, converted to raw audio and video packets, and
store it in the file <i>out.crc</i>:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-f framecrc out.crc</p>

<p style="margin-left:9%; margin-top: 1em">To print the
information to stdout, use the command:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-f framecrc -</p>

<p style="margin-left:9%; margin-top: 1em">With
<b>ffmpeg</b>, you can select the output format to which the
audio and video frames are encoded before computing the CRC
for each packet by specifying the audio and video codec. For
example, to compute the CRC of each decoded input audio
frame converted to PCM unsigned 8-bit and of each decoded
input video frame converted to MPEG-2 video, use the
command:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-c:a pcm_u8 -c:v mpeg2video -f framecrc -</p>

<p style="margin-left:9%; margin-top: 1em">See also the
<b>crc</b> muxer.</p>

<h3>framehash
<a name="framehash"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Per-packet hash
testing format.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
computes and prints a cryptographic hash for each audio and
video packet. This can be used for packet-by-packet equality
checks without having to individually do a binary comparison
on each.</p>

<p style="margin-left:9%; margin-top: 1em">By default audio
frames are converted to signed 16-bit raw audio and video
frames to raw video before computing the hash, but the
output of explicit conversions to other codecs can also be
used. It uses the SHA-256 cryptographic hash function by
default, but supports several other algorithms.</p>

<p style="margin-left:9%; margin-top: 1em">The output of
the muxer consists of a line for each audio and video packet
of the form:</p>


<p style="margin-left:9%; margin-top: 1em">&lt;stream_index&gt;,
&lt;packet_dts&gt;, &lt;packet_pts&gt;,
&lt;packet_duration&gt;, &lt;packet_size&gt;,
&lt;hash&gt;</p>

<p style="margin-left:9%; margin-top: 1em"><i>hash</i> is a
hexadecimal number representing the computed hash for the
packet. <b><br>
hash</b> <i>algorithm</i></p>

<p style="margin-left:14%;">Use the cryptographic hash
function specified by the string <i>algorithm</i>. Supported
values include &quot;MD5&quot;, &quot;murmur3&quot;,
&quot;RIPEMD128&quot;, &quot;RIPEMD160&quot;,
&quot;RIPEMD256&quot;, &quot;RIPEMD320&quot;,
&quot;SHA160&quot;, &quot;SHA224&quot;, &quot;SHA256&quot;
(default), &quot;SHA512/224&quot;, &quot;SHA512/256&quot;,
&quot;SHA384&quot;, &quot;SHA512&quot;, &quot;CRC32&quot;
and &quot;adler32&quot;.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<p style="margin-left:9%; margin-top: 1em">To compute the
SHA-256 hash of the audio and video frames in <i>INPUT</i>,
converted to raw audio and video packets, and store it in
the file <i>out.sha256</i>:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-f framehash out.sha256</p>

<p style="margin-left:9%; margin-top: 1em">To print the
information to stdout, using the MD5 hash function, use the
command:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-f framehash -hash md5 -</p>

<p style="margin-left:9%; margin-top: 1em">See also the
<b>hash</b> muxer.</p>

<h3>framemd5
<a name="framemd5"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Per-packet MD5
testing format.</p>

<p style="margin-left:9%; margin-top: 1em">This is a
variant of the <b>framehash</b> muxer. Unlike that muxer, it
defaults to using the MD5 hash function.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<p style="margin-left:9%; margin-top: 1em">To compute the
MD5 hash of the audio and video frames in <i>INPUT</i>,
converted to raw audio and video packets, and store it in
the file <i>out.md5</i>:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-f framemd5 out.md5</p>

<p style="margin-left:9%; margin-top: 1em">To print the
information to stdout, use the command:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-f framemd5 -</p>

<p style="margin-left:9%; margin-top: 1em">See also the
<b>framehash</b> and <b>md5</b> muxers.</p>

<h3>gif
<a name="gif"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Animated GIF
muxer.</p>

<p style="margin-left:9%; margin-top: 1em">Note that the
GIF format has a very large time base: the delay between two
frames can therefore not be smaller than one centi
second.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
loop</b> <i>bool</i></p>

<p style="margin-left:14%;">Set the number of times to loop
the output. Use -1 for no loop, 0 for looping indefinitely
(default).</p>

<p style="margin-left:9%;"><b>final_delay</b>
<i>delay</i></p>

<p style="margin-left:14%;">Force the delay (expressed in
centiseconds) after the last frame. Each frame ends with a
delay until the next frame. The default is -1, which is a
special value to tell the muxer to re-use the previous
delay. In case of a loop, you might want to customize this
value to mark a pause for instance.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Example</i></p>

<p style="margin-left:9%; margin-top: 1em">Encode a gif
looping 10 times, with a 5 seconds delay between the
loops:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-loop 10 -final_delay 500 out.gif</p>

<p style="margin-left:9%; margin-top: 1em">Note 1: if you
wish to extract the frames into separate GIF files, you need
to force the <b>image2</b> muxer:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-c:v gif -f image2 &quot;out%d.gif&quot;</p>

<h3>gxf
<a name="gxf"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">General eXchange
Format (GXF) muxer.</p>

<p style="margin-left:9%; margin-top: 1em">GXF was
developed by Grass Valley Group, then standardized by SMPTE
as SMPTE 360M and was extended in SMPTE RDD 14-2007 to
include high-definition video resolutions.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts at
most one video stream with codec <b>mjpeg</b>, or
<b>mpeg1video</b>, or <b>mpeg2video</b>, or <b>dvvideo</b>
with resolution <b>512x480</b> or <b>608x576</b>, and
several audio streams with rate 48000Hz and codec
<b>pcm16_le</b>.</p>

<h3>hash
<a name="hash"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Hash testing
format.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
computes and prints a cryptographic hash of all the input
audio and video frames. This can be used for equality checks
without having to do a complete binary comparison.</p>

<p style="margin-left:9%; margin-top: 1em">By default audio
frames are converted to signed 16-bit raw audio and video
frames to raw video before computing the hash, but the
output of explicit conversions to other codecs can also be
used. Timestamps are ignored. It uses the SHA-256
cryptographic hash function by default, but supports several
other algorithms.</p>

<p style="margin-left:9%; margin-top: 1em">The output of
the muxer consists of a single line of the form:
<i>algo</i>=<i>hash</i>, where <i>algo</i> is a short string
representing the hash function used, and <i>hash</i> is a
hexadecimal number representing the computed hash. <b><br>
hash</b> <i>algorithm</i></p>

<p style="margin-left:14%;">Use the cryptographic hash
function specified by the string <i>algorithm</i>. Supported
values include &quot;MD5&quot;, &quot;murmur3&quot;,
&quot;RIPEMD128&quot;, &quot;RIPEMD160&quot;,
&quot;RIPEMD256&quot;, &quot;RIPEMD320&quot;,
&quot;SHA160&quot;, &quot;SHA224&quot;, &quot;SHA256&quot;
(default), &quot;SHA512/224&quot;, &quot;SHA512/256&quot;,
&quot;SHA384&quot;, &quot;SHA512&quot;, &quot;CRC32&quot;
and &quot;adler32&quot;.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<p style="margin-left:9%; margin-top: 1em">To compute the
SHA-256 hash of the input converted to raw audio and video,
and store it in the file <i>out.sha256</i>:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-f hash out.sha256</p>

<p style="margin-left:9%; margin-top: 1em">To print an MD5
hash to stdout use the command:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-f hash -hash md5 -</p>

<p style="margin-left:9%; margin-top: 1em">See also the
<b>framehash</b> muxer.</p>

<h3>hds
<a name="hds"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">HTTP Dynamic
Streaming (HDS) muxer.</p>

<p style="margin-left:9%; margin-top: 1em">HTTP dynamic
streaming, or HDS, is an adaptive bitrate streaming method
developed by Adobe. HDS delivers MP4 video content over HTTP
connections. HDS can be used for on-demand streaming or live
streaming.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
creates an .f4m (Adobe Flash Media Manifest File) manifest,
an .abst (Adobe Bootstrap File) for each stream, and segment
files in a directory specified as the output.</p>

<p style="margin-left:9%; margin-top: 1em">These needs to
be accessed by an HDS player throuhg HTTPS for it to be able
to perform playback on the generated stream.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
extra_window_size</b> <i>int</i></p>

<p style="margin-left:14%;">number of fragments kept
outside of the manifest before removing from disk</p>

<p style="margin-left:9%;"><b>min_frag_duration</b>
<i>microseconds</i></p>

<p style="margin-left:14%;">minimum fragment duration (in
microseconds), default value is 1 second (10000000)</p>

<p style="margin-left:9%;"><b>remove_at_exit</b>
<i>bool</i></p>

<p style="margin-left:14%;">remove all fragments when
finished when set to &quot;true&quot;</p>

<p style="margin-left:9%;"><b>window_size</b>
<i>int</i></p>

<p style="margin-left:14%;">number of fragments kept in the
manifest, if set to a value different from 0. By default all
segments are kept in the output directory.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Example</i></p>

<p style="margin-left:9%; margin-top: 1em">Use
<b>ffmpeg</b> to generate HDS files to the <i>output.hds</i>
directory in real-time rate:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -re -i
INPUT -f hds -b:v 200k output.hds</p>

<h3>hls
<a name="hls"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Apple HTTP Live
Streaming muxer that segments MPEG-TS according to the HTTP
Live Streaming (HLS) specification.</p>

<p style="margin-left:9%; margin-top: 1em">It creates a
playlist file, and one or more segment files. The output
filename specifies the playlist filename.</p>

<p style="margin-left:9%; margin-top: 1em">By default, the
muxer creates a file for each segment produced. These files
have the same name as the playlist, followed by a sequential
number and a .ts extension.</p>

<p style="margin-left:9%; margin-top: 1em">Make sure to
require a closed GOP when encoding and to set the GOP size
to fit your segment time constraint.</p>

<p style="margin-left:9%; margin-top: 1em">For example, to
convert an input file with <b>ffmpeg</b>:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i in.mkv
-c:v h264 -flags +cgop -g 30 -hls_time 1 out.m3u8</p>

<p style="margin-left:9%; margin-top: 1em">This example
will produce the playlist, <i>out.m3u8</i>, and segment
files: <i>out0.ts</i>, <i>out1.ts</i>, <i>out2.ts</i>,
etc.</p>

<p style="margin-left:9%; margin-top: 1em">See also the
<b>segment</b> muxer, which provides a more generic and
flexible implementation of a segmenter, and can be used to
perform HLS segmentation.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
hls_init_time</b> <i>duration</i></p>

<p style="margin-left:14%;">Set the initial target segment
length. Default value is <i>0</i>.</p>


<p style="margin-left:14%; margin-top: 1em"><i>duration</i>
must be a time duration specification, see <b>the Time
duration section in the ffmpeg-utils(1) manual</b>.</p>

<p style="margin-left:14%; margin-top: 1em">Segment will be
cut on the next key frame after this time has passed on the
first m3u8 list. After the initial playlist is filled,
<b>ffmpeg</b> will cut segments at duration equal to
<b>hls_time</b>.</p>

<p style="margin-left:9%;"><b>hls_time</b>
<i>duration</i></p>

<p style="margin-left:14%;">Set the target segment length.
Default value is 2.</p>


<p style="margin-left:14%; margin-top: 1em"><i>duration</i>
must be a time duration specification, see <b>the Time
duration section in the ffmpeg-utils(1) manual</b>. Segment
will be cut on the next key frame after this time has
passed.</p>

<p style="margin-left:9%;"><b>hls_list_size</b>
<i>size</i></p>

<p style="margin-left:14%;">Set the maximum number of
playlist entries. If set to 0 the list file will contain all
the segments. Default value is 5.</p>

<p style="margin-left:9%;"><b>hls_delete_threshold</b>
<i>size</i></p>

<p style="margin-left:14%;">Set the number of unreferenced
segments to keep on disk before &quot;hls_flags
delete_segments&quot; deletes them. Increase this to allow
continue clients to download segments which were recently
referenced in the playlist. Default value is 1, meaning
segments older than <b>hls_list_size+1</b> will be
deleted.</p>

<p style="margin-left:9%;"><b>hls_start_number_source</b>
<i>source</i></p>

<p style="margin-left:14%;">Start the playlist sequence
number (&quot;#EXT-X-MEDIA-SEQUENCE&quot;) according to the
specified source. Unless <b>hls_flags single_file</b> is
set, it also specifies source of starting sequence numbers
of segment and subtitle filenames. In any case, if
<b>hls_flags append_list</b> is set and read playlist
sequence number is greater than the specified start sequence
number, then that value will be used as start value.</p>

<p style="margin-left:14%; margin-top: 1em">It accepts the
following values: <b><br>
generic (default)</b></p>

<p style="margin-left:19%;">Set the start numbers according
to the <b>start_number</b> option value.</p>

<p style="margin-left:14%;"><b>epoch</b></p>

<p style="margin-left:19%;">Set the start number as the
seconds since epoch (1970-01-01 00:00:00).</p>

<p style="margin-left:14%;"><b>epoch_us</b></p>

<p style="margin-left:19%;">Set the start number as the
microseconds since epoch (1970-01-01 00:00:00).</p>

<p style="margin-left:14%;"><b>datetime</b></p>

<p style="margin-left:19%;">Set the start number based on
the current date/time as YYYYmmddHHMMSS. e.g.
20161231235759.</p>

<p style="margin-left:9%;"><b>start_number</b>
<i>number</i></p>

<p style="margin-left:14%;">Start the playlist sequence
number (&quot;#EXT-X-MEDIA-SEQUENCE&quot;) from the
specified <i>number</i> when <b>hls_start_number_source</b>
value is <i>generic</i>. (This is the default case.) Unless
<b>hls_flags single_file</b> is set, it also specifies
starting sequence numbers of segment and subtitle filenames.
Default value is 0.</p>

<p style="margin-left:9%;"><b>hls_allow_cache</b>
<i>bool</i></p>

<p style="margin-left:14%;">Explicitly set whether the
client MAY (1) or MUST NOT (0) cache media segments.</p>

<p style="margin-left:9%;"><b>hls_base_url</b>
<i>baseurl</i></p>

<p style="margin-left:14%;">Append <i>baseurl</i> to every
entry in the playlist. Useful to generate playlists with
absolute paths.</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
playlist sequence number must be unique for each segment and
it is not to be confused with the segment filename sequence
number which can be cyclic, for example if the <b>wrap</b>
option is specified.</p>

<p style="margin-left:9%;"><b>hls_segment_filename</b>
<i>filename</i></p>

<p style="margin-left:14%;">Set the segment filename.
Unless the <b>hls_flags</b> option is set with
<b>single_file</b>, <i>filename</i> is used as a string
format with the segment number appended.</p>

<p style="margin-left:14%; margin-top: 1em">For
example:</p>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
in.nut -hls_segment_filename 'file%03d.ts' out.m3u8</p>

<p style="margin-left:14%; margin-top: 1em">will produce
the playlist, <i>out.m3u8</i>, and segment files:
<i>file000.ts</i>, <i>file001.ts</i>, <i>file002.ts</i>,
etc.</p>


<p style="margin-left:14%; margin-top: 1em"><i>filename</i>
may contain a full path or relative path specification, but
only the file name part without any path will be contained
in the m3u8 segment list. Should a relative path be
specified, the path of the created segment files will be
relative to the current working directory. When
<b>strftime_mkdir</b> is set, the whole expanded value of
<i>filename</i> will be written into the m3u8 segment
list.</p>

<p style="margin-left:14%; margin-top: 1em">When
<b>var_stream_map</b> is set with two or more variant
streams, the <i>filename</i> pattern must contain the string
&quot;%v&quot;, and this string will be expanded to the
position of variant stream index in the generated segment
file names.</p>

<p style="margin-left:14%; margin-top: 1em">For
example:</p>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i in.ts
-b:v:0 1000k -b:v:1 256k -b:a:0 64k -b:a:1 32k \ <br>
-map 0:v -map 0:a -map 0:v -map 0:a -f hls -var_stream_map
&quot;v:0,a:0 v:1,a:1&quot; \ <br>
-hls_segment_filename 'file_%v_%03d.ts' out_%v.m3u8</p>

<p style="margin-left:14%; margin-top: 1em">will produce
the playlists segment file sets: <i>file_0_000.ts</i>,
<i>file_0_001.ts</i>, <i>file_0_002.ts</i>, etc. and
<i>file_1_000.ts</i>, <i>file_1_001.ts</i>,
<i>file_1_002.ts</i>, etc.</p>

<p style="margin-left:14%; margin-top: 1em">The string
&quot;%v&quot; may be present in the filename or in the last
directory name containing the file, but only in one of them.
(Additionally, %v may appear multiple times in the last
sub-directory or filename.) If the string %v is present in
the directory name, then sub-directories are created after
expanding the directory name pattern. This enables creation
of segments corresponding to different variant streams in
subdirectories.</p>

<p style="margin-left:14%; margin-top: 1em">For
example:</p>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i in.ts
-b:v:0 1000k -b:v:1 256k -b:a:0 64k -b:a:1 32k \ <br>
-map 0:v -map 0:a -map 0:v -map 0:a -f hls -var_stream_map
&quot;v:0,a:0 v:1,a:1&quot; \ <br>
-hls_segment_filename 'vs%v/file_%03d.ts' vs%v/out.m3u8</p>

<p style="margin-left:14%; margin-top: 1em">will produce
the playlists segment file sets: <i>vs0/file_000.ts</i>,
<i>vs0/file_001.ts</i>, <i>vs0/file_002.ts</i>, etc. and
<i>vs1/file_000.ts</i>, <i>vs1/file_001.ts</i>,
<i>vs1/file_002.ts</i>, etc.</p>

<p style="margin-left:9%;"><b>strftime</b> <i>bool</i></p>

<p style="margin-left:14%;">Use strftime() on
<i>filename</i> to expand the segment filename with
localtime. The segment number is also available in this
mode, but to use it, you need to set
<b>second_level_segment_index</b> in the <b>hls_flag</b> and
%%d will be the specifier.</p>

<p style="margin-left:14%; margin-top: 1em">For
example:</p>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
in.nut -strftime 1 -hls_segment_filename 'file-%Y%m%d-%s.ts'
out.m3u8</p>

<p style="margin-left:14%; margin-top: 1em">will produce
the playlist, <i>out.m3u8</i>, and segment files:
<i>file-20160215-1455569023.ts</i>,
<i>file-20160215-1455569024.ts</i>, etc. Note: On some
systems/environments, the %s specifier is not available. See
strftime() documentation.</p>

<p style="margin-left:14%; margin-top: 1em">For
example:</p>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
in.nut -strftime 1 -hls_flags second_level_segment_index
-hls_segment_filename 'file-%Y%m%d-%%04d.ts' out.m3u8</p>

<p style="margin-left:14%; margin-top: 1em">will produce
the playlist, <i>out.m3u8</i>, and segment files:
<i>file-20160215-0001.ts</i>, <i>file-20160215-0002.ts</i>,
etc.</p>

<p style="margin-left:9%;"><b>strftime_mkdir</b>
<i>bool</i></p>

<p style="margin-left:14%;">Used together with
<b>strftime</b>, it will create all subdirectories which are
present in the expanded values of option
<b>hls_segment_filename</b>.</p>

<p style="margin-left:14%; margin-top: 1em">For
example:</p>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
in.nut -strftime 1 -strftime_mkdir 1 -hls_segment_filename
'%Y%m%d/file-%Y%m%d-%s.ts' out.m3u8</p>

<p style="margin-left:14%; margin-top: 1em">will create a
directory <i>201560215</i> (if it does not exist), and then
produce the playlist, <i>out.m3u8</i>, and segment files:
<i>20160215/file-20160215-1455569023.ts</i>,
<i>20160215/file-20160215-1455569024.ts</i>, etc.</p>

<p style="margin-left:14%; margin-top: 1em">For
example:</p>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
in.nut -strftime 1 -strftime_mkdir 1 -hls_segment_filename
'%Y/%m/%d/file-%Y%m%d-%s.ts' out.m3u8</p>

<p style="margin-left:14%; margin-top: 1em">will create a
directory hierarchy <i>2016/02/15</i> (if any of them do not
exist), and then produce the playlist, <i>out.m3u8</i>, and
segment files:
<i>2016/02/15/file-20160215-1455569023.ts</i>,
<i>2016/02/15/file-20160215-1455569024.ts</i>, etc.</p>

<p style="margin-left:9%;"><b>hls_segment_options</b>
<i>options_list</i></p>

<p style="margin-left:14%;">Set output format options using
a :-separated list of key=value parameters. Values
containing &quot;:&quot; special characters must be
escaped.</p>

<p style="margin-left:9%;"><b>hls_key_info_file</b>
<i>key_info_file</i></p>

<p style="margin-left:14%;">Use the information in
<i>key_info_file</i> for segment encryption. The first line
of <i>key_info_file</i> specifies the key URI written to the
playlist. The key URL is used to access the encryption key
during playback. The second line specifies the path to the
key file used to obtain the key during the encryption
process. The key file is read as a single packed array of 16
octets in binary format. The optional third line specifies
the initialization vector (IV) as a hexadecimal string to be
used instead of the segment sequence number (default) for
encryption. Changes to <i>key_info_file</i> will result in
segment encryption with the new key/IV and an entry in the
playlist for the new key URI/IV if <b>hls_flags
periodic_rekey</b> is enabled.</p>

<p style="margin-left:14%; margin-top: 1em">Key info file
format:</p>

<p style="margin-left:14%; margin-top: 1em">&lt;key URI&gt;
<br>
&lt;key file path&gt; <br>
&lt;IV&gt; (optional)</p>

<p style="margin-left:14%; margin-top: 1em">Example key
URIs:</p>


<p style="margin-left:14%; margin-top: 1em">http://server/file.key
<br>
/path/to/file.key <br>
file.key</p>

<p style="margin-left:14%; margin-top: 1em">Example key
file paths:</p>

<p style="margin-left:14%; margin-top: 1em">file.key <br>
/path/to/file.key</p>

<p style="margin-left:14%; margin-top: 1em">Example IV:</p>


<p style="margin-left:14%; margin-top: 1em">0123456789ABCDEF0123456789ABCDEF</p>

<p style="margin-left:14%; margin-top: 1em">Key info file
example:</p>


<p style="margin-left:14%; margin-top: 1em">http://server/file.key
<br>
/path/to/file.key <br>
0123456789ABCDEF0123456789ABCDEF</p>

<p style="margin-left:14%; margin-top: 1em">Example shell
script:</p>

<p style="margin-left:14%; margin-top: 1em">#!/bin/sh <br>
BASE_URL=${1:-'.'} <br>
openssl rand 16 &gt; file.key <br>
echo $BASE_URL/file.key &gt; file.keyinfo <br>
echo file.key &gt;&gt; file.keyinfo <br>
echo $(openssl rand -hex 16) &gt;&gt; file.keyinfo <br>
ffmpeg -f lavfi -re -i testsrc -c:v h264 -hls_flags
delete_segments \ <br>
-hls_key_info_file file.keyinfo out.m3u8</p>

<p style="margin-left:9%;"><b>hls_enc</b> <i>bool</i></p>

<p style="margin-left:14%;">Enable (1) or disable (0) the
AES128 encryption. When enabled every segment generated is
encrypted and the encryption key is saved as <i>playlist
name</i>.key.</p>

<p style="margin-left:9%;"><b>hls_enc_key</b>
<i>key</i></p>

<p style="margin-left:14%;">Specify a 16-octet key to
encrypt the segments, by default it is randomly
generated.</p>

<p style="margin-left:9%;"><b>hls_enc_key_url</b>
<i>keyurl</i></p>

<p style="margin-left:14%;">If set, <i>keyurl</i> is
prepended instead of <i>baseurl</i> to the key filename in
the playlist.</p>

<p style="margin-left:9%;"><b>hls_enc_iv</b> <i>iv</i></p>

<p style="margin-left:14%;">Specify the 16-octet
initialization vector for every segment instead of the
autogenerated ones.</p>

<p style="margin-left:9%;"><b>hls_segment_type</b>
<i>flags</i></p>

<p style="margin-left:14%;">Possible values: <b><br>
mpegts</b></p>

<p style="margin-left:19%;">Output segment files in MPEG-2
Transport Stream format. This is compatible with all HLS
versions.</p>

<p style="margin-left:14%;"><b>fmp4</b></p>

<p style="margin-left:19%;">Output segment files in
fragmented MP4 format, similar to MPEG-DASH. fmp4 files may
be used in HLS version 7 and above.</p>

<p style="margin-left:9%;"><b>hls_fmp4_init_filename</b>
<i>filename</i></p>

<p style="margin-left:14%;">Set filename for the fragment
files header file, default filename is <i>init.mp4</i>.</p>

<p style="margin-left:14%; margin-top: 1em">When
<b>strftime</b> is enabled, <i>filename</i> is expanded to
the segment filename with localtime.</p>

<p style="margin-left:14%; margin-top: 1em">For
example:</p>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
in.nut -hls_segment_type fmp4 -strftime 1
-hls_fmp4_init_filename &quot;%s_init.mp4&quot; out.m3u8</p>

<p style="margin-left:14%; margin-top: 1em">will produce
init like this <i>1602678741_init.mp4</i>.</p>

<p style="margin-left:9%;"><b>hls_fmp4_init_resend</b>
<i>bool</i></p>

<p style="margin-left:14%;">Resend init file after m3u8
file refresh every time, default is <i>0</i>.</p>

<p style="margin-left:14%; margin-top: 1em">When
<b>var_stream_map</b> is set with two or more variant
streams, the <i>filename</i> pattern must contain the string
&quot;%v&quot;, this string specifies the position of
variant stream index in the generated init file names. The
string &quot;%v&quot; may be present in the filename or in
the last directory name containing the file. If the string
is present in the directory name, then sub-directories are
created after expanding the directory name pattern. This
enables creation of init files corresponding to different
variant streams in subdirectories.</p>

<p style="margin-left:9%;"><b>hls_flags</b>
<i>flags</i></p>

<p style="margin-left:14%;">Possible values: <b><br>
single_file</b></p>

<p style="margin-left:19%;">If this flag is set, the muxer
will store all segments in a single MPEG-TS file, and will
use byte ranges in the playlist. HLS playlists generated
with this way will have the version number 4.</p>

<p style="margin-left:19%; margin-top: 1em">For
example:</p>

<p style="margin-left:19%; margin-top: 1em">ffmpeg -i
in.nut -hls_flags single_file out.m3u8</p>

<p style="margin-left:19%; margin-top: 1em">will produce
the playlist, <i>out.m3u8</i>, and a single segment file,
<i>out.ts</i>.</p>

<p style="margin-left:14%;"><b>delete_segments</b></p>

<p style="margin-left:19%;">Segment files removed from the
playlist are deleted after a period of time equal to the
duration of the segment plus the duration of the
playlist.</p>

<p style="margin-left:14%;"><b>append_list</b></p>

<p style="margin-left:19%;">Append new segments into the
end of old segment list, and remove the
&quot;#EXT-X-ENDLIST&quot; from the old segment list.</p>

<p style="margin-left:14%;"><b>round_durations</b></p>

<p style="margin-left:19%;">Round the duration info in the
playlist file segment info to integer values, instead of
using floating point. If there are no other features
requiring higher HLS versions be used, then this will allow
<b>ffmpeg</b> to output a HLS version 2 m3u8.</p>

<p style="margin-left:14%;"><b>discont_start</b></p>

<p style="margin-left:19%;">Add the
&quot;#EXT-X-DISCONTINUITY&quot; tag to the playlist, before
the first segment&rsquo;s information.</p>

<p style="margin-left:14%;"><b>omit_endlist</b></p>

<p style="margin-left:19%;">Do not append the
&quot;EXT-X-ENDLIST&quot; tag at the end of the
playlist.</p>

<p style="margin-left:14%;"><b>periodic_rekey</b></p>

<p style="margin-left:19%;">The file specified by
&quot;hls_key_info_file&quot; will be checked periodically
and detect updates to the encryption info. Be sure to
replace this file atomically, including the file containing
the AES encryption key.</p>


<p style="margin-left:14%;"><b>independent_segments</b></p>

<p style="margin-left:19%;">Add the
&quot;#EXT-X-INDEPENDENT-SEGMENTS&quot; tag to playlists
that has video segments and when all the segments of that
playlist are guaranteed to start with a key frame.</p>

<p style="margin-left:14%;"><b>iframes_only</b></p>

<p style="margin-left:19%;">Add the
&quot;#EXT-X-I-FRAMES-ONLY&quot; tag to playlists that has
video segments and can play only I-frames in the
&quot;#EXT-X-BYTERANGE&quot; mode.</p>

<p style="margin-left:14%;"><b>split_by_time</b></p>

<p style="margin-left:19%;">Allow segments to start on
frames other than key frames. This improves behavior on some
players when the time between key frames is inconsistent,
but may make things worse on others, and can cause some
oddities during seeking. This flag should be used with the
<b>hls_time</b> option.</p>

<p style="margin-left:14%;"><b>program_date_time</b></p>

<p style="margin-left:19%;">Generate
&quot;EXT-X-PROGRAM-DATE-TIME&quot; tags.</p>


<p style="margin-left:14%;"><b>second_level_segment_index</b></p>

<p style="margin-left:19%;">Make it possible to use segment
indexes as %%d in the <b>hls_segment_filename</b> option
expression besides date/time values when <b>strftime</b>
option is on. To get fixed width numbers with trailing
zeroes, %%0xd format is available where x is the required
width.</p>


<p style="margin-left:14%;"><b>second_level_segment_size</b></p>

<p style="margin-left:19%;">Make it possible to use segment
sizes (counted in bytes) as %%s in
<b>hls_segment_filename</b> option expression besides
date/time values when strftime is on. To get fixed width
numbers with trailing zeroes, %%0xs format is available
where x is the required width.</p>


<p style="margin-left:14%;"><b>second_level_segment_duration</b></p>

<p style="margin-left:19%;">Make it possible to use segment
duration (calculated in microseconds) as %%t in
<b>hls_segment_filename</b> option expression besides
date/time values when strftime is on. To get fixed width
numbers with trailing zeroes, %%0xt format is available
where x is the required width.</p>

<p style="margin-left:19%; margin-top: 1em">For
example:</p>

<p style="margin-left:19%; margin-top: 1em">ffmpeg -i
sample.mpeg \ <br>
-f hls -hls_time 3 -hls_list_size 5 \ <br>
-hls_flags
second_level_segment_index+second_level_segment_size+second_level_segment_duration
\ <br>
-strftime 1 -strftime_mkdir 1 -hls_segment_filename
&quot;segment_%Y%m%d%H%M%S_%%04d_%%08s_%%013t.ts&quot;
stream.m3u8</p>

<p style="margin-left:19%; margin-top: 1em">will produce
segments like this:
<i>segment_20170102194334_0003_00122200_0000003000000.ts</i>,
<i>segment_20170102194334_0004_00120072_0000003000000.ts</i>
etc.</p>

<p style="margin-left:14%;"><b>temp_file</b></p>

<p style="margin-left:19%;">Write segment data to
<i>filename.tmp</i> and rename to filename only once the
segment is complete.</p>

<p style="margin-left:19%; margin-top: 1em">A webserver
serving up segments can be configured to reject requests to
*.tmp to prevent access to in-progress segments before they
have been added to the m3u8 playlist.</p>

<p style="margin-left:19%; margin-top: 1em">This flag also
affects how m3u8 playlist files are created. If this flag is
set, all playlist files will be written into a temporary
file and renamed after they are complete, similarly as
segments are handled. But playlists with &quot;file&quot;
protocol and with <b>hls_playlist_type</b> type other than
<b>vod</b> are always written into a temporary file
regardless of this flag.</p>

<p style="margin-left:19%; margin-top: 1em">Master playlist
files specified with <b>master_pl_name</b>, if any, with
&quot;file&quot; protocol, are always written into temporary
file regardless of this flag if
<b>master_pl_publish_rate</b> value is other than zero.</p>

<p style="margin-left:9%;"><b>hls_playlist_type</b>
<i>type</i></p>

<p style="margin-left:14%;">If type is <b>event</b>, emit
&quot;#EXT-X-PLAYLIST-TYPE:EVENT&quot; in the m3u8 header.
This forces <b>hls_list_size</b> to 0; the playlist can only
be appended to.</p>

<p style="margin-left:14%; margin-top: 1em">If type is
<b>vod</b>, emit &quot;#EXT-X-PLAYLIST-TYPE:VOD&quot; in the
m3u8 header. This forces <b>hls_list_size</b> to 0; the
playlist must not change.</p>

<p style="margin-left:9%;"><b>method</b> <i>method</i></p>

<p style="margin-left:14%;">Use the given HTTP method to
create the hls files.</p>

<p style="margin-left:14%; margin-top: 1em">For
example:</p>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -re -i
in.ts -f hls -method PUT
http://example.com/live/out.m3u8</p>

<p style="margin-left:14%; margin-top: 1em">will upload all
the mpegts segment files to the HTTP server using the HTTP
PUT method, and update the m3u8 files every
&quot;refresh&quot; times using the same method. Note that
the HTTP server must support the given method for uploading
files.</p>

<p style="margin-left:9%;"><b>http_user_agent</b>
<i>agent</i></p>

<p style="margin-left:14%;">Override User-Agent field in
HTTP header. Applicable only for HTTP output.</p>

<p style="margin-left:9%;"><b>var_stream_map</b>
<i>stream_map</i></p>

<p style="margin-left:14%;">Specify a map string defining
how to group the audio, video and subtitle streams into
different variant streams. The variant stream groups are
separated by space.</p>

<p style="margin-left:14%; margin-top: 1em">Expected string
format is like this &quot;a:0,v:0 a:1,v:1 ....&quot;. Here
a:, v:, s: are the keys to specify audio, video and subtitle
streams respectively. Allowed values are 0 to 9 (limited
just based on practical usage).</p>

<p style="margin-left:14%; margin-top: 1em">When there are
two or more variant streams, the output filename pattern
must contain the string &quot;%v&quot;: this string
specifies the position of variant stream index in the output
media playlist filenames. The string &quot;%v&quot; may be
present in the filename or in the last directory name
containing the file. If the string is present in the
directory name, then sub-directories are created after
expanding the directory name pattern. This enables creation
of variant streams in subdirectories.</p>

<p style="margin-left:14%; margin-top: 1em">A few examples
follow.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="81%">


<p>Create two hls variant streams. The first variant stream
will contain video stream of bitrate 1000k and audio stream
of bitrate 64k and the second variant stream will contain
video stream of bitrate 256k and audio stream of bitrate
32k. Here, two media playlist with file names
<i>out_0.m3u8</i> and <i>out_1.m3u8</i> will be created.</p></td></tr>
</table>

<p style="margin-left:19%; margin-top: 1em">ffmpeg -re -i
in.ts -b:v:0 1000k -b:v:1 256k -b:a:0 64k -b:a:1 32k \ <br>
-map 0:v -map 0:a -map 0:v -map 0:a -f hls -var_stream_map
&quot;v:0,a:0 v:1,a:1&quot; \ <br>
http://example.com/live/out_%v.m3u8</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="81%">


<p style="margin-top: 1em">If you want something meaningful
text instead of indexes in result names, you may specify
names for each or some of the variants. The following
example will create two hls variant streams as in the
previous one. But here, the two media playlist with file
names <i>out_my_hd.m3u8</i> and <i>out_my_sd.m3u8</i> will
be created.</p></td></tr>
</table>

<p style="margin-left:19%; margin-top: 1em">ffmpeg -re -i
in.ts -b:v:0 1000k -b:v:1 256k -b:a:0 64k -b:a:1 32k \ <br>
-map 0:v -map 0:a -map 0:v -map 0:a -f hls -var_stream_map
&quot;v:0,a:0,name:my_hd v:1,a:1,name:my_sd&quot; \ <br>
http://example.com/live/out_%v.m3u8</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="81%">


<p style="margin-top: 1em">Create three hls variant
streams. The first variant stream will be a video only
stream with video bitrate 1000k, the second variant stream
will be an audio only stream with bitrate 64k and the third
variant stream will be a video only stream with bitrate
256k. Here, three media playlist with file names
<i>out_0.m3u8</i>, <i>out_1.m3u8</i> and <i>out_2.m3u8</i>
will be created.</p></td></tr>
</table>

<p style="margin-left:19%; margin-top: 1em">ffmpeg -re -i
in.ts -b:v:0 1000k -b:v:1 256k -b:a:0 64k \ <br>
-map 0:v -map 0:a -map 0:v -f hls -var_stream_map &quot;v:0
a:0 v:1&quot; \ <br>
http://example.com/live/out_%v.m3u8</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="81%">


<p style="margin-top: 1em">Create the variant streams in
subdirectories. Here, the first media playlist is created at
<i>http://example.com/live/vs_0/out.m3u8</i> and the second
one at <i>http://example.com/live/vs_1/out.m3u8</i>.</p></td></tr>
</table>

<p style="margin-left:19%; margin-top: 1em">ffmpeg -re -i
in.ts -b:v:0 1000k -b:v:1 256k -b:a:0 64k -b:a:1 32k \ <br>
-map 0:v -map 0:a -map 0:v -map 0:a -f hls -var_stream_map
&quot;v:0,a:0 v:1,a:1&quot; \ <br>
http://example.com/live/vs_%v/out.m3u8</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="81%">


<p style="margin-top: 1em">Create two audio only and two
video only variant streams. In addition to the
&quot;#EXT-X-STREAM-INF&quot; tag for each variant stream in
the master playlist, the &quot;#EXT-X-MEDIA&quot; tag is
also added for the two audio only variant streams and they
are mapped to the two video only variant streams with audio
group names &rsquo;aud_low&rsquo; and
&rsquo;aud_high&rsquo;. By default, a single hls variant
containing all the encoded streams is created.</p></td></tr>
</table>

<p style="margin-left:19%; margin-top: 1em">ffmpeg -re -i
in.ts -b:a:0 32k -b:a:1 64k -b:v:0 1000k -b:v:1 3000k \ <br>
-map 0:a -map 0:a -map 0:v -map 0:v -f hls \ <br>
-var_stream_map &quot;a:0,agroup:aud_low a:1,agroup:aud_high
v:0,agroup:aud_low v:1,agroup:aud_high&quot; \ <br>
-master_pl_name master.m3u8 \ <br>
http://example.com/live/out_%v.m3u8</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="81%">


<p style="margin-top: 1em">Create two audio only and one
video only variant streams. In addition to the
&quot;#EXT-X-STREAM-INF&quot; tag for each variant stream in
the master playlist, the &quot;#EXT-X-MEDIA&quot; tag is
also added for the two audio only variant streams and they
are mapped to the one video only variant streams with audio
group name &rsquo;aud_low&rsquo;, and the audio group have
default stat is NO or YES. By default, a single hls variant
containing all the encoded streams is created.</p></td></tr>
</table>

<p style="margin-left:19%; margin-top: 1em">ffmpeg -re -i
in.ts -b:a:0 32k -b:a:1 64k -b:v:0 1000k \ <br>
-map 0:a -map 0:a -map 0:v -f hls \ <br>
-var_stream_map &quot;a:0,agroup:aud_low,default:yes
a:1,agroup:aud_low v:0,agroup:aud_low&quot; \ <br>
-master_pl_name master.m3u8 \ <br>
http://example.com/live/out_%v.m3u8</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="81%">


<p style="margin-top: 1em">Create two audio only and one
video only variant streams. In addition to the
&quot;#EXT-X-STREAM-INF&quot; tag for each variant stream in
the master playlist, the &quot;#EXT-X-MEDIA&quot; tag is
also added for the two audio only variant streams and they
are mapped to the one video only variant streams with audio
group name &rsquo;aud_low&rsquo;, and the audio group have
default stat is NO or YES, and one audio have and language
is named ENG, the other audio language is named CHN. By
default, a single hls variant containing all the encoded
streams is created.</p></td></tr>
</table>

<p style="margin-left:19%; margin-top: 1em">ffmpeg -re -i
in.ts -b:a:0 32k -b:a:1 64k -b:v:0 1000k \ <br>
-map 0:a -map 0:a -map 0:v -f hls \ <br>
-var_stream_map
&quot;a:0,agroup:aud_low,default:yes,language:ENG
a:1,agroup:aud_low,language:CHN v:0,agroup:aud_low&quot; \
<br>
-master_pl_name master.m3u8 \ <br>
http://example.com/live/out_%v.m3u8</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="81%">


<p style="margin-top: 1em">Create a single variant stream.
Add the &quot;#EXT-X-MEDIA&quot; tag with
&quot;TYPE=SUBTITLES&quot; in the master playlist with
webvtt subtitle group name &rsquo;subtitle&rsquo;. Make sure
the input file has one text subtitle stream at least.</p></td></tr>
</table>

<p style="margin-left:19%; margin-top: 1em">ffmpeg -y -i
input_with_subtitle.mkv \ <br>
-b:v:0 5250k -c:v h264 -pix_fmt yuv420p -profile:v main
-level 4.1 \ <br>
-b:a:0 256k \ <br>
-c:s webvtt -c:a mp2 -ar 48000 -ac 2 -map 0:v -map 0:a:0
-map 0:s:0 \ <br>
-f hls -var_stream_map
&quot;v:0,a:0,s:0,sgroup:subtitle&quot; \ <br>
-master_pl_name master.m3u8 -t 300 -hls_time 10
-hls_init_time 4 -hls_list_size \ <br>
10 -master_pl_publish_rate 10 -hls_flags \ <br>
delete_segments+discont_start+split_by_time
./tmp/video.m3u8</p>

<p style="margin-left:9%;"><b>cc_stream_map</b>
<i>cc_stream_map</i></p>

<p style="margin-left:14%;">Map string which specifies
different closed captions groups and their attributes. The
closed captions stream groups are separated by space.</p>

<p style="margin-left:14%; margin-top: 1em">Expected string
format is like this &quot;ccgroup:&lt;group
name&gt;,instreamid:&lt;INSTREAM-ID&gt;,language:&lt;language
code&gt; ....&quot;. &rsquo;ccgroup&rsquo; and
&rsquo;instreamid&rsquo; are mandatory attributes.
&rsquo;language&rsquo; is an optional attribute.</p>

<p style="margin-left:14%; margin-top: 1em">The closed
captions groups configured using this option are mapped to
different variant streams by providing the same
&rsquo;ccgroup&rsquo; name in the <b>var_stream_map</b>
string.</p>

<p style="margin-left:14%; margin-top: 1em">For
example:</p>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -re -i
in.ts -b:v:0 1000k -b:v:1 256k -b:a:0 64k -b:a:1 32k \ <br>
-a53cc:0 1 -a53cc:1 1 \ <br>
-map 0:v -map 0:a -map 0:v -map 0:a -f hls \ <br>
-cc_stream_map &quot;ccgroup:cc,instreamid:CC1,language:en
ccgroup:cc,instreamid:CC2,language:sp&quot; \ <br>
-var_stream_map &quot;v:0,a:0,ccgroup:cc
v:1,a:1,ccgroup:cc&quot; \ <br>
-master_pl_name master.m3u8 \ <br>
http://example.com/live/out_%v.m3u8</p>

<p style="margin-left:14%; margin-top: 1em">will add two
&quot;#EXT-X-MEDIA&quot; tags with
&quot;TYPE=CLOSED-CAPTIONS&quot; in the master playlist for
the INSTREAM-IDs &rsquo;CC1&rsquo; and &rsquo;CC2&rsquo;.
Also, it will add &quot;CLOSED-CAPTIONS&quot; attribute with
group name &rsquo;cc&rsquo; for the two output variant
streams.</p>

<p style="margin-left:14%; margin-top: 1em">If
<b>var_stream_map</b> is not set, then the first available
ccgroup in <b>cc_stream_map</b> is mapped to the output
variant stream.</p>

<p style="margin-left:14%; margin-top: 1em">For
example:</p>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -re -i
in.ts -b:v 1000k -b:a 64k -a53cc 1 -f hls \ <br>
-cc_stream_map
&quot;ccgroup:cc,instreamid:CC1,language:en&quot; \ <br>
-master_pl_name master.m3u8 \ <br>
http://example.com/live/out.m3u8</p>

<p style="margin-left:14%; margin-top: 1em">this will add
&quot;#EXT-X-MEDIA&quot; tag with
&quot;TYPE=CLOSED-CAPTIONS&quot; in the master playlist with
group name &rsquo;cc&rsquo;, language &rsquo;en&rsquo;
(english) and INSTREAM-ID &rsquo;CC1&rsquo;. Also, it will
add &quot;CLOSED-CAPTIONS&quot; attribute with group name
&rsquo;cc&rsquo; for the output variant stream.</p>

<p style="margin-left:9%;"><b>master_pl_name</b>
<i>name</i></p>

<p style="margin-left:14%;">Create HLS master playlist with
the given name.</p>

<p style="margin-left:14%; margin-top: 1em">For
example:</p>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -re -i
in.ts -f hls -master_pl_name master.m3u8
http://example.com/live/out.m3u8</p>

<p style="margin-left:14%; margin-top: 1em">creates an HLS
master playlist with name <i>master.m3u8</i> which is
published at &lt;<b>http://example.com/live/</b>&gt;.</p>

<p style="margin-left:9%;"><b>master_pl_publish_rate</b>
<i>count</i></p>

<p style="margin-left:14%;">Publish master play list
repeatedly every after specified number of segment
intervals.</p>

<p style="margin-left:14%; margin-top: 1em">For
example:</p>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -re -i
in.ts -f hls -master_pl_name master.m3u8 \ <br>
-hls_time 2 -master_pl_publish_rate 30
http://example.com/live/out.m3u8</p>

<p style="margin-left:14%; margin-top: 1em">creates an HLS
master playlist with name <i>master.m3u8</i> and keeps
publishing it repeatedly every after 30 segments i.e. every
after 60s.</p>

<p style="margin-left:9%;"><b>http_persistent</b>
<i>bool</i></p>

<p style="margin-left:14%;">Use persistent HTTP
connections. Applicable only for HTTP output.</p>

<p style="margin-left:9%;"><b>timeout</b>
<i>timeout</i></p>

<p style="margin-left:14%;">Set timeout for socket I/O
operations. Applicable only for HTTP output.</p>

<p style="margin-left:9%;"><b>ignore_io_errors</b>
<i>bool</i></p>

<p style="margin-left:14%;">Ignore IO errors during open,
write and delete. Useful for long-duration runs with network
output.</p>

<p style="margin-left:9%;"><b>headers</b>
<i>headers</i></p>

<p style="margin-left:14%;">Set custom HTTP headers, can
override built in default headers. Applicable only for HTTP
output.</p>

<h3>iamf
<a name="iamf"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Immersive Audio
Model and Formats (IAMF) muxer.</p>

<p style="margin-left:9%; margin-top: 1em">IAMF is used to
provide immersive audio content for presentation on a wide
range of devices in both streaming and offline applications.
These applications include internet audio streaming,
multicasting/broadcasting services, file download, gaming,
communication, virtual and augmented reality, and others. In
these applications, audio may be played back on a wide range
of devices, e.g., headphones, mobile phones, tablets, TVs,
sound bars, home theater systems, and big screens.</p>

<p style="margin-left:9%; margin-top: 1em">This format was
promoted and desgined by Alliance for Open Media.</p>

<p style="margin-left:9%; margin-top: 1em">For more
information about this format, see
&lt;<b>https://aomedia.org/iamf/</b>&gt;.</p>

<h3>ico
<a name="ico"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">ICO file
muxer.</p>


<p style="margin-left:9%; margin-top: 1em">Microsoft&rsquo;s
icon file format (ICO) has some strict limitations that
should be noted:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>Size cannot exceed 256 pixels in any dimension</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>Only BMP and PNG images can be stored</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>If a BMP image is used, it must be one of the following
pixel formats:</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">BMP Bit Depth
FFmpeg Pixel Format <br>
1bit pal8 <br>
4bit pal8 <br>
8bit pal8 <br>
16bit rgb555le <br>
24bit bgr24 <br>
32bit bgra</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">If a BMP image is used, it must
use the BITMAPINFOHEADER DIB header</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>If a PNG image is used, it must use the rgba pixel
format</p> </td></tr>
</table>

<h3>ilbc
<a name="ilbc"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Internet Low
Bitrate Codec (iLBC) raw muxer.</p>

<p style="margin-left:9%; margin-top: 1em">It accepts a
single <b>ilbc</b> audio stream.</p>

<h3>image2, image2pipe
<a name="image2, image2pipe"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Image file
muxer.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>image2</b> muxer writes video frames to image files.</p>

<p style="margin-left:9%; margin-top: 1em">The output
filenames are specified by a pattern, which can be used to
produce sequentially numbered series of files. The pattern
may contain the string &quot;%d&quot; or
&quot;%0<i>N</i>d&quot;, this string specifies the position
of the characters representing a numbering in the filenames.
If the form &quot;%0<i>N</i>d&quot; is used, the string
representing the number in each filename is 0-padded to
<i>N</i> digits. The literal character &rsquo;%&rsquo; can
be specified in the pattern with the string
&quot;%%&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">If the pattern
contains &quot;%d&quot; or &quot;%0<i>N</i>d&quot;, the
first filename of the file list specified will contain the
number 1, all the following numbers will be sequential.</p>

<p style="margin-left:9%; margin-top: 1em">The pattern may
contain a suffix which is used to automatically determine
the format of the image files to write.</p>

<p style="margin-left:9%; margin-top: 1em">For example the
pattern &quot;img-%03d.bmp&quot; will specify a sequence of
filenames of the form <i>img-001.bmp</i>,
<i>img-002.bmp</i>, ..., <i>img-010.bmp</i>, etc. The
pattern &quot;img%%-%d.jpg&quot; will specify a sequence of
filenames of the form <i>img%-1.jpg</i>, <i>img%-2.jpg</i>,
..., <i>img%-10.jpg</i>, etc.</p>

<p style="margin-left:9%; margin-top: 1em">The image muxer
supports the .Y.U.V image file format. This format is
special in that each image frame consists of three files,
for each of the YUV420P components. To read or write this
image file format, specify the name of the &rsquo;.Y&rsquo;
file. The muxer will automatically open the &rsquo;.U&rsquo;
and &rsquo;.V&rsquo; files as required.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>image2pipe</b> muxer accepts the same options as the
<b>image2</b> muxer, but ignores the pattern verification
and expansion, as it is supposed to write to the command
output rather than to an actual stored file.</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
frame_pts</b> <i>bool</i></p>

<p style="margin-left:14%;">If set to 1, expand the
filename with the packet PTS (presentation time stamp).
Default value is 0.</p>

<p style="margin-left:9%;"><b>start_number</b>
<i>count</i></p>

<p style="margin-left:14%;">Start the sequence from the
specified number. Default value is 1.</p>

<p style="margin-left:9%;"><b>update</b> <i>bool</i></p>

<p style="margin-left:14%;">If set to 1, the filename will
always be interpreted as just a filename, not a pattern, and
the corresponding file will be continuously overwritten with
new images. Default value is 0.</p>

<p style="margin-left:9%;"><b>strftime</b> <i>bool</i></p>

<p style="margin-left:14%;">If set to 1, expand the
filename with date and time information from strftime().
Default value is 0.</p>

<p style="margin-left:9%;"><b>atomic_writing</b>
<i>bool</i></p>

<p style="margin-left:14%;">Write output to a temporary
file, which is renamed to target filename once writing is
completed. Default is disabled.</p>

<p style="margin-left:9%;"><b>protocol_opts</b>
<i>options_list</i></p>

<p style="margin-left:14%;">Set protocol options as a
:-separated list of key=value parameters. Values containing
the &quot;:&quot; special character must be escaped.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>Use <b>ffmpeg</b> for creating a sequence of files
<i>img-001.jpeg</i>, <i>img-002.jpeg</i>, ..., taking one
image every second from the input video:</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
in.avi -vsync cfr -r 1 -f image2 'img-%03d.jpeg'</p>

<p style="margin-left:14%; margin-top: 1em">Note that with
<b>ffmpeg</b>, if the format is not specified with the
&quot;-f&quot; option and the output filename specifies an
image file format, the image2 muxer is automatically
selected, so the previous command can be written as:</p>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
in.avi -vsync cfr -r 1 'img-%03d.jpeg'</p>

<p style="margin-left:14%; margin-top: 1em">Note also that
the pattern must not necessarily contain &quot;%d&quot; or
&quot;%0<i>N</i>d&quot;, for example to create a single
image file <i>img.jpeg</i> from the start of the input video
you can employ the command:</p>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
in.avi -f image2 -frames:v 1 img.jpeg</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">The <b>strftime</b> option
allows you to expand the filename with date and time
information. Check the documentation of the strftime()
function for the syntax.</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">To generate
image files from the strftime()
&quot;%Y-%m-%d_%H-%M-%S&quot; pattern, the following
<b>ffmpeg</b> command can be used:</p>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -f v4l2
-r 1 -i /dev/video0 -f image2 -strftime 1
&quot;%Y-%m-%d_%H-%M-%S.jpg&quot;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="55%">


<p style="margin-top: 1em">Set the file name with current
frame&rsquo;s PTS:</p></td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -f v4l2
-r 1 -i /dev/video0 -copyts -f image2 -frame_pts true
%d.jpg</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">Publish contents of your desktop
directly to a WebDAV server every second:</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -f
x11grab -framerate 1 -i :0.0 -q:v 6 -update 1 -protocol_opts
method=PUT http://example.com/desktop.jpg</p>

<h3>ircam
<a name="ircam"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Berkeley / IRCAM
/ CARL Sound Filesystem (BICSF) format muxer.</p>

<p style="margin-left:9%; margin-top: 1em">The
Berkeley/IRCAM/CARL Sound Format, developed in the 1980s, is
a result of the merging of several different earlier sound
file formats and systems including the csound system
developed by Dr Gareth Loy at the Computer Audio Research
Lab (CARL) at UC San Diego, the IRCAM sound file system
developed by Rob Gross and Dan Timis at the Institut de
Recherche et Coordination Acoustique / Musique in Paris and
the Berkeley Fast Filesystem.</p>

<p style="margin-left:9%; margin-top: 1em">It was developed
initially as part of the Berkeley/IRCAM/CARL Sound
Filesystem, a suite of programs designed to implement a
filesystem for audio applications running under Berkeley
UNIX. It was particularly popular in academic music research
centres, and was used a number of times in the creation of
early computer-generated compositions.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
accepts a single audio stream containing PCM data.</p>

<h3>ivf
<a name="ivf"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">On2 IVF
muxer.</p>

<p style="margin-left:9%; margin-top: 1em">IVF was
developed by On2 Technologies (formerly known as Duck
Corporation), to store internally developed codecs.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
accepts a single <b>vp8</b>, <b>vp9</b>, or <b>av1</b> video
stream.</p>

<h3>jacosub
<a name="jacosub"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">JACOsub subtitle
format muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
accepts a single <b>jacosub</b> subtitles stream.</p>

<p style="margin-left:9%; margin-top: 1em">For more
information about the format, see
&lt;<b>http://unicorn.us.com/jacosub/jscripts.html</b>&gt;.</p>

<h3>kvag
<a name="kvag"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Simon &amp;
Schuster Interactive VAG muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This custom VAG
container is used by some Simon &amp; Schuster Interactive
games such as &quot;Real War&quot;, and &quot;Real War:
Rogue States&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
accepts a single <b>adpcm_ima_ssi</b> audio stream.</p>

<h3>lc3
<a name="lc3"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Bluetooth SIG
Low Complexity Communication Codec audio (LC3), or ETSI TS
103 634 Low Complexity Communication Codec plus
(LC3plus).</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
accepts a single <b>lc3</b> audio stream.</p>

<h3>lrc
<a name="lrc"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">LRC lyrics file
format muxer.</p>

<p style="margin-left:9%; margin-top: 1em">LRC (short for
LyRiCs) is a computer file format that synchronizes song
lyrics with an audio file, such as MP3, Vorbis, or MIDI.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
accepts a single <b>subrip</b> or <b>text</b> subtitles
stream.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Metadata</i></p>

<p style="margin-left:9%; margin-top: 1em">The following
metadata tags are converted to the format corresponding
metadata: <b><br>
title <br>
album <br>
artist <br>
author <br>
creator <br>
encoder <br>
encoder_version</b></p>

<p style="margin-left:9%; margin-top: 1em">If
<b>encoder_version</b> is not explicitly set, it is
automatically set to the libavformat version.</p>

<h3>matroska
<a name="matroska"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Matroska
container muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
implements the matroska and webm container specs.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Metadata</i></p>

<p style="margin-left:9%; margin-top: 1em">The recognized
metadata settings in this muxer are: <b><br>
title</b></p>

<p style="margin-left:14%;">Set title name provided to a
single track. This gets mapped to the FileDescription
element for a stream written as attachment.</p>

<p style="margin-left:9%;"><b>language</b></p>

<p style="margin-left:14%;">Specify the language of the
track in the Matroska languages form.</p>

<p style="margin-left:14%; margin-top: 1em">The language
can be either the 3 letters bibliographic ISO-639-2 (ISO
639-2/B) form (like &quot;fre&quot; for French), or a
language code mixed with a country code for specialities in
languages (like &quot;fre-ca&quot; for Canadian French).</p>

<p style="margin-left:9%;"><b>stereo_mode</b></p>

<p style="margin-left:14%;">Set stereo 3D video layout of
two views in a single video track.</p>

<p style="margin-left:14%; margin-top: 1em">The following
values are recognized: <b><br>
mono</b></p>

<p style="margin-left:19%;">video is not stereo</p>

<p style="margin-left:14%;"><b>left_right</b></p>

<p style="margin-left:19%;">Both views are arranged side by
side, Left-eye view is on the left</p>

<p style="margin-left:14%;"><b>bottom_top</b></p>

<p style="margin-left:19%;">Both views are arranged in
top-bottom orientation, Left-eye view is at bottom</p>

<p style="margin-left:14%;"><b>top_bottom</b></p>

<p style="margin-left:19%;">Both views are arranged in
top-bottom orientation, Left-eye view is on top</p>

<p style="margin-left:14%;"><b>checkerboard_rl</b></p>

<p style="margin-left:19%;">Each view is arranged in a
checkerboard interleaved pattern, Left-eye view being
first</p>

<p style="margin-left:14%;"><b>checkerboard_lr</b></p>

<p style="margin-left:19%;">Each view is arranged in a
checkerboard interleaved pattern, Right-eye view being
first</p>

<p style="margin-left:14%;"><b>row_interleaved_rl</b></p>

<p style="margin-left:19%;">Each view is constituted by a
row based interleaving, Right-eye view is first row</p>

<p style="margin-left:14%;"><b>row_interleaved_lr</b></p>

<p style="margin-left:19%;">Each view is constituted by a
row based interleaving, Left-eye view is first row</p>

<p style="margin-left:14%;"><b>col_interleaved_rl</b></p>

<p style="margin-left:19%;">Both views are arranged in a
column based interleaving manner, Right-eye view is first
column</p>

<p style="margin-left:14%;"><b>col_interleaved_lr</b></p>

<p style="margin-left:19%;">Both views are arranged in a
column based interleaving manner, Left-eye view is first
column</p>

<p style="margin-left:14%;"><b>anaglyph_cyan_red</b></p>

<p style="margin-left:19%;">All frames are in anaglyph
format viewable through red-cyan filters</p>

<p style="margin-left:14%;"><b>right_left</b></p>

<p style="margin-left:19%;">Both views are arranged side by
side, Right-eye view is on the left</p>


<p style="margin-left:14%;"><b>anaglyph_green_magenta</b></p>

<p style="margin-left:19%;">All frames are in anaglyph
format viewable through green-magenta filters</p>

<p style="margin-left:14%;"><b>block_lr</b></p>

<p style="margin-left:19%;">Both eyes laced in one Block,
Left-eye view is first</p>

<p style="margin-left:14%;"><b>block_rl</b></p>

<p style="margin-left:19%;">Both eyes laced in one Block,
Right-eye view is first</p>

<p style="margin-left:9%; margin-top: 1em">For example a 3D
WebM clip can be created using the following command
line:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i
sample_left_right_clip.mpg -an -c:v libvpx -metadata
stereo_mode=left_right -y stereo_clip.webm</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
reserve_index_space</b> <i>size</i></p>

<p style="margin-left:14%;">By default, this muxer writes
the index for seeking (called cues in Matroska terms) at the
end of the file, because it cannot know in advance how much
space to leave for the index at the beginning of the file.
However for some use cases -- e.g. streaming where seeking
is possible but slow -- it is useful to put the index at the
beginning of the file.</p>

<p style="margin-left:14%; margin-top: 1em">If this option
is set to a non-zero value, the muxer will reserve
<i>size</i> bytes of space in the file header and then try
to write the cues there when the muxing finishes. If the
reserved space does not suffice, no Cues will be written,
the file will be finalized and writing the trailer will
return an error. A safe size for most use cases should be
about 50kB per hour of video.</p>

<p style="margin-left:14%; margin-top: 1em">Note that cues
are only written if the output is seekable and this option
will have no effect if it is not.</p>

<p style="margin-left:9%;"><b>cues_to_front</b>
<i>bool</i></p>

<p style="margin-left:14%;">If set, the muxer will write
the index at the beginning of the file by shifting the main
data if necessary. This can be combined with
reserve_index_space in which case the data is only shifted
if the initially reserved space turns out to be
insufficient.</p>

<p style="margin-left:14%; margin-top: 1em">This option is
ignored if the output is unseekable.</p>

<p style="margin-left:9%;"><b>cluster_size_limit</b>
<i>size</i></p>

<p style="margin-left:14%;">Store at most the provided
amount of bytes in a cluster.</p>

<p style="margin-left:14%; margin-top: 1em">If not
specified, the limit is set automatically to a sensible
hardcoded fixed value.</p>

<p style="margin-left:9%;"><b>cluster_time_limit</b>
<i>duration</i></p>

<p style="margin-left:14%;">Store at most the provided
number of milliseconds in a cluster.</p>

<p style="margin-left:14%; margin-top: 1em">If not
specified, the limit is set automatically to a sensible
hardcoded fixed value.</p>

<p style="margin-left:9%;"><b>dash</b> <i>bool</i></p>

<p style="margin-left:14%;">Create a WebM file conforming
to WebM DASH specification. By default it is set to
&quot;false&quot;.</p>

<p style="margin-left:9%;"><b>dash_track_number</b>
<i>index</i></p>

<p style="margin-left:14%;">Track number for the DASH
stream. By default it is set to 1.</p>

<p style="margin-left:9%;"><b>live</b> <i>bool</i></p>

<p style="margin-left:14%;">Write files assuming it is a
live stream. By default it is set to &quot;false&quot;.</p>

<p style="margin-left:9%;"><b>allow_raw_vfw</b>
<i>bool</i></p>

<p style="margin-left:14%;">Allow raw VFW mode. By default
it is set to &quot;false&quot;.</p>

<p style="margin-left:9%;"><b>flipped_raw_rgb</b>
<i>bool</i></p>

<p style="margin-left:14%;">If set to &quot;true&quot;,
store positive height for raw RGB bitmaps, which indicates
bitmap is stored bottom-up. Note that this option does not
flip the bitmap which has to be done manually beforehand,
e.g. by using the <b>vflip</b> filter. Default is
&quot;false&quot; and indicates bitmap is stored top
down.</p>

<p style="margin-left:9%;"><b>write_crc32</b>
<i>bool</i></p>

<p style="margin-left:14%;">Write a CRC32 element inside
every Level 1 element. By default it is set to
&quot;true&quot;. This option is ignored for WebM.</p>

<p style="margin-left:9%;"><b>default_mode</b>
<i>mode</i></p>

<p style="margin-left:14%;">Control how the FlagDefault of
the output tracks will be set. It influences which tracks
players should play by default. The default mode is
<b>passthrough</b>. <b><br>
infer</b></p>

<p style="margin-left:19%;">Every track with disposition
default will have the FlagDefault set. Additionally, for
each type of track (audio, video or subtitle), if no track
with disposition default of this type exists, then the first
track of this type will be marked as default (if existing).
This ensures that the default flag is set in a sensible way
even if the input originated from containers that lack the
concept of default tracks.</p>

<p style="margin-left:14%;"><b>infer_no_subs</b></p>

<p style="margin-left:19%;">This mode is the same as infer
except that if no subtitle track with disposition default
exists, no subtitle track will be marked as default.</p>

<p style="margin-left:14%;"><b>passthrough</b></p>

<p style="margin-left:19%;">In this mode the FlagDefault is
set if and only if the AV_DISPOSITION_DEFAULT flag is set in
the disposition of the corresponding stream.</p>

<h3>md5
<a name="md5"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">MD5 testing
format.</p>

<p style="margin-left:9%; margin-top: 1em">This is a
variant of the <b>hash</b> muxer. Unlike that muxer, it
defaults to using the MD5 hash function.</p>

<p style="margin-left:9%; margin-top: 1em">See also the
<b>hash</b> and <b>framemd5</b> muxers.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>To compute the MD5 hash of the input converted to raw
audio and video, and store it in the file
<i>out.md5</i>:</p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i INPUT
-f md5 out.md5</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="41%">


<p style="margin-top: 1em">To print the MD5 hash to
stdout:</p> </td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i INPUT
-f md5 -</p>

<h3>microdvd
<a name="microdvd"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">MicroDVD
subtitle format muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
accepts a single <b>microdvd</b> subtitles stream.</p>

<h3>mmf
<a name="mmf"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Synthetic music
Mobile Application Format (SMAF) format muxer.</p>

<p style="margin-left:9%; margin-top: 1em">SMAF is a music
data format specified by Yamaha for portable electronic
devices, such as mobile phones and personal digital
assistants.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
accepts a single <b>adpcm_yamaha</b> audio stream.</p>

<h3>mp3
<a name="mp3"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The MP3 muxer
writes a raw MP3 stream with the following optional
features:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">An ID3v2 metadata header at the
beginning (enabled by default). Versions 2.3 and 2.4 are
supported, the &quot;id3v2_version&quot; private option
controls which one is used (3 or 4). Setting
&quot;id3v2_version&quot; to 0 disables the ID3v2 header
completely.</p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">The muxer
supports writing attached pictures (APIC frames) to the
ID3v2 header. The pictures are supplied to the muxer in form
of a video stream with a single packet. There can be any
number of those streams, each will correspond to a single
APIC frame. The stream metadata tags <i>title</i> and
<i>comment</i> map to APIC <i>description</i> and <i>picture
type</i> respectively. See
&lt;<b>http://id3.org/id3v2.4.0-frames</b>&gt; for allowed
picture types.</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
APIC frames must be written at the beginning, so the muxer
will buffer the audio frames until it gets all the pictures.
It is therefore advised to provide the pictures as soon as
possible to avoid excessive buffering.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">A Xing/LAME frame right after
the ID3v2 header (if present). It is enabled by default, but
will be written only if the output is seekable. The
&quot;write_xing&quot; private option can be used to disable
it. The frame contains various information that may be
useful to the decoder, like the audio duration or encoder
delay.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>A legacy ID3v1 tag at the end of the file (disabled by
default). It may be enabled with the &quot;write_id3v1&quot;
private option, but as its capabilities are very limited,
its usage is not recommended.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Examples:</p>

<p style="margin-left:9%; margin-top: 1em">Write an mp3
with an ID3v2.3 header and an ID3v1 footer:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-id3v2_version 3 -write_id3v1 1 out.mp3</p>

<p style="margin-left:9%; margin-top: 1em">To attach a
picture to an mp3 file select both the audio and the picture
stream with &quot;map&quot;:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i
input.mp3 -i cover.png -c copy -map 0 -map 1 <br>
-metadata:s:v title=&quot;Album cover&quot; -metadata:s:v
comment=&quot;Cover (Front)&quot; out.mp3</p>

<p style="margin-left:9%; margin-top: 1em">Write a
&quot;clean&quot; MP3 without any extra features:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i
input.wav -write_xing 0 -id3v2_version 0 out.mp3</p>

<h3>mpegts
<a name="mpegts"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">MPEG transport
stream muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
implements ISO 13818-1 and part of ETSI EN 300 468.</p>

<p style="margin-left:9%; margin-top: 1em">The recognized
metadata settings in mpegts muxer are
&quot;service_provider&quot; and &quot;service_name&quot;.
If they are not set the default for
&quot;service_provider&quot; is <b>FFmpeg</b> and the
default for &quot;service_name&quot; is
<b>Service01</b>.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Options</i></p>

<p style="margin-left:9%; margin-top: 1em">The muxer
options are: <b><br>
mpegts_transport_stream_id</b> <i>integer</i></p>

<p style="margin-left:14%;">Set the
<b>transport_stream_id</b>. This identifies a transponder in
DVB. Default is 0x0001.</p>


<p style="margin-left:9%;"><b>mpegts_original_network_id</b>
<i>integer</i></p>

<p style="margin-left:14%;">Set the
<b>original_network_id</b>. This is unique identifier of a
network in DVB. Its main use is in the unique identification
of a service through the path <b>Original_Network_ID,
Transport_Stream_ID</b>. Default is 0x0001.</p>

<p style="margin-left:9%;"><b>mpegts_service_id</b>
<i>integer</i></p>

<p style="margin-left:14%;">Set the <b>service_id</b>, also
known as program in DVB. Default is 0x0001.</p>

<p style="margin-left:9%;"><b>mpegts_service_type</b>
<i>integer</i></p>

<p style="margin-left:14%;">Set the program
<b>service_type</b>. Default is &quot;digital_tv&quot;.
Accepts the following options: <b><br>
hex_value</b></p>

<p style="margin-left:19%;">Any hexadecimal value between
0x01 and 0xff as defined in ETSI 300 468.</p>

<p style="margin-left:14%;"><b>digital_tv</b></p>

<p style="margin-left:19%;">Digital TV service.</p>

<p style="margin-left:14%;"><b>digital_radio</b></p>

<p style="margin-left:19%;">Digital Radio service.</p>

<p style="margin-left:14%;"><b>teletext</b></p>

<p style="margin-left:19%;">Teletext service.</p>


<p style="margin-left:14%;"><b>advanced_codec_digital_radio</b></p>

<p style="margin-left:19%;">Advanced Codec Digital Radio
service.</p>

<p style="margin-left:14%;"><b>mpeg2_digital_hdtv</b></p>

<p style="margin-left:19%;">MPEG2 Digital HDTV service.</p>


<p style="margin-left:14%;"><b>advanced_codec_digital_sdtv</b></p>

<p style="margin-left:19%;">Advanced Codec Digital SDTV
service.</p>


<p style="margin-left:14%;"><b>advanced_codec_digital_hdtv</b></p>

<p style="margin-left:19%;">Advanced Codec Digital HDTV
service.</p>

<p style="margin-left:9%;"><b>mpegts_pmt_start_pid</b>
<i>integer</i></p>

<p style="margin-left:14%;">Set the first PID for PMTs.
Default is 0x1000, minimum is 0x0020, maximum is 0x1ffa.
This option has no effect in m2ts mode where the PMT PID is
fixed 0x0100.</p>

<p style="margin-left:9%;"><b>mpegts_start_pid</b>
<i>integer</i></p>

<p style="margin-left:14%;">Set the first PID for
elementary streams. Default is 0x0100, minimum is 0x0020,
maximum is 0x1ffa. This option has no effect in m2ts mode
where the elementary stream PIDs are fixed.</p>

<p style="margin-left:9%;"><b>mpegts_m2ts_mode</b>
<i>boolean</i></p>

<p style="margin-left:14%;">Enable m2ts mode if set to 1.
Default value is -1 which disables m2ts mode.</p>

<p style="margin-left:9%;"><b>muxrate</b>
<i>integer</i></p>

<p style="margin-left:14%;">Set a constant muxrate. Default
is VBR.</p>

<p style="margin-left:9%;"><b>pes_payload_size</b>
<i>integer</i></p>

<p style="margin-left:14%;">Set minimum PES packet payload
in bytes. Default is 2930.</p>

<p style="margin-left:9%;"><b>mpegts_flags</b>
<i>flags</i></p>

<p style="margin-left:14%;">Set mpegts flags. Accepts the
following options: <b><br>
resend_headers</b></p>

<p style="margin-left:19%;">Reemit PAT/PMT before writing
the next packet.</p>

<p style="margin-left:14%;"><b>latm</b></p>

<p style="margin-left:19%;">Use LATM packetization for
AAC.</p>

<p style="margin-left:14%;"><b>pat_pmt_at_frames</b></p>

<p style="margin-left:19%;">Reemit PAT and PMT at each
video frame.</p>

<p style="margin-left:14%;"><b>system_b</b></p>

<p style="margin-left:19%;">Conform to System B (DVB)
instead of System A (ATSC).</p>


<p style="margin-left:14%;"><b>initial_discontinuity</b></p>

<p style="margin-left:19%;">Mark the initial packet of each
stream as discontinuity.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p><b>nit</b></p></td>
<td width="1%"></td>
<td width="19%">


<p>Emit NIT table.</p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:14%;"><b>omit_rai</b></p>

<p style="margin-left:19%;">Disable writing of random
access indicator.</p>

<p style="margin-left:9%;"><b>mpegts_copyts</b>
<i>boolean</i></p>

<p style="margin-left:14%;">Preserve original timestamps,
if value is set to 1. Default value is -1, which results in
shifting timestamps so that they start from 0.</p>

<p style="margin-left:9%;"><b>omit_video_pes_length</b>
<i>boolean</i></p>

<p style="margin-left:14%;">Omit the PES packet length for
video packets. Default is 1 (true).</p>

<p style="margin-left:9%;"><b>pcr_period</b>
<i>integer</i></p>

<p style="margin-left:14%;">Override the default PCR
retransmission time in milliseconds. Default is -1 which
means that the PCR interval will be determined
automatically: 20 ms is used for CBR streams, the highest
multiple of the frame duration which is less than 100 ms is
used for VBR streams.</p>

<p style="margin-left:9%;"><b>pat_period</b>
<i>duration</i></p>

<p style="margin-left:14%;">Maximum time in seconds between
PAT/PMT tables. Default is 0.1.</p>

<p style="margin-left:9%;"><b>sdt_period</b>
<i>duration</i></p>

<p style="margin-left:14%;">Maximum time in seconds between
SDT tables. Default is 0.5.</p>

<p style="margin-left:9%;"><b>nit_period</b>
<i>duration</i></p>

<p style="margin-left:14%;">Maximum time in seconds between
NIT tables. Default is 0.5.</p>

<p style="margin-left:9%;"><b>tables_version</b>
<i>integer</i></p>

<p style="margin-left:14%;">Set PAT, PMT, SDT and NIT
version (default 0, valid values are from 0 to 31,
inclusively). This option allows updating stream structure
so that standard consumer may detect the change. To do so,
reopen output &quot;AVFormatContext&quot; (in case of API
usage) or restart <b>ffmpeg</b> instance, cyclically
changing <b>tables_version</b> value:</p>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
source1.ts -codec copy -f mpegts -tables_version 0
udp://1.1.1.1:1111 <br>
ffmpeg -i source2.ts -codec copy -f mpegts -tables_version 1
udp://1.1.1.1:1111 <br>
... <br>
ffmpeg -i source3.ts -codec copy -f mpegts -tables_version
31 udp://1.1.1.1:1111 <br>
ffmpeg -i source1.ts -codec copy -f mpegts -tables_version 0
udp://1.1.1.1:1111 <br>
ffmpeg -i source2.ts -codec copy -f mpegts -tables_version 1
udp://1.1.1.1:1111 <br>
...</p>


<p style="margin-left:9%; margin-top: 1em"><i>Example</i></p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i
file.mpg -c copy \ <br>
-mpegts_original_network_id 0x1122 \ <br>
-mpegts_transport_stream_id 0x3344 \ <br>
-mpegts_service_id 0x5566 \ <br>
-mpegts_pmt_start_pid 0x1500 \ <br>
-mpegts_start_pid 0x150 \ <br>
-metadata service_provider=&quot;Some provider&quot; \ <br>
-metadata service_name=&quot;Some Channel&quot; \ <br>
out.ts</p>

<h3>mxf, mxf_d10, mxf_opatom
<a name="mxf, mxf_d10, mxf_opatom"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">MXF muxer.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Options</i></p>

<p style="margin-left:9%; margin-top: 1em">The muxer
options are: <b><br>
store_user_comments</b> <i>bool</i></p>

<p style="margin-left:14%;">Set if user comments should be
stored if available or never. IRT D-10 does not allow user
comments. The default is thus to write them for mxf and
mxf_opatom but not for mxf_d10</p>

<h3>null
<a name="null"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Null muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer does
not generate any output file, it is mainly useful for
testing or benchmarking purposes.</p>

<p style="margin-left:9%; margin-top: 1em">For example to
benchmark decoding with <b>ffmpeg</b> you can use the
command:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg
-benchmark -i INPUT -f null out.null</p>

<p style="margin-left:9%; margin-top: 1em">Note that the
above command does not read or write the <i>out.null</i>
file, but specifying the output file is required by the
<b>ffmpeg</b> syntax.</p>

<p style="margin-left:9%; margin-top: 1em">Alternatively
you can write the command as:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg
-benchmark -i INPUT -f null -</p>

<h3>nut
<a name="nut"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>-syncpoints</b>
<i>flags</i></p>

<p style="margin-left:14%;">Change the syncpoint usage in
nut: <i><br>
default</i> <b>use the normal low-overhead seeking aids.</b>
<i><br>
none</i> <b>do not use the syncpoints at all, reducing the
overhead but <br>
making the stream non-seekable;</b></p>

<p style="margin-left:19%;">Use of this option is not
recommended, as the resulting files are very damage <br>
sensitive and seeking is not possible. Also in general the
overhead from <br>
syncpoints is negligible. Note, -C&lt;write_index&gt; 0 can
be used to disable <br>
all growing data tables, allowing to mux endless streams
with limited memory <br>
and without these disadvantages.</p>

<p style="margin-left:14%;"><i>timestamped</i> <b>extend
the syncpoint with a wallclock field.</b></p>

<p style="margin-left:14%; margin-top: 1em">The <i>none</i>
and <i>timestamped</i> flags are experimental.</p>

<p style="margin-left:9%;"><b>-write_index</b>
<i>bool</i></p>

<p style="margin-left:14%;">Write index at the end, the
default is to write an index.</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-f_strict experimental -syncpoints none - | processor</p>

<h3>ogg
<a name="ogg"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Ogg container
muxer. <b><br>
-page_duration</b> <i>duration</i></p>

<p style="margin-left:14%;">Preferred page duration, in
microseconds. The muxer will attempt to create pages that
are approximately <i>duration</i> microseconds long. This
allows the user to compromise between seek granularity and
container overhead. The default is 1 second. A value of 0
will fill all segments, making pages as large as possible. A
value of 1 will effectively use 1 packet-per-page in most
situations, giving a small seek granularity at the cost of
additional container overhead.</p>

<p style="margin-left:9%;"><b>-serial_offset</b>
<i>value</i></p>

<p style="margin-left:14%;">Serial value from which to set
the streams serial number. Setting it to different and
sufficiently large values ensures that the produced ogg
files can be safely chained.</p>

<h3>rcwt
<a name="rcwt"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">RCWT (Raw
Captions With Time) is a format native to ccextractor, a
commonly used open source tool for processing 608/708 Closed
Captions (CC) sources. It can be used to archive the
original extracted CC bitstream and to produce a source file
for later processing or conversion. The format allows for
interoperability between ccextractor and FFmpeg, is simple
to parse, and can be used to create a backup of the CC
presentation.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
implements the specification as of March 2024, which has
been stable and unchanged since April 2014.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer will
have some nuances from the way that ccextractor muxes RCWT.
No compatibility issues when processing the output with
ccextractor have been observed as a result of this so far,
but mileage may vary and outputs will not be a bit-exact
match.</p>

<p style="margin-left:9%; margin-top: 1em">A free
specification of RCWT can be found here:
&lt;<b>https://github.com/CCExtractor/ccextractor/blob/master/docs/BINARY_FILE_FORMAT.TXT</b>&gt;</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="57%">


<p>Extract Closed Captions to RCWT using lavfi:</p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -f lavfi
-i &quot;movie=INPUT.mkv[out+subcc]&quot; -map 0:s:0 -c:s
copy -f rcwt CC.rcwt.bin</p>

<h3>segment, stream_segment, ssegment
<a name="segment, stream_segment, ssegment"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Basic stream
segmenter.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
outputs streams to a number of separate files of nearly
fixed duration. Output filename pattern can be set in a
fashion similar to <b>image2</b>, or by using a
&quot;strftime&quot; template if the <b>strftime</b> option
is enabled.</p>


<p style="margin-left:9%; margin-top: 1em">&quot;stream_segment&quot;
is a variant of the muxer used to write to streaming output
formats, i.e. which do not require global headers, and is
recommended for outputting e.g. to MPEG transport stream
segments. &quot;ssegment&quot; is a shorter alias for
&quot;stream_segment&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">Every segment
starts with a keyframe of the selected reference stream,
which is set through the <b>reference_stream</b> option.</p>

<p style="margin-left:9%; margin-top: 1em">Note that if you
want accurate splitting for a video file, you need to make
the input key frames correspond to the exact splitting times
expected by the segmenter, or the segment muxer will start
the new segment with the key frame found next after the
specified start time.</p>

<p style="margin-left:9%; margin-top: 1em">The segment
muxer works best with a single constant frame rate
video.</p>

<p style="margin-left:9%; margin-top: 1em">Optionally it
can generate a list of the created segments, by setting the
option <i>segment_list</i>. The list type is specified by
the <i>segment_list_type</i> option. The entry filenames in
the segment list are set by default to the basename of the
corresponding segment files.</p>

<p style="margin-left:9%; margin-top: 1em">See also the
<b>hls</b> muxer, which provides a more specific
implementation for HLS segmentation.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Options</i></p>

<p style="margin-left:9%; margin-top: 1em">The segment
muxer supports the following options: <b><br>
increment_tc</b> <i>1|0</i></p>

<p style="margin-left:14%;">if set to 1, increment timecode
between each segment If this is selected, the input need to
have a timecode in the first video stream. Default value is
0.</p>

<p style="margin-left:9%;"><b>reference_stream</b>
<i>specifier</i></p>

<p style="margin-left:14%;">Set the reference stream, as
specified by the string <i>specifier</i>. If
<i>specifier</i> is set to &quot;auto&quot;, the reference
is chosen automatically. Otherwise it must be a stream
specifier (see the &lsquo;&lsquo;Stream
specifiers&rsquo;&rsquo; chapter in the ffmpeg manual) which
specifies the reference stream. The default value is
&quot;auto&quot;.</p>

<p style="margin-left:9%;"><b>segment_format</b>
<i>format</i></p>

<p style="margin-left:14%;">Override the inner container
format, by default it is guessed by the filename
extension.</p>

<p style="margin-left:9%;"><b>segment_format_options</b>
<i>options_list</i></p>

<p style="margin-left:14%;">Set output format options using
a :-separated list of key=value parameters. Values
containing the &quot;:&quot; special character must be
escaped.</p>

<p style="margin-left:9%;"><b>segment_list</b>
<i>name</i></p>

<p style="margin-left:14%;">Generate also a listfile named
<i>name</i>. If not specified no listfile is generated.</p>

<p style="margin-left:9%;"><b>segment_list_flags</b>
<i>flags</i></p>

<p style="margin-left:14%;">Set flags affecting the segment
list generation.</p>

<p style="margin-left:14%; margin-top: 1em">It currently
supports the following flags: <b><br>
cache</b></p>

<p style="margin-left:19%;">Allow caching (only affects
M3U8 list files).</p>

<p style="margin-left:14%;"><b>live</b></p>

<p style="margin-left:19%;">Allow live-friendly file
generation.</p>

<p style="margin-left:9%;"><b>segment_list_size</b>
<i>size</i></p>

<p style="margin-left:14%;">Update the list file so that it
contains at most <i>size</i> segments. If 0 the list file
will contain all the segments. Default value is 0.</p>


<p style="margin-left:9%;"><b>segment_list_entry_prefix</b>
<i>prefix</i></p>

<p style="margin-left:14%;">Prepend <i>prefix</i> to each
entry. Useful to generate absolute paths. By default no
prefix is applied.</p>

<p style="margin-left:9%;"><b>segment_list_type</b>
<i>type</i></p>

<p style="margin-left:14%;">Select the listing format.</p>

<p style="margin-left:14%; margin-top: 1em">The following
values are recognized: <b><br>
flat</b></p>

<p style="margin-left:19%;">Generate a flat list for the
created segments, one segment per line.</p>

<p style="margin-left:14%;"><b>csv, ext</b></p>

<p style="margin-left:19%;">Generate a list for the created
segments, one segment per line, each line matching the
format (comma-separated values):</p>


<p style="margin-left:19%; margin-top: 1em">&lt;segment_filename&gt;,&lt;segment_start_time&gt;,&lt;segment_end_time&gt;</p>


<p style="margin-left:19%; margin-top: 1em"><i>segment_filename</i>
is the name of the output file generated by the muxer
according to the provided pattern. CSV escaping (according
to RFC4180) is applied if required.</p>


<p style="margin-left:19%; margin-top: 1em"><i>segment_start_time</i>
and <i>segment_end_time</i> specify the segment start and
end time expressed in seconds.</p>

<p style="margin-left:19%; margin-top: 1em">A list file
with the suffix &quot;.csv&quot; or &quot;.ext&quot; will
auto-select this format.</p>

<p style="margin-left:19%; margin-top: 1em"><b>ext</b> is
deprecated in favor or <b>csv</b>.</p>

<p style="margin-left:14%;"><b>ffconcat</b></p>

<p style="margin-left:19%;">Generate an ffconcat file for
the created segments. The resulting file can be read using
the FFmpeg <b>concat</b> demuxer.</p>

<p style="margin-left:19%; margin-top: 1em">A list file
with the suffix &quot;.ffcat&quot; or &quot;.ffconcat&quot;
will auto-select this format.</p>

<p style="margin-left:14%;"><b>m3u8</b></p>

<p style="margin-left:19%;">Generate an extended M3U8 file,
version 3, compliant with
&lt;<b>http://tools.ietf.org/id/draft-pantos-http-live-streaming</b>&gt;.</p>

<p style="margin-left:19%; margin-top: 1em">A list file
with the suffix &quot;.m3u8&quot; will auto-select this
format.</p>

<p style="margin-left:14%; margin-top: 1em">If not
specified the type is guessed from the list file name
suffix.</p>

<p style="margin-left:9%;"><b>segment_time</b>
<i>time</i></p>

<p style="margin-left:14%;">Set segment duration to
<i>time</i>, the value must be a duration specification.
Default value is &quot;2&quot;. See also the
<b>segment_times</b> option.</p>

<p style="margin-left:14%; margin-top: 1em">Note that
splitting may not be accurate, unless you force the
reference stream key-frames at the given time. See the
introductory notice and the examples below.</p>

<p style="margin-left:9%;"><b>min_seg_duration</b>
<i>time</i></p>

<p style="margin-left:14%;">Set minimum segment duration to
<i>time</i>, the value must be a duration specification.
This prevents the muxer ending segments at a duration below
this value. Only effective with &quot;segment_time&quot;.
Default value is &quot;0&quot;.</p>

<p style="margin-left:9%;"><b>segment_atclocktime</b>
<i>1|0</i></p>

<p style="margin-left:14%;">If set to &quot;1&quot; split
at regular clock time intervals starting from 00:00
o&rsquo;clock. The <i>time</i> value specified in
<b>segment_time</b> is used for setting the length of the
splitting interval.</p>

<p style="margin-left:14%; margin-top: 1em">For example
with <b>segment_time</b> set to &quot;900&quot; this makes
it possible to create files at 12:00 o&rsquo;clock, 12:15,
12:30, etc.</p>

<p style="margin-left:14%; margin-top: 1em">Default value
is &quot;0&quot;.</p>

<p style="margin-left:9%;"><b>segment_clocktime_offset</b>
<i>duration</i></p>

<p style="margin-left:14%;">Delay the segment splitting
times with the specified duration when using
<b>segment_atclocktime</b>.</p>

<p style="margin-left:14%; margin-top: 1em">For example
with <b>segment_time</b> set to &quot;900&quot; and
<b>segment_clocktime_offset</b> set to &quot;300&quot; this
makes it possible to create files at 12:05, 12:20, 12:35,
etc.</p>

<p style="margin-left:14%; margin-top: 1em">Default value
is &quot;0&quot;.</p>


<p style="margin-left:9%;"><b>segment_clocktime_wrap_duration</b>
<i>duration</i></p>

<p style="margin-left:14%;">Force the segmenter to only
start a new segment if a packet reaches the muxer within the
specified duration after the segmenting clock time. This way
you can make the segmenter more resilient to backward local
time jumps, such as leap seconds or transition to standard
time from daylight savings time.</p>

<p style="margin-left:14%; margin-top: 1em">Default is the
maximum possible duration which means starting a new segment
regardless of the elapsed time since the last clock
time.</p>

<p style="margin-left:9%;"><b>segment_time_delta</b>
<i>delta</i></p>

<p style="margin-left:14%;">Specify the accuracy time when
selecting the start time for a segment, expressed as a
duration specification. Default value is &quot;0&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">When delta is
specified a key-frame will start a new segment if its PTS
satisfies the relation:</p>

<p style="margin-left:14%; margin-top: 1em">PTS &gt;=
start_time - time_delta</p>

<p style="margin-left:14%; margin-top: 1em">This option is
useful when splitting video content, which is always split
at GOP boundaries, in case a key frame is found just before
the specified split time.</p>

<p style="margin-left:14%; margin-top: 1em">In particular
may be used in combination with the <i>ffmpeg</i> option
<i>force_key_frames</i>. The key frame times specified by
<i>force_key_frames</i> may not be set accurately because of
rounding issues, with the consequence that a key frame time
may result set just before the specified time. For constant
frame rate videos a value of 1/(2*<i>frame_rate</i>) should
address the worst case mismatch between the specified time
and the time set by <i>force_key_frames</i>.</p>

<p style="margin-left:9%;"><b>segment_times</b>
<i>times</i></p>

<p style="margin-left:14%;">Specify a list of split points.
<i>times</i> contains a list of comma separated duration
specifications, in increasing order. See also the
<b>segment_time</b> option.</p>

<p style="margin-left:9%;"><b>segment_frames</b>
<i>frames</i></p>

<p style="margin-left:14%;">Specify a list of split video
frame numbers. <i>frames</i> contains a list of comma
separated integer numbers, in increasing order.</p>

<p style="margin-left:14%; margin-top: 1em">This option
specifies to start a new segment whenever a reference stream
key frame is found and the sequential number (starting from
0) of the frame is greater or equal to the next value in the
list.</p>

<p style="margin-left:9%;"><b>segment_wrap</b>
<i>limit</i></p>

<p style="margin-left:14%;">Wrap around segment index once
it reaches <i>limit</i>.</p>

<p style="margin-left:9%;"><b>segment_start_number</b>
<i>number</i></p>

<p style="margin-left:14%;">Set the sequence number of the
first segment. Defaults to 0.</p>

<p style="margin-left:9%;"><b>strftime</b> <i>1|0</i></p>

<p style="margin-left:14%;">Use the &quot;strftime&quot;
function to define the name of the new segments to write. If
this is selected, the output segment name must contain a
&quot;strftime&quot; function template. Default value is
0.</p>

<p style="margin-left:9%;"><b>break_non_keyframes</b>
<i>1|0</i></p>

<p style="margin-left:14%;">If enabled, allow segments to
start on frames other than keyframes. This improves behavior
on some players when the time between keyframes is
inconsistent, but may make things worse on others, and can
cause some oddities during seeking. Defaults to 0.</p>

<p style="margin-left:9%;"><b>reset_timestamps</b>
<i>1|0</i></p>

<p style="margin-left:14%;">Reset timestamps at the
beginning of each segment, so that each segment will start
with near-zero timestamps. It is meant to ease the playback
of the generated segments. May not work with some
combinations of muxers/codecs. It is set to 0 by
default.</p>

<p style="margin-left:9%;"><b>initial_offset</b>
<i>offset</i></p>

<p style="margin-left:14%;">Specify timestamp offset to
apply to the output packet timestamps. The argument must be
a time duration specification, and defaults to 0.</p>

<p style="margin-left:9%;"><b>write_empty_segments</b>
<i>1|0</i></p>

<p style="margin-left:14%;">If enabled, write an empty
segment if there are no packets during the period a segment
would usually span. Otherwise, the segment will be filled
with the next packet written. Defaults to 0.</p>

<p style="margin-left:9%; margin-top: 1em">Make sure to
require a closed GOP when encoding and to set the GOP size
to fit your segment time constraint.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>Remux the content of file <i>in.mkv</i> to a list of
segments <i>out-000.nut</i>, <i>out-001.nut</i>, etc., and
write the list of generated segments to <i>out.list</i>:</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
in.mkv -codec hevc -flags +cgop -g 60 -map 0 -f segment
-segment_list out.list out%03d.nut</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">Segment input and set output
format options for the output segments:</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
in.mkv -f segment -segment_time 10 -segment_format_options
movflags=+faststart out%03d.mp4</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">Segment the input file according
to the split points specified by the <i>segment_times</i>
option:</p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
in.mkv -codec copy -map 0 -f segment -segment_list out.csv
-segment_times 1,2,3,5,8,13,21 out%03d.nut</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">Use the <b>ffmpeg
force_key_frames</b> option to force key frames in the input
at the specified location, together with the segment option
<b>segment_time_delta</b> to account for possible roundings
operated when setting key frame times.</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
in.mkv -force_key_frames 1,2,3,5,8,13,21 -codec:v mpeg4
-codec:a pcm_s16le -map 0 \ <br>
-f segment -segment_list out.csv -segment_times
1,2,3,5,8,13,21 -segment_time_delta 0.05 out%03d.nut</p>

<p style="margin-left:14%; margin-top: 1em">In order to
force key frames on the input file, transcoding is
required.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">Segment the input file by
splitting the input file according to the frame numbers
sequence specified with the <b>segment_frames</b>
option:</p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
in.mkv -codec copy -map 0 -f segment -segment_list out.csv
-segment_frames 100,200,300,500,800 out%03d.nut</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">Convert the <i>in.mkv</i> to TS
segments using the &quot;libx264&quot; and &quot;aac&quot;
encoders:</p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i
in.mkv -map 0 -codec:v libx264 -codec:a aac -f ssegment
-segment_list out.list out%03d.ts</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">Segment the input file, and
create an M3U8 live playlist (can be used as live HLS
source):</p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -re -i
in.mkv -codec copy -map 0 -f segment -segment_list
playlist.m3u8 \ <br>
-segment_list_flags +live -segment_time 10 out%03d.mkv</p>

<h3>smoothstreaming
<a name="smoothstreaming"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Smooth Streaming
muxer generates a set of files (Manifest, chunks) suitable
for serving with conventional web server. <b><br>
window_size</b></p>

<p style="margin-left:14%;">Specify the number of fragments
kept in the manifest. Default 0 (keep all).</p>

<p style="margin-left:9%;"><b>extra_window_size</b></p>

<p style="margin-left:14%;">Specify the number of fragments
kept outside of the manifest before removing from disk.
Default 5.</p>

<p style="margin-left:9%;"><b>lookahead_count</b></p>

<p style="margin-left:14%;">Specify the number of lookahead
fragments. Default 2.</p>

<p style="margin-left:9%;"><b>min_frag_duration</b></p>

<p style="margin-left:14%;">Specify the minimum fragment
duration (in microseconds). Default 5000000.</p>

<p style="margin-left:9%;"><b>remove_at_exit</b></p>

<p style="margin-left:14%;">Specify whether to remove all
fragments when finished. Default 0 (do not remove).</p>

<h3>streamhash
<a name="streamhash"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Per stream hash
testing format.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
computes and prints a cryptographic hash of all the input
frames, on a per-stream basis. This can be used for equality
checks without having to do a complete binary
comparison.</p>

<p style="margin-left:9%; margin-top: 1em">By default audio
frames are converted to signed 16-bit raw audio and video
frames to raw video before computing the hash, but the
output of explicit conversions to other codecs can also be
used. Timestamps are ignored. It uses the SHA-256
cryptographic hash function by default, but supports several
other algorithms.</p>

<p style="margin-left:9%; margin-top: 1em">The output of
the muxer consists of one line per stream of the form:
<i>streamindex</i>,<i>streamtype</i>,<i>algo</i>=<i>hash</i>,
where <i>streamindex</i> is the index of the mapped stream,
<i>streamtype</i> is a single character indicating the type
of stream, <i>algo</i> is a short string representing the
hash function used, and <i>hash</i> is a hexadecimal number
representing the computed hash. <b><br>
hash</b> <i>algorithm</i></p>

<p style="margin-left:14%;">Use the cryptographic hash
function specified by the string <i>algorithm</i>. Supported
values include &quot;MD5&quot;, &quot;murmur3&quot;,
&quot;RIPEMD128&quot;, &quot;RIPEMD160&quot;,
&quot;RIPEMD256&quot;, &quot;RIPEMD320&quot;,
&quot;SHA160&quot;, &quot;SHA224&quot;, &quot;SHA256&quot;
(default), &quot;SHA512/224&quot;, &quot;SHA512/256&quot;,
&quot;SHA384&quot;, &quot;SHA512&quot;, &quot;CRC32&quot;
and &quot;adler32&quot;.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<p style="margin-left:9%; margin-top: 1em">To compute the
SHA-256 hash of the input converted to raw audio and video,
and store it in the file <i>out.sha256</i>:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-f streamhash out.sha256</p>

<p style="margin-left:9%; margin-top: 1em">To print an MD5
hash to stdout use the command:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-f streamhash -hash md5 -</p>

<p style="margin-left:9%; margin-top: 1em">See also the
<b>hash</b> and <b>framehash</b> muxers.</p>

<h3>tee
<a name="tee"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The tee muxer
can be used to write the same data to several outputs, such
as files or streams. It can be used, for example, to stream
a video over a network and save it to disk at the same
time.</p>

<p style="margin-left:9%; margin-top: 1em">It is different
from specifying several outputs to the <b>ffmpeg</b>
command-line tool. With the tee muxer, the audio and video
data will be encoded only once. With conventional multiple
outputs, multiple encoding operations in parallel are
initiated, which can be a very expensive process. The tee
muxer is not useful when using the libavformat API directly
because it is then possible to feed the same packets to
several muxers directly.</p>

<p style="margin-left:9%; margin-top: 1em">Since the tee
muxer does not represent any particular output format,
ffmpeg cannot auto-select output streams. So all streams
intended for output must be specified using
&quot;-map&quot;. See the examples below.</p>

<p style="margin-left:9%; margin-top: 1em">Some encoders
may need different options depending on the output format;
the auto-detection of this can not work with the tee muxer,
so they need to be explicitly specified. The main example is
the <b>global_header</b> flag.</p>

<p style="margin-left:9%; margin-top: 1em">The slave
outputs are specified in the file name given to the muxer,
separated by &rsquo;|&rsquo;. If any of the slave name
contains the &rsquo;|&rsquo; separator, leading or trailing
spaces or any special character, those must be escaped (see
<b>the &quot;Quoting and escaping&quot; section in the
ffmpeg-utils(1) manual</b>).</p>

<p style="margin-left:9%; margin-top: 1em"><i>Options</i>
<b><br>
use_fifo</b> <i>bool</i></p>

<p style="margin-left:14%;">If set to 1, slave outputs will
be processed in separate threads using the <b>fifo</b>
muxer. This allows to compensate for different
speed/latency/reliability of outputs and setup transparent
recovery. By default this feature is turned off.</p>

<p style="margin-left:9%;"><b>fifo_options</b></p>

<p style="margin-left:14%;">Options to pass to fifo
pseudo-muxer instances. See <b>fifo</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Muxer options
can be specified for each slave by prepending them as a list
of <i>key</i>=<i>value</i> pairs separated by
&rsquo;:&rsquo;, between square brackets. If the options
values contain a special character or the &rsquo;:&rsquo;
separator, they must be escaped; note that this is a second
level escaping.</p>

<p style="margin-left:9%; margin-top: 1em">The following
special options are also recognized:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p><b>f</b></p></td>
<td width="4%"></td>
<td width="86%">


<p>Specify the format name. Required if it cannot be
guessed from the output URL.</p></td></tr>
</table>


<p style="margin-left:9%;"><b>bsfs[/</b><i>spec</i><b>]</b></p>

<p style="margin-left:14%;">Specify a list of bitstream
filters to apply to the specified output.</p>

<p style="margin-left:14%; margin-top: 1em">It is possible
to specify to which streams a given bitstream filter
applies, by appending a stream specifier to the option
separated by &quot;/&quot;. <i>spec</i> must be a stream
specifier (see <b>Format stream specifiers</b>).</p>

<p style="margin-left:14%; margin-top: 1em">If the stream
specifier is not specified, the bitstream filters will be
applied to all streams in the output. This will cause that
output operation to fail if the output contains streams to
which the bitstream filter cannot be applied e.g.
&quot;h264_mp4toannexb&quot; being applied to an output
containing an audio stream.</p>

<p style="margin-left:14%; margin-top: 1em">Options for a
bitstream filter must be specified in the form of
&quot;opt=value&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Several
bitstream filters can be specified, separated by
&quot;,&quot;.</p>

<p style="margin-left:9%;"><b>use_fifo</b> <i>bool</i></p>

<p style="margin-left:14%;">This allows to override tee
muxer use_fifo option for individual slave muxer.</p>

<p style="margin-left:9%;"><b>fifo_options</b></p>

<p style="margin-left:14%;">This allows to override tee
muxer fifo_options for individual slave muxer. See
<b>fifo</b>.</p>

<p style="margin-left:9%;"><b>select</b></p>

<p style="margin-left:14%;">Select the streams that should
be mapped to the slave output, specified by a stream
specifier. If not specified, this defaults to all the mapped
streams. This will cause that output operation to fail if
the output format does not accept all mapped streams.</p>

<p style="margin-left:14%; margin-top: 1em">You may use
multiple stream specifiers separated by commas
(&quot;,&quot;) e.g.: &quot;a:0,v&quot;</p>

<p style="margin-left:9%;"><b>onfail</b></p>

<p style="margin-left:14%;">Specify behaviour on output
failure. This can be set to either &quot;abort&quot; (which
is default) or &quot;ignore&quot;. &quot;abort&quot; will
cause whole process to fail in case of failure on this slave
output. &quot;ignore&quot; will ignore failure on this
output, so other outputs will continue without being
affected.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Examples</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>Encode something and both archive it in a WebM file and
stream it as MPEG-TS over UDP:</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i ...
-c:v libx264 -c:a mp2 -f tee -map 0:v -map 0:a <br>

&quot;archive-20121107.mkv|[f=mpegts]udp://10.0.1.255:1234/&quot;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">As above, but continue streaming
even if output to local file fails (for example local drive
fills up):</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i ...
-c:v libx264 -c:a mp2 -f tee -map 0:v -map 0:a <br>

&quot;[onfail=ignore]archive-20121107.mkv|[f=mpegts]udp://10.0.1.255:1234/&quot;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">Use <b>ffmpeg</b> to encode the
input, and send the output to three different destinations.
The &quot;dump_extra&quot; bitstream filter is used to add
extradata information to all the output video keyframes
packets, as requested by the MPEG-TS format. The select
option is applied to <i>out.aac</i> in order to make it
contain only audio packets.</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i ...
-map 0 -flags +global_header -c:v libx264 -c:a aac <br>
-f tee
&quot;[bsfs/v=dump_extra=freq=keyframe]out.ts|[movflags=+faststart]out.mp4|[select=a]out.aac&quot;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p style="margin-top: 1em">As above, but select only stream
&quot;a:1&quot; for the audio output. Note that a second
level escaping must be performed, as &quot;:&quot; is a
special character used to separate options.</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">ffmpeg -i ...
-map 0 -flags +global_header -c:v libx264 -c:a aac <br>
-f tee
&quot;[bsfs/v=dump_extra=freq=keyframe]out.ts|[movflags=+faststart]out.mp4|[select=\'a:1\']out.aac&quot;</p>

<h3>webm_chunk
<a name="webm_chunk"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">WebM Live Chunk
Muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
writes out WebM headers and chunks as separate files which
can be consumed by clients that support WebM Live streams
via DASH.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Options</i></p>

<p style="margin-left:9%; margin-top: 1em">This muxer
supports the following options: <b><br>
chunk_start_index</b></p>

<p style="margin-left:14%;">Index of the first chunk
(defaults to 0).</p>

<p style="margin-left:9%;"><b>header</b></p>

<p style="margin-left:14%;">Filename of the header where
the initialization data will be written.</p>

<p style="margin-left:9%;"><b>audio_chunk_duration</b></p>

<p style="margin-left:14%;">Duration of each audio chunk in
milliseconds (defaults to 5000).</p>


<p style="margin-left:9%; margin-top: 1em"><i>Example</i></p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -f v4l2
-i /dev/video0 \ <br>
-f alsa -i hw:0 \ <br>
-map 0:0 \ <br>
-c:v libvpx-vp9 \ <br>
-s 640x360 -keyint_min 30 -g 30 \ <br>
-f webm_chunk \ <br>
-header webm_live_video_360.hdr \ <br>
-chunk_start_index 1 \ <br>
webm_live_video_360_%d.chk \ <br>
-map 1:0 \ <br>
-c:a libvorbis \ <br>
-b:a 128k \ <br>
-f webm_chunk \ <br>
-header webm_live_audio_128.hdr \ <br>
-chunk_start_index 1 \ <br>
-audio_chunk_duration 1000 \ <br>
webm_live_audio_128_%d.chk</p>

<h3>webm_dash_manifest
<a name="webm_dash_manifest"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">WebM DASH
Manifest muxer.</p>

<p style="margin-left:9%; margin-top: 1em">This muxer
implements the WebM DASH Manifest specification to generate
the DASH manifest XML. It also supports manifest generation
for DASH live streams.</p>

<p style="margin-left:9%; margin-top: 1em">For more
information see:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>WebM DASH Specification:
&lt;<b>https://sites.google.com/a/webmproject.org/wiki/adaptive-streaming/webm-dash-specification</b>&gt;</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>ISO DASH Specification:
&lt;<b>http://standards.iso.org/ittf/PubliclyAvailableStandards/c065274_ISO_IEC_23009-1_2014.zip</b>&gt;</p> </td></tr>
</table>


<p style="margin-left:9%; margin-top: 1em"><i>Options</i></p>

<p style="margin-left:9%; margin-top: 1em">This muxer
supports the following options: <b><br>
adaptation_sets</b></p>

<p style="margin-left:14%;">This option has the following
syntax: &quot;id=x,streams=a,b,c id=y,streams=d,e&quot;
where x and y are the unique identifiers of the adaptation
sets and a,b,c,d and e are the indices of the corresponding
audio and video streams. Any number of adaptation sets can
be added using this option.</p>

<p style="margin-left:9%;"><b>live</b></p>

<p style="margin-left:14%;">Set this to 1 to create a live
stream DASH Manifest. Default: 0.</p>

<p style="margin-left:9%;"><b>chunk_start_index</b></p>

<p style="margin-left:14%;">Start index of the first chunk.
This will go in the <b>startNumber</b> attribute of the
<b>SegmentTemplate</b> element in the manifest. Default:
0.</p>

<p style="margin-left:9%;"><b>chunk_duration_ms</b></p>

<p style="margin-left:14%;">Duration of each chunk in
milliseconds. This will go in the <b>duration</b> attribute
of the <b>SegmentTemplate</b> element in the manifest.
Default: 1000.</p>

<p style="margin-left:9%;"><b>utc_timing_url</b></p>

<p style="margin-left:14%;">URL of the page that will
return the UTC timestamp in ISO format. This will go in the
<b>value</b> attribute of the <b>UTCTiming</b> element in
the manifest. Default: None.</p>


<p style="margin-left:9%;"><b>time_shift_buffer_depth</b></p>

<p style="margin-left:14%;">Smallest time (in seconds)
shifting buffer for which any Representation is guaranteed
to be available. This will go in the
<b>timeShiftBufferDepth</b> attribute of the <b>MPD</b>
element. Default: 60.</p>


<p style="margin-left:9%;"><b>minimum_update_period</b></p>

<p style="margin-left:14%;">Minimum update period (in
seconds) of the manifest. This will go in the
<b>minimumUpdatePeriod</b> attribute of the <b>MPD</b>
element. Default: 0.</p>


<p style="margin-left:9%; margin-top: 1em"><i>Example</i></p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -f
webm_dash_manifest -i video1.webm \ <br>
-f webm_dash_manifest -i video2.webm \ <br>
-f webm_dash_manifest -i audio1.webm \ <br>
-f webm_dash_manifest -i audio2.webm \ <br>
-map 0 -map 1 -map 2 -map 3 \ <br>
-c copy \ <br>
-f webm_dash_manifest \ <br>
-adaptation_sets &quot;id=0,streams=0,1
id=1,streams=2,3&quot; \ <br>
manifest.xml</p>

<h2>METADATA
<a name="METADATA"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">FFmpeg is able
to dump metadata from media files into a simple
UTF-8-encoded INI-like text file and then load it back using
the metadata muxer/demuxer.</p>

<p style="margin-left:9%; margin-top: 1em">The file format
is as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>1.</p></td>
<td width="2%"></td>
<td width="86%">


<p>A file consists of a header and a number of metadata
tags divided into sections, each on its own line.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>2.</p></td>
<td width="2%"></td>
<td width="86%">


<p>The header is a <b>;FFMETADATA</b> string, followed by a
version number (now 1).</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>3.</p></td>
<td width="2%"></td>
<td width="86%">


<p>Metadata tags are of the form <b>key=value</b></p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>4.</p></td>
<td width="2%"></td>
<td width="86%">


<p>Immediately after header follows global metadata</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>5.</p></td>
<td width="2%"></td>
<td width="86%">


<p>After global metadata there may be sections with
per-stream/per-chapter metadata.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>6.</p></td>
<td width="2%"></td>
<td width="86%">


<p>A section starts with the section name in uppercase
(i.e. STREAM or CHAPTER) in brackets (<b>[</b>, <b>]</b>)
and ends with next section or end of file.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>7.</p></td>
<td width="2%"></td>
<td width="86%">


<p>At the beginning of a chapter section there may be an
optional timebase to be used for start/end values. It must
be in form <b>TIMEBASE=</b><i>num</i><b>/</b><i>den</i>,
where <i>num</i> and <i>den</i> are integers. If the
timebase is missing then start/end times are assumed to be
in nanoseconds.</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Next a chapter
section must contain chapter start and end times in form
<b>START=</b><i>num</i>, <b>END=</b><i>num</i>, where
<i>num</i> is a positive integer.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p style="margin-top: 1em">8.</p></td>
<td width="1%"></td>
<td width="86%">


<p style="margin-top: 1em">Empty lines and lines starting
with <b>;</b> or <b>#</b> are ignored.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>9.</p></td>
<td width="1%"></td>
<td width="86%">


<p>Metadata keys or values containing special characters
(<b>=</b>, <b>;</b>, <b>#</b>, <b>\</b> and a newline) must
be escaped with a backslash <b>\</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>10.</p></td>
<td width="1%"></td>
<td width="86%">


<p>Note that whitespace in metadata (e.g. <b>foo = bar</b>)
is considered to be a part of the tag (in the example above
key is <b>foo</b> , value is</p></td></tr>
</table>

<p style="margin-left:14%;"><b>bar</b>).</p>

<p style="margin-left:9%; margin-top: 1em">A ffmetadata
file might look like this:</p>

<p style="margin-left:9%; margin-top: 1em">;FFMETADATA1
<br>
title=bike\\shed <br>
;this is a comment <br>
artist=FFmpeg troll team <br>
[CHAPTER] <br>
TIMEBASE=1/1000 <br>
START=0 <br>
#chapter ends at 0:01:00 <br>
END=60000 <br>
title=chapter \#1 <br>
[STREAM] <br>
title=multi\ <br>
line</p>

<p style="margin-left:9%; margin-top: 1em">By using the
ffmetadata muxer and demuxer it is possible to extract
metadata from an input file to an ffmetadata file, and then
transcode the file into an output file with the edited
ffmetadata file.</p>

<p style="margin-left:9%; margin-top: 1em">Extracting an
ffmetadata file with <i>ffmpeg</i> goes as follows:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-f ffmetadata FFMETADATAFILE</p>

<p style="margin-left:9%; margin-top: 1em">Reinserting
edited metadata information from the FFMETADATAFILE file can
be done as:</p>

<p style="margin-left:9%; margin-top: 1em">ffmpeg -i INPUT
-i FFMETADATAFILE -map_metadata 1 -codec copy OUTPUT</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:9%; margin-top: 1em"><b>ffmpeg</b>(1),
<b>ffplay</b>(1), <b>ffprobe</b>(1),
<b>libavformat</b>(3)</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">The FFmpeg
developers.</p>

<p style="margin-left:9%; margin-top: 1em">For details
about the authorship, see the Git history of the project
(https://git.ffmpeg.org/ffmpeg), e.g. by typing the command
<b>git log</b> in the FFmpeg source directory, or browsing
the online repository at
&lt;<b>https://git.ffmpeg.org/ffmpeg</b>&gt;.</p>

<p style="margin-left:9%; margin-top: 1em">Maintainers for
the specific components are listed in the file
<i>MAINTAINERS</i> in the source code tree.</p>
<hr>
</body>
</html>
