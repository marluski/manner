<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Mon Apr  7 17:27:58 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>LIBUV</title>

</head>
<body>

<h1 align="center">LIBUV</h1>

<a href="#NAME">NAME</a><br>
<a href="#OVERVIEW">OVERVIEW</a><br>
<a href="#FEATURES">FEATURES</a><br>
<a href="#DOCUMENTATION">DOCUMENTATION</a><br>
<a href="#Design overview">Design overview</a><br>
<a href="#Handles and requests">Handles and requests</a><br>
<a href="#The I/O loop">The I/O loop</a><br>
<a href="#File I/O">File I/O</a><br>
<a href="#API documentation">API documentation</a><br>
<a href="#Error handling">Error handling</a><br>
<a href="#Error constants">Error constants</a><br>
<a href="#API">API</a><br>
<a href="#Version-checking macros and functions">Version-checking macros and functions</a><br>
<a href="#Macros">Macros</a><br>
<a href="#Functions">Functions</a><br>
<a href="#uv_loop_t --- Event loop">uv_loop_t --- Event loop</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#uv_handle_t --- Base handle">uv_handle_t --- Base handle</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#Miscellaneous API functions">Miscellaneous API functions</a><br>
<a href="#Reference counting">Reference counting</a><br>
<a href="#uv_req_t --- Base request">uv_req_t --- Base request</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#uv_timer_t --- Timer handle">uv_timer_t --- Timer handle</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#uv_prepare_t --- Prepare handle">uv_prepare_t --- Prepare handle</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#uv_check_t --- Check handle">uv_check_t --- Check handle</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#uv_idle_t --- Idle handle">uv_idle_t --- Idle handle</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#uv_async_t --- Async handle">uv_async_t --- Async handle</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#uv_poll_t --- Poll handle">uv_poll_t --- Poll handle</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#uv_signal_t --- Signal handle">uv_signal_t --- Signal handle</a><br>
<a href="#Windows notes">Windows notes</a><br>
<a href="#Unix notes">Unix notes</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#uv_process_t --- Process handle">uv_process_t --- Process handle</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#uv_stream_t --- Stream handle">uv_stream_t --- Stream handle</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#uv_tcp_t --- TCP handle">uv_tcp_t --- TCP handle</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#uv_pipe_t --- Pipe handle">uv_pipe_t --- Pipe handle</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#uv_tty_t --- TTY handle">uv_tty_t --- TTY handle</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#uv_udp_t --- UDP handle">uv_udp_t --- UDP handle</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#uv_fs_event_t --- FS Event handle">uv_fs_event_t --- FS Event handle</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#uv_fs_poll_t --- FS Poll handle">uv_fs_poll_t --- FS Poll handle</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#File system operations">File system operations</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#Helper functions">Helper functions</a><br>
<a href="#File open constants">File open constants</a><br>
<a href="#Thread pool work scheduling">Thread pool work scheduling</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#DNS utility functions">DNS utility functions</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#Shared library handling">Shared library handling</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#Threading and synchronization utilities">Threading and synchronization utilities</a><br>
<a href="#Data types">Data types</a><br>
<a href="#API">API</a><br>
<a href="#Threads">Threads</a><br>
<a href="#Thread-local storage">Thread-local storage</a><br>
<a href="#Once-only initialization">Once-only initialization</a><br>
<a href="#Mutex locks">Mutex locks</a><br>
<a href="#Read-write locks">Read-write locks</a><br>
<a href="#Semaphores">Semaphores</a><br>
<a href="#Conditions">Conditions</a><br>
<a href="#Barriers">Barriers</a><br>
<a href="#Miscellaneous utilities">Miscellaneous utilities</a><br>
<a href="#Data types">Data types</a><br>
<a href="#API">API</a><br>
<a href="#String manipulation functions">String manipulation functions</a><br>
<a href="#Metrics operations">Metrics operations</a><br>
<a href="#Data types">Data types</a><br>
<a href="#Public members">Public members</a><br>
<a href="#API">API</a><br>
<a href="#User guide">User guide</a><br>
<a href="#Introduction">Introduction</a><br>
<a href="#Who this book is for">Who this book is for</a><br>
<a href="#Background">Background</a><br>
<a href="#Code">Code</a><br>
<a href="#Basics of libuv">Basics of libuv</a><br>
<a href="#Event loops">Event loops</a><br>
<a href="#Hello World">Hello World</a><br>
<a href="#Default loop">Default loop</a><br>
<a href="#Error handling">Error handling</a><br>
<a href="#Handles and Requests">Handles and Requests</a><br>
<a href="#Idling">Idling</a><br>
<a href="#Storing context">Storing context</a><br>
<a href="#Filesystem">Filesystem</a><br>
<a href="#Reading/Writing files">Reading/Writing files</a><br>
<a href="#Filesystem operations">Filesystem operations</a><br>
<a href="#Buffers and Streams">Buffers and Streams</a><br>
<a href="#File change events">File change events</a><br>
<a href="#Networking">Networking</a><br>
<a href="#TCP">TCP</a><br>
<a href="#Server">Server</a><br>
<a href="#Client">Client</a><br>
<a href="#UDP">UDP</a><br>
<a href="#UDP Options">UDP Options</a><br>
<a href="#Time-to-live">Time-to-live</a><br>
<a href="#IPv6 stack only">IPv6 stack only</a><br>
<a href="#Multicast">Multicast</a><br>
<a href="#Querying DNS">Querying DNS</a><br>
<a href="#Network interfaces">Network interfaces</a><br>
<a href="#Threads">Threads</a><br>
<a href="#Core thread operations">Core thread operations</a><br>
<a href="#Synchronization Primitives">Synchronization Primitives</a><br>
<a href="#Mutexes">Mutexes</a><br>
<a href="#Locks">Locks</a><br>
<a href="#Others">Others</a><br>
<a href="#libuv work queue">libuv work queue</a><br>
<a href="#Inter-thread communication">Inter-thread communication</a><br>
<a href="#Processes">Processes</a><br>
<a href="#Spawning child processes">Spawning child processes</a><br>
<a href="#Changing process parameters">Changing process parameters</a><br>
<a href="#Change execution directory">Change execution directory</a><br>
<a href="#Set environment variables">Set environment variables</a><br>
<a href="#Option flags">Option flags</a><br>
<a href="#Detaching processes">Detaching processes</a><br>
<a href="#Sending signals to processes">Sending signals to processes</a><br>
<a href="#Signals">Signals</a><br>
<a href="#Child Process I/O">Child Process I/O</a><br>
<a href="#Parent-child IPC">Parent-child IPC</a><br>
<a href="#New stdio Pipes">New stdio Pipes</a><br>
<a href="#Arbitrary process IPC">Arbitrary process IPC</a><br>
<a href="#Sending file descriptors over pipes">Sending file descriptors over pipes</a><br>
<a href="#Advanced event loops">Advanced event loops</a><br>
<a href="#Stopping an event loop">Stopping an event loop</a><br>
<a href="#Utilities">Utilities</a><br>
<a href="#Timers">Timers</a><br>
<a href="#Event loop reference count">Event loop reference count</a><br>
<a href="#Idler pattern">Idler pattern</a><br>
<a href="#Passing data to worker thread">Passing data to worker thread</a><br>
<a href="#External I/O with polling">External I/O with polling</a><br>
<a href="#Check &amp; Prepare watchers">Check &amp; Prepare watchers</a><br>
<a href="#Loading libraries">Loading libraries</a><br>
<a href="#TTY">TTY</a><br>
<a href="#About">About</a><br>
<a href="#Upgrading">Upgrading</a><br>
<a href="#libuv 0.10 -&gt; 1.0.0 migration guide">libuv 0.10 -&gt; 1.0.0 migration guide</a><br>
<a href="#Loop initialization and closing">Loop initialization and closing</a><br>
<a href="#Error handling">Error handling</a><br>
<a href="#Threadpool changes">Threadpool changes</a><br>
<a href="#Allocation callback API change">Allocation callback API change</a><br>
<a href="#Unification of IPv4 / IPv6 APIs">Unification of IPv4 / IPv6 APIs</a><br>
<a href="#Streams / UDP data receive callback API change">Streams / UDP data receive callback API change</a><br>
<a href="#Receiving handles over pipes API change">Receiving handles over pipes API change</a><br>
<a href="#Extracting the file descriptor out of a handle">Extracting the file descriptor out of a handle</a><br>
<a href="#uv_fs_readdir rename and API change">uv_fs_readdir rename and API change</a><br>
<a href="#DOWNLOADS">DOWNLOADS</a><br>
<a href="#INSTALLATION">INSTALLATION</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">libuv - libuv
documentation</p>

<h2>OVERVIEW
<a name="OVERVIEW"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">libuv is a
multi-platform support library with a focus on asynchronous
I/O. It was primarily developed for use by <i>Node.js</i>,
but it's also used by <i>Luvit</i>, <i>Julia</i>,
<i>uvloop</i>, and <i>others</i>.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">In case you find errors in this
documentation you can help by sending <i>pull
requests</i>!</p>

<h2>FEATURES
<a name="FEATURES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">Full-featured event loop backed
by epoll, kqueue, IOCP, event ports.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Asynchronous TCP and UDP sockets</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Asynchronous DNS resolution</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Asynchronous file and file system operations</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>File system events</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>ANSI escape code controlled TTY</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>IPC with socket sharing, using Unix domain sockets or
named pipes (Windows)</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Child processes</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Thread pool</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Signal handling</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>High resolution clock</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Threading and synchronization primitives</p></td></tr>
</table>

<h2>DOCUMENTATION
<a name="DOCUMENTATION"></a>
</h2>


<h3>Design overview
<a name="Design overview"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv is
cross-platform support library which was originally written
for <i>Node.js</i>. It's designed around the event-driven
asynchronous I/O model.</p>

<p style="margin-left:9%; margin-top: 1em">The library
provides much more than a simple abstraction over different
I/O polling mechanisms: 'handles' and 'streams' provide a
high level abstraction for sockets and other entities;
cross-platform file I/O and threading functionality is also
provided, amongst other things.</p>

<p style="margin-left:9%; margin-top: 1em">Here is a
diagram illustrating the different parts that compose libuv
and what subsystem they relate to: [image]</p>

<h3>Handles and requests
<a name="Handles and requests"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv provides
users with 2 abstractions to work with, in combination with
the event loop: handles and requests.</p>

<p style="margin-left:9%; margin-top: 1em">Handles
represent long-lived objects capable of performing certain
operations while active. Some examples:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">A prepare handle gets its
callback called once every loop iteration when active.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>A TCP server handle that gets its connection callback
called every time there is a new connection.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Requests
represent (typically) short-lived operations. These
operations can be performed over a handle: write requests
are used to write data on a handle; or standalone:
getaddrinfo requests don't need a handle they run directly
on the loop.</p>

<h3>The I/O loop
<a name="The I/O loop"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The I/O (or
event) loop is the central part of libuv. It establishes the
content for all I/O operations, and it's meant to be tied to
a single thread. One can run multiple event loops as long as
each runs in a different thread. The libuv event loop (or
any other API involving the loop or handles, for that
matter) <b>is not thread-safe</b> except where stated
otherwise.</p>

<p style="margin-left:9%; margin-top: 1em">The event loop
follows the rather usual single threaded asynchronous I/O
approach: all (network) I/O is performed on non-blocking
sockets which are polled using the best mechanism available
on the given platform: epoll on Linux, kqueue on OSX and
other BSDs, event ports on SunOS and IOCP on Windows. As
part of a loop iteration the loop will block waiting for I/O
activity on sockets which have been added to the poller and
callbacks will be fired indicating socket conditions
(readable, writable hangup) so handles can read, write or
perform the desired I/O operation.</p>

<p style="margin-left:9%; margin-top: 1em">In order to
better understand how the event loop operates, the following
diagram illustrates all stages of a loop iteration:
[image]</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">The loop concept of 'now' is
initially set.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>2.</p></td>
<td width="2%"></td>
<td width="86%">


<p>Due timers are run if the loop was run with
<b>UV_RUN_DEFAULT</b>. All active timers scheduled for a
time before the loop's concept of <i>now</i> get their
callbacks called.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>3.</p></td>
<td width="2%"></td>
<td width="86%">


<p>If the loop is <i>alive</i> an iteration is started,
otherwise the loop will exit immediately. So, when is a loop
considered to be <i>alive</i>? If a loop has active and
ref'd handles, active requests or closing handles it's
considered to be <i>alive</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>4.</p></td>
<td width="2%"></td>
<td width="86%">


<p>Pending callbacks are called. All I/O callbacks are
called right after polling for I/O, for the most part. There
are cases, however, in which calling such a callback is
deferred for the next loop iteration. If the previous
iteration deferred any I/O callback it will be run at this
point.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>5.</p></td>
<td width="2%"></td>
<td width="86%">


<p>Idle handle callbacks are called. Despite the
unfortunate name, idle handles are run on every loop
iteration, if they are active.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>6.</p></td>
<td width="2%"></td>
<td width="86%">


<p>Prepare handle callbacks are called. Prepare handles get
their callbacks called right before the loop will block for
I/O.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>7.</p></td>
<td width="2%"></td>
<td width="86%">


<p>Poll timeout is calculated. Before blocking for I/O the
loop calculates for how long it should block. These are the
rules when calculating the timeout:</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%"></td>
<td width="2%"></td>
<td width="79%">


<p style="margin-top: 1em">If the loop was run with the
<b>UV_RUN_NOWAIT</b> flag, the timeout is 0.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>If the loop is going to be stopped (<i>uv_stop()</i> was
called), the timeout is 0.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>If there are no active handles or requests, the timeout
is 0.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>If there are any idle handles active, the timeout is
0.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>If there are any handles pending to be closed, the
timeout is 0.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>If none of the above cases matches, the timeout of the
closest timer is taken, or if there are no active timers,
infinity.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">


<p>8.</p></td>
<td width="2%"></td>
<td width="79%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">The loop blocks
for I/O. At this point the loop will block for I/O for the
duration calculated in the previous step. All I/O related
handles that were monitoring a given file descriptor for a
read or write operation get their callbacks called at this
point.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p style="margin-top: 1em">9.</p></td>
<td width="1%"></td>
<td width="86%">


<p style="margin-top: 1em">Check handle callbacks are
called. Check handles get their callbacks called right after
the loop has blocked for I/O. Check handles are essentially
the counterpart of prepare handles.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>10.</p></td>
<td width="1%"></td>
<td width="86%">


<p>Close callbacks are called. If a handle was closed by
calling <i>uv_close()</i> it will get the close callback
called.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>11.</p></td>
<td width="1%"></td>
<td width="86%">


<p>The loop concept of 'now' is updated.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>12.</p></td>
<td width="1%"></td>
<td width="86%">


<p>Due timers are run. Note that 'now' is not updated again
until the next loop iteration. So if a timer became due
while other timers were being processed, it won't be run
until the following event loop iteration.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>13.</p></td>
<td width="1%"></td>
<td width="86%">


<p>Iteration ends. If the loop was run with
<b>UV_RUN_NOWAIT</b> or <b>UV_RUN_ONCE</b> modes the
iteration ends and <i>uv_run()</i> will return. If the loop
was run with <b>UV_RUN_DEFAULT</b> it will continue from the
start if it's still <i>alive</i>, otherwise it will also
end.</p> </td></tr>
</table>


<p style="margin-left:9%; margin-top: 1em"><b>IMPORTANT:</b></p>

<p style="margin-left:13%;">libuv uses a thread pool to
make asynchronous file I/O operations possible, but network
I/O is <b>always</b> performed in a single thread, each
loop's thread.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">While the polling mechanism is
different, libuv makes the execution model consistent across
Unix systems and Windows.</p>

<h3>File I/O
<a name="File I/O"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Unlike network
I/O, there are no platform-specific file I/O primitives
libuv could rely on, so the current approach is to run
blocking file I/O operations in a thread pool.</p>

<p style="margin-left:9%; margin-top: 1em">For a thorough
explanation of the cross-platform file I/O landscape, check
out <i>this post</i>.</p>

<p style="margin-left:9%; margin-top: 1em">libuv currently
uses a global thread pool on which all loops can queue work.
3 types of operations are currently run on this pool:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="56%">


<p style="margin-top: 1em">File system operations</p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="56%">


<p>DNS functions (getaddrinfo and getnameinfo)</p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="56%">


<p>User specified code via <i>uv_queue_work()</i></p></td>
<td width="29%">
</td></tr>
</table>


<p style="margin-left:9%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:13%;">See the <i>Thread pool work
scheduling</i> section for more details, but keep in mind
the thread pool size is quite limited.</p>

<h3>API documentation
<a name="API documentation"></a>
</h3>


<h3>Error handling
<a name="Error handling"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">In libuv errors
are negative numbered constants. As a rule of thumb,
whenever there is a status parameter, or an API functions
returns an integer, a negative number will imply an
error.</p>

<p style="margin-left:9%; margin-top: 1em">When a function
which takes a callback returns an error, the callback will
never be called.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">Implementation detail: on Unix
error codes are the negated <i>errno</i> (or <i>-errno</i>),
while on Windows they are defined by libuv to arbitrary
negative numbers.</p>

<h3>Error constants
<a name="Error constants"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>UV_E2BIG</b></p>

<p style="margin-left:18%;">argument list too long</p>

<p style="margin-left:9%;"><b>UV_EACCES</b></p>

<p style="margin-left:18%;">permission denied</p>

<p style="margin-left:9%;"><b>UV_EADDRINUSE</b></p>

<p style="margin-left:18%;">address already in use</p>

<p style="margin-left:9%;"><b>UV_EADDRNOTAVAIL</b></p>

<p style="margin-left:18%;">address not available</p>

<p style="margin-left:9%;"><b>UV_EAFNOSUPPORT</b></p>

<p style="margin-left:18%;">address family not
supported</p>

<p style="margin-left:9%;"><b>UV_EAGAIN</b></p>

<p style="margin-left:18%;">resource temporarily
unavailable</p>

<p style="margin-left:9%;"><b>UV_EAI_ADDRFAMILY</b></p>

<p style="margin-left:18%;">address family not
supported</p>

<p style="margin-left:9%;"><b>UV_EAI_AGAIN</b></p>

<p style="margin-left:18%;">temporary failure</p>

<p style="margin-left:9%;"><b>UV_EAI_BADFLAGS</b></p>

<p style="margin-left:18%;">bad ai_flags value</p>

<p style="margin-left:9%;"><b>UV_EAI_BADHINTS</b></p>

<p style="margin-left:18%;">invalid value for hints</p>

<p style="margin-left:9%;"><b>UV_EAI_CANCELED</b></p>

<p style="margin-left:18%;">request canceled</p>

<p style="margin-left:9%;"><b>UV_EAI_FAIL</b></p>

<p style="margin-left:18%;">permanent failure</p>

<p style="margin-left:9%;"><b>UV_EAI_FAMILY</b></p>

<p style="margin-left:18%;">ai_family not supported</p>

<p style="margin-left:9%;"><b>UV_EAI_MEMORY</b></p>

<p style="margin-left:18%;">out of memory</p>

<p style="margin-left:9%;"><b>UV_EAI_NODATA</b></p>

<p style="margin-left:18%;">no address</p>

<p style="margin-left:9%;"><b>UV_EAI_NONAME</b></p>

<p style="margin-left:18%;">unknown node or service</p>

<p style="margin-left:9%;"><b>UV_EAI_OVERFLOW</b></p>

<p style="margin-left:18%;">argument buffer overflow</p>

<p style="margin-left:9%;"><b>UV_EAI_PROTOCOL</b></p>

<p style="margin-left:18%;">resolved protocol is
unknown</p>

<p style="margin-left:9%;"><b>UV_EAI_SERVICE</b></p>

<p style="margin-left:18%;">service not available for
socket type</p>

<p style="margin-left:9%;"><b>UV_EAI_SOCKTYPE</b></p>

<p style="margin-left:18%;">socket type not supported</p>

<p style="margin-left:9%;"><b>UV_EALREADY</b></p>

<p style="margin-left:18%;">connection already in
progress</p>

<p style="margin-left:9%;"><b>UV_EBADF</b></p>

<p style="margin-left:18%;">bad file descriptor</p>

<p style="margin-left:9%;"><b>UV_EBUSY</b></p>

<p style="margin-left:18%;">resource busy or locked</p>

<p style="margin-left:9%;"><b>UV_ECANCELED</b></p>

<p style="margin-left:18%;">operation canceled</p>

<p style="margin-left:9%;"><b>UV_ECHARSET</b></p>

<p style="margin-left:18%;">invalid Unicode character</p>

<p style="margin-left:9%;"><b>UV_ECONNABORTED</b></p>

<p style="margin-left:18%;">software caused connection
abort</p>

<p style="margin-left:9%;"><b>UV_ECONNREFUSED</b></p>

<p style="margin-left:18%;">connection refused</p>

<p style="margin-left:9%;"><b>UV_ECONNRESET</b></p>

<p style="margin-left:18%;">connection reset by peer</p>

<p style="margin-left:9%;"><b>UV_EDESTADDRREQ</b></p>

<p style="margin-left:18%;">destination address
required</p>

<p style="margin-left:9%;"><b>UV_EEXIST</b></p>

<p style="margin-left:18%;">file already exists</p>

<p style="margin-left:9%;"><b>UV_EFAULT</b></p>

<p style="margin-left:18%;">bad address in system call
argument</p>

<p style="margin-left:9%;"><b>UV_EFBIG</b></p>

<p style="margin-left:18%;">file too large</p>

<p style="margin-left:9%;"><b>UV_EHOSTUNREACH</b></p>

<p style="margin-left:18%;">host is unreachable</p>

<p style="margin-left:9%;"><b>UV_EINTR</b></p>

<p style="margin-left:18%;">interrupted system call</p>

<p style="margin-left:9%;"><b>UV_EINVAL</b></p>

<p style="margin-left:18%;">invalid argument</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p><b>UV_EIO</b></p></td>
<td width="1%"></td>
<td width="11%">


<p>i/o error</p></td>
<td width="71%">
</td></tr>
</table>

<p style="margin-left:9%;"><b>UV_EISCONN</b></p>

<p style="margin-left:18%;">socket is already connected</p>

<p style="margin-left:9%;"><b>UV_EISDIR</b></p>

<p style="margin-left:18%;">illegal operation on a
directory</p>

<p style="margin-left:9%;"><b>UV_ELOOP</b></p>

<p style="margin-left:18%;">too many symbolic links
encountered</p>

<p style="margin-left:9%;"><b>UV_EMFILE</b></p>

<p style="margin-left:18%;">too many open files</p>

<p style="margin-left:9%;"><b>UV_EMSGSIZE</b></p>

<p style="margin-left:18%;">message too long</p>

<p style="margin-left:9%;"><b>UV_ENAMETOOLONG</b></p>

<p style="margin-left:18%;">name too long</p>

<p style="margin-left:9%;"><b>UV_ENETDOWN</b></p>

<p style="margin-left:18%;">network is down</p>

<p style="margin-left:9%;"><b>UV_ENETUNREACH</b></p>

<p style="margin-left:18%;">network is unreachable</p>

<p style="margin-left:9%;"><b>UV_ENFILE</b></p>

<p style="margin-left:18%;">file table overflow</p>

<p style="margin-left:9%;"><b>UV_ENOBUFS</b></p>

<p style="margin-left:18%;">no buffer space available</p>

<p style="margin-left:9%;"><b>UV_ENODEV</b></p>

<p style="margin-left:18%;">no such device</p>

<p style="margin-left:9%;"><b>UV_ENOENT</b></p>

<p style="margin-left:18%;">no such file or directory</p>

<p style="margin-left:9%;"><b>UV_ENOMEM</b></p>

<p style="margin-left:18%;">not enough memory</p>

<p style="margin-left:9%;"><b>UV_ENONET</b></p>

<p style="margin-left:18%;">machine is not on the
network</p>

<p style="margin-left:9%;"><b>UV_ENOPROTOOPT</b></p>

<p style="margin-left:18%;">protocol not available</p>

<p style="margin-left:9%;"><b>UV_ENOSPC</b></p>

<p style="margin-left:18%;">no space left on device</p>

<p style="margin-left:9%;"><b>UV_ENOSYS</b></p>

<p style="margin-left:18%;">function not implemented</p>

<p style="margin-left:9%;"><b>UV_ENOTCONN</b></p>

<p style="margin-left:18%;">socket is not connected</p>

<p style="margin-left:9%;"><b>UV_ENOTDIR</b></p>

<p style="margin-left:18%;">not a directory</p>

<p style="margin-left:9%;"><b>UV_ENOTEMPTY</b></p>

<p style="margin-left:18%;">directory not empty</p>

<p style="margin-left:9%;"><b>UV_ENOTSOCK</b></p>

<p style="margin-left:18%;">socket operation on
non-socket</p>

<p style="margin-left:9%;"><b>UV_ENOTSUP</b></p>

<p style="margin-left:18%;">operation not supported on
socket</p>

<p style="margin-left:9%;"><b>UV_EOVERFLOW</b></p>

<p style="margin-left:18%;">value too large for defined
data type</p>

<p style="margin-left:9%;"><b>UV_EPERM</b></p>

<p style="margin-left:18%;">operation not permitted</p>

<p style="margin-left:9%;"><b>UV_EPIPE</b></p>

<p style="margin-left:18%;">broken pipe</p>

<p style="margin-left:9%;"><b>UV_EPROTO</b></p>

<p style="margin-left:18%;">protocol error</p>

<p style="margin-left:9%;"><b>UV_EPROTONOSUPPORT</b></p>

<p style="margin-left:18%;">protocol not supported</p>

<p style="margin-left:9%;"><b>UV_EPROTOTYPE</b></p>

<p style="margin-left:18%;">protocol wrong type for
socket</p>

<p style="margin-left:9%;"><b>UV_ERANGE</b></p>

<p style="margin-left:18%;">result too large</p>

<p style="margin-left:9%;"><b>UV_EROFS</b></p>

<p style="margin-left:18%;">read-only file system</p>

<p style="margin-left:9%;"><b>UV_ESHUTDOWN</b></p>

<p style="margin-left:18%;">cannot send after transport
endpoint shutdown</p>

<p style="margin-left:9%;"><b>UV_ESPIPE</b></p>

<p style="margin-left:18%;">invalid seek</p>

<p style="margin-left:9%;"><b>UV_ESRCH</b></p>

<p style="margin-left:18%;">no such process</p>

<p style="margin-left:9%;"><b>UV_ETIMEDOUT</b></p>

<p style="margin-left:18%;">connection timed out</p>

<p style="margin-left:9%;"><b>UV_ETXTBSY</b></p>

<p style="margin-left:18%;">text file is busy</p>

<p style="margin-left:9%;"><b>UV_EXDEV</b></p>

<p style="margin-left:18%;">cross-device link not
permitted</p>

<p style="margin-left:9%;"><b>UV_UNKNOWN</b></p>

<p style="margin-left:18%;">unknown error</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p><b>UV_EOF</b></p></td>
<td width="1%"></td>
<td width="14%">


<p>end of file</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:9%;"><b>UV_ENXIO</b></p>

<p style="margin-left:18%;">no such device or address</p>

<p style="margin-left:9%;"><b>UV_EMLINK</b></p>

<p style="margin-left:18%;">too many links</p>

<p style="margin-left:9%;"><b>UV_ENOTTY</b></p>

<p style="margin-left:18%;">inappropriate ioctl for
device</p>

<p style="margin-left:9%;"><b>UV_EFTYPE</b></p>

<p style="margin-left:18%;">inappropriate file type or
format</p>

<p style="margin-left:9%;"><b>UV_EILSEQ</b></p>

<p style="margin-left:18%;">illegal byte sequence</p>

<p style="margin-left:9%;"><b>UV_ESOCKTNOSUPPORT</b></p>

<p style="margin-left:18%;">socket type not supported</p>

<p style="margin-left:9%;"><b>UV_EUNATCH</b></p>

<p style="margin-left:18%;">protocol driver not
attached</p>

<h3>API
<a name="API"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>UV_ERRNO_MAP(iter_macro)</b></p>

<p style="margin-left:18%;">Macro that expands to a series
of invocations of <i>iter_macro</i> for each of the error
constants above. <i>iter_macro</i> is invoked with two
arguments: the name of the error constant without the
<i>UV_</i> prefix, and the error message string literal.</p>

<p style="margin-left:9%;"><b>const char *uv_strerror(int
err)</b></p>

<p style="margin-left:18%;">Returns the error message for
the given error code. Leaks a few bytes of memory when you
call it with an unknown error code.</p>

<p style="margin-left:9%;"><b>char *uv_strerror_r(int err,
char *buf, size_t buflen)</b></p>

<p style="margin-left:18%;">Returns the error message for
the given error code. The zero-terminated message is stored
in the user-supplied buffer <i>buf</i> of at most
<i>buflen</i> bytes.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.22.0.</p>

<p style="margin-left:9%;"><b>const char *uv_err_name(int
err)</b></p>

<p style="margin-left:18%;">Returns the error name for the
given error code. Leaks a few bytes of memory when you call
it with an unknown error code.</p>

<p style="margin-left:9%;"><b>char *uv_err_name_r(int err,
char *buf, size_t buflen)</b></p>

<p style="margin-left:18%;">Returns the error name for the
given error code. The zero-terminated name is stored in the
user-supplied buffer <i>buf</i> of at most <i>buflen</i>
bytes.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.22.0.</p>

<p style="margin-left:9%;"><b>int
uv_translate_sys_error(int sys_errno)</b></p>

<p style="margin-left:18%;">Returns the libuv error code
equivalent to the given platform dependent error code: POSIX
error codes on Unix (the ones stored in <i>errno</i>), and
Win32 error codes on Windows (those returned by
<i>GetLastError()</i> or <i>WSAGetLastError()</i>).</p>

<p style="margin-left:18%; margin-top: 1em">If
<i>sys_errno</i> is already a libuv error, it is simply
returned.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.10.0: function declared public.</p>

<h3>Version-checking macros and functions
<a name="Version-checking macros and functions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Starting with
version 1.0.0 libuv follows the <i>semantic versioning</i>
scheme. This means that new APIs can be introduced
throughout the lifetime of a major release. In this section
you'll find all macros and functions that will allow you to
write or compile code conditionally, in order to work with
multiple libuv versions.</p>

<h3>Macros
<a name="Macros"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>UV_VERSION_MAJOR</b></p>

<p style="margin-left:18%;">libuv version's major
number.</p>

<p style="margin-left:9%;"><b>UV_VERSION_MINOR</b></p>

<p style="margin-left:18%;">libuv version's minor
number.</p>

<p style="margin-left:9%;"><b>UV_VERSION_PATCH</b></p>

<p style="margin-left:18%;">libuv version's patch
number.</p>


<p style="margin-left:9%;"><b>UV_VERSION_IS_RELEASE</b></p>

<p style="margin-left:18%;">Set to 1 to indicate a release
version of libuv, 0 for a development snapshot.</p>

<p style="margin-left:9%;"><b>UV_VERSION_SUFFIX</b></p>

<p style="margin-left:18%;">libuv version suffix. Certain
development releases such as Release Candidates might have a
suffix such as &quot;rc&quot;.</p>

<p style="margin-left:9%;"><b>UV_VERSION_HEX</b></p>

<p style="margin-left:18%;">Returns the libuv version
packed into a single integer. 8 bits are used for each
component, with the patch number stored in the 8 least
significant bits. E.g. for libuv 1.2.3 this would be
0x010203.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.7.0.</p>

<h3>Functions
<a name="Functions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>unsigned int
uv_version(void)</b></p>

<p style="margin-left:18%;">Returns
<i>UV_VERSION_HEX</i>.</p>

<p style="margin-left:9%;"><b>const char
*uv_version_string(void)</b></p>

<p style="margin-left:18%;">Returns the libuv version
number as a string. For non-release versions the version
suffix is included.</p>

<h3>uv_loop_t --- Event loop
<a name="uv_loop_t --- Event loop"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The event loop
is the central part of libuv's functionality. It takes care
of polling for i/o and scheduling callbacks to be run based
on different sources of events.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_loop_t</b></p>

<p style="margin-left:18%;">Loop data type.</p>

<p style="margin-left:9%;"><b>enum uv_loop_option</b></p>

<p style="margin-left:18%;">Additional loop options. See
<i>uv_loop_configure()</i>.</p>

<p style="margin-left:22%; margin-top: 1em">typedef enum {
<br>
UV_LOOP_BLOCK_SIGNAL = 0, <br>
UV_METRICS_IDLE_TIME, <br>
UV_LOOP_USE_IO_URING_SQPOLL <br>
} uv_loop_option;</p>

<p style="margin-left:9%;"><b>enum uv_run_mode</b></p>

<p style="margin-left:18%;">Mode used to run the loop with
<i>uv_run()</i>.</p>

<p style="margin-left:22%; margin-top: 1em">typedef enum {
<br>
UV_RUN_DEFAULT = 0, <br>
UV_RUN_ONCE, <br>
UV_RUN_NOWAIT <br>
} uv_run_mode;</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_walk_cb)(</b><i>uv_handle_t</i> <b>*handle, void
*arg)</b></p>

<p style="margin-left:18%;">Type definition for callback
passed to <i>uv_walk()</i>.</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>void
*</b><i>uv_loop_t</i><b>.data</b></p>

<p style="margin-left:18%;">Space for user-defined
arbitrary data. libuv does not use and does not touch this
field.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_loop_init(</b><i>uv_loop_t</i> <b>*loop)</b></p>

<p style="margin-left:18%;">Initializes the given
<i>uv_loop_t</i> structure.</p>

<p style="margin-left:9%;"><b>int
uv_loop_configure(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_loop_option</i> <b>option, ...)</b></p>

<p style="margin-left:18%;">Added in version 1.0.2.</p>

<p style="margin-left:18%; margin-top: 1em">Set additional
loop options. You should normally call this before the first
call to <i>uv_run()</i> unless mentioned otherwise.</p>

<p style="margin-left:18%; margin-top: 1em">Returns 0 on
success or a UV_E* error code on failure. Be prepared to
handle UV_ENOSYS; it means the loop option is not supported
by the platform.</p>

<p style="margin-left:18%; margin-top: 1em">Supported
options:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>UV_LOOP_BLOCK_SIGNAL: Block a signal when polling for
new events. The second argument to
<i>uv_loop_configure()</i> is the signal number.</p></td></tr>
</table>

<p style="margin-left:21%; margin-top: 1em">This operation
is currently only implemented for SIGPROF signals, to
suppress unnecessary wakeups when using a sampling profiler.
Requesting other signals will fail with UV_EINVAL.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p style="margin-top: 1em">UV_METRICS_IDLE_TIME: Accumulate
the amount of idle time the event loop spends in the event
provider.</p> </td></tr>
</table>

<p style="margin-left:21%; margin-top: 1em">This option is
necessary to use <i>uv_metrics_idle_time()</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p style="margin-top: 1em">UV_LOOP_ENABLE_IO_URING_SQPOLL:
Enable SQPOLL io_uring instance to handle asynchronous file
system operations.</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.39.0: added the UV_METRICS_IDLE_TIME option.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.49.0: added the UV_LOOP_ENABLE_IO_URING_SQPOLL
option.</p>

<p style="margin-left:9%;"><b>int
uv_loop_close(</b><i>uv_loop_t</i> <b>*loop)</b></p>

<p style="margin-left:18%;">Releases all internal loop
resources. Call this function only when the loop has
finished executing and all open handles and requests have
been closed, or it will return UV_EBUSY. After this function
returns, the user can free the memory allocated for the
loop.</p>

<p style="margin-left:9%;"><i>uv_loop_t</i>
<b>*uv_default_loop(void)</b></p>

<p style="margin-left:18%;">Returns the initialized default
loop. It may return NULL in case of allocation failure.</p>

<p style="margin-left:18%; margin-top: 1em">This function
is just a convenient way for having a global loop throughout
an application, the default loop is in no way different than
the ones initialized with <i>uv_loop_init()</i>. As such,
the default loop can (and should) be closed with
<i>uv_loop_close()</i> so the resources associated with it
are freed.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">This function is not thread
safe.</p>

<p style="margin-left:9%;"><b>int
uv_run(</b><i>uv_loop_t</i> <b>*loop,</b> <i>uv_run_mode</i>
<b>mode)</b></p>

<p style="margin-left:18%;">This function runs the event
loop. It will act differently depending on the specified
mode:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>UV_RUN_DEFAULT: Runs the event loop until there are no
more active and referenced handles or requests. Returns
non-zero if <i>uv_stop()</i> was called and there are still
active handles or requests. Returns zero in all other
cases.</p> </td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>UV_RUN_ONCE: Poll for i/o once. Note that this function
blocks if there are no pending callbacks. Returns zero when
done (no active handles or requests left), or non-zero if
more callbacks are expected (meaning you should run the
event loop again sometime in the future).</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>UV_RUN_NOWAIT: Poll for i/o once but don't block if
there are no pending callbacks. Returns zero if done (no
active handles or requests left), or non-zero if more
callbacks are expected (meaning you should run the event
loop again sometime in the future).</p></td></tr>
</table>


<p style="margin-left:18%; margin-top: 1em"><i>uv_run()</i>
is not reentrant. It must not be called from a callback.</p>

<p style="margin-left:9%;"><b>int uv_loop_alive(const</b>
<i>uv_loop_t</i> <b>*loop)</b></p>

<p style="margin-left:18%;">Returns non-zero if there are
referenced active handles, active requests or closing
handles in the loop.</p>

<p style="margin-left:9%;"><b>void
uv_stop(</b><i>uv_loop_t</i> <b>*loop)</b></p>

<p style="margin-left:18%;">Stop the event loop, causing
<i>uv_run()</i> to end as soon as possible. This will happen
not sooner than the next loop iteration. If this function
was called before blocking for i/o, the loop won't block for
i/o on this iteration.</p>

<p style="margin-left:9%;"><b>size_t
uv_loop_size(void)</b></p>

<p style="margin-left:18%;">Returns the size of the
<i>uv_loop_t</i> structure. Useful for FFI binding writers
who don't want to know the structure layout.</p>

<p style="margin-left:9%;"><b>int uv_backend_fd(const</b>
<i>uv_loop_t</i> <b>*loop)</b></p>

<p style="margin-left:18%;">Get backend file descriptor.
Only kqueue, epoll and event ports are supported.</p>

<p style="margin-left:18%; margin-top: 1em">This can be
used in conjunction with <i>uv_run(loop, UV_RUN_NOWAIT)</i>
to poll in one thread and run the event loop's callbacks in
another see test/test-embed.c for an example.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Embedding a kqueue fd in
another kqueue pollset doesn't work on all platforms. It's
not an error to add the fd but it never generates
events.</p>

<p style="margin-left:9%;"><b>int
uv_backend_timeout(const</b> <i>uv_loop_t</i>
<b>*loop)</b></p>

<p style="margin-left:18%;">Get the poll timeout. The
return value is in milliseconds, or -1 for no timeout.</p>

<p style="margin-left:9%;"><b>uint64_t uv_now(const</b>
<i>uv_loop_t</i> <b>*loop)</b></p>

<p style="margin-left:18%;">Return the current timestamp in
milliseconds. The timestamp is cached at the start of the
event loop tick, see <i>uv_update_time()</i> for details and
rationale.</p>

<p style="margin-left:18%; margin-top: 1em">The timestamp
increases monotonically from some arbitrary point in time.
Don't make assumptions about the starting point, you will
only get disappointed.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Use <i>uv_hrtime()</i> if you
need sub-millisecond granularity.</p>

<p style="margin-left:9%;"><b>void
uv_update_time(</b><i>uv_loop_t</i> <b>*loop)</b></p>

<p style="margin-left:18%;">Update the event loop's concept
of &quot;now&quot;. Libuv caches the current time at the
start of the event loop tick in order to reduce the number
of time-related system calls.</p>

<p style="margin-left:18%; margin-top: 1em">You won't
normally need to call this function unless you have
callbacks that block the event loop for longer periods of
time, where &quot;longer&quot; is somewhat subjective but
probably on the order of a millisecond or more.</p>

<p style="margin-left:9%;"><b>void
uv_walk(</b><i>uv_loop_t</i> <b>*loop,</b> <i>uv_walk_cb</i>
<b>walk_cb, void *arg)</b></p>

<p style="margin-left:18%;">Walk the list of handles:
<i>walk_cb</i> will be executed with the given
<i>arg</i>.</p>

<p style="margin-left:9%;"><b>int
uv_loop_fork(</b><i>uv_loop_t</i> <b>*loop)</b></p>

<p style="margin-left:18%;">Added in version 1.12.0.</p>

<p style="margin-left:18%; margin-top: 1em">Reinitialize
any kernel state necessary in the child process after a
<i>fork(2)</i> system call.</p>

<p style="margin-left:18%; margin-top: 1em">Previously
started watchers will continue to be started in the child
process.</p>

<p style="margin-left:18%; margin-top: 1em">It is necessary
to explicitly call this function on every event loop created
in the parent process that you plan to continue to use in
the child, including the default loop (even if you don't
continue to use it in the parent). This function must be
called before calling <i>uv_run()</i> or any other API
function using the loop in the child. Failure to do so will
result in undefined behaviour, possibly including duplicate
events delivered to both parent and child or aborting the
child process.</p>

<p style="margin-left:18%; margin-top: 1em">When possible,
it is preferred to create a new loop in the child process
instead of reusing a loop created in the parent. New loops
created in the child process after the fork should not use
this function.</p>

<p style="margin-left:18%; margin-top: 1em">This function
is not implemented on Windows, where it returns
<b>UV_ENOSYS</b>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>CAUTION:</b></p>

<p style="margin-left:22%;">This function is experimental.
It may contain bugs, and is subject to change or removal.
API and ABI stability is not guaranteed.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">On Mac OS X, if directory FS
event handles were in use in the parent process <i>for any
event loop</i>, the child process will no longer be able to
use the most efficient FSEvent implementation. Instead, uses
of directory FS event handles in the child will fall back to
the same implementation used for files and on other
kqueue-based systems.</p>


<p style="margin-left:18%; margin-top: 1em"><b>CAUTION:</b></p>

<p style="margin-left:22%;">On AIX and SunOS, FS event
handles that were already started in the parent process at
the time of forking will <i>not</i> deliver events in the
child process; they must be closed and restarted. On all
other platforms, they will continue to work normally without
any further intervention.</p>


<p style="margin-left:18%; margin-top: 1em"><b>CAUTION:</b></p>

<p style="margin-left:22%;">Any previous value returned
from <i>uv_backend_fd()</i> is now invalid. That function
must be called again to determine the correct backend file
descriptor.</p>

<p style="margin-left:9%;"><b>void
*uv_loop_get_data(const</b> <i>uv_loop_t</i>
<b>*loop)</b></p>

<p style="margin-left:18%;">Returns
<i>loop-&gt;data</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<p style="margin-left:9%;"><b>void
uv_loop_set_data(</b><i>uv_loop_t</i> <b>*loop, void
*data)</b></p>

<p style="margin-left:18%;">Sets <i>loop-&gt;data</i> to
<i>data</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<h3>uv_handle_t --- Base handle
<a name="uv_handle_t --- Base handle"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>uv_handle_t</i>
is the base type for all libuv handle types.</p>

<p style="margin-left:9%; margin-top: 1em">Structures are
aligned so that any libuv handle can be cast to
<i>uv_handle_t</i>. All API functions defined here work with
any handle type.</p>

<p style="margin-left:9%; margin-top: 1em">Libuv handles
are not movable. Pointers to handle structures passed to
functions must remain valid for the duration of the
requested operation. Take care when using stack allocated
handles.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_handle_t</b></p>

<p style="margin-left:18%;">The base libuv handle type.</p>

<p style="margin-left:9%;"><b>enum uv_handle_type</b></p>

<p style="margin-left:18%;">The kind of the libuv
handle.</p>

<p style="margin-left:22%; margin-top: 1em">typedef enum {
<br>
UV_UNKNOWN_HANDLE = 0, <br>
UV_ASYNC, <br>
UV_CHECK, <br>
UV_FS_EVENT, <br>
UV_FS_POLL, <br>
UV_HANDLE, <br>
UV_IDLE, <br>
UV_NAMED_PIPE, <br>
UV_POLL, <br>
UV_PREPARE, <br>
UV_PROCESS, <br>
UV_STREAM, <br>
UV_TCP, <br>
UV_TIMER, <br>
UV_TTY, <br>
UV_UDP, <br>
UV_SIGNAL, <br>
UV_FILE, <br>
UV_HANDLE_TYPE_MAX <br>
} uv_handle_type;</p>

<p style="margin-left:9%;"><b>type uv_any_handle</b></p>

<p style="margin-left:18%;">Union of all handle types.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_alloc_cb)(</b><i>uv_handle_t</i> <b>*handle, size_t
suggested_size,</b> <i><br>
uv_buf_t</i> <b>*buf)</b></p>

<p style="margin-left:18%;">Type definition for callback
passed to <i>uv_read_start()</i> and
<i>uv_udp_recv_start()</i>. The user must allocate memory
and fill the supplied <i>uv_buf_t</i> structure. If NULL is
assigned as the buffer's base or 0 as its length, a
<b>UV_ENOBUFS</b> error will be triggered in the
<i>uv_udp_recv_cb</i> or the <i>uv_read_cb</i> callback.</p>

<p style="margin-left:18%; margin-top: 1em">Each buffer is
used only once and the user is responsible for freeing it in
the <i>uv_udp_recv_cb</i> or the <i>uv_read_cb</i>
callback.</p>

<p style="margin-left:18%; margin-top: 1em">A suggested
size (65536 at the moment in most cases) is provided, but
it's just an indication, not related in any way to the
pending data to be read. The user is free to allocate the
amount of memory they decide.</p>

<p style="margin-left:18%; margin-top: 1em">As an example,
applications with custom allocation schemes such as using
freelists, allocation pools or slab based allocators may
decide to use a different size which matches the memory
chunks they already have.</p>

<p style="margin-left:18%; margin-top: 1em">Example:</p>

<p style="margin-left:22%; margin-top: 1em">static void
my_alloc_cb(uv_handle_t* handle, size_t suggested_size,
uv_buf_t* buf) { <br>
buf-&gt;base = malloc(suggested_size); <br>
buf-&gt;len = suggested_size; <br>
}</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_close_cb)(</b><i>uv_handle_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Type definition for callback
passed to <i>uv_close()</i>.</p>

<h3>Public members
<a name="Public members"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>uv_loop_t</i>
<b>*</b><i>uv_handle_t</i><b>.loop</b></p>

<p style="margin-left:18%;">Pointer to the <i>uv_loop_t</i>
the handle is running on. Readonly.</p>

<p style="margin-left:9%;"><i>uv_handle_type
uv_handle_t</i><b>.type</b></p>

<p style="margin-left:18%;">The <i>uv_handle_type</i>,
indicating the type of the underlying handle. Readonly.</p>

<p style="margin-left:9%;"><b>void
*</b><i>uv_handle_t</i><b>.data</b></p>

<p style="margin-left:18%;">Space for user-defined
arbitrary data. libuv does not use this field.</p>

<h3>API
<a name="API"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>UV_HANDLE_TYPE_MAP(iter_macro)</b></p>

<p style="margin-left:18%;">Macro that expands to a series
of invocations of <i>iter_macro</i> for each of the handle
types. <i>iter_macro</i> is invoked with two arguments: the
name of the <i>uv_handle_type</i> element without the
<i>UV_</i> prefix, and the name of the corresponding
structure type without the <i>uv_</i> prefix and <i>_t</i>
suffix.</p>

<p style="margin-left:9%;"><b>int uv_is_active(const</b>
<i>uv_handle_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Returns non-zero if the handle
is active, zero if it's inactive. What &quot;active&quot;
means depends on the type of handle:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>A uv_async_t handle is always active and cannot be
deactivated, except by closing it with uv_close().</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>A uv_pipe_t, uv_tcp_t, uv_udp_t, etc. handle - basically
any handle that deals with i/o - is active when it is doing
something that involves i/o, like reading, writing,
connecting, accepting new connections, etc.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>A uv_check_t, uv_idle_t, uv_timer_t, etc. handle is
active when it has been started with a call to
uv_check_start(), uv_idle_start(), etc.</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Rule of thumb:
if a handle of type <i>uv_foo_t</i> has a
<i>uv_foo_start()</i> function, then it's active from the
moment that function is called. Likewise,
<i>uv_foo_stop()</i> deactivates the handle again.</p>

<p style="margin-left:9%;"><b>int uv_is_closing(const</b>
<i>uv_handle_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Returns non-zero if the handle
is closing or closed, zero otherwise.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">This function should only be
used between the initialization of the handle and the
arrival of the close callback.</p>

<p style="margin-left:9%;"><b>void
uv_close(</b><i>uv_handle_t</i> <b>*handle,</b>
<i>uv_close_cb</i> <b>close_cb)</b></p>

<p style="margin-left:18%;">Request handle to be closed.
<i>close_cb</i> will be called asynchronously after this
call. This MUST be called on each handle before memory is
released. Moreover, the memory can only be released in
<i>close_cb</i> or after it has returned.</p>

<p style="margin-left:18%; margin-top: 1em">Handles that
wrap file descriptors are closed immediately but
<i>close_cb</i> will still be deferred to the next iteration
of the event loop. It gives you a chance to free up any
resources associated with the handle.</p>

<p style="margin-left:18%; margin-top: 1em">In-progress
requests, like uv_connect_t or uv_write_t, are cancelled and
have their callbacks called asynchronously with
status=UV_ECANCELED.</p>


<p style="margin-left:18%; margin-top: 1em"><i>close_cb</i>
can be <i>NULL</i> in cases where no cleanup or deallocation
is necessary.</p>

<p style="margin-left:9%;"><b>void
uv_ref(</b><i>uv_handle_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Reference the given handle.
References are idempotent, that is, if a handle is already
referenced calling this function again will have no
effect.</p>

<p style="margin-left:18%; margin-top: 1em">See
<i>Reference counting</i>.</p>

<p style="margin-left:9%;"><b>void
uv_unref(</b><i>uv_handle_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Un-reference the given handle.
References are idempotent, that is, if a handle is not
referenced calling this function again will have no
effect.</p>

<p style="margin-left:18%; margin-top: 1em">See
<i>Reference counting</i>.</p>

<p style="margin-left:9%;"><b>int uv_has_ref(const</b>
<i>uv_handle_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Returns non-zero if the handle
referenced, zero otherwise.</p>

<p style="margin-left:18%; margin-top: 1em">See
<i>Reference counting</i>.</p>

<p style="margin-left:9%;"><b>size_t
uv_handle_size(</b><i>uv_handle_type</i> <b>type)</b></p>

<p style="margin-left:18%;">Returns the size of the given
handle type. Useful for FFI binding writers who don't want
to know the structure layout.</p>

<h3>Miscellaneous API functions
<a name="Miscellaneous API functions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The following
API functions take a <i>uv_handle_t</i> argument but they
work just for some handle types. <b><br>
int uv_send_buffer_size(</b><i>uv_handle_t</i> <b>*handle,
int *value)</b></p>

<p style="margin-left:18%;">Gets or sets the size of the
send buffer that the operating system uses for the
socket.</p>

<p style="margin-left:18%; margin-top: 1em">If
<i>*value</i> == 0, then it will set <i>*value</i> to the
current send buffer size. If <i>*value</i> &gt; 0 then it
will use <i>*value</i> to set the new send buffer size.</p>

<p style="margin-left:18%; margin-top: 1em">On success,
zero is returned. On error, a negative result is
returned.</p>

<p style="margin-left:18%; margin-top: 1em">This function
works for TCP, pipe and UDP handles on Unix and for TCP and
UDP handles on Windows.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Linux will set double the size
and return double the size of the original set value.</p>

<p style="margin-left:9%;"><b>int
uv_recv_buffer_size(</b><i>uv_handle_t</i> <b>*handle, int
*value)</b></p>

<p style="margin-left:18%;">Gets or sets the size of the
receive buffer that the operating system uses for the
socket.</p>

<p style="margin-left:18%; margin-top: 1em">If
<i>*value</i> == 0, then it will set <i>*value</i> to the
current receive buffer size. If <i>*value</i> &gt; 0 then it
will use <i>*value</i> to set the new receive buffer
size.</p>

<p style="margin-left:18%; margin-top: 1em">On success,
zero is returned. On error, a negative result is
returned.</p>

<p style="margin-left:18%; margin-top: 1em">This function
works for TCP, pipe and UDP handles on Unix and for TCP and
UDP handles on Windows.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Linux will set double the size
and return double the size of the original set value.</p>

<p style="margin-left:9%;"><b>int uv_fileno(const</b>
<i>uv_handle_t</i> <b>*handle,</b> <i>uv_os_fd_t</i>
<b>*fd)</b></p>

<p style="margin-left:18%;">Gets the platform dependent
file descriptor equivalent.</p>

<p style="margin-left:18%; margin-top: 1em">The following
handles are supported: TCP, pipes, TTY, UDP and poll.
Passing any other handle type will fail with
<i>UV_EINVAL</i>.</p>

<p style="margin-left:18%; margin-top: 1em">If a handle
doesn't have an attached file descriptor yet or the handle
itself has been closed, this function will return
<i>UV_EBADF</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">Be very careful when using this
function. libuv assumes it's in control of the file
descriptor so any change to it may lead to malfunction.</p>

<p style="margin-left:9%;"><i>uv_loop_t</i>
<b>*uv_handle_get_loop(const</b> <i>uv_handle_t</i>
<b>*handle)</b></p>

<p style="margin-left:18%;">Returns
<i>handle-&gt;loop</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<p style="margin-left:9%;"><b>void
*uv_handle_get_data(const</b> <i>uv_handle_t</i>
<b>*handle)</b></p>

<p style="margin-left:18%;">Returns
<i>handle-&gt;data</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<p style="margin-left:9%;"><b>void
uv_handle_set_data(</b><i>uv_handle_t</i> <b>*handle, void
*data)</b></p>

<p style="margin-left:18%;">Sets <i>handle-&gt;data</i> to
<i>data</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<p style="margin-left:9%;"><i>uv_handle_type</i>
<b>uv_handle_get_type(const</b> <i>uv_handle_t</i>
<b>*handle)</b></p>

<p style="margin-left:18%;">Returns
<i>handle-&gt;type</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<p style="margin-left:9%;"><b>const char
*uv_handle_type_name(</b><i>uv_handle_type</i>
<b>type)</b></p>

<p style="margin-left:18%;">Returns the name for the
equivalent struct for a given handle type, e.g.
<i>&quot;pipe&quot;</i> (as in <i>uv_pipe_t</i>) for
<i>UV_NAMED_PIPE</i>.</p>

<p style="margin-left:18%; margin-top: 1em">If no such
handle type exists, this returns <i>NULL</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<h3>Reference counting
<a name="Reference counting"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The libuv event
loop (if run in the default mode) will run until there are
no active <i>and</i> referenced handles left. The user can
force the loop to exit early by unreferencing handles which
are active, for example by calling <i>uv_unref()</i> after
calling <i>uv_timer_start()</i>.</p>

<p style="margin-left:9%; margin-top: 1em">A handle can be
referenced or unreferenced, the refcounting scheme doesn't
use a counter, so both operations are idempotent.</p>

<p style="margin-left:9%; margin-top: 1em">All handles are
referenced when active by default, see <i>uv_is_active()</i>
for a more detailed explanation on what being <i>active</i>
involves.</p>

<h3>uv_req_t --- Base request
<a name="uv_req_t --- Base request"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><i>uv_req_t</i>
is the base type for all libuv request types.</p>

<p style="margin-left:9%; margin-top: 1em">Structures are
aligned so that any libuv request can be cast to
<i>uv_req_t</i>. All API functions defined here work with
any request type.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_req_t</b></p>

<p style="margin-left:18%;">The base libuv request
structure.</p>

<p style="margin-left:9%;"><b>type uv_any_req</b></p>

<p style="margin-left:18%;">Union of all request types.</p>

<p style="margin-left:9%;"><b>enum uv_req_type</b></p>

<p style="margin-left:18%;">The kind of the libuv
request.</p>

<p style="margin-left:22%; margin-top: 1em">typedef enum {
<br>
UV_UNKNOWN_REQ = 0, <br>
UV_REQ, <br>
UV_CONNECT, <br>
UV_WRITE, <br>
UV_SHUTDOWN, <br>
UV_UDP_SEND, <br>
UV_FS, <br>
UV_WORK, <br>
UV_GETADDRINFO, <br>
UV_GETNAMEINFO, <br>
UV_REQ_TYPE_MAX, <br>
} uv_req_type;</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>void
*</b><i>uv_req_t</i><b>.data</b></p>

<p style="margin-left:18%;">Space for user-defined
arbitrary data. libuv does not use this field.</p>

<p style="margin-left:9%;"><i>uv_req_type
uv_req_t</i><b>.type</b></p>

<p style="margin-left:18%;">The <i>uv_req_type</i>,
indicating the type of the request. Readonly.</p>

<h3>API
<a name="API"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>UV_REQ_TYPE_MAP(iter_macro)</b></p>

<p style="margin-left:18%;">Macro that expands to a series
of invocations of <i>iter_macro</i> for each of the request
types. <i>iter_macro</i> is invoked with two arguments: the
name of the <i>uv_req_type</i> element without the
<i>UV_</i> prefix, and the name of the corresponding
structure type without the <i>uv_</i> prefix and <i>_t</i>
suffix.</p>

<p style="margin-left:9%;"><b>int
uv_cancel(</b><i>uv_req_t</i> <b>*req)</b></p>

<p style="margin-left:18%;">Cancel a pending request. Fails
if the request is executing or has finished executing.</p>

<p style="margin-left:18%; margin-top: 1em">Returns 0 on
success, or an error code &lt; 0 on failure.</p>

<p style="margin-left:18%; margin-top: 1em">Only
cancellation of <i>uv_fs_t</i>, <i>uv_getaddrinfo_t</i>,
<i>uv_getnameinfo_t</i>, <i>uv_random_t</i> and
<i>uv_work_t</i> requests is currently supported.</p>

<p style="margin-left:18%; margin-top: 1em">Cancelled
requests have their callbacks invoked some time in the
future. It's <b>not</b> safe to free the memory associated
with the request until the callback is called.</p>

<p style="margin-left:18%; margin-top: 1em">Here is how
cancellation is reported to the callback:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>A <i>uv_fs_t</i> request has its req-&gt;result field
set to <i>UV_ECANCELED</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>A <i>uv_work_t</i>, <i>uv_getaddrinfo_t</i>,
<i>uv_getnameinfo_t</i> or <i>uv_random_t</i> request has
its callback invoked with status == <i>UV_ECANCELED</i>.</p></td></tr>
</table>

<p style="margin-left:9%;"><b>size_t
uv_req_size(</b><i>uv_req_type</i> <b>type)</b></p>

<p style="margin-left:18%;">Returns the size of the given
request type. Useful for FFI binding writers who don't want
to know the structure layout.</p>

<p style="margin-left:9%;"><b>void
*uv_req_get_data(const</b> <i>uv_req_t</i> <b>*req)</b></p>

<p style="margin-left:18%;">Returns
<i>req-&gt;data</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<p style="margin-left:9%;"><b>void
uv_req_set_data(</b><i>uv_req_t</i> <b>*req, void
*data)</b></p>

<p style="margin-left:18%;">Sets <i>req-&gt;data</i> to
<i>data</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<p style="margin-left:9%;"><i>uv_req_type</i>
<b>uv_req_get_type(const</b> <i>uv_req_t</i>
<b>*req)</b></p>

<p style="margin-left:18%;">Returns
<i>req-&gt;type</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<p style="margin-left:9%;"><b>const char
*uv_req_type_name(</b><i>uv_req_type</i> <b>type)</b></p>

<p style="margin-left:18%;">Returns the name for the
equivalent struct for a given request type, e.g.
<i>&quot;connect&quot;</i> (as in <i>uv_connect_t</i>) for
<i>UV_CONNECT</i>.</p>

<p style="margin-left:18%; margin-top: 1em">If no such
request type exists, this returns <i>NULL</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<h3>uv_timer_t --- Timer handle
<a name="uv_timer_t --- Timer handle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Timer handles
are used to schedule callbacks to be called in the
future.</p>

<p style="margin-left:9%; margin-top: 1em">Timers are
either single-shot or repeating. Repeating timers do not
adjust for overhead but are rearmed relative to the event
loop's idea of &quot;now&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">Libuv updates
its idea of &quot;now&quot; right before executing timer
callbacks, and right after waking up from waiting for I/O.
See also <i>uv_update_time()</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Example: a
repeating timer with a 50 ms interval whose callback takes
17 ms to complete, runs again 33 ms later. If other tasks
take longer than 33 ms, the timer callback runs as soon as
possible.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_timer_t</b></p>

<p style="margin-left:18%;">Timer handle type.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_timer_cb)(</b><i>uv_timer_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Type definition for callback
passed to <i>uv_timer_start()</i>.</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">N/A</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> members
also apply.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_timer_init(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_timer_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Initialize the handle.</p>

<p style="margin-left:9%;"><b>int
uv_timer_start(</b><i>uv_timer_t</i> <b>*handle,</b>
<i>uv_timer_cb</i> <b>cb, uint64_t <br>
timeout, uint64_t repeat)</b></p>

<p style="margin-left:18%;">Start the timer. <i>timeout</i>
and <i>repeat</i> are in milliseconds.</p>

<p style="margin-left:18%; margin-top: 1em">If
<i>timeout</i> is zero, the callback fires on the next event
loop iteration. If <i>repeat</i> is non-zero, the callback
fires first after <i>timeout</i> milliseconds and then
repeatedly after <i>repeat</i> milliseconds.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Does not update the event
loop's concept of &quot;now&quot;. See
<i>uv_update_time()</i> for more information.</p>

<p style="margin-left:22%; margin-top: 1em">If the timer is
already active, it is simply updated.</p>

<p style="margin-left:9%;"><b>int
uv_timer_stop(</b><i>uv_timer_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Stop the timer, the callback
will not be called anymore.</p>

<p style="margin-left:9%;"><b>int
uv_timer_again(</b><i>uv_timer_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Stop the timer, and if it is
repeating restart it using the repeat value as the timeout.
If the timer has never been started before it returns
UV_EINVAL.</p>

<p style="margin-left:9%;"><b>void
uv_timer_set_repeat(</b><i>uv_timer_t</i> <b>*handle,
uint64_t repeat)</b></p>

<p style="margin-left:18%;">Set the repeat interval value
in milliseconds. The timer will be scheduled to run on the
given interval, regardless of the callback execution
duration, and will follow normal timer semantics in the case
of a time-slice overrun.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">If the repeat value is set from
a timer callback it does not immediately take effect. If the
timer was non-repeating before, it will have been stopped.
If it was repeating, then the old repeat value will have
been used to schedule the next timeout.</p>

<p style="margin-left:9%;"><b>uint64_t
uv_timer_get_repeat(const</b> <i>uv_timer_t</i>
<b>*handle)</b></p>

<p style="margin-left:18%;">Get the timer repeat value.</p>

<p style="margin-left:9%;"><b>uint64_t
uv_timer_get_due_in(const</b> <i>uv_timer_t</i>
<b>*handle)</b></p>

<p style="margin-left:18%;">Get the timer due value or 0 if
it has expired. The time is relative to <i>uv_now()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.40.0.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> API
functions also apply.</p>

<h3>uv_prepare_t --- Prepare handle
<a name="uv_prepare_t --- Prepare handle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Prepare handles
will run the given callback once per loop iteration, right
before polling for i/o.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_prepare_t</b></p>

<p style="margin-left:18%;">Prepare handle type.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_prepare_cb)(</b><i>uv_prepare_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Type definition for callback
passed to <i>uv_prepare_start()</i>.</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">N/A</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> members
also apply.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_prepare_init(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_prepare_t</i> <b>*prepare)</b></p>

<p style="margin-left:18%;">Initialize the handle. This
function always succeeds. <b><br>
Returns</b></p>

<p style="margin-left:27%;">0</p>

<p style="margin-left:9%;"><b>int
uv_prepare_start(</b><i>uv_prepare_t</i> <b>*prepare,</b>
<i>uv_prepare_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Start the handle with the given
callback. This function always succeeds, except when
<i>cb</i> is <i>NULL</i>. <b><br>
Returns</b></p>

<p style="margin-left:27%;">0 on success, or
<i>UV_EINVAL</i> when <i>cb == NULL</i>.</p>

<p style="margin-left:9%;"><b>int
uv_prepare_stop(</b><i>uv_prepare_t</i> <b>*prepare)</b></p>

<p style="margin-left:18%;">Stop the handle, the callback
will no longer be called. This function always succeeds.
<b><br>
Returns</b></p>

<p style="margin-left:27%;">0</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> API
functions also apply.</p>

<h3>uv_check_t --- Check handle
<a name="uv_check_t --- Check handle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Check handles
will run the given callback once per loop iteration, right
after polling for i/o.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_check_t</b></p>

<p style="margin-left:18%;">Check handle type.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_check_cb)(</b><i>uv_check_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Type definition for callback
passed to <i>uv_check_start()</i>.</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">N/A</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> members
also apply.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_check_init(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_check_t</i> <b>*check)</b></p>

<p style="margin-left:18%;">Initialize the handle. This
function always succeeds. <b><br>
Returns</b></p>

<p style="margin-left:27%;">0</p>

<p style="margin-left:9%;"><b>int
uv_check_start(</b><i>uv_check_t</i> <b>*check,</b>
<i>uv_check_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Start the handle with the given
callback. This function always succeeds, except when
<i>cb</i> is <i>NULL</i>. <b><br>
Returns</b></p>

<p style="margin-left:27%;">0 on success, or
<i>UV_EINVAL</i> when <i>cb == NULL</i>.</p>

<p style="margin-left:9%;"><b>int
uv_check_stop(</b><i>uv_check_t</i> <b>*check)</b></p>

<p style="margin-left:18%;">Stop the handle, the callback
will no longer be called. This function always succeeds.
<b><br>
Returns</b></p>

<p style="margin-left:27%;">0</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> API
functions also apply.</p>

<h3>uv_idle_t --- Idle handle
<a name="uv_idle_t --- Idle handle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Idle handles
will run the given callback once per loop iteration, right
before the <i>uv_prepare_t</i> handles.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">The notable difference with
prepare handles is that when there are active idle handles,
the loop will perform a zero timeout poll instead of
blocking for i/o.</p>


<p style="margin-left:9%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:13%;">Despite the name, idle handles
will get their callbacks called on every loop iteration, not
when the loop is actually &quot;idle&quot;.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_idle_t</b></p>

<p style="margin-left:18%;">Idle handle type.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_idle_cb)(</b><i>uv_idle_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Type definition for callback
passed to <i>uv_idle_start()</i>.</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">N/A</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> members
also apply.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_idle_init(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_idle_t</i> <b>*idle)</b></p>

<p style="margin-left:18%;">Initialize the handle. This
function always succeeds. <b><br>
Returns</b></p>

<p style="margin-left:27%;">0</p>

<p style="margin-left:9%;"><b>int
uv_idle_start(</b><i>uv_idle_t</i> <b>*idle,</b>
<i>uv_idle_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Start the handle with the given
callback. This function always succeeds, except when
<i>cb</i> is <i>NULL</i>. <b><br>
Returns</b></p>

<p style="margin-left:27%;">0 on success, or
<i>UV_EINVAL</i> when <i>cb == NULL</i>.</p>

<p style="margin-left:9%;"><b>int
uv_idle_stop(</b><i>uv_idle_t</i> <b>*idle)</b></p>

<p style="margin-left:18%;">Stop the handle, the callback
will no longer be called. This function always succeeds.
<b><br>
Returns</b></p>

<p style="margin-left:27%;">0</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> API
functions also apply.</p>

<h3>uv_async_t --- Async handle
<a name="uv_async_t --- Async handle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Async handles
allow the user to &quot;wakeup&quot; the event loop and get
a callback called from another thread.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_async_t</b></p>

<p style="margin-left:18%;">Async handle type.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_async_cb)(</b><i>uv_async_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Type definition for callback
passed to <i>uv_async_init()</i>.</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">N/A</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> members
also apply.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_async_init(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_async_t</i> <b>*async,</b> <i>uv_async_cb</i> <b><br>
async_cb)</b></p>

<p style="margin-left:18%;">Initialize the handle. A NULL
callback is allowed. <b><br>
Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Unlike other handle
initialization functions, it immediately starts the
handle.</p>

<p style="margin-left:9%;"><b>int
uv_async_send(</b><i>uv_async_t</i> <b>*async)</b></p>

<p style="margin-left:18%;">Wake up the event loop and call
the async handle's callback. <b><br>
Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">It's safe to call this function
from any thread. The callback will be called on the loop
thread.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>uv_async_send()</i> is
<i>async-signal-safe</i>. It's safe to call this function
from a signal handler.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">libuv will coalesce calls to
<i>uv_async_send()</i>, that is, not every call to it will
yield an execution of the callback. For example: if
<i>uv_async_send()</i> is called 5 times in a row before the
callback is called, the callback will only be called once.
If <i>uv_async_send()</i> is called again after the callback
was called, it will be called again.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> API
functions also apply.</p>

<h3>uv_poll_t --- Poll handle
<a name="uv_poll_t --- Poll handle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Poll handles are
used to watch file descriptors for readability, writability
and disconnection similar to the purpose of
<i>poll(2)</i>.</p>

<p style="margin-left:9%; margin-top: 1em">The purpose of
poll handles is to enable integrating external libraries
that rely on the event loop to signal it about the socket
status changes, like c-ares or libssh2. Using uv_poll_t for
any other purpose is not recommended; <i>uv_tcp_t</i>,
<i>uv_udp_t</i>, etc. provide an implementation that is
faster and more scalable than what can be achieved with
<i>uv_poll_t</i>, especially on Windows.</p>

<p style="margin-left:9%; margin-top: 1em">It is possible
that poll handles occasionally signal that a file descriptor
is readable or writable even when it isn't. The user should
therefore always be prepared to handle EAGAIN or equivalent
when it attempts to read from or write to the fd.</p>

<p style="margin-left:9%; margin-top: 1em">It is not okay
to have multiple active poll handles for the same socket,
this can cause libuv to busyloop or otherwise
malfunction.</p>

<p style="margin-left:9%; margin-top: 1em">The user should
not close a file descriptor while it is being polled by an
active poll handle. This can cause the handle to report an
error, but it might also start polling another socket.
However the fd can be safely closed immediately after a call
to <i>uv_poll_stop()</i> or <i>uv_close()</i>.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">On windows only sockets can be
polled with poll handles. On Unix any file descriptor that
would be accepted by <i>poll(2)</i> can be used.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">On AIX, watching for
disconnection is not supported.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_poll_t</b></p>

<p style="margin-left:18%;">Poll handle type.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_poll_cb)(</b><i>uv_poll_t</i> <b>*handle, int status,
int events)</b></p>

<p style="margin-left:18%;">Type definition for callback
passed to <i>uv_poll_start()</i>.</p>

<p style="margin-left:9%;"><b>enum uv_poll_event</b></p>

<p style="margin-left:18%;">Poll event types</p>

<p style="margin-left:22%; margin-top: 1em">enum
uv_poll_event { <br>
UV_READABLE = 1, <br>
UV_WRITABLE = 2, <br>
UV_DISCONNECT = 4, <br>
UV_PRIORITIZED = 8 <br>
};</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">N/A</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> members
also apply.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_poll_init(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_poll_t</i> <b>*handle, int fd)</b></p>

<p style="margin-left:18%;">Initialize the handle using a
file descriptor.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.2.2: the file descriptor is set to non-blocking
mode.</p>

<p style="margin-left:9%;"><b>int
uv_poll_init_socket(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_poll_t</i> <b>*handle,</b> <i><br>
uv_os_sock_t</i> <b>socket)</b></p>

<p style="margin-left:18%;">Initialize the handle using a
socket descriptor. On Unix this is identical to
<i>uv_poll_init()</i>. On windows it takes a SOCKET
handle.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.2.2: the socket is set to non-blocking mode.</p>

<p style="margin-left:9%;"><b>int
uv_poll_start(</b><i>uv_poll_t</i> <b>*handle, int
events,</b> <i>uv_poll_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Starts polling the file
descriptor. <i>events</i> is a bitmask made up of
<i>UV_READABLE</i>, <i>UV_WRITABLE</i>,
<i>UV_PRIORITIZED</i> and <i>UV_DISCONNECT</i>. As soon as
an event is detected the callback will be called with
<i>status</i> set to 0, and the detected events set on the
<i>events</i> field.</p>

<p style="margin-left:18%; margin-top: 1em">The
<i>UV_PRIORITIZED</i> event is used to watch for sysfs
interrupts or TCP out-of-band messages.</p>

<p style="margin-left:18%; margin-top: 1em">The
<i>UV_DISCONNECT</i> event is optional in the sense that it
may not be reported and the user is free to ignore it, but
it can help optimize the shutdown path because an extra read
or write call might be avoided.</p>

<p style="margin-left:18%; margin-top: 1em">If an error
happens while polling, <i>status</i> will be &lt; 0 and
corresponds with one of the <i>UV_E*</i> error codes (see
<i>Error handling</i>). The user should not close the socket
while the handle is active. If the user does that anyway,
the callback <i>may</i> be called reporting an error status,
but this is <b>not</b> guaranteed. If <i>status ==
UV_EBADF</i> polling is discontinued for the file handle and
no further events will be reported. The user should then
call <i>uv_close()</i> on the handle.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Calling <i>uv_poll_start()</i>
on a handle that is already active is fine. Doing so will
update the events mask that is being watched for.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Though <i>UV_DISCONNECT</i> can
be set, it is unsupported on AIX and as such will not be set
on the <i>events</i> field in the callback.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">If one of the events
<i>UV_READABLE</i> or <i>UV_WRITABLE</i> are set, the
callback will be called again, as long as the given
fd/socket remains readable or writable accordingly.
Particularly in each of the following scenarios:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="76%">


<p>The callback has been called because the socket became
readable/writable and the callback did not conduct a
read/write on this socket at all.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="76%">


<p>The callback committed a read on the socket, and has not
read all the available data (when <i>UV_READABLE</i> is
set).</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="76%">


<p>The callback committed a write on the socket, but it
remained writable afterwards (when <i>UV_WRITABLE</i> is
set).</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="76%">


<p>The socket has already became readable/writable before
calling <i>uv_poll_start()</i> on a poll handle associated
with this socket, and since then the state of the socket did
not changed.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">In all of the
above listed scenarios, the socket remains readable or
writable and hence the callback will be called again
(depending on the events set in the bitmask). This behaviour
is known as level triggering.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.9.0: Added the <i>UV_DISCONNECT</i> event.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.14.0: Added the <i>UV_PRIORITIZED</i> event.</p>

<p style="margin-left:9%;"><b>int
uv_poll_stop(</b><i>uv_poll_t</i> <b>*poll)</b></p>

<p style="margin-left:18%;">Stop polling the file
descriptor, the callback will no longer be called.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Calling <i>uv_poll_stop()</i>
is effective immediately: any pending callback is also
canceled, even if the socket state change notification was
already pending.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> API
functions also apply.</p>

<h3>uv_signal_t --- Signal handle
<a name="uv_signal_t --- Signal handle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Signal handles
implement Unix style signal handling on a per-event loop
bases.</p>

<h3>Windows notes
<a name="Windows notes"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Reception of
some signals is emulated:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>SIGINT is normally delivered when the user presses
CTRL+C. However, like on Unix, it is not generated when
terminal raw mode is enabled.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>SIGBREAK is delivered when the user pressed CTRL +
BREAK.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>SIGHUP is generated when the user closes the console
window. On SIGHUP the program is given approximately 10
seconds to perform cleanup. After that Windows will
unconditionally terminate it.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>SIGWINCH is raised whenever libuv detects that the
console has been resized. When a libuv app is running under
a console emulator, or when a 32-bit libuv app is running on
64-bit system, SIGWINCH will be emulated. In such cases
SIGWINCH signals may not always be delivered in a timely
manner. For a writable <i>uv_tty_t</i> handle libuv will
only detect size changes when the cursor is moved. When a
readable <i>uv_tty_t</i> handle is used, resizing of the
console buffer will be detected only if the handle is in raw
mode and is being read.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Watchers for other signals can be successfully created,
but these signals are never received. These signals are:
<i>SIGILL</i>, <i>SIGABRT</i>, <i>SIGFPE</i>,
<i>SIGSEGV</i>, <i>SIGTERM</i> and <i>SIGKILL.</i></p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Calls to raise() or abort() to programmatically raise a
signal are not detected by libuv; these will not trigger a
signal watcher.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Changed in
version 1.15.0: SIGWINCH support on Windows was
improved.</p>

<p style="margin-left:9%; margin-top: 1em">Changed in
version 1.31.0: 32-bit libuv SIGWINCH support on 64-bit
Windows was rolled back to old implementation.</p>

<h3>Unix notes
<a name="Unix notes"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">SIGKILL and SIGSTOP are
impossible to catch.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Handling SIGBUS, SIGFPE, SIGILL or SIGSEGV via libuv
results into undefined behavior.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>SIGABRT will not be caught by libuv if generated by
<i>abort()</i>, e.g. through <i>assert()</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>On Linux SIGRT0 and SIGRT1 (signals 32 and 33) are used
by the NPTL pthreads library to manage threads. Installing
watchers for those signals will lead to unpredictable
behavior and is strongly discouraged. Future versions of
libuv may simply reject them.</p></td></tr>
</table>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_signal_t</b></p>

<p style="margin-left:18%;">Signal handle type.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_signal_cb)(</b><i>uv_signal_t</i> <b>*handle, int
signum)</b></p>

<p style="margin-left:18%;">Type definition for callback
passed to <i>uv_signal_start()</i>.</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int</b>
<i>uv_signal_t</i><b>.signum</b></p>

<p style="margin-left:18%;">Signal being monitored by this
handle. Readonly.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> members
also apply.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_signal_init(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_signal_t</i> <b>*signal)</b></p>

<p style="margin-left:18%;">Initialize the handle.</p>

<p style="margin-left:9%;"><b>int
uv_signal_start(</b><i>uv_signal_t</i> <b>*signal,</b>
<i>uv_signal_cb</i> <b>cb, int signum)</b></p>

<p style="margin-left:18%;">Start the handle with the given
callback, watching for the given signal.</p>

<p style="margin-left:9%;"><b>int
uv_signal_start_oneshot(</b><i>uv_signal_t</i>
<b>*signal,</b> <i>uv_signal_cb</i> <b>cb, int <br>
signum)</b></p>

<p style="margin-left:18%;">Added in version 1.12.0.</p>

<p style="margin-left:18%; margin-top: 1em">Same
functionality as <i>uv_signal_start()</i> but the signal
handler is reset the moment the signal is received.</p>

<p style="margin-left:9%;"><b>int
uv_signal_stop(</b><i>uv_signal_t</i> <b>*signal)</b></p>

<p style="margin-left:18%;">Stop the handle, the callback
will no longer be called.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> API
functions also apply.</p>

<h3>uv_process_t --- Process handle
<a name="uv_process_t --- Process handle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Process handles
will spawn a new process and allow the user to control it
and establish communication channels with it using
streams.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_process_t</b></p>

<p style="margin-left:18%;">Process handle type.</p>

<p style="margin-left:9%;"><b>type
uv_process_options_t</b></p>

<p style="margin-left:18%;">Options for spawning the
process (passed to <i>uv_spawn()</i>.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
uv_process_options_s { <br>
uv_exit_cb exit_cb; <br>
const char* file; <br>
char** args; <br>
char** env; <br>
const char* cwd; <br>
unsigned int flags; <br>
int stdio_count; <br>
uv_stdio_container_t* stdio; <br>
uv_uid_t uid; <br>
uv_gid_t gid; <br>
} uv_process_options_t;</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_exit_cb)(</b><i>uv_process_t</i><b>*, int64_t
exit_status, int <br>
term_signal)</b></p>

<p style="margin-left:18%;">Type definition for callback
passed in <i>uv_process_options_t</i> which will indicate
the exit status and the signal that caused the process to
terminate, if any.</p>

<p style="margin-left:9%;"><b>enum uv_process_flags</b></p>

<p style="margin-left:18%;">Flags to be set on the flags
field of <i>uv_process_options_t</i>.</p>

<p style="margin-left:22%; margin-top: 1em">enum
uv_process_flags { <br>
/* <br>
* Set the child process' user id. <br>
*/ <br>
UV_PROCESS_SETUID = (1 &lt;&lt; 0), <br>
/* <br>
* Set the child process' group id. <br>
*/ <br>
UV_PROCESS_SETGID = (1 &lt;&lt; 1), <br>
/* <br>
* Do not wrap any arguments in quotes, or perform any other
escaping, when <br>
* converting the argument list into a command line string.
This option is <br>
* only meaningful on Windows systems. On Unix it is silently
ignored. <br>
*/ <br>
UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS = (1 &lt;&lt; 2), <br>
/* <br>
* Spawn the child process in a detached state - this will
make it a process <br>
* group leader, and will effectively enable the child to
keep running after <br>
* the parent exits. Note that the child process will still
keep the <br>
* parent's event loop alive unless the parent process calls
uv_unref() on <br>
* the child's process handle. <br>
*/ <br>
UV_PROCESS_DETACHED = (1 &lt;&lt; 3), <br>
/* <br>
* Hide the subprocess window that would normally be created.
This option is <br>
* only meaningful on Windows systems. On Unix it is silently
ignored. <br>
*/ <br>
UV_PROCESS_WINDOWS_HIDE = (1 &lt;&lt; 4), <br>
/* <br>
* Hide the subprocess console window that would normally be
created. This <br>
* option is only meaningful on Windows systems. On Unix it
is silently <br>
* ignored. <br>
*/ <br>
UV_PROCESS_WINDOWS_HIDE_CONSOLE = (1 &lt;&lt; 5), <br>
/* <br>
* Hide the subprocess GUI window that would normally be
created. This <br>
* option is only meaningful on Windows systems. On Unix it
is silently <br>
* ignored. <br>
*/ <br>
UV_PROCESS_WINDOWS_HIDE_GUI = (1 &lt;&lt; 6), <br>
/* <br>
* On Windows, if the path to the program to execute,
specified in <br>
* uv_process_options_t's file field, has a directory
component, <br>
* search for the exact file name before trying variants with
<br>
* extensions like '.exe' or '.cmd'. <br>
*/ <br>
UV_PROCESS_WINDOWS_FILE_PATH_EXACT_NAME = (1 &lt;&lt; 7)
<br>
};</p>

<p style="margin-left:9%;"><b>type
uv_stdio_container_t</b></p>

<p style="margin-left:18%;">Container for each stdio handle
or fd passed to a child process.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
uv_stdio_container_s { <br>
uv_stdio_flags flags; <br>
union { <br>
uv_stream_t* stream; <br>
int fd; <br>
} data; <br>
} uv_stdio_container_t;</p>

<p style="margin-left:9%;"><b>enum uv_stdio_flags</b></p>

<p style="margin-left:18%;">Flags specifying how a stdio
should be transmitted to the child process.</p>

<p style="margin-left:22%; margin-top: 1em">typedef enum {
<br>
/* <br>
* The following four options are mutually-exclusive, and
define <br>
* the operation to perform for the corresponding file
descriptor <br>
* in the child process: <br>
*/</p>

<p style="margin-left:22%; margin-top: 1em">/* <br>
* No file descriptor will be provided (or redirected to <br>
* `/dev/null` if it is fd 0, 1 or 2). <br>
*/ <br>
UV_IGNORE = 0x00,</p>

<p style="margin-left:22%; margin-top: 1em">/* <br>
* Open a new pipe into `data.stream`, per the flags below.
The <br>
* `data.stream` field must point to a uv_pipe_t object that
has <br>
* been initialized with `uv_pipe_init(loop, data.stream,
ipc);`, <br>
* but not yet opened or connected. <br>
/* <br>
UV_CREATE_PIPE = 0x01,</p>

<p style="margin-left:22%; margin-top: 1em">/* <br>
* The child process will be given a duplicate of the
parent's <br>
* file descriptor given by `data.fd`. <br>
*/ <br>
UV_INHERIT_FD = 0x02,</p>

<p style="margin-left:22%; margin-top: 1em">/* <br>
* The child process will be given a duplicate of the
parent's <br>
* file descriptor being used by the stream handle given by
<br>
* `data.stream`. <br>
*/ <br>
UV_INHERIT_STREAM = 0x04,</p>

<p style="margin-left:22%; margin-top: 1em">/* <br>
* When UV_CREATE_PIPE is specified, UV_READABLE_PIPE and
UV_WRITABLE_PIPE <br>
* determine the direction of flow, from the child process'
perspective. Both <br>
* flags may be specified to create a duplex data stream.
<br>
*/ <br>
UV_READABLE_PIPE = 0x10, <br>
UV_WRITABLE_PIPE = 0x20,</p>

<p style="margin-left:22%; margin-top: 1em">/* <br>
* When UV_CREATE_PIPE is specified, specifying
UV_NONBLOCK_PIPE opens the <br>
* handle in non-blocking mode in the child. This may cause
loss of data, <br>
* if the child is not designed to handle to encounter this
mode, <br>
* but can also be significantly more efficient. <br>
*/ <br>
UV_NONBLOCK_PIPE = 0x40 <br>
} uv_stdio_flags;</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int</b>
<i>uv_process_t</i><b>.pid</b></p>

<p style="margin-left:18%;">The PID of the spawned process.
It's set after calling <i>uv_spawn()</i>.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> members
also apply.</p>

<p style="margin-left:9%;"><i>uv_exit_cb
uv_process_options_t</i><b>.exit_cb</b></p>

<p style="margin-left:18%;">Callback called after the
process exits.</p>

<p style="margin-left:9%;"><b>const char
*</b><i>uv_process_options_t</i><b>.file</b></p>

<p style="margin-left:18%;">Path pointing to the program to
be executed.</p>

<p style="margin-left:9%;"><b>char
**</b><i>uv_process_options_t</i><b>.args</b></p>

<p style="margin-left:18%;">Command line arguments. args[0]
should be the path to the program. On Windows this uses
<i>CreateProcess</i> which concatenates the arguments into a
string this can cause some strange errors. See the
<b>UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS</b> flag on
<i>uv_process_flags</i>.</p>

<p style="margin-left:9%;"><b>char
**</b><i>uv_process_options_t</i><b>.env</b></p>

<p style="margin-left:18%;">Environment for the new
process. If NULL the parents environment is used.</p>

<p style="margin-left:9%;"><b>const char
*</b><i>uv_process_options_t</i><b>.cwd</b></p>

<p style="margin-left:18%;">Current working directory for
the subprocess.</p>

<p style="margin-left:9%;"><b>unsigned int</b>
<i>uv_process_options_t</i><b>.flags</b></p>

<p style="margin-left:18%;">Various flags that control how
<i>uv_spawn()</i> behaves. See <i>uv_process_flags</i>.</p>

<p style="margin-left:9%;"><b>int</b>
<i>uv_process_options_t</i><b>.stdio_count</b> <i><br>
uv_stdio_container_t</i>
<b>*</b><i>uv_process_options_t</i><b>.stdio</b></p>

<p style="margin-left:18%;">The <i>stdio</i> field points
to an array of <i>uv_stdio_container_t</i> structs that
describe the file descriptors that will be made available to
the child process. The convention is that stdio[0] points to
stdin, fd 1 is used for stdout, and fd 2 is stderr.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">On Windows file descriptors
greater than 2 are available to the child process only if
the child processes uses the MSVCRT runtime.</p>

<p style="margin-left:9%;"><b>uv_uid_t</b>
<i>uv_process_options_t</i><b>.uid <br>
uv_gid_t</b> <i>uv_process_options_t</i><b>.gid</b></p>

<p style="margin-left:18%;">Libuv can change the child
process' user/group id. This happens only when the
appropriate bits are set in the flags fields.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">This is not supported on
Windows, <i>uv_spawn()</i> will fail and set the error to
<b>UV_ENOTSUP</b>.</p>

<p style="margin-left:9%;"><i>uv_stdio_flags
uv_stdio_container_t</i><b>.flags</b></p>

<p style="margin-left:18%;">Flags specifying how the stdio
container should be passed to the child.</p>

<p style="margin-left:9%;"><b>union [anonymous]</b>
<i>uv_stdio_container_t</i><b>.data</b></p>

<p style="margin-left:18%;">Union containing either the
<i>stream</i> or <i>fd</i> to be passed on to the child
process.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>void
uv_disable_stdio_inheritance(void)</b></p>

<p style="margin-left:18%;">Disables inheritance for file
descriptors / handles that this process inherited from its
parent. The effect is that child processes spawned by this
process don't accidentally inherit these handles.</p>

<p style="margin-left:18%; margin-top: 1em">It is
recommended to call this function as early in your program
as possible, before the inherited file descriptors can be
closed or duplicated.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">This function works on a
best-effort basis: there is no guarantee that libuv can
discover all file descriptors that were inherited. In
general it does a better job on Windows than it does on
Unix.</p>

<p style="margin-left:9%;"><b>int
uv_spawn(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_process_t</i> <b>*handle, const</b> <i><br>
uv_process_options_t</i> <b>*options)</b></p>

<p style="margin-left:18%;">Initializes the process handle
and starts the process. If the process is successfully
spawned, this function will return 0. Otherwise, the
negative error code corresponding to the reason it couldn't
spawn is returned.</p>

<p style="margin-left:18%; margin-top: 1em">Possible
reasons for failing to spawn would include (but not be
limited to) the file to execute not existing, not having
permissions to use the setuid or setgid specified, or not
having enough memory to allocate for the new process.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.24.0: Added <i>UV_PROCESS_WINDOWS_HIDE_CONSOLE</i>
and <i>UV_PROCESS_WINDOWS_HIDE_GUI</i> flags.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.48.0: Added the
<i>UV_PROCESS_WINDOWS_FILE_PATH_EXACT_NAME</i> flag.</p>

<p style="margin-left:9%;"><b>int
uv_process_kill(</b><i>uv_process_t</i> <b>*handle, int
signum)</b></p>

<p style="margin-left:18%;">Sends the specified signal to
the given process handle. Check the documentation on
<i>uv_signal_t --- Signal handle</i> for signal support,
specially on Windows.</p>

<p style="margin-left:9%;"><b>int uv_kill(int pid, int
signum)</b></p>

<p style="margin-left:18%;">Sends the specified signal to
the given PID. Check the documentation on <i>uv_signal_t ---
Signal handle</i> for signal support, specially on
Windows.</p>

<p style="margin-left:9%;"><i>uv_pid_t</i>
<b>uv_process_get_pid(const</b> <i>uv_process_t</i>
<b>*handle)</b></p>

<p style="margin-left:18%;">Returns
<i>handle-&gt;pid</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> API
functions also apply.</p>

<h3>uv_stream_t --- Stream handle
<a name="uv_stream_t --- Stream handle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Stream handles
provide an abstraction of a duplex communication channel.
<i>uv_stream_t</i> is an abstract type, libuv provides 3
stream implementations in the form of <i>uv_tcp_t</i>,
<i>uv_pipe_t</i> and <i>uv_tty_t</i>.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_stream_t</b></p>

<p style="margin-left:18%;">Stream handle type.</p>

<p style="margin-left:9%;"><b>type uv_connect_t</b></p>

<p style="margin-left:18%;">Connect request type.</p>

<p style="margin-left:9%;"><b>type uv_shutdown_t</b></p>

<p style="margin-left:18%;">Shutdown request type.</p>

<p style="margin-left:9%;"><b>type uv_write_t</b></p>

<p style="margin-left:18%;">Write request type. Careful
attention must be paid when reusing objects of this type.
When a stream is in non-blocking mode, write requests sent
with <b>uv_write</b> will be queued. Reusing objects at this
point is undefined behaviour. It is safe to reuse the
<b>uv_write_t</b> object only after the callback passed to
<b>uv_write</b> is fired.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_read_cb)(</b><i>uv_stream_t</i> <b>*stream, ssize_t
nread, const</b> <i><br>
uv_buf_t</i> <b>*buf)</b></p>

<p style="margin-left:18%;">Callback called when data was
read on a stream.</p>

<p style="margin-left:18%; margin-top: 1em"><i>nread</i> is
&gt; 0 if there is data available or &lt; 0 on error. When
we've reached EOF, <i>nread</i> will be set to
<b>UV_EOF</b>. When <i>nread</i> &lt; 0, the <i>buf</i>
parameter might not point to a valid buffer; in that case
<i>buf.len</i> and <i>buf.base</i> are both set to 0.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>nread</i> might be 0, which
does <i>not</i> indicate an error or EOF. This is equivalent
to <b>EAGAIN</b> or <b>EWOULDBLOCK</b> under
<b>read(2)</b>.</p>

<p style="margin-left:18%; margin-top: 1em">The callee is
responsible for stopping/closing the stream when an error
happens by calling <i>uv_read_stop()</i> or
<i>uv_close()</i>. Trying to read from the stream again is
undefined.</p>

<p style="margin-left:18%; margin-top: 1em">The callee is
responsible for freeing the buffer, libuv does not reuse it.
The buffer may be a null buffer (where <i>buf-&gt;base</i>
== NULL and <i>buf-&gt;len</i> == 0) on error.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_write_cb)(</b><i>uv_write_t</i> <b>*req, int
status)</b></p>

<p style="margin-left:18%;">Callback called after data was
written on a stream. <i>status</i> will be 0 in case of
success, &lt; 0 otherwise.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_connect_cb)(</b><i>uv_connect_t</i> <b>*req, int
status)</b></p>

<p style="margin-left:18%;">Callback called after a
connection started by <b>uv_connect()</b> is done.
<i>status</i> will be 0 in case of success, &lt; 0
otherwise.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_shutdown_cb)(</b><i>uv_shutdown_t</i> <b>*req, int
status)</b></p>

<p style="margin-left:18%;">Callback called after a
shutdown request has been completed. <i>status</i> will be 0
in case of success, &lt; 0 otherwise.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_connection_cb)(</b><i>uv_stream_t</i> <b>*server, int
status)</b></p>

<p style="margin-left:18%;">Callback called when a stream
server has received an incoming connection. The user can
accept the connection by calling <i>uv_accept()</i>.
<i>status</i> will be 0 in case of success, &lt; 0
otherwise.</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>size_t</b>
<i>uv_stream_t</i><b>.write_queue_size</b></p>

<p style="margin-left:18%;">Contains the amount of queued
bytes waiting to be sent. Readonly.</p>

<p style="margin-left:9%;"><i>uv_stream_t</i>
<b>*</b><i>uv_connect_t</i><b>.handle</b></p>

<p style="margin-left:18%;">Pointer to the stream where
this connection request is running.</p>

<p style="margin-left:9%;"><i>uv_stream_t</i>
<b>*</b><i>uv_shutdown_t</i><b>.handle</b></p>

<p style="margin-left:18%;">Pointer to the stream where
this shutdown request is running.</p>

<p style="margin-left:9%;"><i>uv_stream_t</i>
<b>*</b><i>uv_write_t</i><b>.handle</b></p>

<p style="margin-left:18%;">Pointer to the stream where
this write request is running.</p>

<p style="margin-left:9%;"><i>uv_stream_t</i>
<b>*</b><i>uv_write_t</i><b>.send_handle</b></p>

<p style="margin-left:18%;">Pointer to the stream being
sent using this write request.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> members
also apply.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_shutdown(</b><i>uv_shutdown_t</i> <b>*req,</b>
<i>uv_stream_t</i> <b>*handle,</b> <i>uv_shutdown_cb</i>
<b><br>
cb)</b></p>

<p style="margin-left:18%;">Shutdown the outgoing (write)
side of a duplex stream. It waits for pending write requests
to complete. The <i>handle</i> should refer to a initialized
stream. <i>req</i> should be an uninitialized shutdown
request struct. The <i>cb</i> is called after shutdown is
complete.</p>

<p style="margin-left:9%;"><b>int
uv_listen(</b><i>uv_stream_t</i> <b>*stream, int
backlog,</b> <i>uv_connection_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Start listening for incoming
connections. <i>backlog</i> indicates the number of
connections the kernel might queue, same as
<i>listen(2)</i>. When a new incoming connection is received
the <i>uv_connection_cb</i> callback is called.</p>

<p style="margin-left:9%;"><b>int
uv_accept(</b><i>uv_stream_t</i> <b>*server,</b>
<i>uv_stream_t</i> <b>*client)</b></p>

<p style="margin-left:18%;">This call is used in
conjunction with <i>uv_listen()</i> to accept incoming
connections. Call this function after receiving a
<i>uv_connection_cb</i> to accept the connection. Before
calling this function the client handle must be initialized.
&lt; 0 return value indicates an error.</p>

<p style="margin-left:18%; margin-top: 1em">When the
<i>uv_connection_cb</i> callback is called it is guaranteed
that this function will complete successfully the first
time. If you attempt to use it more than once, it may fail.
It is suggested to only call this function once per
<i>uv_connection_cb</i> call.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>server</i> and <i>client</i>
must be handles running on the same loop.</p>

<p style="margin-left:9%;"><b>int
uv_read_start(</b><i>uv_stream_t</i> <b>*stream,</b>
<i>uv_alloc_cb</i> <b>alloc_cb,</b> <i>uv_read_cb</i>
<b><br>
read_cb)</b></p>

<p style="margin-left:18%;">Read data from an incoming
stream. The <i>uv_read_cb</i> callback will be made several
times until there is no more data to read or
<i>uv_read_stop()</i> is called.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.38.0: <i>uv_read_start()</i> now consistently
returns <i>UV_EALREADY</i> when called twice, and
<i>UV_EINVAL</i> when the stream is closing. With older
libuv versions, it returns <i>UV_EALREADY</i> on Windows but
not UNIX, and <i>UV_EINVAL</i> on UNIX but not Windows.</p>

<p style="margin-left:9%;"><b>int
uv_read_stop(</b><i>uv_stream_t</i><b>*)</b></p>

<p style="margin-left:18%;">Stop reading data from the
stream. The <i>uv_read_cb</i> callback will no longer be
called.</p>

<p style="margin-left:18%; margin-top: 1em">This function
is idempotent and may be safely called on a stopped
stream.</p>

<p style="margin-left:18%; margin-top: 1em">This function
will always succeed; hence, checking its return value is
unnecessary. A non-zero return indicates that finishing
releasing resources may be pending on the next input event
on that TTY on Windows, and does not indicate failure.</p>

<p style="margin-left:9%;"><b>int
uv_write(</b><i>uv_write_t</i> <b>*req,</b>
<i>uv_stream_t</i> <b>*handle, const</b> <i>uv_buf_t</i>
<b><br>
bufs[], unsigned int nbufs,</b> <i>uv_write_cb</i>
<b>cb)</b></p>

<p style="margin-left:18%;">Write data to stream. Buffers
are written in order. Example:</p>

<p style="margin-left:22%; margin-top: 1em">void
cb(uv_write_t* req, int status) { <br>
/* Logic which handles the write result */ <br>
}</p>

<p style="margin-left:22%; margin-top: 1em">uv_buf_t a[] =
{ <br>
{ .base = &quot;1&quot;, .len = 1 }, <br>
{ .base = &quot;2&quot;, .len = 1 } <br>
};</p>

<p style="margin-left:22%; margin-top: 1em">uv_buf_t b[] =
{ <br>
{ .base = &quot;3&quot;, .len = 1 }, <br>
{ .base = &quot;4&quot;, .len = 1 } <br>
};</p>

<p style="margin-left:22%; margin-top: 1em">uv_write_t
req1; <br>
uv_write_t req2;</p>

<p style="margin-left:22%; margin-top: 1em">/* writes
&quot;1234&quot; */ <br>
uv_write(&amp;req1, stream, a, 2, cb); <br>
uv_write(&amp;req2, stream, b, 2, cb);</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">The memory pointed to by the
buffers must remain valid until the callback gets called.
This also holds for <i>uv_write2()</i>.</p>

<p style="margin-left:9%;"><b>int
uv_write2(</b><i>uv_write_t</i> <b>*req,</b>
<i>uv_stream_t</i> <b>*handle, const</b> <i>uv_buf_t</i>
<b><br>
bufs[], unsigned int nbufs,</b> <i>uv_stream_t</i>
<b>*send_handle,</b> <i>uv_write_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Extended write function for
sending handles over a pipe. The pipe must be initialized
with <i>ipc</i> == 1.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>send_handle</i> must be a
TCP, pipe and UDP handle on Unix, or a TCP handle on
Windows, which is a server or a connection (listening or
connected state). Bound sockets or pipes will be assumed to
be servers.</p>

<p style="margin-left:9%;"><b>int
uv_try_write(</b><i>uv_stream_t</i> <b>*handle, const</b>
<i>uv_buf_t</i> <b>bufs[], unsigned <br>
int nbufs)</b></p>

<p style="margin-left:18%;">Same as <i>uv_write()</i>, but
won't queue a write request if it can't be completed
immediately.</p>

<p style="margin-left:18%; margin-top: 1em">Will return
either:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>&gt; 0: number of bytes written (can be less than the
supplied buffer size).</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>&lt; 0: negative error code (<b>UV_EAGAIN</b> is
returned if no data can be sent immediately).</p></td></tr>
</table>

<p style="margin-left:9%;"><b>int
uv_try_write2(</b><i>uv_stream_t</i> <b>*handle, const</b>
<i>uv_buf_t</i> <b>bufs[], unsigned <br>
int nbufs,</b> <i>uv_stream_t</i> <b>*send_handle)</b></p>

<p style="margin-left:18%;">Same as <i>uv_try_write()</i>
and extended write function for sending handles over a pipe
like c:func:<i>uv_write2</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Try to send a
handle is not supported on Windows, where it returns
<b>UV_EAGAIN</b>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.42.0.</p>

<p style="margin-left:9%;"><b>int uv_is_readable(const</b>
<i>uv_stream_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Returns 1 if the stream is
readable, 0 otherwise.</p>

<p style="margin-left:9%;"><b>int uv_is_writable(const</b>
<i>uv_stream_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Returns 1 if the stream is
writable, 0 otherwise.</p>

<p style="margin-left:9%;"><b>int
uv_stream_set_blocking(</b><i>uv_stream_t</i> <b>*handle,
int blocking)</b></p>

<p style="margin-left:18%;">Enable or disable blocking mode
for a stream.</p>

<p style="margin-left:18%; margin-top: 1em">When blocking
mode is enabled all writes complete synchronously. The
interface remains unchanged otherwise, e.g. completion or
failure of the operation will still be reported through a
callback which is made asynchronously.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">Relying too much on this API is
not recommended. It is likely to change significantly in the
future.</p>

<p style="margin-left:22%; margin-top: 1em">Currently only
works on Windows for <i>uv_pipe_t</i> handles. On UNIX
platforms, all <i>uv_stream_t</i> handles are supported.</p>

<p style="margin-left:22%; margin-top: 1em">Also libuv
currently makes no ordering guarantee when the blocking mode
is changed after write requests have already been submitted.
Therefore it is recommended to set the blocking mode
immediately after opening or creating the stream.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.4.0: UNIX implementation added.</p>

<p style="margin-left:9%;"><b>size_t
uv_stream_get_write_queue_size(const</b> <i>uv_stream_t</i>
<b>*stream)</b></p>

<p style="margin-left:18%;">Returns
<i>stream-&gt;write_queue_size</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> API
functions also apply.</p>

<h3>uv_tcp_t --- TCP handle
<a name="uv_tcp_t --- TCP handle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">TCP handles are
used to represent both TCP streams and servers.</p>

<p style="margin-left:9%; margin-top: 1em"><i>uv_tcp_t</i>
is a 'subclass' of <i>uv_stream_t</i>.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_tcp_t</b></p>

<p style="margin-left:18%;">TCP handle type.</p>

<p style="margin-left:9%;"><b>enum uv_tcp_flags</b></p>

<p style="margin-left:18%;">Flags used in
<i>uv_tcp_bind()</i>.</p>

<p style="margin-left:22%; margin-top: 1em">enum
uv_tcp_flags { <br>
/* Used with uv_tcp_bind, when an IPv6 address is used. */
<br>
UV_TCP_IPV6ONLY = 1,</p>

<p style="margin-left:22%; margin-top: 1em">/* Enable
SO_REUSEPORT socket option when binding the handle. <br>
* This allows completely duplicate bindings by multiple
processes <br>
* or threads if they all set SO_REUSEPORT before binding the
port. <br>
* Incoming connections are distributed across the
participating <br>
* listener sockets. <br>
* <br>
* This flag is available only on Linux 3.9+, DragonFlyBSD
3.6+, <br>
* FreeBSD 12.0+, Solaris 11.4, and AIX 7.2.5+ for now. <br>
*/ <br>
UV_TCP_REUSEPORT = 2, <br>
};</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">N/A</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_stream_t</i> members
also apply.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_tcp_init(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_tcp_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Initialize the handle. No
socket is created as of yet.</p>

<p style="margin-left:9%;"><b>int
uv_tcp_init_ex(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_tcp_t</i> <b>*handle, unsigned int <br>
flags)</b></p>

<p style="margin-left:18%;">Initialize the handle with the
specified flags. At the moment only the lower 8 bits of the
<i>flags</i> parameter are used as the socket domain. A
socket will be created for the given domain. If the
specified domain is <b>AF_UNSPEC</b> no socket is created,
just like <i>uv_tcp_init()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.7.0.</p>

<p style="margin-left:9%;"><b>int
uv_tcp_open(</b><i>uv_tcp_t</i> <b>*handle,</b>
<i>uv_os_sock_t</i> <b>sock)</b></p>

<p style="margin-left:18%;">Open an existing file
descriptor or SOCKET as a TCP handle.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.2.1: the file descriptor is set to non-blocking
mode.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">The passed file descriptor or
SOCKET is not checked for its type, but it's required that
it represents a valid stream socket.</p>

<p style="margin-left:9%;"><b>int
uv_tcp_nodelay(</b><i>uv_tcp_t</i> <b>*handle, int
enable)</b></p>

<p style="margin-left:18%;">Enable <i>TCP_NODELAY</i>,
which disables Nagle's algorithm.</p>

<p style="margin-left:9%;"><b>int
uv_tcp_keepalive(</b><i>uv_tcp_t</i> <b>*handle, int enable,
unsigned int delay)</b></p>

<p style="margin-left:18%;">Enable / disable TCP
keep-alive. <i>delay</i> is the initial delay in seconds,
ignored when <i>enable</i> is zero.</p>

<p style="margin-left:18%; margin-top: 1em">After
<i>delay</i> has been reached, 10 successive probes, each
spaced 1 second from the previous one, will still happen. If
the connection is still lost at the end of this procedure,
then the handle is destroyed with a <b>UV_ETIMEDOUT</b>
error passed to the corresponding callback.</p>

<p style="margin-left:18%; margin-top: 1em">If <i>delay</i>
is less than 1 then <b>UV_EINVAL</b> is returned.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.49.0: If <i>delay</i> is less than 1 then
<b>UV_EINVAL`</b> is returned.</p>

<p style="margin-left:9%;"><b>int
uv_tcp_simultaneous_accepts(</b><i>uv_tcp_t</i> <b>*handle,
int enable)</b></p>

<p style="margin-left:18%;">Enable / disable simultaneous
asynchronous accept requests that are queued by the
operating system when listening for new TCP connections.</p>

<p style="margin-left:18%; margin-top: 1em">This setting is
used to tune a TCP server for the desired performance.
Having simultaneous accepts can significantly improve the
rate of accepting connections (which is why it is enabled by
default) but may lead to uneven load distribution in
multi-process setups.</p>

<p style="margin-left:9%;"><b>int
uv_tcp_bind(</b><i>uv_tcp_t</i> <b>*handle, const struct
sockaddr *addr, unsigned <br>
int flags)</b></p>

<p style="margin-left:18%;">Bind the handle to an address
and port.</p>

<p style="margin-left:18%; margin-top: 1em">When the port
is already taken, you can expect to see an
<b>UV_EADDRINUSE</b> error from <i>uv_listen()</i> or
<i>uv_tcp_connect()</i> unless you specify
<b>UV_TCP_REUSEPORT</b> in <i>flags</i> for all the binding
sockets. That is, a successful call to this function does
not guarantee that the call to <i>uv_listen()</i> or
<i>uv_tcp_connect()</i> will succeed as well. <b><br>
Parameters</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>handle</b> -- TCP handle. It should have been
initialized with <i>uv_tcp_init()</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>addr</b> -- Address to bind to. It should point to an
initialized <b>struct sockaddr_in</b> or <b>struct
sockaddr_in6</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>flags</b> -- Flags that control the behavior of
binding the socket. <b>UV_TCP_IPV6ONLY</b> can be contained
in <i>flags</i> to disable dual-stack support and only use
IPv6. <b>UV_TCP_REUSEPORT</b> can be contained in
<i>flags</i> to enable the socket option <i>SO_REUSEPORT</i>
with the capability of load balancing that distribute
incoming connections across all listening sockets in
multiple processes or threads.</p></td></tr>
</table>

<p style="margin-left:18%;"><b>Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.49.0: added the <b>UV_TCP_REUSEPORT</b> flag.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><b>UV_TCP_REUSEPORT</b> flag is
available only on Linux 3.9+, DragonFlyBSD 3.6+, FreeBSD
12.0+, Solaris 11.4, and AIX 7.2.5+ at the moment. On other
platforms this function will return an UV_ENOTSUP error.</p>

<p style="margin-left:9%;"><b>int
uv_tcp_getsockname(const</b> <i>uv_tcp_t</i> <b>*handle,
struct sockaddr *name, <br>
int *namelen)</b></p>

<p style="margin-left:18%;">Get the current address to
which the handle is bound. <i>name</i> must point to a valid
and big enough chunk of memory, <b>struct
sockaddr_storage</b> is recommended for IPv4 and IPv6
support.</p>

<p style="margin-left:9%;"><b>int
uv_tcp_getpeername(const</b> <i>uv_tcp_t</i> <b>*handle,
struct sockaddr *name, <br>
int *namelen)</b></p>

<p style="margin-left:18%;">Get the address of the peer
connected to the handle. <i>name</i> must point to a valid
and big enough chunk of memory, <b>struct
sockaddr_storage</b> is recommended for IPv4 and IPv6
support.</p>

<p style="margin-left:9%;"><b>int
uv_tcp_connect(</b><i>uv_connect_t</i> <b>*req,</b>
<i>uv_tcp_t</i> <b>*handle, const struct <br>
sockaddr *addr,</b> <i>uv_connect_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Establish an IPv4 or IPv6 TCP
connection. Provide an initialized TCP handle and an
uninitialized <i>uv_connect_t</i>. <i>addr</i> should point
to an initialized <b>struct sockaddr_in</b> or <b>struct
sockaddr_in6</b>.</p>

<p style="margin-left:18%; margin-top: 1em">On Windows if
the <i>addr</i> is initialized to point to an unspecified
address (<b>0.0.0.0</b> or <b>::</b>) it will be changed to
point to <b>localhost</b>. This is done to match the
behavior of Linux systems.</p>

<p style="margin-left:18%; margin-top: 1em">The callback is
made when the connection has been established or when a
connection error happened.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.19.0: added <b>0.0.0.0</b> and <b>::</b> to
<b>localhost</b> mapping</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_stream_t</i> API
functions also apply.</p>

<p style="margin-left:9%;"><b>int
uv_tcp_close_reset(</b><i>uv_tcp_t</i> <b>*handle,</b>
<i>uv_close_cb</i> <b>close_cb)</b></p>

<p style="margin-left:18%;">Resets a TCP connection by
sending a RST packet. This is accomplished by setting the
<i>SO_LINGER</i> socket option with a linger interval of
zero and then calling <i>uv_close()</i>. Due to some
platform inconsistencies, mixing of <i>uv_shutdown()</i> and
<i>uv_tcp_close_reset()</i> calls is not allowed.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.32.0.</p>

<p style="margin-left:9%;"><b>int uv_socketpair(int type,
int protocol,</b> <i>uv_os_sock_t</i> <b><br>
socket_vector[2], int flags0, int flags1)</b></p>

<p style="margin-left:18%;">Create a pair of connected
sockets with the specified properties. The resulting handles
can be passed to <i>uv_tcp_open</i>, used with
<i>uv_spawn</i>, or for any other purpose.</p>

<p style="margin-left:18%; margin-top: 1em">Valid values
for <i>flags0</i> and <i>flags1</i> are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="76%">


<p>UV_NONBLOCK_PIPE: Opens the specified socket handle for
<i>OVERLAPPED</i> or <i>FIONBIO</i>/<i>O_NONBLOCK</i> I/O
usage. This is recommended for handles that will be used by
libuv, and not usually recommended otherwise.</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Equivalent to
<i>socketpair(2)</i> with a domain of AF_UNIX.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.41.0.</p>

<h3>uv_pipe_t --- Pipe handle
<a name="uv_pipe_t --- Pipe handle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Pipe handles
provide an abstraction over streaming files on Unix
(including local domain sockets, pipes, and FIFOs) and named
pipes on Windows.</p>


<p style="margin-left:9%; margin-top: 1em"><i>uv_pipe_t</i>
is a 'subclass' of <i>uv_stream_t</i>.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_pipe_t</b></p>

<p style="margin-left:18%;">Pipe handle type.</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int</b>
<i>uv_pipe_t</i><b>.ipc</b></p>

<p style="margin-left:18%;">Whether this pipe is suitable
for handle passing between processes. Only a connected pipe
that will be passing the handles should have this flag set,
not the listening pipe that uv_accept is called on.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_stream_t</i> members
also apply.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_pipe_init(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_pipe_t</i> <b>*handle, int ipc)</b></p>

<p style="margin-left:18%;">Initialize a pipe handle. The
<i>ipc</i> argument is a boolean to indicate if this pipe
will be used for handle passing between processes (which may
change the bytes on the wire). Only a connected pipe that
will be passing the handles should have this flag set, not
the listening pipe that uv_accept is called on.</p>

<p style="margin-left:9%;"><b>int
uv_pipe_open(</b><i>uv_pipe_t</i> <b>*handle,</b>
<i>uv_file</i> <b>file)</b></p>

<p style="margin-left:18%;">Open an existing file
descriptor or HANDLE as a pipe.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.2.1: the file descriptor is set to non-blocking
mode.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">The passed file descriptor or
HANDLE is not checked for its type, but it's required that
it represents a valid pipe.</p>

<p style="margin-left:9%;"><b>int
uv_pipe_bind(</b><i>uv_pipe_t</i> <b>*handle, const char
*name)</b></p>

<p style="margin-left:18%;">Bind the pipe to a file path
(Unix) or a name (Windows).</p>

<p style="margin-left:18%; margin-top: 1em">Does not
support Linux abstract namespace sockets, unlike
<i>uv_pipe_bind2()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Alias for
<b>uv_pipe_bind2(handle, name, strlen(name), 0)</b>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Paths on Unix get truncated to
<b>sizeof(sockaddr_un.sun_path)</b> bytes, typically between
92 and 108 bytes.</p>

<p style="margin-left:9%;"><b>int
uv_pipe_bind2(</b><i>uv_pipe_t</i> <b>*handle, const char
*name, size_t namelen, <br>
unsigned int flags)</b></p>

<p style="margin-left:18%;">Bind the pipe to a file path
(Unix) or a name (Windows).</p>

<p style="margin-left:18%; margin-top: 1em"><b>flags</b>
must be zero or <b>UV_PIPE_NO_TRUNCATE</b>. Returns
<b>UV_EINVAL</b> for unsupported flags without performing
the bind operation.</p>

<p style="margin-left:18%; margin-top: 1em">Supports Linux
abstract namespace sockets. <b>namelen</b> must include the
leading nul byte but not the trailing nul byte.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.46.0.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Paths on Unix get truncated to
<b>sizeof(sockaddr_un.sun_path)</b> bytes, typically between
92 and 108 bytes, unless the <b>UV_PIPE_NO_TRUNCATE</b> flag
is specified, in which case an <b>UV_EINVAL</b> error is
returned.</p>

<p style="margin-left:9%;"><b>void
uv_pipe_connect(</b><i>uv_connect_t</i> <b>*req,</b>
<i>uv_pipe_t</i> <b>*handle, const char <br>
*name,</b> <i>uv_connect_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Connect to the Unix domain
socket or the Windows named pipe.</p>

<p style="margin-left:18%; margin-top: 1em">Does not
support Linux abstract namespace sockets, unlike
<i>uv_pipe_connect2()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Alias for
<b>uv_pipe_connect2(req, handle, name, strlen(name), 0,
cb)</b>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Paths on Unix get truncated to
<b>sizeof(sockaddr_un.sun_path)</b> bytes, typically between
92 and 108 bytes.</p>

<p style="margin-left:9%;"><b>void
uv_pipe_connect2(</b><i>uv_connect_t</i> <b>*req,</b>
<i>uv_pipe_t</i> <b>*handle, const char <br>
*name, size_t namelen, unsigned int flags,</b>
<i>uv_connect_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Connect to the Unix domain
socket or the Windows named pipe.</p>

<p style="margin-left:18%; margin-top: 1em"><b>flags</b>
must be zero or <b>UV_PIPE_NO_TRUNCATE</b>. Returns
<b>UV_EINVAL</b> for unsupported flags without performing
the connect operation.</p>

<p style="margin-left:18%; margin-top: 1em">Supports Linux
abstract namespace sockets. <b>namelen</b> must include the
leading nul byte but not the trailing nul byte.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.46.0.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Paths on Unix get truncated to
<b>sizeof(sockaddr_un.sun_path)</b> bytes, typically between
92 and 108 bytes, unless the <b>UV_PIPE_NO_TRUNCATE</b> flag
is specified, in which case an <b>UV_EINVAL</b> error is
returned.</p>

<p style="margin-left:9%;"><b>int
uv_pipe_getsockname(const</b> <i>uv_pipe_t</i> <b>*handle,
char *buffer, size_t <br>
*size)</b></p>

<p style="margin-left:18%;">Get the name of the Unix domain
socket or the named pipe.</p>

<p style="margin-left:18%; margin-top: 1em">A preallocated
buffer must be provided. The size parameter holds the length
of the buffer and it's set to the number of bytes written to
the buffer on output. If the buffer is not big enough
<b>UV_ENOBUFS</b> will be returned and len will contain the
required size.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.3.0: the returned length no longer includes the
terminating null byte, and the buffer is not null
terminated.</p>

<p style="margin-left:9%;"><b>int
uv_pipe_getpeername(const</b> <i>uv_pipe_t</i> <b>*handle,
char *buffer, size_t <br>
*size)</b></p>

<p style="margin-left:18%;">Get the name of the Unix domain
socket or the named pipe to which the handle is
connected.</p>

<p style="margin-left:18%; margin-top: 1em">A preallocated
buffer must be provided. The size parameter holds the length
of the buffer and it's set to the number of bytes written to
the buffer on output. If the buffer is not big enough
<b>UV_ENOBUFS</b> will be returned and len will contain the
required size.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.3.0.</p>

<p style="margin-left:9%;"><b>void
uv_pipe_pending_instances(</b><i>uv_pipe_t</i> <b>*handle,
int count)</b></p>

<p style="margin-left:18%;">Set the number of pending pipe
instance handles when the pipe server is waiting for
connections.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">This setting applies to Windows
only.</p>

<p style="margin-left:9%;"><b>int
uv_pipe_pending_count(</b><i>uv_pipe_t</i> <b>*handle)</b>
<i><br>
uv_handle_type</i>
<b>uv_pipe_pending_type(</b><i>uv_pipe_t</i>
<b>*handle)</b></p>

<p style="margin-left:18%;">Used to receive handles over
IPC pipes.</p>

<p style="margin-left:18%; margin-top: 1em">First - call
<i>uv_pipe_pending_count()</i>, if it's &gt; 0 then
initialize a handle of the given <i>type</i>, returned by
<i>uv_pipe_pending_type()</i> and call <b>uv_accept(pipe,
handle)</b>.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_stream_t</i> API
functions also apply.</p>

<p style="margin-left:9%;"><b>int
uv_pipe_chmod(</b><i>uv_pipe_t</i> <b>*handle, int
flags)</b></p>

<p style="margin-left:18%;">Alters pipe permissions,
allowing it to be accessed from processes run by different
users. Makes the pipe writable or readable by all users.
Mode can be <b>UV_WRITABLE</b>, <b>UV_READABLE</b> or
<b>UV_WRITABLE | UV_READABLE</b>. This function is
blocking.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.16.0.</p>

<p style="margin-left:9%;"><b>int
uv_pipe(</b><i>uv_file</i> <b>fds[2], int read_flags, int
write_flags)</b></p>

<p style="margin-left:18%;">Create a pair of connected pipe
handles. Data may be written to <i>fds[1]</i> and read from
<i>fds[0]</i>. The resulting handles can be passed to
<i>uv_pipe_open</i>, used with <i>uv_spawn</i>, or for any
other purpose.</p>

<p style="margin-left:18%; margin-top: 1em">Valid values
for <i>flags</i> are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="76%">


<p>UV_NONBLOCK_PIPE: Opens the specified socket handle for
<i>OVERLAPPED</i> or <i>FIONBIO</i>/<i>O_NONBLOCK</i> I/O
usage. This is recommended for handles that will be used by
libuv, and not usually recommended otherwise.</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Equivalent to
<i>pipe(2)</i> with the <i>O_CLOEXEC</i> flag set.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.41.0.</p>

<h3>uv_tty_t --- TTY handle
<a name="uv_tty_t --- TTY handle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">TTY handles
represent a stream for the console.</p>

<p style="margin-left:9%; margin-top: 1em"><i>uv_tty_t</i>
is a 'subclass' of <i>uv_stream_t</i>.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_tty_t</b></p>

<p style="margin-left:18%;">TTY handle type.</p>

<p style="margin-left:9%;"><b>enum uv_tty_mode_t</b></p>

<p style="margin-left:18%;">Added in version 1.2.0.</p>

<p style="margin-left:18%; margin-top: 1em">TTY mode
type:</p>

<p style="margin-left:22%; margin-top: 1em">typedef enum {
<br>
/* Initial/normal terminal mode */ <br>
UV_TTY_MODE_NORMAL, <br>
/* Raw input mode (On Windows, ENABLE_WINDOW_INPUT is also
enabled) */ <br>
UV_TTY_MODE_RAW, <br>
/* Binary-safe I/O mode for IPC (Unix-only) */ <br>
UV_TTY_MODE_IO <br>
} uv_tty_mode_t;</p>

<p style="margin-left:9%;"><b>enum
uv_tty_vtermstate_t</b></p>

<p style="margin-left:18%;">Console virtual terminal mode
type:</p>

<p style="margin-left:22%; margin-top: 1em">typedef enum {
<br>
/* <br>
* The console supports handling of virtual terminal
sequences <br>
* (Windows10 new console, ConEmu) <br>
*/ <br>
UV_TTY_SUPPORTED, <br>
/* The console cannot process virtual terminal sequences.
(Legacy <br>
* console) <br>
*/ <br>
UV_TTY_UNSUPPORTED <br>
} uv_tty_vtermstate_t</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">N/A</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_stream_t</i> members
also apply.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_tty_init(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_tty_t</i> <b>*handle,</b> <i>uv_file</i> <b>fd, int
<br>
unused)</b></p>

<p style="margin-left:18%;">Initialize a new TTY stream
with the given file descriptor. Usually the file descriptor
will be:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p>0 = stdin</p></td>
<td width="67%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p>1 = stdout</p></td>
<td width="67%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p>2 = stderr</p></td>
<td width="67%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">On Unix this
function will determine the path of the fd of the terminal
using <i>ttyname_r(3)</i>, open it, and use it if the passed
file descriptor refers to a TTY. This lets libuv put the tty
in non-blocking mode without affecting other processes that
share the tty.</p>

<p style="margin-left:18%; margin-top: 1em">This function
is not thread safe on systems that don't support ioctl
TIOCGPTN or TIOCPTYGNAME, for instance OpenBSD and
Solaris.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">If reopening the TTY fails,
libuv falls back to blocking writes.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.23.1:: the <i>readable</i> parameter is now unused
and ignored. The correct value will now be auto-detected
from the kernel.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.9.0:: the path of the TTY is determined by
<i>ttyname_r(3)</i>. In earlier versions libuv opened
<i>/dev/tty</i> instead.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.5.0:: trying to initialize a TTY stream with a
file descriptor that refers to a file returns
<i>UV_EINVAL</i> on UNIX.</p>

<p style="margin-left:9%;"><b>int
uv_tty_set_mode(</b><i>uv_tty_t</i> <b>*handle,</b>
<i>uv_tty_mode_t</i> <b>mode)</b></p>

<p style="margin-left:18%;">Changed in version 1.2.0:: the
mode is specified as a <i>uv_tty_mode_t</i> value.</p>

<p style="margin-left:18%; margin-top: 1em">Set the TTY
using the specified terminal mode.</p>

<p style="margin-left:9%;"><b>int
uv_tty_reset_mode(void)</b></p>

<p style="margin-left:18%;">To be called when the program
exits. Resets TTY settings to default values for the next
process to take over.</p>

<p style="margin-left:18%; margin-top: 1em">This function
is async signal-safe on Unix platforms but can fail with
error code <b>UV_EBUSY</b> if you call it when execution is
inside <i>uv_tty_set_mode()</i>.</p>

<p style="margin-left:9%;"><b>int
uv_tty_get_winsize(</b><i>uv_tty_t</i> <b>*handle, int
*width, int *height)</b></p>

<p style="margin-left:18%;">Gets the current Window size.
On success it returns 0.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_stream_t</i> API
functions also apply.</p>

<p style="margin-left:9%;"><b>void
uv_tty_set_vterm_state(</b><i>uv_tty_vtermstate_t</i>
<b>state)</b></p>

<p style="margin-left:18%;">Controls whether console
virtual terminal sequences are processed by libuv or
console. Useful in particular for enabling ConEmu support of
ANSI X3.64 and Xterm 256 colors. Otherwise Windows10
consoles are usually detected automatically.</p>

<p style="margin-left:18%; margin-top: 1em">This function
is only meaningful on Windows systems. On Unix it is
silently ignored.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.33.0.</p>

<p style="margin-left:9%;"><b>int
uv_tty_get_vterm_state(</b><i>uv_tty_vtermstate_t</i>
<b>*state)</b></p>

<p style="margin-left:18%;">Get the current state of
whether console virtual terminal sequences are handled by
libuv or the console.</p>

<p style="margin-left:18%; margin-top: 1em">This function
is not implemented on Unix, where it returns
<b>UV_ENOTSUP</b>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.33.0.</p>

<h3>uv_udp_t --- UDP handle
<a name="uv_udp_t --- UDP handle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">UDP handles
encapsulate UDP communication for both clients and
servers.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_udp_t</b></p>

<p style="margin-left:18%;">UDP handle type.</p>

<p style="margin-left:9%;"><b>type uv_udp_send_t</b></p>

<p style="margin-left:18%;">UDP send request type.</p>

<p style="margin-left:9%;"><b>enum uv_udp_flags</b></p>

<p style="margin-left:18%;">Flags used in
<i>uv_udp_bind()</i> and <i>uv_udp_recv_cb</i>..</p>

<p style="margin-left:22%; margin-top: 1em">enum
uv_udp_flags { <br>
/* Disables dual stack mode. */ <br>
UV_UDP_IPV6ONLY = 1, <br>
/* <br>
* Indicates message was truncated because read buffer was
too small. The <br>
* remainder was discarded by the OS. Used in uv_udp_recv_cb.
<br>
*/ <br>
UV_UDP_PARTIAL = 2, <br>
/* <br>
* Indicates if SO_REUSEADDR will be set when binding the
handle. <br>
* This sets the SO_REUSEPORT socket flag on the BSDs (except
for <br>
* DragonFlyBSD), OS X, and other platforms where
SO_REUSEPORTs don't <br>
* have the capability of load balancing, as the opposite of
what <br>
* UV_UDP_REUSEPORT would do. On other Unix platforms, it
sets the <br>
* SO_REUSEADDR flag. What that means is that multiple
threads or <br>
* processes can bind to the same address without error
(provided <br>
* they all set the flag) but only the last one to bind will
receive <br>
* any traffic, in effect &quot;stealing&quot; the port from
the previous listener. <br>
*/ <br>
UV_UDP_REUSEADDR = 4, <br>
/* <br>
* Indicates that the message was received by recvmmsg, so
the buffer provided <br>
* must not be freed by the recv_cb callback. <br>
*/ <br>
UV_UDP_MMSG_CHUNK = 8, <br>
/* <br>
* Indicates that the buffer provided has been fully utilized
by recvmmsg and <br>
* that it should now be freed by the recv_cb callback. When
this flag is set <br>
* in uv_udp_recv_cb, nread will always be 0 and addr will
always be NULL. <br>
*/ <br>
UV_UDP_MMSG_FREE = 16, <br>
/* <br>
* Indicates if IP_RECVERR/IPV6_RECVERR will be set when
binding the handle. <br>
* This sets IP_RECVERR for IPv4 and IPV6_RECVERR for IPv6
UDP sockets on <br>
* Linux. This stops the Linux kernel from suppressing some
ICMP error messages <br>
* and enables full ICMP error reporting for faster failover.
<br>
* This flag is no-op on platforms other than Linux. <br>
*/ <br>
UV_UDP_LINUX_RECVERR = 32, <br>
/* <br>
* Indicates if SO_REUSEPORT will be set when binding the
handle. <br>
* This sets the SO_REUSEPORT socket option on supported
platforms. <br>
* Unlike UV_UDP_REUSEADDR, this flag will make multiple
threads or <br>
* processes that are binding to the same address and port
&quot;share&quot; <br>
* the port, which means incoming datagrams are distributed
across <br>
* the receiving sockets among threads or processes. <br>
* <br>
* This flag is available only on Linux 3.9+, DragonFlyBSD
3.6+, <br>
* FreeBSD 12.0+, Solaris 11.4, and AIX 7.2.5+ for now. <br>
*/ <br>
UV_UDP_REUSEPORT = 64, <br>
/* <br>
* Indicates that recvmmsg should be used, if available. <br>
*/ <br>
UV_UDP_RECVMMSG = 256 <br>
};</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_udp_send_cb)(</b><i>uv_udp_send_t</i> <b>*req, int
status)</b></p>

<p style="margin-left:18%;">Type definition for callback
passed to <i>uv_udp_send()</i>, which is called after the
data was sent.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_udp_recv_cb)(</b><i>uv_udp_t</i> <b>*handle, ssize_t
nread, const</b> <i><br>
uv_buf_t</i> <b>*buf, const struct sockaddr *addr, unsigned
flags)</b></p>

<p style="margin-left:18%;">Type definition for callback
passed to <i>uv_udp_recv_start()</i>, which is called when
the endpoint receives data.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><i>handle</i>: UDP handle</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><i>nread</i>: Number of bytes that have been received. 0
if there is no more data to read. Note that 0 may also mean
that an empty datagram was received (in this case
<i>addr</i> is not NULL). &lt; 0 if a transmission error was
detected; if using <i>recvmmsg(2)</i> no more chunks will be
received and the buffer can be freed safely.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><i>buf</i>: <i>uv_buf_t</i> with the received data.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><i>addr</i>: <b>struct sockaddr*</b> containing the
address of the sender. Can be NULL. Valid for the duration
of the callback only.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><i>flags</i>: One or more or'ed UV_UDP_* constants.</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The callee is
responsible for freeing the buffer, libuv does not reuse it.
The buffer may be a null buffer (where <i>buf-&gt;base</i>
== NULL and <i>buf-&gt;len</i> == 0) on error.</p>

<p style="margin-left:18%; margin-top: 1em">When using
<i>recvmmsg(2)</i>, chunks will have the
<i>UV_UDP_MMSG_CHUNK</i> flag set, those must not be freed.
If no errors occur, there will be a final callback with
<i>nread</i> set to 0, <i>addr</i> set to NULL and the
buffer pointing at the initially allocated data with the
<i>UV_UDP_MMSG_CHUNK</i> flag cleared and the
<i>UV_UDP_MMSG_FREE</i> flag set. If a UDP socket error
occurs, <i>nread</i> will be &lt; 0. In either scenario, the
callee can now safely free the provided buffer.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.40.0: added the <i>UV_UDP_MMSG_FREE</i> flag.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">The receive callback will be
called with <i>nread</i> == 0 and <i>addr</i> == NULL when
there is nothing to read, and with <i>nread</i> == 0 and
<i>addr</i> != NULL when an empty UDP packet is
received.</p>

<p style="margin-left:9%;"><b>enum uv_membership</b></p>

<p style="margin-left:18%;">Membership type for a multicast
address.</p>

<p style="margin-left:22%; margin-top: 1em">typedef enum {
<br>
UV_LEAVE_GROUP = 0, <br>
UV_JOIN_GROUP <br>
} uv_membership;</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>size_t</b>
<i>uv_udp_t</i><b>.send_queue_size</b></p>

<p style="margin-left:18%;">Number of bytes queued for
sending. This field strictly shows how much information is
currently queued.</p>

<p style="margin-left:9%;"><b>size_t</b>
<i>uv_udp_t</i><b>.send_queue_count</b></p>

<p style="margin-left:18%;">Number of send requests
currently in the queue awaiting to be processed.</p>

<p style="margin-left:9%;"><i>uv_udp_t</i>
<b>*</b><i>uv_udp_send_t</i><b>.handle</b></p>

<p style="margin-left:18%;">UDP handle where this send
request is taking place.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> members
also apply.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_udp_init(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_udp_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Initialize a new UDP handle.
The actual socket is created lazily. Returns 0 on
success.</p>

<p style="margin-left:9%;"><b>int
uv_udp_init_ex(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_udp_t</i> <b>*handle, unsigned int <br>
flags)</b></p>

<p style="margin-left:18%;">Initialize the handle with the
specified flags. The lower 8 bits of the <i>flags</i>
parameter are used as the socket domain. A socket will be
created for the given domain. If the specified domain is
<b>AF_UNSPEC</b> no socket is created, just like
<i>uv_udp_init()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">The remaining
bits can be used to set one of these flags:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><i>UV_UDP_RECVMMSG</i>: if set, and the platform
supports it, - <i>recvmmsg(2)</i> will be used.</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.7.0.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.37.0: added the <i>UV_UDP_RECVMMSG</i> flag.</p>

<p style="margin-left:9%;"><b>int
uv_udp_open(</b><i>uv_udp_t</i> <b>*handle,</b>
<i>uv_os_sock_t</i> <b>sock)</b></p>

<p style="margin-left:18%;">Opens an existing file
descriptor or Windows SOCKET as a UDP handle.</p>

<p style="margin-left:18%; margin-top: 1em">Unix only: The
only requirement of the <i>sock</i> argument is that it
follows the datagram contract (works in unconnected mode,
supports sendmsg()/recvmsg(), etc). In other words, other
datagram-type sockets like raw sockets or netlink sockets
can also be passed to this function.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.2.1: the file descriptor is set to non-blocking
mode.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">The passed file descriptor or
SOCKET is not checked for its type, but it's required that
it represents a valid datagram socket.</p>

<p style="margin-left:9%;"><b>int
uv_udp_bind(</b><i>uv_udp_t</i> <b>*handle, const struct
sockaddr *addr, unsigned <br>
int flags)</b></p>

<p style="margin-left:18%;">Bind the UDP handle to an IP
address and port. <b><br>
Parameters</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>handle</b> -- UDP handle. Should have been
initialized with <i>uv_udp_init()</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>addr</b> -- <i>struct sockaddr_in</i> or <i>struct
sockaddr_in6</i> with the address and port to bind to.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>flags</b> -- Indicate how the socket will be bound,
<b>UV_UDP_IPV6ONLY</b>, <b>UV_UDP_REUSEADDR</b>,
<b>UV_UDP_REUSEPORT</b>, and <b>UV_UDP_RECVERR</b> are
supported.</p> </td></tr>
</table>

<p style="margin-left:18%;"><b>Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.49.0: added the <b>UV_UDP_REUSEPORT</b> flag.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><b>UV_UDP_REUSEPORT</b> flag is
available only on Linux 3.9+, DragonFlyBSD 3.6+, FreeBSD
12.0+, Solaris 11.4, and AIX 7.2.5+ at the moment. On other
platforms this function will return an UV_ENOTSUP error. For
platforms where <i>SO_REUSEPORT`s have the capability of
load balancing, specifying both ``UV_UDP_REUSEADDR`</i> and
<b>UV_UDP_REUSEPORT</b> in flags is allowed and
<i>SO_REUSEPORT</i> will always override the behavior of
<i>SO_REUSEADDR</i>. For platforms where <i>SO_REUSEPORT`s
don't have the capability of load balancing, specifying both
``UV_UDP_REUSEADDR`</i> and <b>UV_UDP_REUSEPORT</b> in flags
will fail, returning an UV_ENOTSUP error.</p>

<p style="margin-left:9%;"><b>int
uv_udp_connect(</b><i>uv_udp_t</i> <b>*handle, const struct
sockaddr *addr)</b></p>

<p style="margin-left:18%;">Associate the UDP handle to a
remote address and port, so every message sent by this
handle is automatically sent to that destination. Calling
this function with a <i>NULL addr</i> disconnects the
handle. Trying to call <i>uv_udp_connect()</i> on an already
connected handle will result in an <i>UV_EISCONN</i> error.
Trying to disconnect a handle that is not connected will
return an <i>UV_ENOTCONN</i> error. <b><br>
Parameters</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>handle</b> -- UDP handle. Should have been
initialized with <i>uv_udp_init()</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>addr</b> -- <i>struct sockaddr_in</i> or <i>struct
sockaddr_in6</i> with the address and port to associate
to.</p> </td></tr>
</table>

<p style="margin-left:18%;"><b>Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.27.0.</p>

<p style="margin-left:9%;"><b>int
uv_udp_getpeername(const</b> <i>uv_udp_t</i> <b>*handle,
struct sockaddr *name, <br>
int *namelen)</b></p>

<p style="margin-left:18%;">Get the remote IP and port of
the UDP handle on connected UDP handles. On unconnected
handles, it returns <i>UV_ENOTCONN</i>. <b><br>
Parameters</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>handle</b> -- UDP handle. Should have been
initialized with <i>uv_udp_init()</i> and bound.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>name</b> -- Pointer to the structure to be filled
with the address data. In order to support IPv4 and IPv6
<i>struct sockaddr_storage</i> should be used.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>namelen</b> -- On input it indicates the data of the
<i>name</i> field. On output it indicates how much of it was
filled.</p> </td></tr>
</table>

<p style="margin-left:18%;"><b>Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.27.0.</p>

<p style="margin-left:9%;"><b>int
uv_udp_getsockname(const</b> <i>uv_udp_t</i> <b>*handle,
struct sockaddr *name, <br>
int *namelen)</b></p>

<p style="margin-left:18%;">Get the local IP and port of
the UDP handle. <b><br>
Parameters</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>handle</b> -- UDP handle. Should have been
initialized with <i>uv_udp_init()</i> and bound.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>name</b> -- Pointer to the structure to be filled
with the address data. In order to support IPv4 and IPv6
<i>struct sockaddr_storage</i> should be used.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>namelen</b> -- On input it indicates the data of the
<i>name</i> field. On output it indicates how much of it was
filled.</p> </td></tr>
</table>

<p style="margin-left:18%;"><b>Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure.</p>

<p style="margin-left:9%;"><b>int
uv_udp_set_membership(</b><i>uv_udp_t</i> <b>*handle, const
char *multicast_addr, <br>
const char *interface_addr,</b> <i>uv_membership</i>
<b>membership)</b></p>

<p style="margin-left:18%;">Set membership for a multicast
address <b><br>
Parameters</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>handle</b> -- UDP handle. Should have been
initialized with <i>uv_udp_init()</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>multicast_addr</b> -- Multicast address to set
membership for.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>interface_addr</b> -- Interface address.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>membership</b> -- Should be <b>UV_JOIN_GROUP</b> or
<b>UV_LEAVE_GROUP</b>.</p> </td></tr>
</table>

<p style="margin-left:18%;"><b>Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure.</p>

<p style="margin-left:9%;"><b>int
uv_udp_set_source_membership(</b><i>uv_udp_t</i> <b>*handle,
const char <br>
*multicast_addr, const char *interface_addr, const char
*source_addr,</b> <i><br>
uv_membership</i> <b>membership)</b></p>

<p style="margin-left:18%;">Set membership for a
source-specific multicast group. <b><br>
Parameters</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>handle</b> -- UDP handle. Should have been
initialized with <i>uv_udp_init()</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>multicast_addr</b> -- Multicast address to set
membership for.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>interface_addr</b> -- Interface address.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>source_addr</b> -- Source address.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>membership</b> -- Should be <b>UV_JOIN_GROUP</b> or
<b>UV_LEAVE_GROUP</b>.</p> </td></tr>
</table>

<p style="margin-left:18%;"><b>Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.32.0.</p>

<p style="margin-left:9%;"><b>int
uv_udp_set_multicast_loop(</b><i>uv_udp_t</i> <b>*handle,
int on)</b></p>

<p style="margin-left:18%;">Set IP multicast loop flag.
Makes multicast packets loop back to local sockets. <b><br>
Parameters</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>handle</b> -- UDP handle. Should have been
initialized with <i>uv_udp_init_ex()</i> as either
<b>AF_INET</b> or <b>AF_INET6</b>, or have been bound to an
address explicitly with <i>uv_udp_bind()</i>, or implicitly
with <i>uv_udp_send()</i> or <i>uv_udp_recv_start()</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>on</b> -- 1 for on, 0 for off.</p></td></tr>
</table>

<p style="margin-left:18%;"><b>Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure.</p>

<p style="margin-left:9%;"><b>int
uv_udp_set_multicast_ttl(</b><i>uv_udp_t</i> <b>*handle, int
ttl)</b></p>

<p style="margin-left:18%;">Set the multicast ttl. <b><br>
Parameters</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>handle</b> -- UDP handle. Should have been
initialized with <i>uv_udp_init_ex()</i> as either
<b>AF_INET</b> or <b>AF_INET6</b>, or have been bound to an
address explicitly with <i>uv_udp_bind()</i>, or implicitly
with <i>uv_udp_send()</i> or <i>uv_udp_recv_start()</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>ttl</b> -- 1 through 255.</p></td></tr>
</table>

<p style="margin-left:18%;"><b>Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure.</p>

<p style="margin-left:9%;"><b>int
uv_udp_set_multicast_interface(</b><i>uv_udp_t</i>
<b>*handle, const char <br>
*interface_addr)</b></p>

<p style="margin-left:18%;">Set the multicast interface to
send or receive data on. <b><br>
Parameters</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>handle</b> -- UDP handle. Should have been
initialized with <i>uv_udp_init_ex()</i> as either
<b>AF_INET</b> or <b>AF_INET6</b>, or have been bound to an
address explicitly with <i>uv_udp_bind()</i>, or implicitly
with <i>uv_udp_send()</i> or <i>uv_udp_recv_start()</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>interface_addr</b> -- interface address.</p></td></tr>
</table>

<p style="margin-left:18%;"><b>Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure.</p>

<p style="margin-left:9%;"><b>int
uv_udp_set_broadcast(</b><i>uv_udp_t</i> <b>*handle, int
on)</b></p>

<p style="margin-left:18%;">Set broadcast on or off.
<b><br>
Parameters</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>handle</b> -- UDP handle. Should have been
initialized with <i>uv_udp_init_ex()</i> as either
<b>AF_INET</b> or <b>AF_INET6</b>, or have been bound to an
address explicitly with <i>uv_udp_bind()</i>, or implicitly
with <i>uv_udp_send()</i> or <i>uv_udp_recv_start()</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>on</b> -- 1 for on, 0 for off.</p></td></tr>
</table>

<p style="margin-left:18%;"><b>Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure.</p>

<p style="margin-left:9%;"><b>int
uv_udp_set_ttl(</b><i>uv_udp_t</i> <b>*handle, int
ttl)</b></p>

<p style="margin-left:18%;">Set the time to live. <b><br>
Parameters</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>handle</b> -- UDP handle. Should have been
initialized with <i>uv_udp_init_ex()</i> as either
<b>AF_INET</b> or <b>AF_INET6</b>, or have been bound to an
address explicitly with <i>uv_udp_bind()</i>, or implicitly
with <i>uv_udp_send()</i> or <i>uv_udp_recv_start()</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>ttl</b> -- 1 through 255.</p></td></tr>
</table>

<p style="margin-left:18%;"><b>Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure.</p>

<p style="margin-left:9%;"><b>int
uv_udp_send(</b><i>uv_udp_send_t</i> <b>*req,</b>
<i>uv_udp_t</i> <b>*handle, const</b> <i>uv_buf_t</i>
<b><br>
bufs[], unsigned int nbufs, const struct sockaddr *addr,</b>
<i>uv_udp_send_cb</i> <b><br>
send_cb)</b></p>

<p style="margin-left:18%;">Send data over the UDP socket.
If the socket has not previously been bound with
<i>uv_udp_bind()</i> it will be bound to 0.0.0.0 (the
&quot;all interfaces&quot; IPv4 address) and a random port
number.</p>

<p style="margin-left:18%; margin-top: 1em">On Windows if
the <i>addr</i> is initialized to point to an unspecified
address (<b>0.0.0.0</b> or <b>::</b>) it will be changed to
point to <b>localhost</b>. This is done to match the
behavior of Linux systems.</p>

<p style="margin-left:18%; margin-top: 1em">For connected
UDP handles, <i>addr</i> must be set to <i>NULL</i>,
otherwise it will return <i>UV_EISCONN</i> error.</p>

<p style="margin-left:18%; margin-top: 1em">For
connectionless UDP handles, <i>addr</i> cannot be
<i>NULL</i>, otherwise it will return <i>UV_EDESTADDRREQ</i>
error. <b><br>
Parameters</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>req</b> -- UDP request handle. Need not be
initialized.</p> </td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>handle</b> -- UDP handle. Should have been
initialized with <i>uv_udp_init()</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>bufs</b> -- List of buffers to send.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>nbufs</b> -- Number of buffers in <i>bufs</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>addr</b> -- <i>struct sockaddr_in</i> or <i>struct
sockaddr_in6</i> with the address and port of the remote
peer.</p> </td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>send_cb</b> -- Callback to invoke when the data has
been sent out.</p></td></tr>
</table>

<p style="margin-left:18%;"><b>Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.19.0: added <b>0.0.0.0</b> and <b>::</b> to
<b>localhost</b> mapping</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.27.0: added support for connected sockets</p>

<p style="margin-left:9%;"><b>int
uv_udp_try_send(</b><i>uv_udp_t</i> <b>*handle, const</b>
<i>uv_buf_t</i> <b>bufs[], unsigned <br>
int nbufs, const struct sockaddr *addr)</b></p>

<p style="margin-left:18%;">Same as <i>uv_udp_send()</i>,
but won't queue a send request if it can't be completed
immediately.</p>

<p style="margin-left:18%; margin-top: 1em">For connected
UDP handles, <i>addr</i> must be set to <i>NULL</i>,
otherwise it will return <i>UV_EISCONN</i> error.</p>

<p style="margin-left:18%; margin-top: 1em">For
connectionless UDP handles, <i>addr</i> cannot be
<i>NULL</i>, otherwise it will return <i>UV_EDESTADDRREQ</i>
error. <b><br>
Returns</b></p>

<p style="margin-left:27%;">&gt;= 0: number of bytes sent
(it matches the given buffer size). &lt; 0: negative error
code (<b>UV_EAGAIN</b> is returned when the message can't be
sent immediately).</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.27.0: added support for connected sockets</p>

<p style="margin-left:9%;"><b>int
uv_udp_try_send2(</b><i>uv_udp_t</i> <b>*handle, unsigned
int count,</b> <i>uv_buf_t</i> <b><br>
*bufs[/*count*/], unsigned int nbufs[/*count*/], struct
sockaddr <br>
*addrs[/*count*/], unsigned int flags)</b></p>

<p style="margin-left:18%;">Like <i>uv_udp_try_send()</i>,
but can send multiple datagrams. Lightweight abstraction
around <i>sendmmsg(2)</i>, with a <i>sendmsg(2)</i> fallback
loop for platforms that do not support the former. The
handle must be fully initialized; call
c:func:<i>uv_udp_bind</i> first. <b><br>
Returns</b></p>

<p style="margin-left:27%;">&gt;= 0: number of datagrams
sent. Zero only if <i>count</i> was zero. &lt; 0: negative
error code. Only if sending the first datagram fails,
otherwise returns a positive send count. <b>UV_EAGAIN</b>
when datagrams cannot be sent right now; fall back to
<i>uv_udp_send()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.50.0.</p>

<p style="margin-left:9%;"><b>int
uv_udp_recv_start(</b><i>uv_udp_t</i> <b>*handle,</b>
<i>uv_alloc_cb</i> <b>alloc_cb,</b> <i><br>
uv_udp_recv_cb</i> <b>recv_cb)</b></p>

<p style="margin-left:18%;">Prepare for receiving data. If
the socket has not previously been bound with
<i>uv_udp_bind()</i> it is bound to 0.0.0.0 (the &quot;all
interfaces&quot; IPv4 address) and a random port number.
<b><br>
Parameters</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>handle</b> -- UDP handle. Should have been
initialized with <i>uv_udp_init()</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>alloc_cb</b> -- Callback to invoke when temporary
storage is needed.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>recv_cb</b> -- Callback to invoke with received
data.</p> </td></tr>
</table>

<p style="margin-left:18%;"><b>Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">When using <i>recvmmsg(2)</i>,
the number of messages received at a time is limited by the
number of max size dgrams that will fit into the buffer
allocated in <i>alloc_cb</i>, and <i>suggested_size</i> in
<i>alloc_cb</i> for udp_recv is always set to the size of 1
max size dgram.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.35.0: added support for <i>recvmmsg(2)</i> on
supported platforms). The use of this feature requires a
buffer larger than 2 * 64KB to be passed to
<i>alloc_cb</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.37.0: <i>recvmmsg(2)</i> support is no longer
enabled implicitly, it must be explicitly requested by
passing the <i>UV_UDP_RECVMMSG</i> flag to
<i>uv_udp_init_ex()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.39.0: <i>uv_udp_using_recvmmsg()</i> can be used
in <i>alloc_cb</i> to determine if a buffer sized for use
with - <i>recvmmsg(2)</i> should be allocated for the
current handle/platform.</p>

<p style="margin-left:9%;"><b>int
uv_udp_using_recvmmsg(</b><i>uv_udp_t</i>
<b>*handle)</b></p>

<p style="margin-left:18%;">Returns 1 if the UDP handle was
created with the <i>UV_UDP_RECVMMSG</i> flag and the
platform supports <i>recvmmsg(2)</i>, 0 otherwise.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.39.0.</p>

<p style="margin-left:9%;"><b>int
uv_udp_recv_stop(</b><i>uv_udp_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Stop listening for incoming
datagrams. <b><br>
Parameters</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>handle</b> -- UDP handle. Should have been
initialized with <i>uv_udp_init()</i>.</p></td></tr>
</table>

<p style="margin-left:18%;"><b>Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure.</p>

<p style="margin-left:9%;"><b>size_t
uv_udp_get_send_queue_size(const</b> <i>uv_udp_t</i>
<b>*handle)</b></p>

<p style="margin-left:18%;">Returns
<i>handle-&gt;send_queue_size</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<p style="margin-left:9%;"><b>size_t
uv_udp_get_send_queue_count(const</b> <i>uv_udp_t</i>
<b>*handle)</b></p>

<p style="margin-left:18%;">Returns
<i>handle-&gt;send_queue_count</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> API
functions also apply.</p>

<h3>uv_fs_event_t --- FS Event handle
<a name="uv_fs_event_t --- FS Event handle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">FS Event handles
allow the user to monitor a given path for changes, for
example, if the file was renamed or there was a generic
change in it. This handle uses the best backend for the job
on each platform.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">For AIX, the non default IBM
bos.ahafs package has to be installed. The AIX Event
Infrastructure file system (ahafs) has some limitations:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>ahafs tracks monitoring per process and is not thread
safe. A separate process must be spawned for each monitor
for the same event.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>Events for file modification (writing to a file) are not
received if only the containing folder is watched.</p></td></tr>
</table>

<p style="margin-left:13%; margin-top: 1em">See
<i>documentation</i> for more details.</p>

<p style="margin-left:13%; margin-top: 1em">The z/OS file
system events monitoring infrastructure does not notify of
file creation/deletion within a directory that is being
monitored. See the <i>IBM Knowledge centre</i> for more
details.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_fs_event_t</b></p>

<p style="margin-left:18%;">FS Event handle type.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_fs_event_cb)(</b><i>uv_fs_event_t</i> <b>*handle, const
char <br>
*filename, int events, int status)</b></p>

<p style="margin-left:18%;">Callback passed to
<i>uv_fs_event_start()</i> which will be called repeatedly
after the handle is started.</p>

<p style="margin-left:18%; margin-top: 1em">If the handle
was started with a directory the <i>filename</i> parameter
will be a relative path to a file contained in the
directory, or <i>NULL</i> if the file name cannot be
determined.</p>

<p style="margin-left:18%; margin-top: 1em">The
<i>events</i> parameter is an ORed mask of
<i>uv_fs_event</i> elements.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">For FreeBSD path could
sometimes be <i>NULL</i> due to a kernel bug.</p>

<p style="margin-left:9%;"><b>enum uv_fs_event</b></p>

<p style="margin-left:18%;">Event types that
<i>uv_fs_event_t</i> handles monitor.</p>

<p style="margin-left:22%; margin-top: 1em">enum
uv_fs_event { <br>
UV_RENAME = 1, <br>
UV_CHANGE = 2 <br>
};</p>

<p style="margin-left:9%;"><b>enum
uv_fs_event_flags</b></p>

<p style="margin-left:18%;">Flags that can be passed to
<i>uv_fs_event_start()</i> to control its behavior.</p>

<p style="margin-left:22%; margin-top: 1em">enum
uv_fs_event_flags { <br>
/* <br>
* By default, if the fs event watcher is given a directory
name, we will <br>
* watch for all events in that directory. This flags
overrides this behavior <br>
* and makes fs_event report only changes to the directory
entry itself. This <br>
* flag does not affect individual files watched. <br>
* This flag is currently not implemented yet on any backend.
<br>
*/ <br>
UV_FS_EVENT_WATCH_ENTRY = 1, <br>
/* <br>
* By default uv_fs_event will try to use a kernel interface
such as inotify <br>
* or kqueue to detect events. This may not work on remote
file systems such <br>
* as NFS mounts. This flag makes fs_event fall back to
calling stat() on a <br>
* regular interval. <br>
* This flag is currently not implemented yet on any backend.
<br>
*/ <br>
UV_FS_EVENT_STAT = 2, <br>
/* <br>
* By default, event watcher, when watching directory, is not
registering <br>
* (is ignoring) changes in its subdirectories. <br>
* This flag will override this behaviour on platforms that
support it. <br>
*/ <br>
UV_FS_EVENT_RECURSIVE = 4 <br>
};</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">N/A</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> members
also apply.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_fs_event_init(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_event_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Initialize the handle.</p>

<p style="margin-left:9%;"><b>int
uv_fs_event_start(</b><i>uv_fs_event_t</i> <b>*handle,</b>
<i>uv_fs_event_cb</i> <b>cb, const <br>
char *path, unsigned int flags)</b></p>

<p style="margin-left:18%;">Start the handle with the given
callback, which will watch the specified <i>path</i> for
changes. <i>flags</i> can be an ORed mask of
<i>uv_fs_event_flags</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Currently the only supported
flag is <b>UV_FS_EVENT_RECURSIVE</b> and only on OSX and
Windows.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">On macOS, events collected by
the OS immediately before calling <b>uv_fs_event_start</b>
might be reported to the <i>uv_fs_event_cb</i> callback.</p>

<p style="margin-left:9%;"><b>int
uv_fs_event_stop(</b><i>uv_fs_event_t</i>
<b>*handle)</b></p>

<p style="margin-left:18%;">Stop the handle, the callback
will no longer be called.</p>

<p style="margin-left:9%;"><b>int
uv_fs_event_getpath(</b><i>uv_fs_event_t</i> <b>*handle,
char *buffer, size_t <br>
*size)</b></p>

<p style="margin-left:18%;">Get the path being monitored by
the handle. The buffer must be preallocated by the user.
Returns 0 on success or an error code &lt; 0 in case of
failure. On success, <i>buffer</i> will contain the path and
<i>size</i> its length. If the buffer is not big enough
<i>UV_ENOBUFS</i> will be returned and <i>size</i> will be
set to the required size, including the null terminator.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.3.0: the returned length no longer includes the
terminating null byte, and the buffer is not null
terminated.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.9.0: the returned length includes the terminating
null byte on <i>UV_ENOBUFS</i>, and the buffer is null
terminated on success.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> API
functions also apply.</p>

<h3>uv_fs_poll_t --- FS Poll handle
<a name="uv_fs_poll_t --- FS Poll handle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">FS Poll handles
allow the user to monitor a given path for changes. Unlike
<i>uv_fs_event_t</i>, fs poll handles use <i>stat</i> to
detect when a file has changed so they can work on file
systems where fs event handles can't.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_fs_poll_t</b></p>

<p style="margin-left:18%;">FS Poll handle type.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_fs_poll_cb)(</b><i>uv_fs_poll_t</i> <b>*handle, int
status, const</b> <i><br>
uv_stat_t</i> <b>*prev, const</b> <i>uv_stat_t</i>
<b>*curr)</b></p>

<p style="margin-left:18%;">Callback passed to
<i>uv_fs_poll_start()</i> which will be called repeatedly
after the handle is started, when any change happens to the
monitored path.</p>

<p style="margin-left:18%; margin-top: 1em">The callback is
invoked with <i>status &lt; 0</i> if <i>path</i> does not
exist or is inaccessible. The watcher is <i>not</i> stopped
but your callback is not called again until something
changes (e.g. when the file is created or the error reason
changes).</p>

<p style="margin-left:18%; margin-top: 1em">When <i>status
== 0</i>, the callback receives pointers to the old and new
<i>uv_stat_t</i> structs. They are valid for the duration of
the callback only.</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">N/A</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> members
also apply.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_fs_poll_init(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_poll_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Initialize the handle.</p>

<p style="margin-left:9%;"><b>int
uv_fs_poll_start(</b><i>uv_fs_poll_t</i> <b>*handle,</b>
<i>uv_fs_poll_cb</i> <b>poll_cb, const <br>
char *path, unsigned int interval)</b></p>

<p style="margin-left:18%;">Check the file at <i>path</i>
for changes every <i>interval</i> milliseconds.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">For maximum portability, use
multi-second intervals. Sub-second intervals will not detect
all changes on many file systems.</p>

<p style="margin-left:9%;"><b>int
uv_fs_poll_stop(</b><i>uv_fs_poll_t</i> <b>*handle)</b></p>

<p style="margin-left:18%;">Stop the handle, the callback
will no longer be called.</p>

<p style="margin-left:9%;"><b>int
uv_fs_poll_getpath(</b><i>uv_fs_poll_t</i> <b>*handle, char
*buffer, size_t <br>
*size)</b></p>

<p style="margin-left:18%;">Get the path being monitored by
the handle. The buffer must be preallocated by the user.
Returns 0 on success or an error code &lt; 0 in case of
failure. On success, <i>buffer</i> will contain the path and
<i>size</i> its length. If the buffer is not big enough
<i>UV_ENOBUFS</i> will be returned and <i>size</i> will be
set to the required size.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.3.0: the returned length no longer includes the
terminating null byte, and the buffer is not null
terminated.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.9.0: the returned length includes the terminating
null byte on <i>UV_ENOBUFS</i>, and the buffer is null
terminated on success.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_handle_t</i> API
functions also apply.</p>

<h3>File system operations
<a name="File system operations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv provides a
wide variety of cross-platform sync and async file system
operations. All functions defined in this document take a
callback, which is allowed to be NULL. If the callback is
NULL the request is completed synchronously, otherwise it
will be performed asynchronously.</p>

<p style="margin-left:9%; margin-top: 1em">All file
operations are run on the threadpool. See <i>Thread pool
work scheduling</i> for information on the threadpool
size.</p>

<p style="margin-left:9%; margin-top: 1em">Starting with
libuv v1.45.0, some file operations on Linux are handed off
to <i>io_uring
&lt;https://en.wikipedia.org/wiki/Io_uring&gt;</i> when
possible. Apart from a (sometimes significant) increase in
throughput there should be no change in observable behavior.
Libuv reverts to using its threadpool when the necessary
kernel features are unavailable or unsuitable. Starting with
libuv v1.49.0 this behavior was reverted and Libuv on Linux
by default will be using the threadpool again. In order to
enable io_uring the <i>uv_loop_t</i> instance must be
configured with the <b>UV_LOOP_ENABLE_IO_URING_SQPOLL</b>
option.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">On Windows <i>uv_fs_*</i>
functions use utf-8 encoding.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_fs_t</b></p>

<p style="margin-left:18%;">File system request type.</p>

<p style="margin-left:9%;"><b>type uv_timespec_t</b></p>

<p style="margin-left:18%;">Y2K38-unsafe data type for
storing times with nanosecond resolution. Will be replaced
with <i>uv_timespec64_t</i> in libuv v2.0.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
{ <br>
long tv_sec; <br>
long tv_nsec; <br>
} uv_timespec_t;</p>

<p style="margin-left:9%;"><b>type uv_stat_t</b></p>

<p style="margin-left:18%;">Portable equivalent of
<b>struct stat</b>.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
{ <br>
uint64_t st_dev; <br>
uint64_t st_mode; <br>
uint64_t st_nlink; <br>
uint64_t st_uid; <br>
uint64_t st_gid; <br>
uint64_t st_rdev; <br>
uint64_t st_ino; <br>
uint64_t st_size; <br>
uint64_t st_blksize; <br>
uint64_t st_blocks; <br>
uint64_t st_flags; <br>
uint64_t st_gen; <br>
uv_timespec_t st_atim; <br>
uv_timespec_t st_mtim; <br>
uv_timespec_t st_ctim; <br>
uv_timespec_t st_birthtim; <br>
} uv_stat_t;</p>

<p style="margin-left:9%;"><b>enum uv_fs_type</b></p>

<p style="margin-left:18%;">File system request type.</p>

<p style="margin-left:22%; margin-top: 1em">typedef enum {
<br>
UV_FS_UNKNOWN = -1, <br>
UV_FS_CUSTOM, <br>
UV_FS_OPEN, <br>
UV_FS_CLOSE, <br>
UV_FS_READ, <br>
UV_FS_WRITE, <br>
UV_FS_SENDFILE, <br>
UV_FS_STAT, <br>
UV_FS_LSTAT, <br>
UV_FS_FSTAT, <br>
UV_FS_FTRUNCATE, <br>
UV_FS_UTIME, <br>
UV_FS_FUTIME, <br>
UV_FS_ACCESS, <br>
UV_FS_CHMOD, <br>
UV_FS_FCHMOD, <br>
UV_FS_FSYNC, <br>
UV_FS_FDATASYNC, <br>
UV_FS_UNLINK, <br>
UV_FS_RMDIR, <br>
UV_FS_MKDIR, <br>
UV_FS_MKDTEMP, <br>
UV_FS_RENAME, <br>
UV_FS_SCANDIR, <br>
UV_FS_LINK, <br>
UV_FS_SYMLINK, <br>
UV_FS_READLINK, <br>
UV_FS_CHOWN, <br>
UV_FS_FCHOWN, <br>
UV_FS_REALPATH, <br>
UV_FS_COPYFILE, <br>
UV_FS_LCHOWN, <br>
UV_FS_OPENDIR, <br>
UV_FS_READDIR, <br>
UV_FS_CLOSEDIR, <br>
UV_FS_MKSTEMP, <br>
UV_FS_LUTIME <br>
} uv_fs_type;</p>

<p style="margin-left:9%;"><b>type uv_statfs_t</b></p>

<p style="margin-left:18%;">Reduced cross platform
equivalent of <b>struct statfs</b>. Used in
<i>uv_fs_statfs()</i>.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
uv_statfs_s { <br>
uint64_t f_type; <br>
uint64_t f_bsize; <br>
uint64_t f_blocks; <br>
uint64_t f_bfree; <br>
uint64_t f_bavail; <br>
uint64_t f_files; <br>
uint64_t f_ffree; <br>
uint64_t f_spare[4]; <br>
} uv_statfs_t;</p>

<p style="margin-left:9%;"><b>enum uv_dirent_type_t</b></p>

<p style="margin-left:18%;">Type of dirent.</p>

<p style="margin-left:22%; margin-top: 1em">typedef enum {
<br>
UV_DIRENT_UNKNOWN, <br>
UV_DIRENT_FILE, <br>
UV_DIRENT_DIR, <br>
UV_DIRENT_LINK, <br>
UV_DIRENT_FIFO, <br>
UV_DIRENT_SOCKET, <br>
UV_DIRENT_CHAR, <br>
UV_DIRENT_BLOCK <br>
} uv_dirent_type_t;</p>

<p style="margin-left:9%;"><b>type uv_dirent_t</b></p>

<p style="margin-left:18%;">Cross platform (reduced)
equivalent of <b>struct dirent</b>. Used in
<i>uv_fs_scandir_next()</i>.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
uv_dirent_s { <br>
const char* name; <br>
uv_dirent_type_t type; <br>
} uv_dirent_t;</p>

<p style="margin-left:9%;"><b>type uv_dir_t</b></p>

<p style="margin-left:18%;">Data type used for streaming
directory iteration. Used by <i>uv_fs_opendir()</i>,
<i>uv_fs_readdir()</i>, and <i>uv_fs_closedir()</i>.
<i>dirents</i> represents a user provided array of
<i>uv_dirent_t`s used to hold results. `nentries</i> is the
user provided maximum array size of <i>dirents</i>.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
uv_dir_s { <br>
uv_dirent_t* dirents; <br>
size_t nentries; <br>
} uv_dir_t;</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_fs_cb)(</b><i>uv_fs_t</i> <b>*req)</b></p>

<p style="margin-left:18%;">Callback called when a request
is completed asynchronously.</p>

<h3>Public members
<a name="Public members"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>uv_loop_t</i>
<b>*</b><i>uv_fs_t</i><b>.loop</b></p>

<p style="margin-left:18%;">Loop that started this request
and where completion will be reported. Readonly.</p>

<p style="margin-left:9%;"><i>uv_fs_type
uv_fs_t</i><b>.fs_type</b></p>

<p style="margin-left:18%;">FS request type.</p>

<p style="margin-left:9%;"><b>const char
*</b><i>uv_fs_t</i><b>.path</b></p>

<p style="margin-left:18%;">Path affecting the request.</p>

<p style="margin-left:9%;"><b>ssize_t</b>
<i>uv_fs_t</i><b>.result</b></p>

<p style="margin-left:18%;">Result of the request. &lt; 0
means error, success otherwise. On requests such as
<i>uv_fs_read()</i> or <i>uv_fs_write()</i> it indicates the
amount of data that was read or written, respectively.</p>

<p style="margin-left:9%;"><i>uv_stat_t
uv_fs_t</i><b>.statbuf</b></p>

<p style="margin-left:18%;">Stores the result of
<i>uv_fs_stat()</i> and other stat requests.</p>

<p style="margin-left:9%;"><b>void
*</b><i>uv_fs_t</i><b>.ptr</b></p>

<p style="margin-left:18%;">Stores the result of
<i>uv_fs_readlink()</i> and <i>uv_fs_realpath()</i> and
serves as an alias to <i>statbuf</i>.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_req_t</i> members
also apply.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>void
uv_fs_req_cleanup(</b><i>uv_fs_t</i> <b>*req)</b></p>

<p style="margin-left:18%;">Cleanup request. Must be called
after a request is finished to deallocate any memory libuv
might have allocated.</p>

<p style="margin-left:9%;"><b>int
uv_fs_close(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req,</b> <i>uv_file</i> <b>file,</b>
<i>uv_fs_cb</i> <b><br>
cb)</b></p>

<p style="margin-left:18%;">Equivalent to
<i>close(2)</i>.</p>

<p style="margin-left:9%;"><b>int
uv_fs_open(</b><i>uv_loop_t</i> <b>*loop,</b> <i>uv_fs_t</i>
<b>*req, const char *path, int <br>
flags, int mode,</b> <i>uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to
<i>open(2)</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">On Windows libuv uses
<i>CreateFileW</i> and thus the file is always opened in
binary mode. Because of this the O_BINARY and O_TEXT flags
are not supported.</p>

<p style="margin-left:9%;"><b>int
uv_fs_read(</b><i>uv_loop_t</i> <b>*loop,</b> <i>uv_fs_t</i>
<b>*req,</b> <i>uv_file</i> <b>file, const</b> <i><br>
uv_buf_t</i> <b>bufs[], unsigned int nbufs, int64_t
offset,</b> <i>uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to <i>preadv(2)</i>.
If the <i>offset</i> argument is <i>-1</i>, then the current
file offset is used and updated.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">On Windows, under non-MSVC
environments (e.g. when GCC or Clang is used to build
libuv), files opened using <b>UV_FS_O_FILEMAP</b> may cause
a fatal crash if the memory mapped read operation fails.</p>

<p style="margin-left:9%;"><b>int
uv_fs_unlink(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path,</b> <i><br>
uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to
<i>unlink(2)</i>.</p>

<p style="margin-left:9%;"><b>int
uv_fs_write(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req,</b> <i>uv_file</i> <b>file,
const</b> <i><br>
uv_buf_t</i> <b>bufs[], unsigned int nbufs, int64_t
offset,</b> <i>uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to
<i>pwritev(2)</i>. If the <i>offset</i> argument is
<i>-1</i>, then the current file offset is used and
updated.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">On Windows, under non-MSVC
environments (e.g. when GCC or Clang is used to build
libuv), files opened using <b>UV_FS_O_FILEMAP</b> may cause
a fatal crash if the memory mapped write operation
fails.</p>

<p style="margin-left:9%;"><b>int
uv_fs_mkdir(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path, int <br>
mode,</b> <i>uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to
<i>mkdir(2)</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>mode</i> is currently not
implemented on Windows.</p>

<p style="margin-left:9%;"><b>int
uv_fs_mkdtemp(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *tpl,</b> <i><br>
uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to
<i>mkdtemp(3)</i>. The result can be found as a null
terminated string at <i>req-&gt;path</i>.</p>

<p style="margin-left:9%;"><b>int
uv_fs_mkstemp(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *tpl,</b> <i><br>
uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to
<i>mkstemp(3)</i>. The created file path can be found as a
null terminated string at <i>req-&gt;path</i>. The file
descriptor can be found as an integer at
<i>req-&gt;result</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.34.0.</p>

<p style="margin-left:9%;"><b>int
uv_fs_rmdir(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path,</b> <i><br>
uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to
<i>rmdir(2)</i>.</p>

<p style="margin-left:9%;"><b>int
uv_fs_opendir(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path,</b> <i><br>
uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Opens <i>path</i> as a
directory stream. On success, a <i>uv_dir_t</i> is allocated
and returned via <i>req-&gt;ptr</i>. This memory is not
freed by <i>uv_fs_req_cleanup()</i>, although
<i>req-&gt;ptr</i> is set to <i>NULL</i>. The allocated
memory must be freed by calling <i>uv_fs_closedir()</i>. On
failure, no memory is allocated.</p>

<p style="margin-left:18%; margin-top: 1em">The contents of
the directory can be iterated over by passing the resulting
<i>uv_dir_t</i> to <i>uv_fs_readdir()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.28.0.</p>

<p style="margin-left:9%;"><b>int
uv_fs_closedir(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req,</b> <i>uv_dir_t</i> <b>*dir,</b>
<i><br>
uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Closes the directory stream
represented by <i>dir</i> and frees the memory allocated by
<i>uv_fs_opendir()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.28.0.</p>

<p style="margin-left:9%;"><b>int
uv_fs_readdir(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req,</b> <i>uv_dir_t</i> <b>*dir,</b>
<i><br>
uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Iterates over the directory
stream, <i>dir</i>, returned by a successful
<i>uv_fs_opendir()</i> call. Prior to invoking
<i>uv_fs_readdir()</i>, the caller must set
<i>dir-&gt;dirents</i> and <i>dir-&gt;nentries</i>,
representing the array of <i>uv_dirent_t</i> elements used
to hold the read directory entries and its size.</p>

<p style="margin-left:18%; margin-top: 1em">On success, the
result is an integer &gt;= 0 representing the number of
entries read from the stream.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.28.0.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;"><i>uv_fs_readdir()</i> is not
thread safe.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">This function does not return
the &quot;.&quot; and &quot;..&quot; entries.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">On success this function
allocates memory that must be freed using
<i>uv_fs_req_cleanup()</i>. <i>uv_fs_req_cleanup()</i> must
be called before closing the directory with
<i>uv_fs_closedir()</i>.</p>

<p style="margin-left:9%;"><b>int
uv_fs_scandir(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path, int <br>
flags,</b> <i>uv_fs_cb</i> <b>cb) <br>
int uv_fs_scandir_next(</b><i>uv_fs_t</i> <b>*req,</b>
<i>uv_dirent_t</i> <b>*ent)</b></p>

<p style="margin-left:18%;">Equivalent to
<i>scandir(3)</i>, with a slightly different API. Once the
callback for the request is called, the user can use
<i>uv_fs_scandir_next()</i> to get <i>ent</i> populated with
the next directory entry data. When there are no more
entries <b>UV_EOF</b> will be returned.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Unlike <i>scandir(3)</i>, this
function does not return the &quot;.&quot; and
&quot;..&quot; entries.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">On Linux, getting the type of
an entry is only supported by some file systems (btrfs,
ext2, ext3 and ext4 at the time of this writing), check the
<i>getdents(2)</i> man page.</p>

<p style="margin-left:9%;"><b>int
uv_fs_stat(</b><i>uv_loop_t</i> <b>*loop,</b> <i>uv_fs_t</i>
<b>*req, const char *path,</b> <i><br>
uv_fs_cb</i> <b>cb) <br>
int uv_fs_fstat(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req,</b> <i>uv_file</i> <b>file,</b>
<i>uv_fs_cb</i> <b><br>
cb) <br>
int uv_fs_lstat(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path,</b> <i><br>
uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to <i>stat(2)</i>,
<i>fstat(2)</i> and <i>lstat(2)</i> respectively.</p>

<p style="margin-left:9%;"><b>int
uv_fs_statfs(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path,</b> <i><br>
uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to <i>statfs(2)</i>.
On success, a <i>uv_statfs_t</i> is allocated and returned
via <i>req-&gt;ptr</i>. This memory is freed by
<i>uv_fs_req_cleanup()</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Any fields in the resulting
<i>uv_statfs_t</i> that are not supported by the underlying
operating system are set to zero.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.31.0.</p>

<p style="margin-left:9%;"><b>int
uv_fs_rename(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path, const <br>
char *new_path,</b> <i>uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to
<i>rename(2)</i>.</p>

<p style="margin-left:9%;"><b>int
uv_fs_fsync(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req,</b> <i>uv_file</i> <b>file,</b>
<i>uv_fs_cb</i> <b><br>
cb)</b></p>

<p style="margin-left:18%;">Equivalent to
<i>fsync(2)</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">For AIX, <i>uv_fs_fsync</i>
returns <i>UV_EBADF</i> on file descriptors referencing non
regular files.</p>

<p style="margin-left:9%;"><b>int
uv_fs_fdatasync(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req,</b> <i>uv_file</i> <b>file,</b>
<i><br>
uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to
<i>fdatasync(2)</i>.</p>

<p style="margin-left:9%;"><b>int
uv_fs_ftruncate(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req,</b> <i>uv_file</i> <b>file, <br>
int64_t offset,</b> <i>uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to
<i>ftruncate(2)</i>.</p>

<p style="margin-left:9%;"><b>int
uv_fs_copyfile(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path, <br>
const char *new_path, int flags,</b> <i>uv_fs_cb</i>
<b>cb)</b></p>

<p style="margin-left:18%;">Copies a file from <i>path</i>
to <i>new_path</i>. Supported <i>flags</i> are described
below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><i>UV_FS_COPYFILE_EXCL</i>: If present,
<i>uv_fs_copyfile()</i> will fail with <i>UV_EEXIST</i> if
the destination path already exists. The default behavior is
to overwrite the destination if it exists.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><i>UV_FS_COPYFILE_FICLONE</i>: If present,
<i>uv_fs_copyfile()</i> will attempt to create a
copy-on-write reflink. If the underlying platform does not
support copy-on-write, or an error occurs while attempting
to use copy-on-write, a fallback copy mechanism based on
<i>uv_fs_sendfile()</i> is used.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p><i>UV_FS_COPYFILE_FICLONE_FORCE</i>: If present,
<i>uv_fs_copyfile()</i> will attempt to create a
copy-on-write reflink. If the underlying platform does not
support copy-on-write, or an error occurs while attempting
to use copy-on-write, then an error is returned.</p></td></tr>
</table>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">If the destination path is
created, but an error occurs while copying the data, then
the destination path is removed. There is a brief window of
time between closing and removing the file where another
process could access the file.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.14.0.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.20.0: <i>UV_FS_COPYFILE_FICLONE</i> and
<i>UV_FS_COPYFILE_FICLONE_FORCE</i> are supported.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.33.0: If an error occurs while using
<i>UV_FS_COPYFILE_FICLONE_FORCE</i>, that error is returned.
Previously, all errors were mapped to <i>UV_ENOTSUP</i>.</p>

<p style="margin-left:9%;"><b>int
uv_fs_sendfile(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req,</b> <i>uv_file</i> <b>out_fd,</b>
<i><br>
uv_file</i> <b>in_fd, int64_t in_offset, size_t length,</b>
<i>uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Limited equivalent to
<i>sendfile(2)</i>.</p>

<p style="margin-left:9%;"><b>int
uv_fs_access(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path, int <br>
mode,</b> <i>uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to <i>access(2)</i>
on Unix. Windows uses <b>GetFileAttributesW()</b>.</p>

<p style="margin-left:9%;"><b>int
uv_fs_chmod(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path, int <br>
mode,</b> <i>uv_fs_cb</i> <b>cb) <br>
int uv_fs_fchmod(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req,</b> <i>uv_file</i> <b>file, int
mode,</b> <i><br>
uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to <i>chmod(2)</i>
and <i>fchmod(2)</i> respectively.</p>

<p style="margin-left:9%;"><b>int
uv_fs_utime(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path, double <br>
atime, double mtime,</b> <i>uv_fs_cb</i> <b>cb) <br>
int uv_fs_futime(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req,</b> <i>uv_file</i> <b>file, double
<br>
atime, double mtime,</b> <i>uv_fs_cb</i> <b>cb) <br>
int uv_fs_lutime(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path, <br>
double atime, double mtime,</b> <i>uv_fs_cb</i>
<b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to <i>utime(2)</i>,
<i>futimes(3)</i> and <i>lutimes(3)</i> respectively.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">z/OS: <i>uv_fs_lutime()</i> is
not implemented for z/OS. It can still be called but will
return <b>UV_ENOSYS</b>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">AIX: <i>uv_fs_futime()</i> and
<i>uv_fs_lutime()</i> functions only work for AIX 7.1 and
newer. They can still be called on older versions but will
return <b>UV_ENOSYS</b>.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.10.0: sub-second precission is supported on
Windows</p>

<p style="margin-left:9%;"><b>int
uv_fs_link(</b><i>uv_loop_t</i> <b>*loop,</b> <i>uv_fs_t</i>
<b>*req, const char *path, const <br>
char *new_path,</b> <i>uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to
<i>link(2)</i>.</p>

<p style="margin-left:9%;"><b>int
uv_fs_symlink(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path, <br>
const char *new_path, int flags,</b> <i>uv_fs_cb</i>
<b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to
<i>symlink(2)</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">On Windows the <i>flags</i>
parameter can be specified to control how the symlink will
be created:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>UV_FS_SYMLINK_DIR</b>: indicates that <i>path</i>
points to a directory.</p></td></tr>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="71%">


<p><b>UV_FS_SYMLINK_JUNCTION</b>: request that the symlink
is created using junction points.</p></td></tr>
</table>

<p style="margin-left:9%;"><b>int
uv_fs_readlink(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path,</b> <i><br>
uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to
<i>readlink(2)</i>. The resulting string is stored in
<i>req-&gt;ptr</i>.</p>

<p style="margin-left:9%;"><b>int
uv_fs_realpath(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path,</b> <i><br>
uv_fs_cb</i> <b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to
<i>realpath(3)</i> on Unix. Windows uses -
<i>GetFinalPathNameByHandleW</i>. The resulting string is
stored in <i>req-&gt;ptr</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">This function has certain
platform-specific caveats that were discovered when used in
Node.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="76%">


<p>macOS and other BSDs: this function will fail with
UV_ELOOP if more than 32 symlinks are found while resolving
the given path. This limit is hardcoded and cannot be
sidestepped.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="76%">


<p>Windows: while this function works in the common case,
there are a number of corner cases where it doesn't:</p></td></tr>
</table>

<p style="margin-left:24%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="24%"></td>
<td width="2%"></td>
<td width="1%"></td>
<td width="73%">


<p style="margin-top: 1em">Paths in ramdisk volumes created
by tools which sidestep the Volume Manager (such as ImDisk)
cannot be resolved.</p></td></tr>
<tr valign="top" align="left">
<td width="24%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="73%">


<p>Inconsistent casing when using drive letters.</p></td></tr>
<tr valign="top" align="left">
<td width="24%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="73%">


<p>Resolved path bypasses subst'd drives.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">While this
function can still be used, it's not recommended if
scenarios such as the above need to be supported.</p>

<p style="margin-left:22%; margin-top: 1em">The background
story and some more details on these issues can be checked
<i>here</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.8.0.</p>

<p style="margin-left:9%;"><b>int
uv_fs_chown(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path, <br>
uv_uid_t uid, uv_gid_t gid,</b> <i>uv_fs_cb</i> <b>cb) <br>
int uv_fs_fchown(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req,</b> <i>uv_file</i> <b>file, uv_uid_t
<br>
uid, uv_gid_t gid,</b> <i>uv_fs_cb</i> <b>cb) <br>
int uv_fs_lchown(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_fs_t</i> <b>*req, const char *path, <br>
uv_uid_t uid, uv_gid_t gid,</b> <i>uv_fs_cb</i>
<b>cb)</b></p>

<p style="margin-left:18%;">Equivalent to <i>chown(2)</i>,
<i>fchown(2)</i> and <i>lchown(2)</i> respectively.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">These functions are not
implemented on Windows.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.21.0: implemented uv_fs_lchown</p>

<p style="margin-left:9%;"><i>uv_fs_type</i>
<b>uv_fs_get_type(const</b> <i>uv_fs_t</i> <b>*req)</b></p>

<p style="margin-left:18%;">Returns
<i>req-&gt;fs_type</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<p style="margin-left:9%;"><b>ssize_t
uv_fs_get_result(const</b> <i>uv_fs_t</i> <b>*req)</b></p>

<p style="margin-left:18%;">Returns
<i>req-&gt;result</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<p style="margin-left:9%;"><b>int
uv_fs_get_system_error(const</b> <i>uv_fs_t</i>
<b>*req)</b></p>

<p style="margin-left:18%;">Returns the platform specific
error code - <i>GetLastError()</i> value on Windows and
<i>-(req-&gt;result)</i> on other platforms.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.38.0.</p>

<p style="margin-left:9%;"><b>void *uv_fs_get_ptr(const</b>
<i>uv_fs_t</i> <b>*req)</b></p>

<p style="margin-left:18%;">Returns <i>req-&gt;ptr</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<p style="margin-left:9%;"><b>const char
*uv_fs_get_path(const</b> <i>uv_fs_t</i> <b>*req)</b></p>

<p style="margin-left:18%;">Returns
<i>req-&gt;path</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<p style="margin-left:9%;"><i>uv_stat_t</i>
<b>*uv_fs_get_statbuf(</b><i>uv_fs_t</i> <b>*req)</b></p>

<p style="margin-left:18%;">Returns
<i>&amp;req-&gt;statbuf</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.19.0.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_req_t</i> API
functions also apply.</p>

<h3>Helper functions
<a name="Helper functions"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>uv_os_fd_t</i>
<b>uv_get_osfhandle(int fd)</b></p>

<p style="margin-left:18%;">For a file descriptor in the C
runtime, get the OS-dependent handle. On UNIX, returns the
<b>fd</b> intact. On Windows, this calls
<i>_get_osfhandle</i>. Note that the return value is still
owned by the C runtime, any attempts to close it or to use
it after closing the fd may lead to malfunction.</p>

<p style="margin-left:22%;">Added in version 1.12.0.</p>

<p style="margin-left:9%;"><b>int
uv_open_osfhandle(</b><i>uv_os_fd_t</i> <b>os_fd)</b></p>

<p style="margin-left:18%;">For a OS-dependent handle, get
the file descriptor in the C runtime. On UNIX, returns the
<b>os_fd</b> intact. On Windows, this calls
<i>_open_osfhandle</i>. Note that this consumes the
argument, any attempts to close it or to use it after
closing the return value may lead to malfunction.</p>

<p style="margin-left:22%;">Added in version 1.23.0.</p>

<h3>File open constants
<a name="File open constants"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>UV_FS_O_APPEND</b></p>

<p style="margin-left:18%;">The file is opened in append
mode. Before each write, the file offset is positioned at
the end of the file.</p>

<p style="margin-left:9%;"><b>UV_FS_O_CREAT</b></p>

<p style="margin-left:18%;">The file is created if it does
not already exist.</p>

<p style="margin-left:9%;"><b>UV_FS_O_DIRECT</b></p>

<p style="margin-left:18%;">File I/O is done directly to
and from user-space buffers, which must be aligned. Buffer
size and address should be a multiple of the physical sector
size of the block device.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>UV_FS_O_DIRECT</i> is
supported on Linux, and on Windows via -
<i>FILE_FLAG_NO_BUFFERING</i>. <i>UV_FS_O_DIRECT</i> is not
supported on macOS.</p>

<p style="margin-left:9%;"><b>UV_FS_O_DIRECTORY</b></p>

<p style="margin-left:18%;">If the path is not a directory,
fail the open.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>UV_FS_O_DIRECTORY</i> is not
supported on Windows.</p>

<p style="margin-left:9%;"><b>UV_FS_O_DSYNC</b></p>

<p style="margin-left:18%;">The file is opened for
synchronous I/O. Write operations will complete once all
data and a minimum of metadata are flushed to disk.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>UV_FS_O_DSYNC</i> is
supported on Windows via -
<i>FILE_FLAG_WRITE_THROUGH</i>.</p>

<p style="margin-left:9%;"><b>UV_FS_O_EXCL</b></p>

<p style="margin-left:18%;">If the <i>O_CREAT</i> flag is
set and the file already exists, fail the open.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">In general, the behavior of
<i>O_EXCL</i> is undefined if it is used without
<i>O_CREAT</i>. There is one exception: on Linux 2.6 and
later, <i>O_EXCL</i> can be used without <i>O_CREAT</i> if
pathname refers to a block device. If the block device is in
use by the system (e.g., mounted), the open will fail with
the error <i>EBUSY</i>.</p>

<p style="margin-left:9%;"><b>UV_FS_O_EXLOCK</b></p>

<p style="margin-left:18%;">Atomically obtain an exclusive
lock.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>UV_FS_O_EXLOCK</i> is only
supported on macOS and Windows.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.17.0: support is added for Windows.</p>

<p style="margin-left:9%;"><b>UV_FS_O_FILEMAP</b></p>

<p style="margin-left:18%;">Use a memory file mapping to
access the file. When using this flag, the file cannot be
open multiple times concurrently.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>UV_FS_O_FILEMAP</i> is only
supported on Windows.</p>

<p style="margin-left:9%;"><b>UV_FS_O_NOATIME</b></p>

<p style="margin-left:18%;">Do not update the file access
time when the file is read.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>UV_FS_O_NOATIME</i> is not
supported on Windows.</p>

<p style="margin-left:9%;"><b>UV_FS_O_NOCTTY</b></p>

<p style="margin-left:18%;">If the path identifies a
terminal device, opening the path will not cause that
terminal to become the controlling terminal for the process
(if the process does not already have one).</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>UV_FS_O_NOCTTY</i> is not
supported on Windows.</p>

<p style="margin-left:9%;"><b>UV_FS_O_NOFOLLOW</b></p>

<p style="margin-left:18%;">If the path is a symbolic link,
fail the open.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>UV_FS_O_NOFOLLOW</i> is not
supported on Windows.</p>

<p style="margin-left:9%;"><b>UV_FS_O_NONBLOCK</b></p>

<p style="margin-left:18%;">Open the file in nonblocking
mode if possible.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>UV_FS_O_NONBLOCK</i> is not
supported on Windows.</p>

<p style="margin-left:9%;"><b>UV_FS_O_RANDOM</b></p>

<p style="margin-left:18%;">Access is intended to be
random. The system can use this as a hint to optimize file
caching.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>UV_FS_O_RANDOM</i> is only
supported on Windows via -
<i>FILE_FLAG_RANDOM_ACCESS</i>.</p>

<p style="margin-left:9%;"><b>UV_FS_O_RDONLY</b></p>

<p style="margin-left:18%;">Open the file for read-only
access.</p>

<p style="margin-left:9%;"><b>UV_FS_O_RDWR</b></p>

<p style="margin-left:18%;">Open the file for read-write
access.</p>

<p style="margin-left:9%;"><b>UV_FS_O_SEQUENTIAL</b></p>

<p style="margin-left:18%;">Access is intended to be
sequential from beginning to end. The system can use this as
a hint to optimize file caching.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>UV_FS_O_SEQUENTIAL</i> is
only supported on Windows via -
<i>FILE_FLAG_SEQUENTIAL_SCAN</i>.</p>

<p style="margin-left:9%;"><b>UV_FS_O_SHORT_LIVED</b></p>

<p style="margin-left:18%;">The file is temporary and
should not be flushed to disk if possible.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>UV_FS_O_SHORT_LIVED</i> is
only supported on Windows via -
<i>FILE_ATTRIBUTE_TEMPORARY</i>.</p>

<p style="margin-left:9%;"><b>UV_FS_O_SYMLINK</b></p>

<p style="margin-left:18%;">Open the symbolic link itself
rather than the resource it points to.</p>

<p style="margin-left:9%;"><b>UV_FS_O_SYNC</b></p>

<p style="margin-left:18%;">The file is opened for
synchronous I/O. Write operations will complete once all
data and all metadata are flushed to disk.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>UV_FS_O_SYNC</i> is
supported on Windows via -
<i>FILE_FLAG_WRITE_THROUGH</i>.</p>

<p style="margin-left:9%;"><b>UV_FS_O_TEMPORARY</b></p>

<p style="margin-left:18%;">The file is temporary and
should not be flushed to disk if possible.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;"><i>UV_FS_O_TEMPORARY</i> is
only supported on Windows via -
<i>FILE_ATTRIBUTE_TEMPORARY</i>.</p>

<p style="margin-left:9%;"><b>UV_FS_O_TRUNC</b></p>

<p style="margin-left:18%;">If the file exists and is a
regular file, and the file is opened successfully for write
access, its length shall be truncated to zero.</p>

<p style="margin-left:9%;"><b>UV_FS_O_WRONLY</b></p>

<p style="margin-left:18%;">Open the file for write-only
access.</p>

<h3>Thread pool work scheduling
<a name="Thread pool work scheduling"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv provides a
threadpool which can be used to run user code and get
notified in the loop thread. This thread pool is internally
used to run all file system operations, as well as
getaddrinfo and getnameinfo requests.</p>

<p style="margin-left:9%; margin-top: 1em">Its default size
is 4, but it can be changed at startup time by setting the
<b>UV_THREADPOOL_SIZE</b> environment variable to any value
(the absolute maximum is 1024).</p>

<p style="margin-left:9%; margin-top: 1em">Changed in
version 1.30.0: the maximum UV_THREADPOOL_SIZE allowed was
increased from 128 to 1024.</p>

<p style="margin-left:9%; margin-top: 1em">Changed in
version 1.45.0: threads now have an 8 MB stack instead of
the (sometimes too low) platform default.</p>

<p style="margin-left:9%; margin-top: 1em">Changed in
version 1.50.0: threads now have a default name of
libuv-worker.</p>

<p style="margin-left:9%; margin-top: 1em">The threadpool
is global and shared across all event loops. When a
particular function makes use of the threadpool (i.e. when
using <i>uv_queue_work()</i>) libuv preallocates and
initializes the maximum number of threads allowed by
<b>UV_THREADPOOL_SIZE</b>. This causes a relatively minor
memory overhead (&#732;1MB for 128 threads) but increases
the performance of threading at runtime.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">Note that even though a global
thread pool which is shared across all events loops is used,
the functions are not thread safe.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_work_t</b></p>

<p style="margin-left:18%;">Work request type.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_work_cb)(</b><i>uv_work_t</i> <b>*req)</b></p>

<p style="margin-left:18%;">Callback passed to
<i>uv_queue_work()</i> which will be run on the thread
pool.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_after_work_cb)(</b><i>uv_work_t</i> <b>*req, int
status)</b></p>

<p style="margin-left:18%;">Callback passed to
<i>uv_queue_work()</i> which will be called on the loop
thread after the work on the threadpool has been completed.
If the work was cancelled using <i>uv_cancel() status</i>
will be <b>UV_ECANCELED</b>.</p>

<h3>Public members
<a name="Public members"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>uv_loop_t</i>
<b>*</b><i>uv_work_t</i><b>.loop</b></p>

<p style="margin-left:18%;">Loop that started this request
and where completion will be reported. Readonly.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_req_t</i> members
also apply.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_queue_work(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_work_t</i> <b>*req,</b> <i>uv_work_cb</i>
<b>work_cb,</b> <i><br>
uv_after_work_cb</i> <b>after_work_cb)</b></p>

<p style="margin-left:18%;">Initializes a work request
which will run the given <i>work_cb</i> in a thread from the
threadpool. Once <i>work_cb</i> is completed,
<i>after_work_cb</i> will be called on the loop thread.</p>

<p style="margin-left:18%; margin-top: 1em">This request
can be cancelled with <i>uv_cancel()</i>.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_req_t</i> API
functions also apply.</p>

<h3>DNS utility functions
<a name="DNS utility functions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv provides
asynchronous variants of <i>getaddrinfo</i> and
<i>getnameinfo</i>.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_getaddrinfo_t</b></p>

<p style="margin-left:18%;"><i>getaddrinfo</i> request
type.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_getaddrinfo_cb)(</b><i>uv_getaddrinfo_t</i> <b>*req,
int status, <br>
struct addrinfo *res)</b></p>

<p style="margin-left:18%;">Callback which will be called
with the getaddrinfo request result once complete. In case
it was cancelled, <i>status</i> will have a value of
<b>UV_ECANCELED</b>.</p>

<p style="margin-left:9%;"><b>type uv_getnameinfo_t</b></p>

<p style="margin-left:18%;"><i>getnameinfo</i> request
type.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_getnameinfo_cb)(</b><i>uv_getnameinfo_t</i> <b>*req,
int status, <br>
const char *hostname, const char *service)</b></p>

<p style="margin-left:18%;">Callback which will be called
with the getnameinfo request result once complete. In case
it was cancelled, <i>status</i> will have a value of
<b>UV_ECANCELED</b>.</p>

<h3>Public members
<a name="Public members"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>uv_loop_t</i>
<b>*</b><i>uv_getaddrinfo_t</i><b>.loop</b></p>

<p style="margin-left:18%;">Loop that started this
getaddrinfo request and where completion will be reported.
Readonly.</p>

<p style="margin-left:9%;"><b>struct</b> <i>addrinfo</i>
<b>*</b><i>uv_getaddrinfo_t</i><b>.addrinfo</b></p>

<p style="margin-left:18%;">Pointer to a <i>struct
addrinfo</i> containing the result. Must be freed by the
user with <i>uv_freeaddrinfo()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.3.0: the field is declared as public.</p>

<p style="margin-left:9%;"><i>uv_loop_t</i>
<b>*</b><i>uv_getnameinfo_t</i><b>.loop</b></p>

<p style="margin-left:18%;">Loop that started this
getnameinfo request and where completion will be reported.
Readonly.</p>

<p style="margin-left:9%;"><b>char[NI_MAXHOST]
uv_getnameinfo_t.host</b></p>

<p style="margin-left:18%;">Char array containing the
resulting host. It's null terminated.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.3.0: the field is declared as public.</p>

<p style="margin-left:9%;"><b>char[NI_MAXSERV]
uv_getnameinfo_t.service</b></p>

<p style="margin-left:18%;">Char array containing the
resulting service. It's null terminated.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.3.0: the field is declared as public.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_req_t</i> members
also apply.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_getaddrinfo(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_getaddrinfo_t</i> <b>*req,</b> <i><br>
uv_getaddrinfo_cb</i> <b>getaddrinfo_cb, const char *node,
const char <br>
*service, const struct addrinfo *hints)</b></p>

<p style="margin-left:18%;">Asynchronous
<i>getaddrinfo(3)</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Either node or
service may be NULL but not both.</p>

<p style="margin-left:18%; margin-top: 1em"><i>hints</i> is
a pointer to a struct addrinfo with additional address type
constraints, or NULL. Consult <i>man -s 3 getaddrinfo</i>
for more details.</p>

<p style="margin-left:18%; margin-top: 1em">Returns 0 on
success or an error code &lt; 0 on failure. If successful,
the callback will get called sometime in the future with the
lookup result, which is either:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>status == 0, the res argument points to a valid
<i>struct addrinfo</i>, or</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>status &lt; 0, the res argument is NULL. See the
UV_EAI_* constants.</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Call
<i>uv_freeaddrinfo()</i> to free the addrinfo structure.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.3.0: the callback parameter is now allowed to be
NULL, in which case the request will run
<b>synchronously</b>.</p>

<p style="margin-left:9%;"><b>void uv_freeaddrinfo(struct
addrinfo *ai)</b></p>

<p style="margin-left:18%;">Free the struct addrinfo.
Passing NULL is allowed and is a no-op.</p>

<p style="margin-left:9%;"><b>int
uv_getnameinfo(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_getnameinfo_t</i> <b>*req,</b> <i><br>
uv_getnameinfo_cb</i> <b>getnameinfo_cb, const struct
sockaddr *addr, int <br>
flags)</b></p>

<p style="margin-left:18%;">Asynchronous
<i>getnameinfo(3)</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Returns 0 on
success or an error code &lt; 0 on failure. If successful,
the callback will get called sometime in the future with the
lookup result. Consult <i>man -s 3 getnameinfo</i> for more
details.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.3.0: the callback parameter is now allowed to be
NULL, in which case the request will run
<b>synchronously</b>.</p>

<p style="margin-left:9%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:13%;">The <i>uv_req_t</i> API
functions also apply.</p>

<h3>Shared library handling
<a name="Shared library handling"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv provides
cross platform utilities for loading shared libraries and
retrieving symbols from them, using the following API.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_lib_t</b></p>

<p style="margin-left:18%;">Shared library data type.</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">N/A</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>int
uv_dlopen(const char *filename,</b> <i>uv_lib_t</i>
<b>*lib)</b></p>

<p style="margin-left:18%;">Opens a shared library. The
filename is in utf-8. Returns 0 on success and -1 on error.
Call <i>uv_dlerror()</i> to get the error message.</p>

<p style="margin-left:9%;"><b>void
uv_dlclose(</b><i>uv_lib_t</i> <b>*lib)</b></p>

<p style="margin-left:18%;">Close the shared library.</p>

<p style="margin-left:9%;"><b>int
uv_dlsym(</b><i>uv_lib_t</i> <b>*lib, const char *name, void
**ptr)</b></p>

<p style="margin-left:18%;">Retrieves a data pointer from a
dynamic library. It is legal for a symbol to map to NULL.
Returns 0 on success and -1 if the symbol was not found.</p>

<p style="margin-left:9%;"><b>const char
*uv_dlerror(const</b> <i>uv_lib_t</i> <b>*lib)</b></p>

<p style="margin-left:18%;">Returns the last uv_dlopen() or
uv_dlsym() error message.</p>

<h3>Threading and synchronization utilities
<a name="Threading and synchronization utilities"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv provides
cross-platform implementations for multiple threading and
synchronization primitives. The API largely follows the
pthreads API.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_thread_t</b></p>

<p style="margin-left:18%;">Thread data type.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_thread_cb)(void *arg)</b></p>

<p style="margin-left:18%;">Callback that is invoked to
initialize thread execution. <i>arg</i> is the same value
that was passed to <i>uv_thread_create()</i>.</p>

<p style="margin-left:9%;"><b>type uv_key_t</b></p>

<p style="margin-left:18%;">Thread-local key data type.</p>

<p style="margin-left:9%;"><b>type uv_once_t</b></p>

<p style="margin-left:18%;">Once-only initializer data
type.</p>

<p style="margin-left:9%;"><b>type uv_mutex_t</b></p>

<p style="margin-left:18%;">Mutex data type.</p>

<p style="margin-left:9%;"><b>type uv_rwlock_t</b></p>

<p style="margin-left:18%;">Read-write lock data type.</p>

<p style="margin-left:9%;"><b>type uv_sem_t</b></p>

<p style="margin-left:18%;">Semaphore data type.</p>

<p style="margin-left:9%;"><b>type uv_cond_t</b></p>

<p style="margin-left:18%;">Condition data type.</p>

<p style="margin-left:9%;"><b>type uv_barrier_t</b></p>

<p style="margin-left:18%;">Barrier data type.</p>

<h3>API
<a name="API"></a>
</h3>


<h3>Threads
<a name="Threads"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_thread_options_t</b></p>

<p style="margin-left:18%;">Options for spawning a new
thread (passed to <i>uv_thread_create_ex()</i>).</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
uv_thread_options_s { <br>
enum { <br>
UV_THREAD_NO_FLAGS = 0x00, <br>
UV_THREAD_HAS_STACK_SIZE = 0x01 <br>
} flags; <br>
size_t stack_size; <br>
} uv_thread_options_t;</p>

<p style="margin-left:18%; margin-top: 1em">More fields may
be added to this struct at any time, so its exact layout and
size should not be relied upon.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.26.0.</p>

<p style="margin-left:9%;"><b>int
uv_thread_create(</b><i>uv_thread_t</i> <b>*tid,</b>
<i>uv_thread_cb</i> <b>entry, void *arg)</b></p>

<p style="margin-left:18%;">Changed in version 1.4.1:
returns a UV_E* error code on failure</p>

<p style="margin-left:9%;"><b>int
uv_thread_detach(</b><i>uv_thread_t</i> <b>*tid)</b></p>

<p style="margin-left:18%;">Detaches a thread. Detached
threads automatically release their resources upon
termination, eliminating the need for the application to
call <i>uv_thread_join</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.50.0.</p>

<p style="margin-left:9%;"><b>int
uv_thread_create_ex(</b><i>uv_thread_t</i> <b>*tid,
const</b> <i>uv_thread_options_t</i> <b><br>
*params,</b> <i>uv_thread_cb</i> <b>entry, void
*arg)</b></p>

<p style="margin-left:18%;">Like <i>uv_thread_create()</i>,
but additionally specifies options for creating a new
thread.</p>

<p style="margin-left:18%; margin-top: 1em">If
<i>UV_THREAD_HAS_STACK_SIZE</i> is set, <i>stack_size</i>
specifies a stack size for the new thread. <i>0</i>
indicates that the default value should be used, i.e.
behaves as if the flag was not set. Other values will be
rounded up to the nearest page boundary.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.26.0.</p>

<p style="margin-left:9%;"><b>int
uv_thread_setaffinity(</b><i>uv_thread_t</i> <b>*tid, char
*cpumask, char <br>
*oldmask, size_t mask_size)</b></p>

<p style="margin-left:18%;">Sets the specified thread's
affinity to cpumask, which is specified in bytes. Optionally
returning the previous affinity setting in oldmask. On Unix,
uses <i>pthread_getaffinity_np(3)</i> to get the affinity
setting and maps the cpu_set_t to bytes in oldmask. Then
maps the bytes in cpumask to a cpu_set_t and uses
<i>pthread_setaffinity_np(3)</i>. On Windows, maps the bytes
in cpumask to a bitmask and uses SetThreadAffinityMask()
which returns the previous affinity setting.</p>

<p style="margin-left:18%; margin-top: 1em">The mask_size
specifies the number of entries (bytes) in cpumask /
oldmask, and must be greater-than-or-equal-to
<i>uv_cpumask_size()</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Thread affinity setting is not
atomic on Windows. Unsupported on macOS.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.45.0.</p>

<p style="margin-left:9%;"><b>int
uv_thread_getaffinity(</b><i>uv_thread_t</i> <b>*tid, char
*cpumask, size_t <br>
mask_size)</b></p>

<p style="margin-left:18%;">Gets the specified thread's
affinity setting. On Unix, this maps the cpu_set_t returned
by <i>pthread_getaffinity_np(3)</i> to bytes in cpumask.</p>

<p style="margin-left:18%; margin-top: 1em">The mask_size
specifies the number of entries (bytes) in cpumask, and must
be greater-than-or-equal-to <i>uv_cpumask_size()</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Thread affinity getting is not
atomic on Windows. Unsupported on macOS.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.45.0.</p>

<p style="margin-left:9%;"><b>int
uv_thread_getcpu(void)</b></p>

<p style="margin-left:18%;">Gets the CPU number on which
the calling thread is running.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Currently only implemented on
Windows, Linux and FreeBSD.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.45.0.</p>

<p style="margin-left:9%;"><i>uv_thread_t</i>
<b>uv_thread_self(void) <br>
int uv_thread_join(</b><i>uv_thread_t</i> <b>*tid) <br>
int uv_thread_equal(const</b> <i>uv_thread_t</i> <b>*t1,
const</b> <i>uv_thread_t</i> <b>*t2) <br>
int uv_thread_setname(const char *name)</b></p>

<p style="margin-left:18%;">Sets the name of the current
thread. Different platforms define different limits on the
max number of characters a thread name can be: Linux, IBM i
(16), macOS (64), Windows (32767), and NetBSD (32), etc.
<i>uv_thread_setname()</i> will truncate it in case
<i>name</i> is larger than the limit of the platform.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.50.0.</p>

<p style="margin-left:9%;"><b>int
uv_thread_getname(</b><i>uv_thread_t</i> <b>*tid, char
*name, size_t *size)</b></p>

<p style="margin-left:18%;">Gets the name of the thread
specified by <i>tid</i>. The thread name is copied, with the
trailing NUL, into the buffer pointed to by <i>name</i>. The
<i>size</i> parameter specifies the size of the buffer
pointed to by <i>name</i>. The buffer should be large enough
to hold the name of the thread plus the trailing NUL, or it
will be truncated to fit with the trailing NUL.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.50.0.</p>

<p style="margin-left:9%;"><b>int
uv_thread_setpriority(</b><i>uv_thread_t</i> <b>tid, int
priority) <br>
If the function succeeds, the return value is 0. <br>
If the function fails, the return value is less than zero.
<br>
Sets the scheduling priority of the thread specified by tid.
It <br>
requires elevated <br>
privilege to set specific priorities on some platforms. <br>
The priority can be set to the following constants. <br>
UV_THREAD_PRIORITY_HIGHEST, <br>
UV_THREAD_PRIORITY_ABOVE_NORMAL, UV_THREAD_PRIORITY_NORMAL,
<br>
UV_THREAD_PRIORITY_BELOW_NORMAL, UV_THREAD_PRIORITY_LOWEST.
<br>
int uv_thread_getpriority(</b><i>uv_thread_t</i> <b>tid, int
*priority) <br>
If the function succeeds, the return value is 0. <br>
If the function fails, the return value is less than zero.
<br>
Retrieves the scheduling priority of the thread specified by
tid. The <br>
value in the <br>
output parameter priority is platform dependent. <br>
For Linux, when schedule policy is SCHED_OTHER (default),
priority is <br>
0.</b></p>

<h3>Thread-local storage
<a name="Thread-local storage"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">The total thread-local storage
size may be limited. That is, it may not be possible to
create many TLS keys.</p>

<p style="margin-left:9%;"><b>int
uv_key_create(</b><i>uv_key_t</i> <b>*key) <br>
void uv_key_delete(</b><i>uv_key_t</i> <b>*key) <br>
void *uv_key_get(</b><i>uv_key_t</i> <b>*key) <br>
void uv_key_set(</b><i>uv_key_t</i> <b>*key, void
*value)</b></p>

<h3>Once-only initialization
<a name="Once-only initialization"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Runs a function
once and only once. Concurrent calls to <i>uv_once()</i>
with the same guard will block all callers except one (it's
unspecified which one). The guard should be initialized
statically with the UV_ONCE_INIT macro. <b><br>
void uv_once(</b><i>uv_once_t</i> <b>*guard, void
(*callback)(void))</b></p>

<h3>Mutex locks
<a name="Mutex locks"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Functions return
0 on success or an error code &lt; 0 (unless the return type
is void, of course). <b><br>
int uv_mutex_init(</b><i>uv_mutex_t</i> <b>*handle) <br>
int uv_mutex_init_recursive(</b><i>uv_mutex_t</i>
<b>*handle) <br>
void uv_mutex_destroy(</b><i>uv_mutex_t</i> <b>*handle) <br>
void uv_mutex_lock(</b><i>uv_mutex_t</i> <b>*handle) <br>
int uv_mutex_trylock(</b><i>uv_mutex_t</i> <b>*handle) <br>
void uv_mutex_unlock(</b><i>uv_mutex_t</i>
<b>*handle)</b></p>

<h3>Read-write locks
<a name="Read-write locks"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Functions return
0 on success or an error code &lt; 0 (unless the return type
is void, of course). <b><br>
int uv_rwlock_init(</b><i>uv_rwlock_t</i> <b>*rwlock) <br>
void uv_rwlock_destroy(</b><i>uv_rwlock_t</i> <b>*rwlock)
<br>
void uv_rwlock_rdlock(</b><i>uv_rwlock_t</i> <b>*rwlock)
<br>
int uv_rwlock_tryrdlock(</b><i>uv_rwlock_t</i> <b>*rwlock)
<br>
void uv_rwlock_rdunlock(</b><i>uv_rwlock_t</i> <b>*rwlock)
<br>
void uv_rwlock_wrlock(</b><i>uv_rwlock_t</i> <b>*rwlock)
<br>
int uv_rwlock_trywrlock(</b><i>uv_rwlock_t</i> <b>*rwlock)
<br>
void uv_rwlock_wrunlock(</b><i>uv_rwlock_t</i>
<b>*rwlock)</b></p>

<h3>Semaphores
<a name="Semaphores"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Functions return
0 on success or an error code &lt; 0 (unless the return type
is void, of course). <b><br>
int uv_sem_init(</b><i>uv_sem_t</i> <b>*sem, unsigned int
value) <br>
void uv_sem_destroy(</b><i>uv_sem_t</i> <b>*sem) <br>
void uv_sem_post(</b><i>uv_sem_t</i> <b>*sem) <br>
void uv_sem_wait(</b><i>uv_sem_t</i> <b>*sem) <br>
int uv_sem_trywait(</b><i>uv_sem_t</i> <b>*sem)</b></p>

<h3>Conditions
<a name="Conditions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Functions return
0 on success or an error code &lt; 0 (unless the return type
is void, of course).</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="2%">


<p>1.</p></td>
<td width="2%"></td>
<td width="83%">


<p>Callers should be prepared to deal with spurious wakeups
on <i>uv_cond_wait()</i> and <i>uv_cond_timedwait()</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="2%">


<p>2.</p></td>
<td width="2%"></td>
<td width="83%">


<p>The timeout parameter for <i>uv_cond_timedwait()</i> is
relative to the time at which function is called.</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="2%">


<p>3.</p></td>
<td width="2%"></td>
<td width="83%">


<p>On z/OS, the timeout parameter for
<i>uv_cond_timedwait()</i> is converted to an absolute
system time at which the wait expires. If the current system
clock time passes the absolute time calculated before the
condition is signaled, an ETIMEDOUT error results. After the
wait begins, the wait time is not affected by changes to the
system clock.</p></td></tr>
</table>

<p style="margin-left:9%;"><b>int
uv_cond_init(</b><i>uv_cond_t</i> <b>*cond) <br>
void uv_cond_destroy(</b><i>uv_cond_t</i> <b>*cond) <br>
void uv_cond_signal(</b><i>uv_cond_t</i> <b>*cond) <br>
void uv_cond_broadcast(</b><i>uv_cond_t</i> <b>*cond) <br>
void uv_cond_wait(</b><i>uv_cond_t</i> <b>*cond,</b>
<i>uv_mutex_t</i> <b>*mutex) <br>
int uv_cond_timedwait(</b><i>uv_cond_t</i> <b>*cond,</b>
<i>uv_mutex_t</i> <b>*mutex, uint64_t <br>
timeout)</b></p>

<h3>Barriers
<a name="Barriers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Functions return
0 on success or an error code &lt; 0 (unless the return type
is void, of course).</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;"><i>uv_barrier_wait()</i>
returns a value &gt; 0 to an arbitrarily chosen
&quot;serializer&quot; thread to facilitate cleanup,
i.e.</p>

<p style="margin-left:18%; margin-top: 1em">if
(uv_barrier_wait(&amp;barrier) &gt; 0) <br>
uv_barrier_destroy(&amp;barrier);</p>

<p style="margin-left:9%;"><b>int
uv_barrier_init(</b><i>uv_barrier_t</i> <b>*barrier,
unsigned int count) <br>
void uv_barrier_destroy(</b><i>uv_barrier_t</i> <b>*barrier)
<br>
int uv_barrier_wait(</b><i>uv_barrier_t</i>
<b>*barrier)</b></p>

<h3>Miscellaneous utilities
<a name="Miscellaneous utilities"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This section
contains miscellaneous functions that don't really belong in
any other section.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_buf_t</b></p>

<p style="margin-left:18%;">Buffer data type. <b><br>
char *uv_buf_t.base</b></p>

<p style="margin-left:27%;">Pointer to the base of the
buffer.</p>

<p style="margin-left:18%;"><b>size_t uv_buf_t.len</b></p>

<p style="margin-left:27%;">Total bytes in the buffer.</p>


<p style="margin-left:27%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:31%;">On Windows this field is
ULONG.</p>

<p style="margin-left:9%;"><b>typedef void
*(*uv_malloc_func)(size_t size)</b></p>

<p style="margin-left:18%;">Replacement function for
<i>malloc(3)</i>. See <i>uv_replace_allocator()</i>.</p>

<p style="margin-left:9%;"><b>typedef void
*(*uv_realloc_func)(void *ptr, size_t size)</b></p>

<p style="margin-left:18%;">Replacement function for
<i>realloc(3)</i>. See <i>uv_replace_allocator()</i>.</p>

<p style="margin-left:9%;"><b>typedef void
*(*uv_calloc_func)(size_t count, size_t size)</b></p>

<p style="margin-left:18%;">Replacement function for
<i>calloc(3)</i>. See <i>uv_replace_allocator()</i>.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_free_func)(void *ptr)</b></p>

<p style="margin-left:18%;">Replacement function for
<i>free(3)</i>. See <i>uv_replace_allocator()</i>.</p>

<p style="margin-left:9%;"><b>typedef void
(*uv_random_cb)(</b><i>uv_random_t</i> <b>*req, int status,
void *buf, <br>
size_t buflen)</b></p>

<p style="margin-left:18%;">Callback passed to
<i>uv_random()</i>. <i>status</i> is non-zero in case of
error. The <i>buf</i> pointer is the same pointer that was
passed to <i>uv_random()</i>.</p>

<p style="margin-left:9%;"><b>type uv_file</b></p>

<p style="margin-left:18%;">Cross platform representation
of a file handle.</p>

<p style="margin-left:9%;"><b>type uv_os_sock_t</b></p>

<p style="margin-left:18%;">Cross platform representation
of a socket handle.</p>

<p style="margin-left:9%;"><b>type uv_os_fd_t</b></p>

<p style="margin-left:18%;">Abstract representation of a
file descriptor. On Unix systems this is a <i>typedef</i> of
<i>int</i> and on Windows a <i>HANDLE</i>.</p>

<p style="margin-left:9%;"><b>type uv_pid_t</b></p>

<p style="margin-left:18%;">Cross platform representation
of a <i>pid_t</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.16.0.</p>

<p style="margin-left:9%;"><b>type uv_timeval_t</b></p>

<p style="margin-left:18%;">Y2K38-unsafe data type for
storing times with microsecond resolution. Will be replaced
with <i>uv_timeval64_t</i> in libuv v2.0.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
{ <br>
long tv_sec; <br>
long tv_usec; <br>
} uv_timeval_t;</p>

<p style="margin-left:9%;"><b>type uv_timeval64_t</b></p>

<p style="margin-left:18%;">Y2K38-safe data type for
storing times with microsecond resolution.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
{ <br>
int64_t tv_sec; <br>
int32_t tv_usec; <br>
} uv_timeval64_t;</p>

<p style="margin-left:9%;"><b>type uv_timespec64_t</b></p>

<p style="margin-left:18%;">Y2K38-safe data type for
storing times with nanosecond resolution.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
{ <br>
int64_t tv_sec; <br>
int32_t tv_nsec; <br>
} uv_timespec64_t;</p>

<p style="margin-left:9%;"><b>enum uv_clock_id</b></p>

<p style="margin-left:18%;">Clock source for
<i>uv_clock_gettime()</i>.</p>

<p style="margin-left:22%; margin-top: 1em">typedef enum {
<br>
UV_CLOCK_MONOTONIC, <br>
UV_CLOCK_REALTIME <br>
} uv_clock_id;</p>

<p style="margin-left:9%;"><b>type uv_rusage_t</b></p>

<p style="margin-left:18%;">Data type for resource usage
results.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
{ <br>
uv_timeval_t ru_utime; /* user CPU time used */ <br>
uv_timeval_t ru_stime; /* system CPU time used */ <br>
uint64_t ru_maxrss; /* maximum resident set size */ <br>
uint64_t ru_ixrss; /* integral shared memory size (X) */
<br>
uint64_t ru_idrss; /* integral unshared data size (X) */
<br>
uint64_t ru_isrss; /* integral unshared stack size (X) */
<br>
uint64_t ru_minflt; /* page reclaims (soft page faults) (X)
*/ <br>
uint64_t ru_majflt; /* page faults (hard page faults) */
<br>
uint64_t ru_nswap; /* swaps (X) */ <br>
uint64_t ru_inblock; /* block input operations */ <br>
uint64_t ru_oublock; /* block output operations */ <br>
uint64_t ru_msgsnd; /* IPC messages sent (X) */ <br>
uint64_t ru_msgrcv; /* IPC messages received (X) */ <br>
uint64_t ru_nsignals; /* signals received (X) */ <br>
uint64_t ru_nvcsw; /* voluntary context switches (X) */ <br>
uint64_t ru_nivcsw; /* involuntary context switches (X) */
<br>
} uv_rusage_t;</p>

<p style="margin-left:18%; margin-top: 1em">Members marked
with <i>(X)</i> are unsupported on Windows. See -
<i>getrusage(2)</i> for supported fields on UNIX-like
platforms.</p>

<p style="margin-left:18%; margin-top: 1em">The maximum
resident set size is reported in kilobytes, the unit most
platforms use natively.</p>

<p style="margin-left:9%;"><b>type uv_cpu_info_t</b></p>

<p style="margin-left:18%;">Data type for CPU
information.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
uv_cpu_info_s { <br>
char* model; <br>
int speed; <br>
struct uv_cpu_times_s { <br>
uint64_t user; /* milliseconds */ <br>
uint64_t nice; /* milliseconds */ <br>
uint64_t sys; /* milliseconds */ <br>
uint64_t idle; /* milliseconds */ <br>
uint64_t irq; /* milliseconds */ <br>
} cpu_times; <br>
} uv_cpu_info_t;</p>

<p style="margin-left:9%;"><b>type
uv_interface_address_t</b></p>

<p style="margin-left:18%;">Data type for interface
addresses.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
uv_interface_address_s { <br>
char* name; <br>
char phys_addr[6]; <br>
int is_internal; <br>
union { <br>
struct sockaddr_in address4; <br>
struct sockaddr_in6 address6; <br>
} address; <br>
union { <br>
struct sockaddr_in netmask4; <br>
struct sockaddr_in6 netmask6; <br>
} netmask; <br>
} uv_interface_address_t;</p>

<p style="margin-left:9%;"><b>type uv_passwd_t</b></p>

<p style="margin-left:18%;">Data type for password file
information.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
uv_passwd_s { <br>
char* username; <br>
long uid; <br>
long gid; <br>
char* shell; <br>
char* homedir; <br>
} uv_passwd_t;</p>

<p style="margin-left:9%;"><b>type uv_group_t</b></p>

<p style="margin-left:18%;">Data type for group file
information.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
uv_group_s { <br>
char* groupname; <br>
unsigned long gid; <br>
char** members; <br>
} uv_group_t;</p>

<p style="margin-left:9%;"><b>type uv_utsname_t</b></p>

<p style="margin-left:18%;">Data type for operating system
name and version information.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
uv_utsname_s { <br>
char sysname[256]; <br>
char release[256]; <br>
char version[256]; <br>
char machine[256]; <br>
} uv_utsname_t;</p>

<p style="margin-left:9%;"><b>type uv_env_item_t</b></p>

<p style="margin-left:18%;">Data type for environment
variable storage.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
uv_env_item_s { <br>
char* name; <br>
char* value; <br>
} uv_env_item_t;</p>

<p style="margin-left:9%;"><b>type uv_random_t</b></p>

<p style="margin-left:18%;">Random data request type.</p>

<h3>API
<a name="API"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>uv_handle_type</i>
<b>uv_guess_handle(</b><i>uv_file</i> <b>file)</b></p>

<p style="margin-left:18%;">Used to detect what type of
stream should be used with a given file descriptor. Usually
this will be used during initialization to guess the type of
the stdio streams.</p>

<p style="margin-left:18%; margin-top: 1em">For
<i>isatty(3)</i> equivalent functionality use this function
and test for <i>UV_TTY</i>.</p>

<p style="margin-left:9%;"><b>int
uv_replace_allocator(</b><i>uv_malloc_func</i>
<b>malloc_func,</b> <i>uv_realloc_func</i> <b><br>
realloc_func,</b> <i>uv_calloc_func</i> <b>calloc_func,</b>
<i>uv_free_func</i> <b>free_func)</b></p>

<p style="margin-left:18%;">Added in version 1.6.0.</p>

<p style="margin-left:18%; margin-top: 1em">Override the
use of the standard library's <i>malloc(3)</i>,
<i>calloc(3)</i>, <i>realloc(3)</i>, <i>free(3)</i>, memory
allocation functions.</p>

<p style="margin-left:18%; margin-top: 1em">This function
must be called before any other libuv function is called or
after all resources have been freed and thus libuv doesn't
reference any allocated memory chunk.</p>

<p style="margin-left:18%; margin-top: 1em">On success, it
returns 0, if any of the function pointers is <i>NULL</i> it
returns <i>UV_EINVAL</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">There is no protection against
changing the allocator multiple times. If the user changes
it they are responsible for making sure the allocator is
changed while no memory was allocated with the previous
allocator, or that they are compatible.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">Allocator must be
thread-safe.</p>

<p style="margin-left:9%;"><b>void
uv_library_shutdown(void);</b></p>

<p style="margin-left:18%;">Added in version 1.38.0.</p>

<p style="margin-left:18%; margin-top: 1em">Release any
global state that libuv is holding onto. Libuv will normally
do so automatically when it is unloaded but it can be
instructed to perform cleanup manually.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">Only call
<i>uv_library_shutdown()</i> once.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">Don't call
<i>uv_library_shutdown()</i> when there are still event
loops or I/O requests active.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">Don't call libuv functions
after calling <i>uv_library_shutdown()</i>.</p>

<p style="margin-left:9%;"><i>uv_buf_t</i>
<b>uv_buf_init(char *base, unsigned int len)</b></p>

<p style="margin-left:18%;">Constructor for
<i>uv_buf_t</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Due to platform
differences the user cannot rely on the ordering of the
<i>base</i> and <i>len</i> members of the uv_buf_t struct.
The user is responsible for freeing <i>base</i> after the
uv_buf_t is done. Return struct passed by value.</p>

<p style="margin-left:9%;"><b>char **uv_setup_args(int
argc, char **argv)</b></p>

<p style="margin-left:18%;">Store the program arguments.
Required for getting / setting the process title or the
executable path. Libuv may take ownership of the memory that
<i>argv</i> points to. This function should be called
exactly once, at program start-up.</p>

<p style="margin-left:18%; margin-top: 1em">Example:</p>

<p style="margin-left:22%; margin-top: 1em">argv =
uv_setup_args(argc, argv); /* May return a copy of argv.
*/</p>

<p style="margin-left:9%;"><b>int uv_get_process_title(char
*buffer, size_t size)</b></p>

<p style="margin-left:18%;">Gets the title of the current
process. You <i>must</i> call <i>uv_setup_args</i> before
calling this function on Unix and AIX systems. If
<i>uv_setup_args</i> has not been called on systems that
require it, then <i>UV_ENOBUFS</i> is returned. If
<i>buffer</i> is <i>NULL</i> or <i>size</i> is zero,
<i>UV_EINVAL</i> is returned. If <i>size</i> cannot
accommodate the process title and terminating <i>nul</i>
character, the function returns <i>UV_ENOBUFS</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">On BSD systems,
<i>uv_setup_args</i> is needed for getting the initial
process title. The process title returned will be an empty
string until either <i>uv_setup_args</i> or
<i>uv_set_process_title</i> is called.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.18.1: now thread-safe on all supported
platforms.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.39.0: now returns an error if <i>uv_setup_args</i>
is needed but hasn't been called.</p>

<p style="margin-left:9%;"><b>int
uv_set_process_title(const char *title)</b></p>

<p style="margin-left:18%;">Sets the current process title.
You <i>must</i> call <i>uv_setup_args</i> before calling
this function on Unix and AIX systems. If
<i>uv_setup_args</i> has not been called on systems that
require it, then <i>UV_ENOBUFS</i> is returned. On platforms
with a fixed size buffer for the process title the contents
of <i>title</i> will be copied to the buffer and truncated
if larger than the available space. Other platforms will
return <i>UV_ENOMEM</i> if they cannot allocate enough space
to duplicate the contents of <i>title</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.18.1: now thread-safe on all supported
platforms.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.39.0: now returns an error if <i>uv_setup_args</i>
is needed but hasn't been called.</p>

<p style="margin-left:9%;"><b>int
uv_resident_set_memory(size_t *rss)</b></p>

<p style="margin-left:18%;">Gets the resident set size
(RSS) for the current process.</p>

<p style="margin-left:9%;"><b>int uv_uptime(double
*uptime)</b></p>

<p style="margin-left:18%;">Gets the current system uptime.
Depending on the system full or fractional seconds are
returned.</p>

<p style="margin-left:9%;"><b>int
uv_getrusage(</b><i>uv_rusage_t</i> <b>*rusage)</b></p>

<p style="margin-left:18%;">Gets the resource usage
measures for the current process.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">On Windows not all fields are
set, the unsupported fields are filled with zeroes. See
<i>uv_rusage_t</i> for more details.</p>

<p style="margin-left:9%;"><b>int
uv_getrusage_thread(</b><i>uv_rusage_t</i>
<b>*rusage)</b></p>

<p style="margin-left:18%;">Gets the resource usage
measures for the calling thread.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.50.0.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Not supported on all platforms.
May return <i>UV_ENOTSUP</i>. On macOS and Windows not all
fields are set, the unsupported fields are filled with
zeroes. See <i>uv_rusage_t</i> for more details.</p>

<p style="margin-left:9%;"><i>uv_pid_t</i>
<b>uv_os_getpid(void)</b></p>

<p style="margin-left:18%;">Returns the current process
ID.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.18.0.</p>

<p style="margin-left:9%;"><i>uv_pid_t</i>
<b>uv_os_getppid(void)</b></p>

<p style="margin-left:18%;">Returns the parent process
ID.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.16.0.</p>

<p style="margin-left:9%;"><b>unsigned int
uv_available_parallelism(void)</b></p>

<p style="margin-left:18%;">Returns an estimate of the
default amount of parallelism a program should use. Always
returns a non-zero value.</p>

<p style="margin-left:18%; margin-top: 1em">On Linux,
inspects the calling thread's CPU affinity mask to determine
if it has been pinned to specific CPUs.</p>

<p style="margin-left:18%; margin-top: 1em">On Windows, the
available parallelism may be underreported on systems with
more than 64 logical CPUs.</p>

<p style="margin-left:18%; margin-top: 1em">On other
platforms, reports the number of CPUs that the operating
system considers to be online.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.44.0.</p>

<p style="margin-left:9%;"><b>int
uv_cpu_info(</b><i>uv_cpu_info_t</i> <b>**cpu_infos, int
*count)</b></p>

<p style="margin-left:18%;">Gets information about the CPUs
on the system. The <i>cpu_infos</i> array will have
<i>count</i> elements and needs to be freed with
<i>uv_free_cpu_info()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Use
<i>uv_available_parallelism()</i> if you need to know how
many CPUs are available for threads or child processes.</p>

<p style="margin-left:9%;"><b>void
uv_free_cpu_info(</b><i>uv_cpu_info_t</i> <b>*cpu_infos, int
count)</b></p>

<p style="margin-left:18%;">Frees the <i>cpu_infos</i>
array previously allocated with <i>uv_cpu_info()</i>.</p>

<p style="margin-left:9%;"><b>int
uv_cpumask_size(void)</b></p>

<p style="margin-left:18%;">Returns the maximum size of the
mask used for process/thread affinities, or
<i>UV_ENOTSUP</i> if affinities are not supported on the
current platform.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.45.0.</p>

<p style="margin-left:9%;"><b>int
uv_interface_addresses(</b><i>uv_interface_address_t</i>
<b>**addresses, int <br>
*count)</b></p>

<p style="margin-left:18%;">Gets address information about
the network interfaces on the system. An array of
<i>count</i> elements is allocated and returned in
<i>addresses</i>. It must be freed by the user, calling
<i>uv_free_interface_addresses()</i>.</p>

<p style="margin-left:9%;"><b>void
uv_free_interface_addresses(</b><i>uv_interface_address_t</i>
<b>*addresses, int <br>
count)</b></p>

<p style="margin-left:18%;">Free an array of
<i>uv_interface_address_t</i> which was returned by
<i>uv_interface_addresses()</i>.</p>

<p style="margin-left:9%;"><b>void uv_loadavg(double
avg[3])</b></p>

<p style="margin-left:18%;">Gets the load average. See: -
<i>https://en.wikipedia.org/wiki/Load_(computing)</i></p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Returns [0,0,0] on Windows
(i.e., it's not implemented).</p>

<p style="margin-left:9%;"><b>int uv_ip4_addr(const char
*ip, int port, struct sockaddr_in *addr)</b></p>

<p style="margin-left:18%;">Convert a string containing an
IPv4 addresses to a binary structure.</p>

<p style="margin-left:9%;"><b>int uv_ip6_addr(const char
*ip, int port, struct sockaddr_in6 *addr)</b></p>

<p style="margin-left:18%;">Convert a string containing an
IPv6 addresses to a binary structure.</p>

<p style="margin-left:9%;"><b>int uv_ip4_name(const struct
sockaddr_in *src, char *dst, size_t size)</b></p>

<p style="margin-left:18%;">Convert a binary structure
containing an IPv4 address to a string.</p>

<p style="margin-left:9%;"><b>int uv_ip6_name(const struct
sockaddr_in6 *src, char *dst, size_t size)</b></p>

<p style="margin-left:18%;">Convert a binary structure
containing an IPv6 address to a string.</p>

<p style="margin-left:9%;"><b>int uv_ip_name(const struct
sockaddr *src, char *dst, size_t size)</b></p>

<p style="margin-left:18%;">Convert a binary structure
containing an IPv4 address or an IPv6 address to a
string.</p>

<p style="margin-left:9%;"><b>int uv_inet_ntop(int af,
const void *src, char *dst, size_t size) <br>
int uv_inet_pton(int af, const char *src, void *dst)</b></p>

<p style="margin-left:18%;">Cross-platform IPv6-capable
implementation of <i>inet_ntop(3)</i> and -
<i>inet_pton(3)</i>. On success they return 0. In case of
error the target <i>dst</i> pointer is unmodified.</p>

<p style="margin-left:9%;"><b>UV_IF_NAMESIZE</b></p>

<p style="margin-left:18%;">Maximum IPv6 interface
identifier name length. Defined as <i>IFNAMSIZ</i> on Unix
and <i>IF_NAMESIZE</i> on Linux and Windows.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.16.0.</p>

<p style="margin-left:9%;"><b>int
uv_if_indextoname(unsigned int ifindex, char *buffer, size_t
*size)</b></p>

<p style="margin-left:18%;">IPv6-capable implementation of
<i>if_indextoname(3)</i>. When called, <i>*size</i>
indicates the length of the <i>buffer</i>, which is used to
store the result. On success, zero is returned,
<i>buffer</i> contains the interface name, and <i>*size</i>
represents the string length of the <i>buffer</i>, excluding
the NUL terminator byte from <i>*size</i>. On error, a
negative result is returned. If <i>buffer</i> is not large
enough to hold the result, <i>UV_ENOBUFS</i> is returned,
and <i>*size</i> represents the necessary size in bytes,
including the NUL terminator byte into the <i>*size</i>.</p>

<p style="margin-left:18%; margin-top: 1em">On Unix, the
returned interface name can be used directly as an interface
identifier in scoped IPv6 addresses, e.g.
<i>fe80::abc:def1:2345%en0</i>.</p>

<p style="margin-left:18%; margin-top: 1em">On Windows, the
returned interface cannot be used as an interface
identifier, as Windows uses numerical interface identifiers,
e.g. <i>fe80::abc:def1:2345%5</i>.</p>

<p style="margin-left:18%; margin-top: 1em">To get an
interface identifier in a cross-platform compatible way, use
<i>uv_if_indextoiid()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Example:</p>

<p style="margin-left:22%; margin-top: 1em">char
ifname[UV_IF_NAMESIZE]; <br>
size_t size = sizeof(ifname); <br>
uv_if_indextoname(sin6-&gt;sin6_scope_id, ifname,
&amp;size);</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.16.0.</p>

<p style="margin-left:9%;"><b>int uv_if_indextoiid(unsigned
int ifindex, char *buffer, size_t *size)</b></p>

<p style="margin-left:18%;">Retrieves a network interface
identifier suitable for use in an IPv6 scoped address. On
Windows, returns the numeric <i>ifindex</i> as a string. On
all other platforms, <i>uv_if_indextoname()</i> is called.
The result is written to <i>buffer</i>, with <i>*size</i>
indicating the length of <i>buffer</i>. If <i>buffer</i> is
not large enough to hold the result, then <i>UV_ENOBUFS</i>
is returned, and <i>*size</i> represents the size, including
the NUL byte, required to hold the result.</p>

<p style="margin-left:18%; margin-top: 1em">See
<i>uv_if_indextoname</i> for further details.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.16.0.</p>

<p style="margin-left:9%;"><b>int uv_exepath(char *buffer,
size_t *size)</b></p>

<p style="margin-left:18%;">Gets the executable path. You
<i>must</i> call <i>uv_setup_args</i> before calling this
function.</p>

<p style="margin-left:9%;"><b>int uv_cwd(char *buffer,
size_t *size)</b></p>

<p style="margin-left:18%;">Gets the current working
directory, and stores it in <i>buffer</i>. If the current
working directory is too large to fit in <i>buffer</i>, this
function returns <i>UV_ENOBUFS</i>, and sets <i>size</i> to
the required length, including the null terminator.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.1.0: On Unix the path no longer ends in a
slash.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.9.0: the returned length includes the terminating
null byte on <i>UV_ENOBUFS</i>, and the buffer is null
terminated on success.</p>

<p style="margin-left:9%;"><b>int uv_chdir(const char
*dir)</b></p>

<p style="margin-left:18%;">Changes the current working
directory.</p>

<p style="margin-left:9%;"><b>int uv_os_homedir(char
*buffer, size_t *size)</b></p>

<p style="margin-left:18%;">Gets the current user's home
directory. On Windows, <i>uv_os_homedir()</i> first checks
the <i>USERPROFILE</i> environment variable using
<i>GetEnvironmentVariableW()</i>. If <i>USERPROFILE</i> is
not set, <i>GetUserProfileDirectoryW()</i> is called. On all
other operating systems, <i>uv_os_homedir()</i> first checks
the <i>HOME</i> environment variable using <i>getenv(3)</i>.
If <i>HOME</i> is not set, - <i>getpwuid_r(3)</i> is called.
The user's home directory is stored in <i>buffer</i>. When
<i>uv_os_homedir()</i> is called, <i>size</i> indicates the
maximum size of <i>buffer</i>. On success <i>size</i> is set
to the string length of <i>buffer</i>. On <i>UV_ENOBUFS</i>
failure <i>size</i> is set to the required length for
<i>buffer</i>, including the null byte.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;"><i>uv_os_homedir()</i> is not
thread safe.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.6.0.</p>

<p style="margin-left:9%;"><b>int uv_os_tmpdir(char
*buffer, size_t *size)</b></p>

<p style="margin-left:18%;">Gets the temp directory. On
Windows, <i>uv_os_tmpdir()</i> uses <i>GetTempPathW()</i>.
On all other operating systems, <i>uv_os_tmpdir()</i> uses
the first environment variable found in the ordered list
<i>TMPDIR</i>, <i>TMP</i>, <i>TEMP</i>, and <i>TEMPDIR</i>.
If none of these are found, the path <i>&quot;/tmp&quot;</i>
is used, or, on Android, <i>&quot;/data/local/tmp&quot;</i>
is used. The temp directory is stored in <i>buffer</i>. When
<i>uv_os_tmpdir()</i> is called, <i>size</i> indicates the
maximum size of <i>buffer</i>. On success <i>size</i> is set
to the string length of <i>buffer</i> (which does not
include the terminating null). On <i>UV_ENOBUFS</i> failure
<i>size</i> is set to the required length for <i>buffer</i>,
including the null byte.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;"><i>uv_os_tmpdir()</i> is not
thread safe.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.9.0.</p>

<p style="margin-left:9%;"><b>int
uv_os_get_passwd(</b><i>uv_passwd_t</i> <b>*pwd)</b></p>

<p style="margin-left:18%;">Gets a subset of the password
file entry for the current effective uid (not the real uid).
The populated data includes the username, euid, gid, shell,
and home directory. On non-Windows systems, all data comes
from <i>getpwuid_r(3)</i>. On Windows, uid and gid are set
to -1 and have no meaning, and shell is <i>NULL</i>. After
successfully calling this function, the memory allocated to
<i>pwd</i> needs to be freed with
<i>uv_os_free_passwd()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.9.0.</p>

<p style="margin-left:9%;"><b>int
uv_os_get_passwd2(</b><i>uv_passwd_t</i> <b>*pwd, uv_uid_t
uid)</b></p>

<p style="margin-left:18%;">Gets a subset of the password
file entry for the provided uid. The populated data includes
the username, euid, gid, shell, and home directory. On
non-Windows systems, all data comes from -
<i>getpwuid_r(3)</i>. On Windows, uid and gid are set to -1
and have no meaning, and shell is <i>NULL</i>. After
successfully calling this function, the memory allocated to
<i>pwd</i> needs to be freed with
<i>uv_os_free_passwd()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.45.0.</p>

<p style="margin-left:9%;"><b>int
uv_os_get_group(</b><i>uv_group_t</i> <b>*group, uv_uid_t
gid)</b></p>

<p style="margin-left:18%;">Gets a subset of the group file
entry for the provided uid. The populated data includes the
group name, gid, and members. On non-Windows systems, all
data comes from <i>getgrgid_r(3)</i>. On Windows, uid and
gid are set to -1 and have no meaning. After successfully
calling this function, the memory allocated to <i>group</i>
needs to be freed with <i>uv_os_free_group()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.45.0.</p>

<p style="margin-left:9%;"><b>void
uv_os_free_group(</b><i>uv_passwd_t</i> <b>*pwd)</b></p>

<p style="margin-left:18%;">Frees the memory previously
allocated with <i>uv_os_get_group()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.45.0.</p>

<p style="margin-left:9%;"><b>void
uv_os_free_passwd(</b><i>uv_passwd_t</i> <b>*pwd)</b></p>

<p style="margin-left:18%;">Frees the <i>pwd</i> memory
previously allocated with <i>uv_os_get_passwd()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.9.0.</p>

<p style="margin-left:9%;"><b>uint64_t
uv_get_free_memory(void)</b></p>

<p style="margin-left:18%;">Gets the amount of free memory
available in the system, as reported by the kernel (in
bytes). Returns 0 when unknown.</p>

<p style="margin-left:9%;"><b>uint64_t
uv_get_total_memory(void)</b></p>

<p style="margin-left:18%;">Gets the total amount of
physical memory in the system (in bytes). Returns 0 when
unknown.</p>

<p style="margin-left:9%;"><b>uint64_t
uv_get_constrained_memory(void)</b></p>

<p style="margin-left:18%;">Gets the total amount of memory
available to the process (in bytes) based on limits imposed
by the OS. If there is no such constraint, or the constraint
is unknown, <i>0</i> is returned. If there is a constraining
mechanism, but there is no constraint set, <i>UINT64_MAX</i>
is returned. Note that it is not unusual for this value to
be less than or greater than
<i>uv_get_total_memory()</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">This function currently only
returns a non-zero value on Linux, based on cgroups if it is
present, and on z/OS based on RLIMIT_MEMLIMIT.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.29.0.</p>

<p style="margin-left:9%;"><b>uint64_t
uv_get_available_memory(void)</b></p>

<p style="margin-left:18%;">Gets the amount of free memory
that is still available to the process (in bytes). This
differs from <i>uv_get_free_memory()</i> in that it takes
into account any limits imposed by the OS. If there is no
such constraint, or the constraint is unknown, the amount
returned will be identical to
<i>uv_get_free_memory()</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">This function currently only
returns a value that is different from what
<i>uv_get_free_memory()</i> reports on Linux, based on
cgroups if it is present.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.45.0.</p>

<p style="margin-left:9%;"><b>uint64_t
uv_hrtime(void)</b></p>

<p style="margin-left:18%;">Returns the current
high-resolution timestamp. This is expressed in nanoseconds.
It is relative to an arbitrary time in the past. It is not
related to the time of day and therefore not subject to
clock drift. The primary use is for measuring performance
between intervals.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">Not every platform can support
nanosecond resolution; however, this value will always be in
nanoseconds.</p>

<p style="margin-left:9%;"><b>int
uv_clock_gettime(</b><i>uv_clock_id</i> <b>clock_id,</b>
<i>uv_timespec64_t</i> <b>*ts)</b></p>

<p style="margin-left:18%;">Obtain the current system time
from a high-resolution real-time or monotonic clock
source.</p>

<p style="margin-left:18%; margin-top: 1em">The real-time
clock counts from the UNIX epoch (1970-01-01) and is subject
to time adjustments; it can jump back in time.</p>

<p style="margin-left:18%; margin-top: 1em">The monotonic
clock counts from an arbitrary point in the past and never
jumps back in time.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.45.0.</p>

<p style="margin-left:9%;"><b>void
uv_print_all_handles(</b><i>uv_loop_t</i> <b>*loop, FILE
*stream)</b></p>

<p style="margin-left:18%;">Prints all handles associated
with the given <i>loop</i> to the given <i>stream</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Example:</p>


<p style="margin-left:22%; margin-top: 1em">uv_print_all_handles(uv_default_loop(),
stderr); <br>
/* <br>
[--I] signal 0x1a25ea8 <br>
[-AI] async 0x1a25cf0 <br>
[R--] idle 0x1a7a8c8 <br>
*/</p>

<p style="margin-left:18%; margin-top: 1em">The format is
<i>[flags] handle-type handle-address</i>. For
<i>flags</i>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="56%">


<p><i>R</i> is printed for a handle that is referenced</p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="56%">


<p><i>A</i> is printed for a handle that is active</p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="56%">


<p><i>I</i> is printed for a handle that is internal</p></td>
<td width="23%">
</td></tr>
</table>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">This function is meant for ad
hoc debugging, there is no API/ABI stability guarantees.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.8.0.</p>

<p style="margin-left:9%;"><b>void
uv_print_active_handles(</b><i>uv_loop_t</i> <b>*loop, FILE
*stream)</b></p>

<p style="margin-left:18%;">This is the same as
<i>uv_print_all_handles()</i> except only active handles are
printed.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">This function is meant for ad
hoc debugging, there is no API/ABI stability guarantees.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.8.0.</p>

<p style="margin-left:9%;"><b>int
uv_os_environ(</b><i>uv_env_item_t</i> <b>**envitems, int
*count)</b></p>

<p style="margin-left:18%;">Retrieves all environment
variables. This function will allocate memory which must be
freed by calling <i>uv_os_free_environ()</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">This function is not thread
safe.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.31.0.</p>

<p style="margin-left:9%;"><b>void
uv_os_free_environ(</b><i>uv_env_item_t</i> <b>*envitems,
int count);</b></p>

<p style="margin-left:18%;">Frees the memory allocated for
the environment variables by <i>uv_os_environ()</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.31.0.</p>

<p style="margin-left:9%;"><b>int uv_os_getenv(const char
*name, char *buffer, size_t *size)</b></p>

<p style="margin-left:18%;">Retrieves the environment
variable specified by <i>name</i>, copies its value into
<i>buffer</i>, and sets <i>size</i> to the string length of
the value. When calling this function, <i>size</i> must be
set to the amount of storage available in <i>buffer</i>,
including the null terminator. If the environment variable
exceeds the storage available in <i>buffer</i>,
<i>UV_ENOBUFS</i> is returned, and <i>size</i> is set to the
amount of storage required to hold the value. If no matching
environment variable exists, <i>UV_ENOENT</i> is
returned.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">This function is not thread
safe.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.12.0.</p>

<p style="margin-left:9%;"><b>int uv_os_setenv(const char
*name, const char *value)</b></p>

<p style="margin-left:18%;">Creates or updates the
environment variable specified by <i>name</i> with
<i>value</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">This function is not thread
safe.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.12.0.</p>

<p style="margin-left:9%;"><b>int uv_os_unsetenv(const char
*name)</b></p>

<p style="margin-left:18%;">Deletes the environment
variable specified by <i>name</i>. If no such environment
variable exists, this function returns successfully.</p>


<p style="margin-left:18%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:22%;">This function is not thread
safe.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.12.0.</p>

<p style="margin-left:9%;"><b>int uv_os_gethostname(char
*buffer, size_t *size)</b></p>

<p style="margin-left:18%;">Returns the hostname as a
null-terminated string in <i>buffer</i>, and sets
<i>size</i> to the string length of the hostname. When
calling this function, <i>size</i> must be set to the amount
of storage available in <i>buffer</i>, including the null
terminator. If the hostname exceeds the storage available in
<i>buffer</i>, <i>UV_ENOBUFS</i> is returned, and
<i>size</i> is set to the amount of storage required to hold
the value.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.12.0.</p>

<p style="margin-left:18%; margin-top: 1em">Changed in
version 1.26.0: <i>UV_MAXHOSTNAMESIZE</i> is available and
represents the maximum <i>buffer</i> size required to store
a hostname and terminating <i>nul</i> character.</p>

<p style="margin-left:9%;"><b>int
uv_os_getpriority(</b><i>uv_pid_t</i> <b>pid, int
*priority)</b></p>

<p style="margin-left:18%;">Retrieves the scheduling
priority of the process specified by <i>pid</i>. The
returned value of <i>priority</i> is between -20 (high
priority) and 19 (low priority).</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">On Windows, the returned
priority will equal one of the <i>UV_PRIORITY</i>
constants.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.23.0.</p>

<p style="margin-left:9%;"><b>int
uv_os_setpriority(</b><i>uv_pid_t</i> <b>pid, int
priority)</b></p>

<p style="margin-left:18%;">Sets the scheduling priority of
the process specified by <i>pid</i>. The <i>priority</i>
value range is between -20 (high priority) and 19 (low
priority). The constants <i>UV_PRIORITY_LOW</i>,
<i>UV_PRIORITY_BELOW_NORMAL</i>, <i>UV_PRIORITY_NORMAL</i>,
<i>UV_PRIORITY_ABOVE_NORMAL</i>, <i>UV_PRIORITY_HIGH</i>,
and <i>UV_PRIORITY_HIGHEST</i> are also provided for
convenience.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">On Windows, this function
utilizes <i>SetPriorityClass()</i>. The <i>priority</i>
argument is mapped to a Windows priority class. When
retrieving the process priority, the result will equal one
of the <i>UV_PRIORITY</i> constants, and not necessarily the
exact value of <i>priority</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">On Windows, setting
<i>PRIORITY_HIGHEST</i> will only work for elevated user,
for others it will be silently reduced to
<i>PRIORITY_HIGH</i>.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">On IBM i PASE, the highest
process priority is -10. The constant
<i>UV_PRIORITY_HIGHEST</i> is -10, <i>UV_PRIORITY_HIGH</i>
is -7, <i>UV_PRIORITY_ABOVE_NORMAL</i> is -4,
<i>UV_PRIORITY_NORMAL</i> is 0,
<i>UV_PRIORITY_BELOW_NORMAL</i> is 15 and
<i>UV_PRIORITY_LOW</i> is 39.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">On IBM i PASE, you are not
allowed to change your priority unless you have the *JOBCTL
special authority (even to lower it).</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.23.0.</p>

<p style="margin-left:9%;"><b>int
uv_os_uname(</b><i>uv_utsname_t</i> <b>*buffer)</b></p>

<p style="margin-left:18%;">Retrieves system information in
<i>buffer</i>. The populated data includes the operating
system name, release, version, and machine. On non-Windows
systems, <i>uv_os_uname()</i> is a thin wrapper around
<i>uname(2)</i>. Returns zero on success, and a non-zero
error value otherwise.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.25.0.</p>

<p style="margin-left:9%;"><b>int
uv_gettimeofday(</b><i>uv_timeval64_t</i> <b>*tv)</b></p>

<p style="margin-left:18%;">Cross-platform implementation
of <i>gettimeofday(2)</i>. The timezone argument to
<i>gettimeofday()</i> is not supported, as it is considered
obsolete.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.28.0.</p>

<p style="margin-left:9%;"><b>int
uv_random(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_random_t</i> <b>*req, void *buf, size_t <br>
buflen, unsigned int flags,</b> <i>uv_random_cb</i>
<b>cb)</b></p>

<p style="margin-left:18%;">Fill <i>buf</i> with exactly
<i>buflen</i> cryptographically strong random bytes acquired
from the system CSPRNG. <i>flags</i> is reserved for future
extension and must currently be 0.</p>

<p style="margin-left:18%; margin-top: 1em">Short reads are
not possible. When less than <i>buflen</i> random bytes are
available, a non-zero error value is returned or passed to
the callback.</p>

<p style="margin-left:18%; margin-top: 1em">The synchronous
version may block indefinitely when not enough entropy is
available. The asynchronous version may not ever finish when
the system is low on entropy.</p>

<p style="margin-left:18%; margin-top: 1em">Sources of
entropy:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>Windows: <i>RtlGenRandom
&lt;https://docs.microsoft.com/en-us/windows/desktop/api/ntsecapi/nf-ntsecapi-rtlgenrandom&gt;_</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>Linux, Android: <i>getrandom(2)</i> if available, or
<i>urandom(4)</i> after reading from <i>/dev/random</i>
once, or the <i>KERN_RANDOM sysctl(2)</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>FreeBSD: <i>getrandom(2)
&lt;https://www.freebsd.org/cgi/man.cgi?query=getrandom&amp;sektion=2&gt;_</i>,
or <i>/dev/urandom</i> after reading from <i>/dev/random</i>
once.</p> </td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>NetBSD: <i>KERN_ARND sysctl(7)
&lt;https://man.netbsd.org/sysctl.7&gt;_</i></p> </td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>macOS, OpenBSD: <i>getentropy(2)
&lt;https://man.openbsd.org/getentropy.2&gt;_</i> if
available, or <i>/dev/urandom</i> after reading from
<i>/dev/random</i> once.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>AIX: <i>/dev/random</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>IBM i: <i>/dev/urandom</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="79%">


<p>Other UNIX: <i>/dev/urandom</i> after reading from
<i>/dev/random</i> once.</p></td></tr>
</table>

<p style="margin-left:18%;"><b>Returns</b></p>

<p style="margin-left:27%;">0 on success, or an error code
&lt; 0 on failure. The contents of <i>buf</i> is undefined
after an error.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">When using the synchronous
version, both <i>loop</i> and <i>req</i> parameters are not
used and can be set to <i>NULL</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.33.0.</p>

<p style="margin-left:9%;"><b>void uv_sleep(unsigned int
msec)</b></p>

<p style="margin-left:18%;">Causes the calling thread to
sleep for <i>msec</i> milliseconds.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.34.0.</p>

<h3>String manipulation functions
<a name="String manipulation functions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">These string
utilities are needed internally for dealing with Windows,
and are exported to allow clients to work uniformly with
this data when the libuv API is not complete. <b><br>
size_t uv_utf16_length_as_wtf8(const uint16_t *utf16,
ssize_t <br>
utf16_len)</b></p>

<p style="margin-left:18%;">Get the length of a UTF-16 (or
UCS-2) <i>utf16</i> value after converting it to WTF-8. If
<i>utf16</i> is NUL terminated, <i>utf16_len</i> can be set
to -1, otherwise it must be specified.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.47.0.</p>

<p style="margin-left:9%;"><b>int uv_utf16_to_wtf8(const
uint16_t *utf16, ssize_t utf16_len, char <br>
**wtf8_ptr, size_t *wtf8_len_ptr)</b></p>

<p style="margin-left:18%;">Convert UTF-16 (or UCS-2) data
in <i>utf16</i> to WTF-8 data in <i>*wtf8_ptr</i>. The
<i>utf16_len</i> count (in characters) gives the length of
<i>utf16</i>. If <i>utf16</i> is NUL terminated,
<i>utf16_len</i> can be set to -1, otherwise it must be
specified. If <i>wtf8_ptr</i> is <i>NULL</i>, no result will
be computed, but the length (equal to
<i>uv_utf16_length_as_wtf8</i>) will be stored in
<i>wtf8_ptr</i>. If <i>*wtf8_ptr</i> is <i>NULL</i>, space
for the conversion will be allocated and returned in
<i>wtf8_ptr</i> and the length will be returned in
<i>wtf8_len_ptr</i>. Otherwise, the length of
<i>*wtf8_ptr</i> must be passed in <i>wtf8_len_ptr</i>. The
<i>wtf8_ptr</i> must contain an extra space for an extra NUL
after the result. If the result is truncated,
<i>UV_ENOBUFS</i> will be returned and <i>wtf8_len_ptr</i>
will be the length of the required <i>wtf8_ptr</i> to
contain the whole result.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.47.0.</p>

<p style="margin-left:9%;"><b>ssize_t
uv_wtf8_length_as_utf16(const char *wtf8)</b></p>

<p style="margin-left:18%;">Get the length in characters of
a NUL-terminated WTF-8 <i>wtf8</i> value after converting it
to UTF-16 (or UCS-2), including NUL terminator.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.47.0.</p>

<p style="margin-left:9%;"><b>void uv_wtf8_to_utf16(const
char *utf8, uint16_t *utf16, size_t <br>
utf16_len)</b></p>

<p style="margin-left:18%;">Convert NUL-terminated WTF-8
data in <i>wtf8</i> to UTF-16 (or UCS-2) data in
<i>utf16</i>. The <i>utf16_len</i> count (in characters)
must include space for the NUL terminator.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.47.0.</p>

<h3>Metrics operations
<a name="Metrics operations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv provides a
metrics API to track various internal operations of the
event loop.</p>

<h3>Data types
<a name="Data types"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>type
uv_metrics_t</b></p>

<p style="margin-left:18%;">The struct that contains event
loop metrics. It is recommended to retrieve these metrics in
a <i>uv_prepare_cb</i> in order to make sure there are no
inconsistencies with the metrics counters.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
{ <br>
uint64_t loop_count; <br>
uint64_t events; <br>
uint64_t events_waiting; <br>
/* private */ <br>
uint64_t* reserved[13]; <br>
} uv_metrics_t;</p>

<h3>Public members
<a name="Public members"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>uint64_t</b>
<i>uv_metrics_t</i><b>.loop_count</b></p>

<p style="margin-left:18%;">Number of event loop
iterations.</p>

<p style="margin-left:9%;"><b>uint64_t</b>
<i>uv_metrics_t</i><b>.events</b></p>

<p style="margin-left:18%;">Number of events that have been
processed by the event handler.</p>

<p style="margin-left:9%;"><b>uint64_t</b>
<i>uv_metrics_t</i><b>.events_waiting</b></p>

<p style="margin-left:18%;">Number of events that were
waiting to be processed when the event provider was
called.</p>

<h3>API
<a name="API"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>uint64_t
uv_metrics_idle_time(</b><i>uv_loop_t</i> <b>*loop)</b></p>

<p style="margin-left:18%;">Retrieve the amount of time the
event loop has been idle in the kernel's event provider
(e.g. <b>epoll_wait</b>). The call is thread safe.</p>

<p style="margin-left:18%; margin-top: 1em">The return
value is the accumulated time spent idle in the kernel's
event provider starting from when the <i>uv_loop_t</i> was
configured to collect the idle time.</p>


<p style="margin-left:18%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:22%;">The event loop will not begin
accumulating the event provider's idle time until calling
<i>uv_loop_configure</i> with
<b>UV_METRICS_IDLE_TIME</b>.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.39.0.</p>

<p style="margin-left:9%;"><b>int
uv_metrics_info(</b><i>uv_loop_t</i> <b>*loop,</b>
<i>uv_metrics_t</i> <b>*metrics)</b></p>

<p style="margin-left:18%;">Copy the current set of event
loop metrics to the <b>metrics</b> pointer.</p>

<p style="margin-left:18%; margin-top: 1em">Added in
version 1.45.0.</p>

<h3>User guide
<a name="User guide"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:13%;">The contents of this guide have
been recently incorporated into the libuv documentation and
it hasn't gone through thorough review yet. If you spot a
mistake please file an issue, or better yet, open a pull
request!</p>

<h3>Introduction
<a name="Introduction"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This 'book' is a
small set of tutorials about using <i>libuv</i> as a high
performance evented I/O library which offers the same API on
Windows and Unix.</p>

<p style="margin-left:9%; margin-top: 1em">It is meant to
cover the main areas of libuv, but is not a comprehensive
reference discussing every function and data structure. The
<i>official libuv documentation</i> may be consulted for
full details.</p>

<p style="margin-left:9%; margin-top: 1em">This book is
still a work in progress, so sections may be incomplete, but
I hope you will enjoy it as it grows.</p>

<h3>Who this book is for
<a name="Who this book is for"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">If you are
reading this book, you are either:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="87%">


<p>a systems programmer, creating low-level programs such
as daemons or network services and clients. You have found
that the event loop approach is well suited for your
application and decided to use libuv.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="87%">


<p>a node.js module writer, who wants to wrap platform APIs
written in C or C++ with a set of (a)synchronous APIs that
are exposed to JavaScript. You will use libuv purely in the
context of node.js. For this you will require some other
resources as the book does not cover parts specific to
v8/node.js.</p> </td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">This book
assumes that you are comfortable with the C programming
language.</p>

<h3>Background
<a name="Background"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<i>node.js</i> project began in 2009 as a JavaScript
environment decoupled from the browser. Using Google's
<i>V8</i> and Marc Lehmann's <i>libev</i>, node.js combined
a model of I/O -- evented -- with a language that was well
suited to the style of programming; due to the way it had
been shaped by browsers. As node.js grew in popularity, it
was important to make it work on Windows, but libev ran only
on Unix. The Windows equivalent of kernel event notification
mechanisms like kqueue or (e)poll is IOCP. libuv was an
abstraction around libev or IOCP depending on the platform,
providing users an API based on libev. In the node-v0.9.0
version of libuv <i>libev was removed</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Since then libuv
has continued to mature and become a high quality standalone
library for system programming. Users outside of node.js
include Mozilla's <i>Rust</i> programming language, and a
<i>variety</i> of language bindings.</p>

<p style="margin-left:9%; margin-top: 1em">This book and
the code is based on libuv version <i>v1.42.0</i>.</p>

<h3>Code
<a name="Code"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">All the example
code and the source of the book is included as part of the
<i>libuv</i> project on GitHub. Clone or Download
<i>libuv</i>, then build it:</p>

<p style="margin-left:13%; margin-top: 1em">sh autogen.sh
<br>
./configure <br>
make</p>

<p style="margin-left:9%; margin-top: 1em">There is no need
to <b>make install</b>. To build the examples run
<b>make</b> in the <b>docs/code/</b> directory.</p>

<h3>Basics of libuv
<a name="Basics of libuv"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv enforces
an <b>asynchronous</b>, <b>event-driven</b> style of
programming. Its core job is to provide an event loop and
callback based notifications of I/O and other activities.
libuv offers core utilities like timers, non-blocking
networking support, asynchronous file system access, child
processes and more.</p>

<h3>Event loops
<a name="Event loops"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">In event-driven
programming, an application expresses interest in certain
events and respond to them when they occur. The
responsibility of gathering events from the operating system
or monitoring other sources of events is handled by libuv,
and the user can register callbacks to be invoked when an
event occurs. The event-loop usually keeps running
<i>forever</i>. In pseudocode:</p>

<p style="margin-left:13%; margin-top: 1em">while there are
still events to process: <br>
e = get the next event <br>
if there is a callback associated with e: <br>
call the callback</p>

<p style="margin-left:9%; margin-top: 1em">Some examples of
events are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="43%">


<p style="margin-top: 1em">File is ready for writing</p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="43%">


<p>A socket has data ready to be read</p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="43%">


<p>A timer has timed out</p></td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">This event loop
is encapsulated by <b>uv_run()</b> -- the end-all function
when using libuv.</p>

<p style="margin-left:9%; margin-top: 1em">The most common
activity of systems programs is to deal with input and
output, rather than a lot of number-crunching. The problem
with using conventional input/output functions (<b>read</b>,
<b>fprintf</b>, etc.) is that they are <b>blocking</b>. The
actual write to a hard disk or reading from a network, takes
a disproportionately long time compared to the speed of the
processor. The functions don't return until the task is
done, so that your program is doing nothing. For programs
which require high performance this is a major roadblock as
other activities and other I/O operations are kept
waiting.</p>

<p style="margin-left:9%; margin-top: 1em">One of the
standard solutions is to use threads. Each blocking I/O
operation is started in a separate thread (or in a thread
pool). When the blocking function gets invoked in the
thread, the operating system can schedule another thread to
run, which actually needs the CPU.</p>

<p style="margin-left:9%; margin-top: 1em">The approach
followed by libuv uses another style, which is the
<b>asynchronous, non-blocking</b> style. Most modern
operating systems provide event notification subsystems. For
example, a normal <b>read</b> call on a socket would block
until the sender actually sent something. Instead, the
application can request the operating system to watch the
socket and put an event notification in the queue. The
application can inspect the events at its convenience
(perhaps doing some number crunching before to use the
processor to the maximum) and grab the data. It is
<b>asynchronous</b> because the application expressed
interest at one point, then used the data at another point
(in time and space). It is <b>non-blocking</b> because the
application process was free to do other tasks. This fits in
well with libuv's event-loop approach, since the operating
system events can be treated as just another libuv event.
The non-blocking ensures that other events can continue to
be handled as fast as they come in [1].</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">How the I/O is run in the
background is not of our concern, but due to the way our
computer hardware works, with the thread as the basic unit
of the processor, libuv and OSes will usually run
background/worker threads and/or polling to perform tasks in
a non-blocking manner.</p>

<p style="margin-left:9%; margin-top: 1em">Bert Belder, one
of the libuv core developers has a small video explaining
the architecture of libuv and its background. If you have no
prior experience with either libuv or libev, it is a quick,
useful watch.</p>

<p style="margin-left:9%; margin-top: 1em">libuv's event
loop is explained in more detail in the
<i>documentation</i>.</p>

<h3>Hello World
<a name="Hello World"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">With the basics
out of the way, let's write our first libuv program. It does
nothing, except start a loop which will exit
immediately.</p>


<p style="margin-left:9%; margin-top: 1em">helloworld/main.c</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;uv.h&gt;</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
uv_loop_t *loop = malloc(sizeof(uv_loop_t)); <br>
uv_loop_init(loop);</p>


<p style="margin-left:13%; margin-top: 1em">printf(&quot;Now
quitting.\n&quot;); <br>
uv_run(loop, UV_RUN_DEFAULT);</p>


<p style="margin-left:13%; margin-top: 1em">uv_loop_close(loop);
<br>
free(loop); <br>
return 0; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">This program
quits immediately because it has no events to process. A
libuv event loop has to be told to watch out for events
using the various API functions.</p>

<p style="margin-left:9%; margin-top: 1em">Starting with
libuv v1.0, users should allocate the memory for the loops
before initializing it with <b>uv_loop_init(uv_loop_t
*)</b>. This allows you to plug in custom memory management.
Remember to de-initialize the loop using
<b>uv_loop_close(uv_loop_t *)</b> and then delete the
storage. The examples never close loops since the program
quits after the loop ends and the system will reclaim
memory. Production grade projects, especially long running
systems programs, should take care to release correctly.</p>

<h3>Default loop
<a name="Default loop"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">A default loop
is provided by libuv and can be accessed using
<b>uv_default_loop()</b>. You should use this loop if you
only want a single loop.</p>


<p style="margin-left:9%; margin-top: 1em">default-loop/main.c</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
#include &lt;uv.h&gt;</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
uv_loop_t *loop = uv_default_loop();</p>


<p style="margin-left:13%; margin-top: 1em">printf(&quot;Default
loop.\n&quot;); <br>
uv_run(loop, UV_RUN_DEFAULT);</p>


<p style="margin-left:13%; margin-top: 1em">uv_loop_close(loop);
<br>
return 0; <br>
}</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">node.js uses the default loop
as its main loop. If you are writing bindings you should be
aware of this.</p>

<h3>Error handling
<a name="Error handling"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Initialization
functions or synchronous functions which may fail return a
negative number on error. Async functions that may fail will
pass a status parameter to their callbacks. The error
messages are defined as <b>UV_E*</b> <i>constants</i>.</p>

<p style="margin-left:9%; margin-top: 1em">You can use the
<b>uv_strerror(int)</b> and <b>uv_err_name(int)</b>
functions to get a <b>const char *</b> describing the error
or the error name respectively.</p>

<p style="margin-left:9%; margin-top: 1em">I/O read
callbacks (such as for files and sockets) are passed a
parameter <b>nread</b>. If <b>nread</b> is less than 0,
there was an error (UV_EOF is the end of file error, which
you may want to handle differently).</p>

<h3>Handles and Requests
<a name="Handles and Requests"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv works by
the user expressing interest in particular events. This is
usually done by creating a <b>handle</b> to an I/O device,
timer or process. Handles are opaque structs named as
<b>uv_TYPE_t</b> where type signifies what the handle is
used for.</p>

<p style="margin-left:9%; margin-top: 1em">libuv
watchers</p>

<p style="margin-left:13%; margin-top: 1em">/* Handle
types. */ <br>
typedef struct uv_loop_s uv_loop_t; <br>
typedef struct uv_handle_s uv_handle_t; <br>
typedef struct uv_dir_s uv_dir_t; <br>
typedef struct uv_stream_s uv_stream_t; <br>
typedef struct uv_tcp_s uv_tcp_t; <br>
typedef struct uv_udp_s uv_udp_t; <br>
typedef struct uv_pipe_s uv_pipe_t; <br>
typedef struct uv_tty_s uv_tty_t; <br>
typedef struct uv_poll_s uv_poll_t; <br>
typedef struct uv_timer_s uv_timer_t; <br>
typedef struct uv_prepare_s uv_prepare_t; <br>
typedef struct uv_check_s uv_check_t; <br>
typedef struct uv_idle_s uv_idle_t; <br>
typedef struct uv_async_s uv_async_t; <br>
typedef struct uv_process_s uv_process_t; <br>
typedef struct uv_fs_event_s uv_fs_event_t; <br>
typedef struct uv_fs_poll_s uv_fs_poll_t; <br>
typedef struct uv_signal_s uv_signal_t;</p>

<p style="margin-left:13%; margin-top: 1em">/* Request
types. */ <br>
typedef struct uv_req_s uv_req_t; <br>
typedef struct uv_getaddrinfo_s uv_getaddrinfo_t; <br>
typedef struct uv_getnameinfo_s uv_getnameinfo_t; <br>
typedef struct uv_shutdown_s uv_shutdown_t; <br>
typedef struct uv_write_s uv_write_t; <br>
typedef struct uv_connect_s uv_connect_t; <br>
typedef struct uv_udp_send_s uv_udp_send_t; <br>
typedef struct uv_fs_s uv_fs_t; <br>
typedef struct uv_work_s uv_work_t; <br>
typedef struct uv_random_s uv_random_t;</p>

<p style="margin-left:13%; margin-top: 1em">/* None of the
above. */ <br>
typedef struct uv_env_item_s uv_env_item_t; <br>
typedef struct uv_cpu_info_s uv_cpu_info_t; <br>
typedef struct uv_interface_address_s
uv_interface_address_t; <br>
typedef struct uv_dirent_s uv_dirent_t; <br>
typedef struct uv_passwd_s uv_passwd_t; <br>
typedef struct uv_utsname_s uv_utsname_t; <br>
typedef struct uv_statfs_s uv_statfs_t;</p>

<p style="margin-left:9%; margin-top: 1em">Handles
represent long-lived objects. Async operations on such
handles are identified using <b>requests</b>. A request is
short-lived (usually used across only one callback) and
usually indicates one I/O operation on a handle. Requests
are used to preserve context between the initiation and the
callback of individual actions. For example, an UDP socket
is represented by a <b>uv_udp_t</b>, while individual writes
to the socket use a <b>uv_udp_send_t</b> structure that is
passed to the callback after the write is done.</p>

<p style="margin-left:9%; margin-top: 1em">Handles are
setup by a corresponding:</p>


<p style="margin-left:13%; margin-top: 1em">uv_TYPE_init(uv_loop_t
*, uv_TYPE_t *)</p>

<p style="margin-left:9%; margin-top: 1em">function.</p>

<p style="margin-left:9%; margin-top: 1em">Callbacks are
functions which are called by libuv whenever an event the
watcher is interested in has taken place. Application
specific logic will usually be implemented in the callback.
For example, an IO watcher's callback will receive the data
read from a file, a timer callback will be triggered on
timeout and so on.</p>

<h3>Idling
<a name="Idling"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Here is an
example of using an idle handle. The callback is called once
on every turn of the event loop. A use case for idle handles
is discussed in <i>Utilities</i>. Let us use an idle watcher
to look at the watcher life cycle and see how
<b>uv_run()</b> will now block because a watcher is present.
The idle watcher is stopped when the count is reached and
<b>uv_run()</b> exits since no event watchers are
active.</p>


<p style="margin-left:9%; margin-top: 1em">idle-basic/main.c</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
#include &lt;uv.h&gt;</p>

<p style="margin-left:13%; margin-top: 1em">int64_t counter
= 0;</p>

<p style="margin-left:13%; margin-top: 1em">void
wait_for_a_while(uv_idle_t* handle) { <br>
counter++;</p>

<p style="margin-left:13%; margin-top: 1em">if (counter
&gt;= 10e6) <br>
uv_idle_stop(handle); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
uv_idle_t idler;</p>


<p style="margin-left:13%; margin-top: 1em">uv_idle_init(uv_default_loop(),
&amp;idler); <br>
uv_idle_start(&amp;idler, wait_for_a_while);</p>


<p style="margin-left:13%; margin-top: 1em">printf(&quot;Idling...\n&quot;);
<br>
uv_run(uv_default_loop(), UV_RUN_DEFAULT);</p>


<p style="margin-left:13%; margin-top: 1em">uv_loop_close(uv_default_loop());
<br>
return 0; <br>
}</p>

<h3>Storing context
<a name="Storing context"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">In callback
based programming style you'll often want to pass some
'context' -- application specific information -- between the
call site and the callback. All handles and requests have a
<b>void* data</b> member which you can set to the context
and cast back in the callback. This is a common pattern used
throughout the C library ecosystem. In addition
<b>uv_loop_t</b> also has a similar data member.</p>

<p align="center" style="margin-top: 1em">----</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p style="margin-top: 1em">[1]</p></td>
<td width="2%"></td>
<td width="67%">


<p style="margin-top: 1em">Depending on the capacity of the
hardware of course.</p></td>
<td width="18%">
</td></tr>
</table>

<h3>Filesystem
<a name="Filesystem"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Simple
filesystem read/write is achieved using the <b>uv_fs_*</b>
functions and the <b>uv_fs_t</b> struct.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">The libuv filesystem operations
are different from <i>socket operations</i>. Socket
operations use the non-blocking operations provided by the
operating system. Filesystem operations use blocking
functions internally, but invoke these functions in a
<i>thread pool</i> and notify watchers registered with the
event loop when application interaction is required.</p>

<p style="margin-left:9%; margin-top: 1em">All filesystem
functions have two forms - <i>synchronous</i> and
<i>asynchronous</i>.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>synchronous</i> forms automatically get called (and
<b>block</b>) if the callback is null. The return value of
functions is a <i>libuv error code</i>. This is usually only
useful for synchronous calls. The <i>asynchronous</i> form
is called when a callback is passed and the return value is
0.</p>

<h3>Reading/Writing files
<a name="Reading/Writing files"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">A file
descriptor is obtained using</p>

<p style="margin-left:13%; margin-top: 1em">int
uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path,
int flags, int mode, uv_fs_cb cb)</p>

<p style="margin-left:9%; margin-top: 1em"><b>flags</b> and
<b>mode</b> are standard <i>Unix flags</i>. libuv takes care
of converting to the appropriate Windows flags.</p>

<p style="margin-left:9%; margin-top: 1em">File descriptors
are closed using</p>

<p style="margin-left:13%; margin-top: 1em">int
uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file,
uv_fs_cb cb)</p>

<p style="margin-left:9%; margin-top: 1em">Filesystem
operation callbacks have the signature:</p>

<p style="margin-left:13%; margin-top: 1em">void
callback(uv_fs_t* req);</p>

<p style="margin-left:9%; margin-top: 1em">Let's see a
simple implementation of <b>cat</b>. We start with
registering a callback for when the file is opened:</p>

<p style="margin-left:9%; margin-top: 1em">uvcat/main.c -
opening a file</p>

<p style="margin-left:13%; margin-top: 1em">// The request
passed to the callback is the same as the one the call setup
<br>
// function was passed. <br>
assert(req == &amp;open_req); <br>
if (req-&gt;result &gt;= 0) { <br>
iov = uv_buf_init(buffer, sizeof(buffer)); <br>
uv_fs_read(uv_default_loop(), &amp;read_req, req-&gt;result,
<br>
&amp;iov, 1, -1, on_read); <br>
} <br>
else { <br>
fprintf(stderr, &quot;error opening file: %s\n&quot;,
uv_strerror((int)req-&gt;result)); <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>result</b> field of a <b>uv_fs_t</b> is the file
descriptor in case of the <b>uv_fs_open</b> callback. If the
file is successfully opened, we start reading it.</p>

<p style="margin-left:9%; margin-top: 1em">uvcat/main.c -
read callback</p>

<p style="margin-left:13%; margin-top: 1em">if
(req-&gt;result &lt; 0) { <br>
fprintf(stderr, &quot;Read error: %s\n&quot;,
uv_strerror(req-&gt;result)); <br>
} <br>
else if (req-&gt;result == 0) { <br>
uv_fs_t close_req; <br>
// synchronous <br>
uv_fs_close(uv_default_loop(), &amp;close_req,
open_req.result, NULL); <br>
} <br>
else if (req-&gt;result &gt; 0) { <br>
iov.len = req-&gt;result; <br>
uv_fs_write(uv_default_loop(), &amp;write_req, 1, &amp;iov,
1, -1, on_write); <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In the case of a
read call, you should pass an <i>initialized</i> buffer
which will be filled with data before the read callback is
triggered. The <b>uv_fs_*</b> operations map almost directly
to certain POSIX functions, so EOF is indicated in this case
by <b>result</b> being 0. In the case of streams or pipes,
the <b>UV_EOF</b> constant would have been passed as a
status instead.</p>

<p style="margin-left:9%; margin-top: 1em">Here you see a
common pattern when writing asynchronous programs. The
<b>uv_fs_close()</b> call is performed synchronously.
<i>Usually tasks which are one-off, or are done as part of
the startup or shutdown stage are performed synchronously,
since we are interested in fast I/O when the program is
going about its primary task and dealing with multiple I/O
sources</i>. For solo tasks the performance difference
usually is negligible and may lead to simpler code.</p>

<p style="margin-left:9%; margin-top: 1em">Filesystem
writing is similarly simple using <b>uv_fs_write()</b>.
<i>Your callback will be triggered after the write is
complete</i>. In our case the callback simply drives the
next read. Thus read and write proceed in lockstep via
callbacks.</p>

<p style="margin-left:9%; margin-top: 1em">uvcat/main.c -
write callback</p>

<p style="margin-left:13%; margin-top: 1em">if
(req-&gt;result &lt; 0) { <br>
fprintf(stderr, &quot;Write error: %s\n&quot;,
uv_strerror((int)req-&gt;result)); <br>
} <br>
else { <br>
uv_fs_read(uv_default_loop(), &amp;read_req,
open_req.result, &amp;iov, 1, -1, on_read); <br>
} <br>
}</p>


<p style="margin-left:9%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:13%;">Due to the way filesystems and
disk drives are configured for performance, a write that
'succeeds' may not be committed to disk yet.</p>

<p style="margin-left:9%; margin-top: 1em">We set the
dominos rolling in <b>main()</b>:</p>


<p style="margin-left:9%; margin-top: 1em">uvcat/main.c</p>


<p style="margin-left:13%; margin-top: 1em">uv_fs_open(uv_default_loop(),
&amp;open_req, argv[1], O_RDONLY, 0, on_open); <br>
uv_run(uv_default_loop(), UV_RUN_DEFAULT);</p>


<p style="margin-left:13%; margin-top: 1em">uv_fs_req_cleanup(&amp;open_req);
<br>
uv_fs_req_cleanup(&amp;read_req); <br>
uv_fs_req_cleanup(&amp;write_req); <br>
return 0; <br>
}</p>


<p style="margin-left:9%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:13%;">The <b>uv_fs_req_cleanup()</b>
function must always be called on filesystem requests to
free internal memory allocations in libuv.</p>

<h3>Filesystem operations
<a name="Filesystem operations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">All the standard
filesystem operations like <b>unlink</b>, <b>rmdir</b>,
<b>stat</b> are supported asynchronously and have intuitive
argument order. They follow the same patterns as the
read/write/open calls, returning the result in the
<b>uv_fs_t.result</b> field. The full list:</p>

<p style="margin-left:9%; margin-top: 1em">Filesystem
operations</p>

<p style="margin-left:13%; margin-top: 1em">int
uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file,
uv_fs_cb cb); <br>
int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char*
path, int flags, int mode, uv_fs_cb cb); <br>
int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file file,
const uv_buf_t bufs[], unsigned int nbufs, int64_t offset,
uv_fs_cb cb); <br>
int uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char*
path, uv_fs_cb cb); <br>
int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file,
const uv_buf_t bufs[], unsigned int nbufs, int64_t offset,
uv_fs_cb cb); <br>
int uv_fs_copyfile(uv_loop_t* loop, uv_fs_t* req, const
char* path, const char* new_path, int flags, uv_fs_cb cb);
<br>
int uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char*
path, int mode, uv_fs_cb cb); <br>
int uv_fs_mkdtemp(uv_loop_t* loop, uv_fs_t* req, const char*
tpl, uv_fs_cb cb); <br>
int uv_fs_mkstemp(uv_loop_t* loop, uv_fs_t* req, const char*
tpl, uv_fs_cb cb); <br>
int uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char*
path, uv_fs_cb cb); <br>
int uv_fs_scandir(uv_loop_t* loop, uv_fs_t* req, const char*
path, int flags, uv_fs_cb cb); <br>
int uv_fs_scandir_next(uv_fs_t* req, uv_dirent_t* ent); <br>
int uv_fs_opendir(uv_loop_t* loop, uv_fs_t* req, const char*
path, uv_fs_cb cb); <br>
int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, uv_dir_t*
dir, uv_fs_cb cb); <br>
int uv_fs_closedir(uv_loop_t* loop, uv_fs_t* req, uv_dir_t*
dir, uv_fs_cb cb); <br>
int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char*
path, uv_fs_cb cb); <br>
int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file,
uv_fs_cb cb); <br>
int uv_fs_rename(uv_loop_t* loop, uv_fs_t* req, const char*
path, const char* new_path, uv_fs_cb cb); <br>
int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file,
uv_fs_cb cb); <br>
int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file
file, uv_fs_cb cb); <br>
int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file
file, int64_t offset, uv_fs_cb cb); <br>
int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file
out_fd, uv_file in_fd, int64_t in_offset, size_t length,
uv_fs_cb cb); <br>
int uv_fs_access(uv_loop_t* loop, uv_fs_t* req, const char*
path, int mode, uv_fs_cb cb); <br>
int uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char*
path, int mode, uv_fs_cb cb); <br>
int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char*
path, double atime, double mtime, uv_fs_cb cb); <br>
int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file
file, double atime, double mtime, uv_fs_cb cb); <br>
int uv_fs_lutime(uv_loop_t* loop, uv_fs_t* req, const char*
path, double atime, double mtime, uv_fs_cb cb); <br>
int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char*
path, uv_fs_cb cb); <br>
int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, const char*
path, const char* new_path, uv_fs_cb cb); <br>
int uv_fs_symlink(uv_loop_t* loop, uv_fs_t* req, const char*
path, const char* new_path, int flags, uv_fs_cb cb); <br>
int uv_fs_readlink(uv_loop_t* loop, uv_fs_t* req, const
char* path, uv_fs_cb cb); <br>
int uv_fs_realpath(uv_loop_t* loop, uv_fs_t* req, const
char* path, uv_fs_cb cb); <br>
int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file
file, int mode, uv_fs_cb cb); <br>
int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, const char*
path, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb); <br>
int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file
file, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb); <br>
int uv_fs_lchown(uv_loop_t* loop, uv_fs_t* req, const char*
path, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb); <br>
int uv_fs_statfs(uv_loop_t* loop, uv_fs_t* req, const char*
path, uv_fs_cb cb);</p>

<h3>Buffers and Streams
<a name="Buffers and Streams"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The basic I/O
handle in libuv is the stream (<b>uv_stream_t</b>). TCP
sockets, UDP sockets, and pipes for file I/O and IPC are all
treated as stream subclasses.</p>

<p style="margin-left:9%; margin-top: 1em">Streams are
initialized using custom functions for each subclass, then
operated upon using</p>

<p style="margin-left:13%; margin-top: 1em">int
uv_read_start(uv_stream_t*, uv_alloc_cb alloc_cb, uv_read_cb
read_cb); <br>
int uv_read_stop(uv_stream_t*); <br>
int uv_write(uv_write_t* req, uv_stream_t* handle, <br>
const uv_buf_t bufs[], unsigned int nbufs, uv_write_cb
cb);</p>

<p style="margin-left:9%; margin-top: 1em">The stream based
functions are simpler to use than the filesystem ones and
libuv will automatically keep reading from a stream when
<b>uv_read_start()</b> is called once, until
<b>uv_read_stop()</b> is called.</p>

<p style="margin-left:9%; margin-top: 1em">The discrete
unit of data is the buffer -- <b>uv_buf_t</b>. This is
simply a collection of a pointer to bytes
(<b>uv_buf_t.base</b>) and the length (<b>uv_buf_t.len</b>).
The <b>uv_buf_t</b> is lightweight and passed around by
value. What does require management is the actual bytes,
which have to be allocated and freed by the application.</p>


<p style="margin-left:9%; margin-top: 1em"><b>ERROR:</b></p>

<p style="margin-left:13%;"><b>THIS PROGRAM DOES NOT ALWAYS
WORK, NEED SOMETHING BETTER</b></p>

<p style="margin-left:9%; margin-top: 1em">To demonstrate
streams we will need to use <b>uv_pipe_t</b>. This allows
streaming local files [2]. Here is a simple tee utility
using libuv. Doing all operations asynchronously shows the
power of evented I/O. The two writes won't block each other,
but we have to be careful to copy over the buffer data to
ensure we don't free a buffer until it has been written.</p>

<p style="margin-left:9%; margin-top: 1em">The program is
to be executed as:</p>

<p style="margin-left:13%; margin-top: 1em">./uvtee
&lt;output_file&gt;</p>

<p style="margin-left:9%; margin-top: 1em">We start off
opening pipes on the files we require. libuv pipes to a file
are opened as bidirectional by default.</p>

<p style="margin-left:9%; margin-top: 1em">uvtee/main.c -
read on pipes</p>

<p style="margin-left:13%; margin-top: 1em">loop =
uv_default_loop();</p>


<p style="margin-left:13%; margin-top: 1em">uv_pipe_init(loop,
&amp;stdin_pipe, 0); <br>
uv_pipe_open(&amp;stdin_pipe, 0);</p>


<p style="margin-left:13%; margin-top: 1em">uv_pipe_init(loop,
&amp;stdout_pipe, 0); <br>
uv_pipe_open(&amp;stdout_pipe, 1);</p>

<p style="margin-left:13%; margin-top: 1em">uv_fs_t
file_req; <br>
int fd = uv_fs_open(loop, &amp;file_req, argv[1], O_CREAT |
O_RDWR, 0644, NULL); <br>
uv_pipe_init(loop, &amp;file_pipe, 0); <br>
uv_pipe_open(&amp;file_pipe, fd);</p>


<p style="margin-left:13%; margin-top: 1em">uv_read_start((uv_stream_t*)&amp;stdin_pipe,
alloc_buffer, read_stdin);</p>

<p style="margin-left:13%; margin-top: 1em">uv_run(loop,
UV_RUN_DEFAULT); <br>
return 0; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The third
argument of <b>uv_pipe_init()</b> should be set to 1 for IPC
using named pipes. This is covered in <i>Processes</i>. The
<b>uv_pipe_open()</b> call associates the pipe with the file
descriptor, in this case <b>0</b> (standard input).</p>

<p style="margin-left:9%; margin-top: 1em">We start
monitoring <b>stdin</b>. The <b>alloc_buffer</b> callback is
invoked as new buffers are required to hold incoming data.
<b>read_stdin</b> will be called with these buffers.</p>

<p style="margin-left:9%; margin-top: 1em">uvtee/main.c -
reading buffers</p>

<p style="margin-left:13%; margin-top: 1em">*buf =
uv_buf_init((char*) malloc(suggested_size), suggested_size);
<br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
free_write_req(uv_write_t *req) { <br>
if (nread &lt; 0){ <br>
if (nread == UV_EOF){ <br>
// end of file <br>
uv_close((uv_handle_t *)&amp;stdin_pipe, NULL); <br>
uv_close((uv_handle_t *)&amp;stdout_pipe, NULL); <br>
uv_close((uv_handle_t *)&amp;file_pipe, NULL); <br>
} <br>
} else if (nread &gt; 0) { <br>
write_data((uv_stream_t *)&amp;stdout_pipe, nread, *buf,
on_stdout_write); <br>
write_data((uv_stream_t *)&amp;file_pipe, nread, *buf,
on_file_write); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// OK to free
buffer as write_data copies it. <br>
if (buf-&gt;base) <br>
free(buf-&gt;base); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The standard
<b>malloc</b> is sufficient here, but you can use any memory
allocation scheme. For example, node.js uses its own slab
allocator which associates buffers with V8 objects.</p>

<p style="margin-left:9%; margin-top: 1em">The read
callback <b>nread</b> parameter is less than 0 on any error.
This error might be EOF, in which case we close all the
streams, using the generic close function <b>uv_close()</b>
which deals with the handle based on its internal type.
Otherwise <b>nread</b> is a non-negative number and we can
attempt to write that many bytes to the output streams.
Finally remember that buffer allocation and deallocation is
application responsibility, so we free the data.</p>

<p style="margin-left:9%; margin-top: 1em">The allocation
callback may return a buffer with length zero if it fails to
allocate memory. In this case, the read callback is invoked
with error UV_ENOBUFS. libuv will continue to attempt to
read the stream though, so you must explicitly call
<b>uv_close()</b> if you want to stop when allocation
fails.</p>

<p style="margin-left:9%; margin-top: 1em">The read
callback may be called with <b>nread = 0</b>, indicating
that at this point there is nothing to be read. Most
applications will just ignore this.</p>

<p style="margin-left:9%; margin-top: 1em">uvtee/main.c -
Write to pipe</p>

<p style="margin-left:13%; margin-top: 1em">uv_write_t req;
<br>
uv_buf_t buf; <br>
} write_req_t;</p>

<p style="margin-left:13%; margin-top: 1em">uv_loop_t
*loop; <br>
write_req_t *wr = (write_req_t*) req; <br>
free(wr-&gt;buf.base); <br>
free(wr); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
on_stdout_write(uv_write_t *req, int status) { <br>
free_write_req(req); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
on_file_write(uv_write_t *req, int status) { <br>
free_write_req(req); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
write_data(uv_stream_t *dest, size_t size, uv_buf_t buf,
uv_write_cb cb) { <br>
write_req_t *req = (write_req_t*)
malloc(sizeof(write_req_t)); <br>
req-&gt;buf = uv_buf_init((char*) malloc(size), size); <br>
memcpy(req-&gt;buf.base, buf.base, size); <br>
uv_write((uv_write_t*) req, (uv_stream_t*)dest,
&amp;req-&gt;buf, 1, cb); <br>
}</p>


<p style="margin-left:9%; margin-top: 1em"><b>write_data()</b>
makes a copy of the buffer obtained from read. This buffer
does not get passed through to the write callback trigged on
write completion. To get around this we wrap a write request
and a buffer in <b>write_req_t</b> and unwrap it in the
callbacks. We make a copy so we can free the two buffers
from the two calls to <b>write_data</b> independently of
each other. While acceptable for a demo program like this,
you'll probably want smarter memory management, like
reference counted buffers or a pool of buffers in any major
application.</p>


<p style="margin-left:9%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:13%;">If your program is meant to be
used with other programs it may knowingly or unknowingly be
writing to a pipe. This makes it susceptible to <i>aborting
on receiving a SIGPIPE</i>. It is a good idea to insert:</p>


<p style="margin-left:18%; margin-top: 1em">signal(SIGPIPE,
SIG_IGN)</p>

<p style="margin-left:13%; margin-top: 1em">in the
initialization stages of your application.</p>

<h3>File change events
<a name="File change events"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">All modern
operating systems provide APIs to put watches on individual
files or directories and be informed when the files are
modified. libuv wraps common file change notification
libraries [1]. This is one of the more inconsistent parts of
libuv. File change notification systems are themselves
extremely varied across platforms so getting everything
working everywhere is difficult. To demonstrate, I'm going
to build a simple utility which runs a command whenever any
of the watched files change:</p>

<p style="margin-left:13%; margin-top: 1em">./onchange
&lt;command&gt; &lt;file1&gt; [file2] ...</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">Currently this example only
works on OSX and Windows. Refer to the <i>notes of
uv_fs_event_start</i> function.</p>

<p style="margin-left:9%; margin-top: 1em">The file change
notification is started using <b>uv_fs_event_init()</b>:</p>

<p style="margin-left:9%; margin-top: 1em">onchange/main.c
- The setup</p>

<p style="margin-left:13%; margin-top: 1em">int main(int
argc, char **argv) { <br>
if (argc &lt;= 2) { <br>
fprintf(stderr, &quot;Usage: %s &lt;command&gt;
&lt;file1&gt; [file2 ...]\n&quot;, argv[0]); <br>
return 1; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">loop =
uv_default_loop(); <br>
command = argv[1];</p>

<p style="margin-left:13%; margin-top: 1em">while (argc--
&gt; 2) { <br>
fprintf(stderr, &quot;Adding watch on %s\n&quot;,
argv[argc]); <br>
uv_fs_event_t *fs_event_req = malloc(sizeof(uv_fs_event_t));
<br>
uv_fs_event_init(loop, fs_event_req); <br>
// The recursive flag watches subdirectories too. <br>
uv_fs_event_start(fs_event_req, run_command, argv[argc],
UV_FS_EVENT_RECURSIVE); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">return
uv_run(loop, UV_RUN_DEFAULT); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The third
argument is the actual file or directory to monitor. The
last argument, <b>flags</b>, can be:</p>

<p style="margin-left:13%; margin-top: 1em">/* <br>
* Flags to be passed to uv_fs_event_start(). <br>
*/ <br>
enum uv_fs_event_flags { <br>
UV_FS_EVENT_WATCH_ENTRY = 1, <br>
UV_FS_EVENT_STAT = 2, <br>
UV_FS_EVENT_RECURSIVE = 4 <br>
};</p>


<p style="margin-left:9%; margin-top: 1em"><b>UV_FS_EVENT_WATCH_ENTRY</b>
and <b>UV_FS_EVENT_STAT</b> don't do anything (yet).
<b>UV_FS_EVENT_RECURSIVE</b> will start watching
subdirectories as well on supported platforms.</p>

<p style="margin-left:9%; margin-top: 1em">The callback
will receive the following arguments:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="2%">


<p style="margin-top: 1em">1.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>uv_fs_event_t *handle</b> -
The handle. The <b>path</b> field of the handle is the file
on which the watch was set.</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="2%">


<p>2.</p></td>
<td width="2%"></td>
<td width="83%">


<p><b>const char *filename</b> - If a directory is being
monitored, this is the file which was changed. Only
non-<b>null</b> on Linux and Windows. May be <b>null</b>
even on those platforms.</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="2%">


<p>3.</p></td>
<td width="2%"></td>
<td width="83%">


<p><b>int events</b> - one of <b>UV_RENAME</b> or
<b>UV_CHANGE</b>, or a bitwise OR of both.</p></td></tr>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="2%">


<p>4.</p></td>
<td width="2%"></td>
<td width="83%">


<p><b>int status</b> - If <b>status &lt; 0</b>, there is an
<i>libuv error</i>.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">In our example
we simply print the arguments and run the command using
<b>system()</b>.</p>

<p style="margin-left:9%; margin-top: 1em">onchange/main.c
- file change notification callback</p>

<p style="margin-left:13%; margin-top: 1em">void
run_command(uv_fs_event_t *handle, const char *filename, int
events, int status) { <br>
char path[1024]; <br>
size_t size = 1023; <br>
// Does not handle error if path is longer than 1023. <br>
uv_fs_event_getpath(handle, path, &amp;size); <br>
path[size] = '\0';</p>


<p style="margin-left:13%; margin-top: 1em">fprintf(stderr,
&quot;Change detected in %s: &quot;, path); <br>
if (events &amp; UV_RENAME) <br>
fprintf(stderr, &quot;renamed&quot;); <br>
if (events &amp; UV_CHANGE) <br>
fprintf(stderr, &quot;changed&quot;);</p>


<p style="margin-left:13%; margin-top: 1em">fprintf(stderr,
&quot; %s\n&quot;, filename ? filename : &quot;&quot;); <br>
system(command); <br>
}</p>

<p align="center" style="margin-top: 1em">----</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p style="margin-top: 1em">[1]</p></td>
<td width="2%"></td>
<td width="85%">


<p style="margin-top: 1em">inotify on Linux, FSEvents on
Darwin, kqueue on BSDs, ReadDirectoryChangesW on Windows,
event ports on Solaris, unsupported on Cygwin</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>[2]</p></td>
<td width="2%"></td>
<td width="85%">


<p>see <i>Parent-child IPC</i></p></td></tr>
</table>

<h3>Networking
<a name="Networking"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Networking in
libuv is not much different from directly using the BSD
socket interface, some things are easier, all are
non-blocking, but the concepts stay the same. In addition
libuv offers utility functions to abstract the annoying,
repetitive and low-level tasks like setting up sockets using
the BSD socket structures, DNS lookup, and tweaking various
socket parameters.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>uv_tcp_t</b> and <b>uv_udp_t</b> structures are used for
network I/O.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">The code samples in this
chapter exist to show certain libuv APIs. They are not
examples of good quality code. They leak memory and don't
always close connections properly.</p>

<h3>TCP
<a name="TCP"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">TCP is a
connection oriented, stream protocol and is therefore based
on the libuv streams infrastructure.</p>

<h3>Server
<a name="Server"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Server sockets
proceed by:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="1%"></td>
<td width="87%">


<p style="margin-top: 1em"><b>uv_tcp_init</b> the TCP
handle.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="87%">


<p><b>uv_tcp_bind</b> it.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="87%">


<p>Call <b>uv_listen</b> on the handle to have a callback
invoked whenever a new connection is established by a
client.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>4.</p></td>
<td width="1%"></td>
<td width="87%">


<p>Use <b>uv_accept</b> to accept the connection.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>5.</p></td>
<td width="1%"></td>
<td width="87%">


<p>Use <i>stream operations</i> to communicate with the
client.</p> </td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Here is a simple
echo server</p>


<p style="margin-left:9%; margin-top: 1em">tcp-echo-server/main.c
- The listen socket</p>


<p style="margin-left:13%; margin-top: 1em">uv_close((uv_handle_t*)
client, on_close); <br>
} <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
loop = uv_default_loop();</p>

<p style="margin-left:13%; margin-top: 1em">uv_tcp_t
server; <br>
uv_tcp_init(loop, &amp;server);</p>


<p style="margin-left:13%; margin-top: 1em">uv_ip4_addr(&quot;0.0.0.0&quot;,
DEFAULT_PORT, &amp;addr);</p>


<p style="margin-left:13%; margin-top: 1em">uv_tcp_bind(&amp;server,
(const struct sockaddr*)&amp;addr, 0); <br>
int r = uv_listen((uv_stream_t*) &amp;server,
DEFAULT_BACKLOG, on_new_connection); <br>
if (r) { <br>
fprintf(stderr, &quot;Listen error %s\n&quot;,
uv_strerror(r)); <br>
return 1; <br>
} <br>
return uv_run(loop, UV_RUN_DEFAULT); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">You can see the
utility function <b>uv_ip4_addr</b> being used to convert
from a human readable IP address, port pair to the
sockaddr_in structure required by the BSD socket APIs. The
reverse can be obtained using <b>uv_ip4_name</b>.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">There are <b>uv_ip6_*</b>
analogues for the ip4 functions.</p>

<p style="margin-left:9%; margin-top: 1em">Most of the
setup functions are synchronous since they are CPU-bound.
<b>uv_listen</b> is where we return to libuv's callback
style. The second arguments is the backlog queue -- the
maximum length of queued connections.</p>

<p style="margin-left:9%; margin-top: 1em">When a
connection is initiated by clients, the callback is required
to set up a handle for the client socket and associate the
handle using <b>uv_accept</b>. In this case we also
establish interest in reading from this stream.</p>


<p style="margin-left:9%; margin-top: 1em">tcp-echo-server/main.c
- Accepting the client</p>


<p style="margin-left:13%; margin-top: 1em">free(buf-&gt;base);
<br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
on_new_connection(uv_stream_t *server, int status) { <br>
if (status &lt; 0) { <br>
fprintf(stderr, &quot;New connection error %s\n&quot;,
uv_strerror(status)); <br>
// error! <br>
return; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">uv_tcp_t
*client = (uv_tcp_t*) malloc(sizeof(uv_tcp_t)); <br>
uv_tcp_init(loop, client); <br>
if (uv_accept(server, (uv_stream_t*) client) == 0) { <br>
uv_read_start((uv_stream_t*) client, alloc_buffer,
echo_read); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The remaining
set of functions is very similar to the streams example and
can be found in the code. Just remember to call
<b>uv_close</b> when the socket isn't required. This can be
done even in the <b>uv_listen</b> callback if you are not
interested in accepting the connection.</p>

<h3>Client
<a name="Client"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Where you do
bind/listen/accept on the server, on the client side it's
simply a matter of calling <b>uv_tcp_connect</b>. The same
<b>uv_connect_cb</b> style callback of <b>uv_listen</b> is
used by <b>uv_tcp_connect</b>. Try:</p>

<p style="margin-left:13%; margin-top: 1em">uv_tcp_t*
socket = (uv_tcp_t*)malloc(sizeof(uv_tcp_t)); <br>
uv_tcp_init(loop, socket);</p>

<p style="margin-left:13%; margin-top: 1em">uv_connect_t*
connect = (uv_connect_t*)malloc(sizeof(uv_connect_t));</p>

<p style="margin-left:13%; margin-top: 1em">struct
sockaddr_in dest; <br>
uv_ip4_addr(&quot;127.0.0.1&quot;, 80, &amp;dest);</p>


<p style="margin-left:13%; margin-top: 1em">uv_tcp_connect(connect,
socket, (const struct sockaddr*)&amp;dest, on_connect);</p>

<p style="margin-left:9%; margin-top: 1em">where
<b>on_connect</b> will be called after the connection is
established. The callback receives the <b>uv_connect_t</b>
struct, which has a member <b>.handle</b> pointing to the
socket.</p>

<h3>UDP
<a name="UDP"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The <i>User
Datagram Protocol</i> offers connectionless, unreliable
network communication. Hence libuv doesn't offer a stream.
Instead libuv provides non-blocking UDP support via the
<i>uv_udp_t</i> handle (for receiving) and
<i>uv_udp_send_t</i> request (for sending) and related
functions. That said, the actual API for reading/writing is
very similar to normal stream reads. To look at how UDP can
be used, the example shows the first stage of obtaining an
IP address from a <i>DHCP</i> server -- DHCP Discover.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">You will have to run
<i>udp-dhcp</i> as <b>root</b> since it uses well known port
numbers below 1024.</p>

<p style="margin-left:9%; margin-top: 1em">udp-dhcp/main.c
- Setup and send UDP packets</p>

<p style="margin-left:13%; margin-top: 1em">uv_loop_t
*loop; <br>
uv_udp_t send_socket; <br>
uv_udp_t recv_socket;</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
loop = uv_default_loop();</p>


<p style="margin-left:13%; margin-top: 1em">uv_udp_init(loop,
&amp;recv_socket); <br>
struct sockaddr_in recv_addr; <br>
uv_ip4_addr(&quot;0.0.0.0&quot;, 68, &amp;recv_addr); <br>
uv_udp_bind(&amp;recv_socket, (const struct sockaddr
*)&amp;recv_addr, UV_UDP_REUSEADDR); <br>
uv_udp_recv_start(&amp;recv_socket, alloc_buffer,
on_read);</p>


<p style="margin-left:13%; margin-top: 1em">uv_udp_init(loop,
&amp;send_socket); <br>
struct sockaddr_in broadcast_addr; <br>
uv_ip4_addr(&quot;0.0.0.0&quot;, 0, &amp;broadcast_addr);
<br>
uv_udp_bind(&amp;send_socket, (const struct sockaddr
*)&amp;broadcast_addr, 0); <br>
uv_udp_set_broadcast(&amp;send_socket, 1);</p>

<p style="margin-left:13%; margin-top: 1em">uv_udp_send_t
send_req; <br>
uv_buf_t discover_msg = make_discover_msg();</p>

<p style="margin-left:13%; margin-top: 1em">struct
sockaddr_in send_addr; <br>
uv_ip4_addr(&quot;255.255.255.255&quot;, 67,
&amp;send_addr); <br>
uv_udp_send(&amp;send_req, &amp;send_socket,
&amp;discover_msg, 1, (const struct sockaddr
*)&amp;send_addr, on_send);</p>

<p style="margin-left:13%; margin-top: 1em">return
uv_run(loop, UV_RUN_DEFAULT); <br>
}</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">The IP address <b>0.0.0.0</b>
is used to bind to all interfaces. The IP address
<b>255.255.255.255</b> is a broadcast address meaning that
packets will be sent to all interfaces on the subnet. port
<b>0</b> means that the OS randomly assigns a port.</p>

<p style="margin-left:9%; margin-top: 1em">First we setup
the receiving socket to bind on all interfaces on port 68
(DHCP client) and start a read on it. This will read back
responses from any DHCP server that replies. We use the
UV_UDP_REUSEADDR flag to play nice with any other system
DHCP clients that are running on this computer on the same
port. Then we setup a similar send socket and use
<b>uv_udp_send</b> to send a <i>broadcast message</i> on
port 67 (DHCP server).</p>

<p style="margin-left:9%; margin-top: 1em">It is
<b>necessary</b> to set the broadcast flag, otherwise you
will get an <b>EACCES</b> error [1]. The exact message being
sent is not relevant to this book and you can study the code
if you are interested. As usual the read and write callbacks
will receive a status code of &lt; 0 if something went
wrong.</p>

<p style="margin-left:9%; margin-top: 1em">Since UDP
sockets are not connected to a particular peer, the read
callback receives an extra parameter about the sender of the
packet.</p>

<p style="margin-left:9%; margin-top: 1em"><b>nread</b> may
be zero if there is no more data to be read. If <b>addr</b>
is NULL, it indicates there is nothing to read (the callback
shouldn't do anything), if not NULL, it indicates that an
empty datagram was received from the host at <b>addr</b>.
The <b>flags</b> parameter may be <b>UV_UDP_PARTIAL</b> if
the buffer provided by your allocator was not large enough
to hold the data. <i>In this case the OS will discard the
data that could not fit</i> (That's UDP for you!).</p>

<p style="margin-left:9%; margin-top: 1em">udp-dhcp/main.c
- Reading packets</p>

<p style="margin-left:13%; margin-top: 1em">void
on_read(uv_udp_t *req, ssize_t nread, const uv_buf_t *buf,
const struct sockaddr *addr, unsigned flags) { <br>
if (nread &lt; 0) { <br>
fprintf(stderr, &quot;Read error %s\n&quot;,
uv_err_name(nread)); <br>
uv_close((uv_handle_t*) req, NULL); <br>
free(buf-&gt;base); <br>
return; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">char sender[17]
= { 0 }; <br>
uv_ip4_name((const struct sockaddr_in*) addr, sender, 16);
<br>
fprintf(stderr, &quot;Recv from %s\n&quot;, sender);</p>

<p style="margin-left:13%; margin-top: 1em">// ... DHCP
specific code <br>
unsigned int *as_integer = (unsigned int*)buf-&gt;base; <br>
unsigned int ipbin = ntohl(as_integer[4]); <br>
unsigned char ip[4] = {0}; <br>
int i; <br>
for (i = 0; i &lt; 4; i++) <br>
ip[i] = (ipbin &gt;&gt; i*8) &amp; 0xff; <br>
fprintf(stderr, &quot;Offered IP %d.%d.%d.%d\n&quot;, ip[3],
ip[2], ip[1], ip[0]);</p>


<p style="margin-left:13%; margin-top: 1em">free(buf-&gt;base);
<br>
uv_udp_recv_stop(req); <br>
}</p>

<h3>UDP Options
<a name="UDP Options"></a>
</h3>


<h3>Time-to-live
<a name="Time-to-live"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The TTL of
packets sent on the socket can be changed using
<b>uv_udp_set_ttl</b>.</p>

<h3>IPv6 stack only
<a name="IPv6 stack only"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">IPv6 sockets can
be used for both IPv4 and IPv6 communication. If you want to
restrict the socket to IPv6 only, pass the
<b>UV_UDP_IPV6ONLY</b> flag to <b>uv_udp_bind</b>.</p>

<h3>Multicast
<a name="Multicast"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">A socket can
(un)subscribe to a multicast group using:</p>

<p style="margin-left:9%; margin-top: 1em">where
<b>membership</b> is <b>UV_JOIN_GROUP</b> or
<b>UV_LEAVE_GROUP</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The concepts of
multicasting are nicely explained in <i>this guide</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Local loopback
of multicast packets is enabled by default [2], use
<b>uv_udp_set_multicast_loop</b> to switch it off.</p>

<p style="margin-left:9%; margin-top: 1em">The packet
time-to-live for multicast packets can be changed using
<b>uv_udp_set_multicast_ttl</b>.</p>

<h3>Querying DNS
<a name="Querying DNS"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv provides
asynchronous DNS resolution. For this it provides its own
<b>getaddrinfo</b> replacement [3]. In the callback you can
perform normal socket operations on the retrieved addresses.
Let's connect to Libera.chat to see an example of DNS
resolution.</p>

<p style="margin-left:9%; margin-top: 1em">dns/main.c</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
loop = uv_default_loop();</p>

<p style="margin-left:13%; margin-top: 1em">struct addrinfo
hints; <br>
hints.ai_family = PF_INET; <br>
hints.ai_socktype = SOCK_STREAM; <br>
hints.ai_protocol = IPPROTO_TCP; <br>
hints.ai_flags = 0;</p>


<p style="margin-left:13%; margin-top: 1em">uv_getaddrinfo_t
resolver; <br>
fprintf(stderr, &quot;irc.libera.chat is... &quot;); <br>
int r = uv_getaddrinfo(loop, &amp;resolver, on_resolved,
&quot;irc.libera.chat&quot;, &quot;6667&quot;,
&amp;hints);</p>

<p style="margin-left:13%; margin-top: 1em">if (r) { <br>
fprintf(stderr, &quot;getaddrinfo call error %s\n&quot;,
uv_err_name(r)); <br>
return 1; <br>
} <br>
return uv_run(loop, UV_RUN_DEFAULT); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">If
<b>uv_getaddrinfo</b> returns non-zero, something went wrong
in the setup and your callback won't be invoked at all. All
arguments can be freed immediately after
<b>uv_getaddrinfo</b> returns. The <i>hostname</i>,
<i>servname</i> and <i>hints</i> structures are documented
in <i>the getaddrinfo man page</i>. The callback can be
<b>NULL</b> in which case the function will run
synchronously.</p>

<p style="margin-left:9%; margin-top: 1em">In the resolver
callback, you can pick any IP from the linked list of
<b>struct addrinfo(s)</b>. This also demonstrates
<b>uv_tcp_connect</b>. It is necessary to call
<b>uv_freeaddrinfo</b> in the callback.</p>

<p style="margin-left:9%; margin-top: 1em">dns/main.c</p>

<p style="margin-left:13%; margin-top: 1em">void
on_resolved(uv_getaddrinfo_t *resolver, int status, struct
addrinfo *res) { <br>
if (status &lt; 0) { <br>
fprintf(stderr, &quot;getaddrinfo callback error %s\n&quot;,
uv_err_name(status)); <br>
return; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">char addr[17] =
{'\0'}; <br>
uv_ip4_name((struct sockaddr_in*) res-&gt;ai_addr, addr,
16); <br>
fprintf(stderr, &quot;%s\n&quot;, addr);</p>

<p style="margin-left:13%; margin-top: 1em">uv_connect_t
*connect_req = (uv_connect_t*) malloc(sizeof(uv_connect_t));
<br>
uv_tcp_t *socket = (uv_tcp_t*) malloc(sizeof(uv_tcp_t));
<br>
uv_tcp_init(loop, socket);</p>


<p style="margin-left:13%; margin-top: 1em">uv_tcp_connect(connect_req,
socket, (const struct sockaddr*) res-&gt;ai_addr,
on_connect);</p>


<p style="margin-left:13%; margin-top: 1em">uv_freeaddrinfo(res);
<br>
}</p>

<p style="margin-left:9%; margin-top: 1em">libuv also
provides the inverse <i>uv_getnameinfo</i>.</p>

<h3>Network interfaces
<a name="Network interfaces"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Information
about the system's network interfaces can be obtained
through libuv using <b>uv_interface_addresses</b>. This
simple program just prints out all the interface details so
you get an idea of the fields that are available. This is
useful to allow your service to bind to IP addresses when it
starts.</p>


<p style="margin-left:9%; margin-top: 1em">interfaces/main.c</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
#include &lt;uv.h&gt;</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
char buf[512]; <br>
uv_interface_address_t *info; <br>
int count, i;</p>


<p style="margin-left:13%; margin-top: 1em">uv_interface_addresses(&amp;info,
&amp;count); <br>
i = count;</p>


<p style="margin-left:13%; margin-top: 1em">printf(&quot;Number
of interfaces: %d\n&quot;, count); <br>
while (i--) { <br>
uv_interface_address_t interface_a = info[i];</p>


<p style="margin-left:13%; margin-top: 1em">printf(&quot;Name:
%s\n&quot;, interface_a.name); <br>
printf(&quot;Internal? %s\n&quot;, interface_a.is_internal ?
&quot;Yes&quot; : &quot;No&quot;);</p>

<p style="margin-left:13%; margin-top: 1em">if
(interface_a.address.address4.sin_family == AF_INET) { <br>
uv_ip4_name(&amp;interface_a.address.address4, buf,
sizeof(buf)); <br>
printf(&quot;IPv4 address: %s\n&quot;, buf); <br>
} <br>
else if (interface_a.address.address4.sin_family ==
AF_INET6) { <br>
uv_ip6_name(&amp;interface_a.address.address6, buf,
sizeof(buf)); <br>
printf(&quot;IPv6 address: %s\n&quot;, buf); <br>
}</p>


<p style="margin-left:13%; margin-top: 1em">printf(&quot;\n&quot;);
<br>
}</p>


<p style="margin-left:13%; margin-top: 1em">uv_free_interface_addresses(info,
count); <br>
return 0; <br>
}</p>


<p style="margin-left:9%; margin-top: 1em"><b>is_internal</b>
is true for loopback interfaces. Note that if a physical
interface has multiple IPv4/IPv6 addresses, the name will be
reported multiple times, with each address being reported
once.</p>

<p align="center" style="margin-top: 1em">----</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p style="margin-top: 1em">[1]</p></td>
<td width="2%"></td>
<td width="85%">



<p style="margin-top: 1em"><i>https://beej.us/guide/bgnet/html/#broadcast-packetshello-world</i></p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>[2]</p></td>
<td width="2%"></td>
<td width="85%">



<p><i>https://www.tldp.org/HOWTO/Multicast-HOWTO-6.html#ss6.1</i></p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>[3]</p></td>
<td width="2%"></td>
<td width="85%">


<p>libuv use the system <b>getaddrinfo</b> in the libuv
threadpool. libuv v0.8.0 and earlier also included
<i>c-ares</i> as an alternative, but this has been removed
in v0.9.0.</p></td></tr>
</table>

<h3>Threads
<a name="Threads"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Wait a minute?
Why are we on threads? Aren't event loops supposed to be
<b>the way</b> to do <i>web-scale programming</i>? Well...
no. Threads are still the medium in which processors do
their jobs. Threads are therefore mighty useful sometimes,
even though you might have to wade through various
synchronization primitives.</p>

<p style="margin-left:9%; margin-top: 1em">Threads are used
internally to fake the asynchronous nature of all of the
system calls. libuv also uses threads to allow you, the
application, to perform a task asynchronously that is
actually blocking, by spawning a thread and collecting the
result when it is done.</p>

<p style="margin-left:9%; margin-top: 1em">Today there are
two predominant thread libraries: the Windows threads
implementation and POSIX's <i>pthreads(7)</i>. libuv's
thread API is analogous to the pthreads API and often has
similar semantics.</p>

<p style="margin-left:9%; margin-top: 1em">A notable aspect
of libuv's thread facilities is that it is a self contained
section within libuv. Whereas other features intimately
depend on the event loop and callback principles, threads
are complete agnostic, they block as required, signal errors
directly via return values, and, as shown in the <i>first
example</i>, don't even require a running event loop.</p>

<p style="margin-left:9%; margin-top: 1em">libuv's thread
API is also very limited since the semantics and syntax of
threads are different on all platforms, with different
levels of completeness.</p>

<p style="margin-left:9%; margin-top: 1em">This chapter
makes the following assumption: <b>There is only one event
loop, running in one thread (the main thread)</b>. No other
thread interacts with the event loop (except using
<b>uv_async_send</b>).</p>

<h3>Core thread operations
<a name="Core thread operations"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">There isn't much
here, you just start a thread using
<b>uv_thread_create()</b> and wait for it to close using
<b>uv_thread_join()</b>.</p>


<p style="margin-left:9%; margin-top: 1em">thread-create/main.c</p>

<p style="margin-left:13%; margin-top: 1em">int tracklen =
10; <br>
uv_thread_t hare_id; <br>
uv_thread_t tortoise_id; <br>
uv_thread_create(&amp;hare_id, hare, &amp;tracklen); <br>
uv_thread_create(&amp;tortoise_id, tortoise,
&amp;tracklen);</p>


<p style="margin-left:13%; margin-top: 1em">uv_thread_join(&amp;hare_id);
<br>
uv_thread_join(&amp;tortoise_id); <br>
return 0; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em"><b>TIP:</b></p>

<p style="margin-left:13%;"><b>uv_thread_t</b> is just an
alias for <b>pthread_t</b> on Unix, but this is an
implementation detail, avoid depending on it to always be
true.</p>

<p style="margin-left:9%; margin-top: 1em">The second
parameter is the function which will serve as the entry
point for the thread, the last parameter is a <b>void *</b>
argument which can be used to pass custom parameters to the
thread. The function <b>hare</b> will now run in a separate
thread, scheduled pre-emptively by the operating system:</p>


<p style="margin-left:9%; margin-top: 1em">thread-create/main.c</p>

<p style="margin-left:13%; margin-top: 1em">int tracklen =
*((int *) arg); <br>
while (tracklen) { <br>
tracklen--; <br>
uv_sleep(1000); <br>
fprintf(stderr, &quot;Hare ran another step\n&quot;); <br>
} <br>
fprintf(stderr, &quot;Hare done running!\n&quot;); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Unlike
<b>pthread_join()</b> which allows the target thread to pass
back a value to the calling thread using a second parameter,
<b>uv_thread_join()</b> does not. To send values use
<i>Inter-thread communication</i>.</p>

<h3>Synchronization Primitives
<a name="Synchronization Primitives"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This section is
purposely spartan. This book is not about threads, so I only
catalogue any surprises in the libuv APIs here. For the rest
you can look at the <i>pthreads(7)</i> man pages.</p>

<h3>Mutexes
<a name="Mutexes"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The mutex
functions are a <b>direct</b> map to the pthread
equivalents.</p>

<p style="margin-left:9%; margin-top: 1em">libuv mutex
functions</p>

<p style="margin-left:13%; margin-top: 1em">int
uv_mutex_init(uv_mutex_t* handle); <br>
int uv_mutex_init_recursive(uv_mutex_t* handle); <br>
void uv_mutex_destroy(uv_mutex_t* handle); <br>
void uv_mutex_lock(uv_mutex_t* handle); <br>
int uv_mutex_trylock(uv_mutex_t* handle); <br>
void uv_mutex_unlock(uv_mutex_t* handle);</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>uv_mutex_init()</b>, <b>uv_mutex_init_recursive()</b> and
<b>uv_mutex_trylock()</b> functions will return 0 on
success, and an error code otherwise.</p>

<p style="margin-left:9%; margin-top: 1em">If <i>libuv</i>
has been compiled with debugging enabled,
<b>uv_mutex_destroy()</b>, <b>uv_mutex_lock()</b> and
<b>uv_mutex_unlock()</b> will <b>abort()</b> on error.
Similarly <b>uv_mutex_trylock()</b> will abort if the error
is anything <i>other than</i> <b>EAGAIN</b> or
<b>EBUSY</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Recursive
mutexes are supported, but you should not rely on them.
Also, they should not be used with <b>uv_cond_t</b>
variables.</p>

<p style="margin-left:9%; margin-top: 1em">The default BSD
mutex implementation will raise an error if a thread which
has locked a mutex attempts to lock it again. For example, a
construct like:</p>


<p style="margin-left:13%; margin-top: 1em">uv_mutex_init(a_mutex);
<br>
uv_mutex_lock(a_mutex); <br>
uv_thread_create(thread_id, entry, (void *)a_mutex); <br>
uv_mutex_lock(a_mutex); <br>
// more things here</p>

<p style="margin-left:9%; margin-top: 1em">can be used to
wait until another thread initializes some stuff and then
unlocks <b>a_mutex</b> but will lead to your program
crashing if in debug mode, or return an error in the second
call to <b>uv_mutex_lock()</b>.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">Mutexes on Windows are always
recursive.</p>

<h3>Locks
<a name="Locks"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Read-write locks
are a more granular access mechanism. Two readers can access
shared memory at the same time. A writer may not acquire the
lock when it is held by a reader. A reader or writer may not
acquire a lock when a writer is holding it. Read-write locks
are frequently used in databases. Here is a toy example.</p>

<p style="margin-left:9%; margin-top: 1em">locks/main.c -
simple rwlocks</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
#include &lt;uv.h&gt;</p>

<p style="margin-left:13%; margin-top: 1em">uv_barrier_t
blocker; <br>
uv_rwlock_t numlock; <br>
int shared_num;</p>

<p style="margin-left:13%; margin-top: 1em">void
reader(void *n) <br>
{ <br>
int num = *(int *)n; <br>
int i; <br>
for (i = 0; i &lt; 20; i++) { <br>
uv_rwlock_rdlock(&amp;numlock); <br>
printf(&quot;Reader %d: acquired lock\n&quot;, num); <br>
printf(&quot;Reader %d: shared num = %d\n&quot;, num,
shared_num); <br>
uv_rwlock_rdunlock(&amp;numlock); <br>
printf(&quot;Reader %d: released lock\n&quot;, num); <br>
} <br>
uv_barrier_wait(&amp;blocker); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
writer(void *n) <br>
{ <br>
int num = *(int *)n; <br>
int i; <br>
for (i = 0; i &lt; 20; i++) { <br>
uv_rwlock_wrlock(&amp;numlock); <br>
printf(&quot;Writer %d: acquired lock\n&quot;, num); <br>
shared_num++; <br>
printf(&quot;Writer %d: incremented shared num = %d\n&quot;,
num, shared_num); <br>
uv_rwlock_wrunlock(&amp;numlock); <br>
printf(&quot;Writer %d: released lock\n&quot;, num); <br>
} <br>
uv_barrier_wait(&amp;blocker); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int main() <br>
{ <br>
uv_barrier_init(&amp;blocker, 4);</p>

<p style="margin-left:13%; margin-top: 1em">shared_num = 0;
<br>
uv_rwlock_init(&amp;numlock);</p>

<p style="margin-left:13%; margin-top: 1em">uv_thread_t
threads[3];</p>

<p style="margin-left:13%; margin-top: 1em">int
thread_nums[] = {1, 2, 1}; <br>
uv_thread_create(&amp;threads[0], reader,
&amp;thread_nums[0]); <br>
uv_thread_create(&amp;threads[1], reader,
&amp;thread_nums[1]);</p>


<p style="margin-left:13%; margin-top: 1em">uv_thread_create(&amp;threads[2],
writer, &amp;thread_nums[2]);</p>


<p style="margin-left:13%; margin-top: 1em">uv_barrier_wait(&amp;blocker);
<br>
uv_barrier_destroy(&amp;blocker);</p>


<p style="margin-left:13%; margin-top: 1em">uv_rwlock_destroy(&amp;numlock);
<br>
return 0; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Run this and
observe how the readers will sometimes overlap. In case of
multiple writers, schedulers will usually give them higher
priority, so if you add two writers, you'll see that both
writers tend to finish first before the readers get a chance
again.</p>

<p style="margin-left:9%; margin-top: 1em">We also use
barriers in the above example so that the main thread can
wait for all readers and writers to indicate they have
ended.</p>

<h3>Others
<a name="Others"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv also
supports <i>semaphores</i>, <i>condition variables</i> and
<i>barriers</i> with APIs very similar to their pthread
counterparts.</p>

<p style="margin-left:9%; margin-top: 1em">In addition,
libuv provides a convenience function <b>uv_once()</b>.
Multiple threads can attempt to call <b>uv_once()</b> with a
given guard and a function pointer, <b>only the first one
will win, the function will be called once and only
once</b>:</p>

<p style="margin-left:13%; margin-top: 1em">/* Initialize
guard */ <br>
static uv_once_t once_only = UV_ONCE_INIT;</p>

<p style="margin-left:13%; margin-top: 1em">int i = 0;</p>

<p style="margin-left:13%; margin-top: 1em">void
increment() { <br>
i++; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void thread1()
{ <br>
/* ... work */ <br>
uv_once(once_only, increment); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void thread2()
{ <br>
/* ... work */ <br>
uv_once(once_only, increment); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
/* ... spawn threads */ <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">After all
threads are done, <b>i == 1</b>.</p>

<p style="margin-left:9%; margin-top: 1em">libuv v0.11.11
onwards also added a <b>uv_key_t</b> struct and <i>api</i>
for thread-local storage.</p>

<h3>libuv work queue
<a name="libuv work queue"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>uv_queue_work()</b>
is a convenience function that allows an application to run
a task in a separate thread, and have a callback that is
triggered when the task is done. A seemingly simple
function, what makes <b>uv_queue_work()</b> tempting is that
it allows potentially any third-party libraries to be used
with the event-loop paradigm. When you use event loops, it
is <i>imperative to make sure that no function which runs
periodically in the loop thread blocks when performing I/O
or is a serious CPU hog</i>, because this means that the
loop slows down and events are not being handled at full
capacity.</p>

<p style="margin-left:9%; margin-top: 1em">However, a lot
of existing code out there features blocking functions (for
example a routine which performs I/O under the hood) to be
used with threads if you want responsiveness (the classic
'one thread per client' server model), and getting them to
play with an event loop library generally involves rolling
your own system of running the task in a separate thread.
libuv just provides a convenient abstraction for this.</p>

<p style="margin-left:9%; margin-top: 1em">Here is a simple
example inspired by <i>node.js is cancer</i>. We are going
to calculate fibonacci numbers, sleeping a bit along the
way, but run it in a separate thread so that the blocking
and CPU bound task does not prevent the event loop from
performing other activities.</p>


<p style="margin-left:9%; margin-top: 1em">queue-work/main.c
- lazy fibonacci</p>

<p style="margin-left:13%; margin-top: 1em">void
fib(uv_work_t *req) { <br>
int n = *(int *) req-&gt;data; <br>
if (random() % 2) <br>
sleep(1); <br>
else <br>
sleep(3); <br>
long fib = fib_(n); <br>
fprintf(stderr, &quot;%dth fibonacci is %lu\n&quot;, n,
fib); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
after_fib(uv_work_t *req, int status) { <br>
fprintf(stderr, &quot;Done calculating %dth
fibonacci\n&quot;, *(int *) req-&gt;data); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The actual task
function is simple, nothing to show that it is going to be
run in a separate thread. The <b>uv_work_t</b> structure is
the clue. You can pass arbitrary data through it using the
<b>void* data</b> field and use it to communicate to and
from the thread. But be sure you are using proper locks if
you are changing things while both threads may be
running.</p>

<p style="margin-left:9%; margin-top: 1em">The trigger is
<b>uv_queue_work</b>:</p>


<p style="margin-left:9%; margin-top: 1em">queue-work/main.c</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
loop = uv_default_loop();</p>

<p style="margin-left:13%; margin-top: 1em">int
data[FIB_UNTIL]; <br>
uv_work_t req[FIB_UNTIL]; <br>
int i; <br>
for (i = 0; i &lt; FIB_UNTIL; i++) { <br>
data[i] = i; <br>
req[i].data = (void *) &amp;data[i]; <br>
uv_queue_work(loop, &amp;req[i], fib, after_fib); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">return
uv_run(loop, UV_RUN_DEFAULT); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The thread
function will be launched in a separate thread, passed the
<b>uv_work_t</b> structure and once the function returns,
the <i>after</i> function will be called on the thread the
event loop is running in. It will be passed the same
structure.</p>

<p style="margin-left:9%; margin-top: 1em">For writing
wrappers to blocking libraries, a common <i>pattern</i> is
to use a baton to exchange data.</p>

<p style="margin-left:9%; margin-top: 1em">Since libuv
version <i>0.9.4</i> an additional function,
<b>uv_cancel()</b>, is available. This allows you to cancel
tasks on the libuv work queue. Only tasks that <i>are yet to
be started</i> can be cancelled. If a task has <i>already
started executing, or it has finished executing</i>,
<b>uv_cancel() will fail</b>.</p>


<p style="margin-left:9%; margin-top: 1em"><b>uv_cancel()</b>
is useful to cleanup pending tasks if the user requests
termination. For example, a music player may queue up
multiple directories to be scanned for audio files. If the
user terminates the program, it should quit quickly and not
wait until all pending requests are run.</p>

<p style="margin-left:9%; margin-top: 1em">Let's modify the
fibonacci example to demonstrate <b>uv_cancel()</b>. We
first set up a signal handler for termination.</p>


<p style="margin-left:9%; margin-top: 1em">queue-cancel/main.c</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
loop = uv_default_loop();</p>

<p style="margin-left:13%; margin-top: 1em">int
data[FIB_UNTIL]; <br>
int i; <br>
for (i = 0; i &lt; FIB_UNTIL; i++) { <br>
data[i] = i; <br>
fib_reqs[i].data = (void *) &amp;data[i]; <br>
uv_queue_work(loop, &amp;fib_reqs[i], fib, after_fib); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">uv_signal_t
sig; <br>
uv_signal_init(loop, &amp;sig); <br>
uv_signal_start(&amp;sig, signal_handler, SIGINT);</p>

<p style="margin-left:13%; margin-top: 1em">return
uv_run(loop, UV_RUN_DEFAULT); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">When the user
triggers the signal by pressing <b>Ctrl+C</b> we send
<b>uv_cancel()</b> to all the workers. <b>uv_cancel()</b>
will return <b>0</b> for those that are already executing or
finished.</p>


<p style="margin-left:9%; margin-top: 1em">queue-cancel/main.c</p>

<p style="margin-left:13%; margin-top: 1em">void
signal_handler(uv_signal_t *req, int signum) <br>
{ <br>
printf(&quot;Signal received!\n&quot;); <br>
int i; <br>
for (i = 0; i &lt; FIB_UNTIL; i++) { <br>
uv_cancel((uv_req_t*) &amp;fib_reqs[i]); <br>
} <br>
uv_signal_stop(req); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">For tasks that
do get cancelled successfully, the <i>after</i> function is
called with <b>status</b> set to <b>UV_ECANCELED</b>.</p>


<p style="margin-left:9%; margin-top: 1em">queue-cancel/main.c</p>

<p style="margin-left:13%; margin-top: 1em">void
after_fib(uv_work_t *req, int status) { <br>
if (status == UV_ECANCELED) <br>
fprintf(stderr, &quot;Calculation of %d cancelled.\n&quot;,
*(int *) req-&gt;data); <br>
}</p>


<p style="margin-left:9%; margin-top: 1em"><b>uv_cancel()</b>
can also be used with <b>uv_fs_t</b> and
<b>uv_getaddrinfo_t</b> requests. For the filesystem family
of functions, <b>uv_fs_t.errorno</b> will be set to
<b>UV_ECANCELED</b>.</p>

<p style="margin-left:9%; margin-top: 1em"><b>TIP:</b></p>

<p style="margin-left:13%;">A well designed program would
have a way to terminate long running workers that have
already started executing. Such a worker could periodically
check for a variable that only the main process sets to
signal termination.</p>

<h3>Inter-thread communication
<a name="Inter-thread communication"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Sometimes you
want various threads to actually send each other messages
<i>while</i> they are running. For example you might be
running some long duration task in a separate thread
(perhaps using <b>uv_queue_work</b>) but want to notify
progress to the main thread. This is a simple example of
having a download manager informing the user of the status
of running downloads.</p>


<p style="margin-left:9%; margin-top: 1em">progress/main.c</p>

<p style="margin-left:13%; margin-top: 1em">uv_loop_t
*loop; <br>
uv_async_t async;</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
loop = uv_default_loop();</p>

<p style="margin-left:13%; margin-top: 1em">uv_work_t req;
<br>
int size = 10240; <br>
req.data = (void*) &amp;size;</p>


<p style="margin-left:13%; margin-top: 1em">uv_async_init(loop,
&amp;async, print_progress); <br>
uv_queue_work(loop, &amp;req, fake_download, after);</p>

<p style="margin-left:13%; margin-top: 1em">return
uv_run(loop, UV_RUN_DEFAULT); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The async thread
communication works <i>on loops</i> so although any thread
can be the message sender, only threads with libuv loops can
be receivers (or rather the loop is the receiver). libuv
will invoke the callback (<b>print_progress</b>) with the
async watcher whenever it receives a message.</p>


<p style="margin-left:9%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:13%;">It is important to realize that
since the message send is <i>async</i>, the callback may be
invoked immediately after <b>uv_async_send</b> is called in
another thread, or it may be invoked after some time. libuv
may also combine multiple calls to <b>uv_async_send</b> and
invoke your callback only once. The only guarantee that
libuv makes is -- The callback function is called <i>at
least once</i> after the call to <b>uv_async_send</b>. If
you have no pending calls to <b>uv_async_send</b>, the
callback won't be called. If you make two or more calls, and
libuv hasn't had a chance to run the callback yet, it
<i>may</i> invoke your callback <i>only once</i> for the
multiple invocations of <b>uv_async_send</b>. Your callback
will never be called twice for just one event.</p>


<p style="margin-left:9%; margin-top: 1em">progress/main.c</p>

<p style="margin-left:13%; margin-top: 1em">double
percentage;</p>

<p style="margin-left:13%; margin-top: 1em">void
fake_download(uv_work_t *req) { <br>
int size = *((int*) req-&gt;data); <br>
int downloaded = 0; <br>
while (downloaded &lt; size) { <br>
percentage = downloaded*100.0/size; <br>
async.data = (void*) &amp;percentage; <br>
uv_async_send(&amp;async);</p>

<p style="margin-left:13%; margin-top: 1em">sleep(1); <br>
downloaded += (200+random())%1000; // can only download max
1000bytes/sec, <br>
// but at least a 200; <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In the download
function, we modify the progress indicator and queue the
message for delivery with <b>uv_async_send</b>. Remember:
<b>uv_async_send</b> is also non-blocking and will return
immediately.</p>


<p style="margin-left:9%; margin-top: 1em">progress/main.c</p>

<p style="margin-left:13%; margin-top: 1em">void
print_progress(uv_async_t *handle) { <br>
double percentage = *((double*) handle-&gt;data); <br>
fprintf(stderr, &quot;Downloaded %.2f%%\n&quot;,
percentage); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The callback is
a standard libuv pattern, extracting the data from the
watcher.</p>

<p style="margin-left:9%; margin-top: 1em">Finally it is
important to remember to clean up the watcher.</p>


<p style="margin-left:9%; margin-top: 1em">progress/main.c</p>

<p style="margin-left:13%; margin-top: 1em">void
after(uv_work_t *req, int status) { <br>
fprintf(stderr, &quot;Download complete\n&quot;); <br>
uv_close((uv_handle_t*) &amp;async, NULL); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">After this
example, which showed the abuse of the <b>data</b> field, -
<i>bnoordhuis</i> pointed out that using the <b>data</b>
field is not thread safe, and <b>uv_async_send()</b> is
actually only meant to wake up the event loop. Use a mutex
or rwlock to ensure accesses are performed in the right
order.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">mutexes and rwlocks <b>DO
NOT</b> work inside a signal handler, whereas
<b>uv_async_send</b> does.</p>

<p style="margin-left:9%; margin-top: 1em">One use case
where <b>uv_async_send</b> is required is when
interoperating with libraries that require thread affinity
for their functionality. For example in node.js, a v8 engine
instance, contexts and its objects are bound to the thread
that the v8 instance was started in. Interacting with v8
data structures from another thread can lead to undefined
results. Now consider some node.js module which binds a
third party library. It may go something like this:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="1%"></td>
<td width="87%">


<p style="margin-top: 1em">In node, the third party library
is set up with a JavaScript callback to be invoked for more
information:</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">var lib =
require('lib'); <br>
lib.on_progress(function() { <br>
console.log(&quot;Progress&quot;); <br>
});</p>

<p style="margin-left:17%; margin-top: 1em">lib.do();</p>

<p style="margin-left:17%; margin-top: 1em">// do other
stuff</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="1%"></td>
<td width="87%">


<p style="margin-top: 1em"><b>lib.do</b> is supposed to be
non-blocking but the third party lib is blocking, so the
binding uses <b>uv_queue_work</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="87%">


<p>The actual work being done in a separate thread wants to
invoke the progress callback, but cannot directly call into
v8 to interact with JavaScript. So it uses
<b>uv_async_send</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="3%">


<p>4.</p></td>
<td width="1%"></td>
<td width="87%">


<p>The async callback, invoked in the main loop thread,
which is the v8 thread, then interacts with v8 to invoke the
JavaScript callback.</p></td></tr>
</table>

<p align="center" style="margin-top: 1em">----</p>

<h3>Processes
<a name="Processes"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv offers
considerable child process management, abstracting the
platform differences and allowing communication with the
child process using streams or named pipes.</p>

<p style="margin-left:9%; margin-top: 1em">A common idiom
in Unix is for every process to do one thing and do it well.
In such a case, a process often uses multiple child
processes to achieve tasks (similar to using pipes in
shells). A multi-process model with messages may also be
easier to reason about compared to one with threads and
shared memory.</p>

<p style="margin-left:9%; margin-top: 1em">A common refrain
against event-based programs is that they cannot take
advantage of multiple cores in modern computers. In a
multi-threaded program the kernel can perform scheduling and
assign different threads to different cores, improving
performance. But an event loop has only one thread. The
workaround can be to launch multiple processes instead, with
each process running an event loop, and each process getting
assigned to a separate CPU core.</p>

<h3>Spawning child processes
<a name="Spawning child processes"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The simplest
case is when you simply want to launch a process and know
when it exits. This is achieved using <b>uv_spawn</b>.</p>


<p style="margin-left:9%; margin-top: 1em">spawn/main.c</p>

<p style="margin-left:13%; margin-top: 1em">uv_loop_t
*loop; <br>
uv_process_t child_req; <br>
uv_process_options_t options; <br>
int main() { <br>
loop = uv_default_loop();</p>

<p style="margin-left:13%; margin-top: 1em">char* args[3];
<br>
args[0] = &quot;mkdir&quot;; <br>
args[1] = &quot;test-dir&quot;; <br>
args[2] = NULL;</p>


<p style="margin-left:13%; margin-top: 1em">options.exit_cb
= on_exit; <br>
options.file = &quot;mkdir&quot;; <br>
options.args = args;</p>

<p style="margin-left:13%; margin-top: 1em">int r; <br>
if ((r = uv_spawn(loop, &amp;child_req, &amp;options))) {
<br>
fprintf(stderr, &quot;%s\n&quot;, uv_strerror(r)); <br>
return 1; <br>
} else { <br>
fprintf(stderr, &quot;Launched process with ID %d\n&quot;,
child_req.pid); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">return
uv_run(loop, UV_RUN_DEFAULT); <br>
}</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;"><b>options</b> is implicitly
initialized with zeros since it is a global variable. If you
change <b>options</b> to a local variable, remember to
initialize it to null out all unused fields:</p>


<p style="margin-left:18%; margin-top: 1em">uv_process_options_t
options = {0};</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>uv_process_t</b> struct only acts as the handle, all
options are set via <b>uv_process_options_t</b>. To simply
launch a process, you need to set only the <b>file</b> and
<b>args</b> fields. <b>file</b> is the program to execute.
Since <b>uv_spawn</b> uses <i>execvp(3)</i> internally,
there is no need to supply the full path. Finally as per
underlying conventions, <b>the arguments array has to be one
larger than the number of arguments, with the last element
being NULL</b>.</p>

<p style="margin-left:9%; margin-top: 1em">After the call
to <b>uv_spawn</b>, <b>uv_process_t.pid</b> will contain the
process ID of the child process.</p>

<p style="margin-left:9%; margin-top: 1em">The exit
callback will be invoked with the <i>exit status</i> and the
type of <i>signal</i> which caused the exit.</p>

<p style="margin-left:9%; margin-top: 1em">Note that it is
important <b>not</b> to call <b>uv_close</b> before the exit
callback.</p>


<p style="margin-left:9%; margin-top: 1em">spawn/main.c</p>

<p style="margin-left:13%; margin-top: 1em">void
on_exit(uv_process_t *req, int64_t exit_status, int
term_signal) { <br>
fprintf(stderr, &quot;Process exited with status %&quot;
PRId64 &quot;, signal %d\n&quot;, exit_status, term_signal);
<br>
uv_close((uv_handle_t*) req, NULL);</p>

<p style="margin-left:9%; margin-top: 1em">It is
<b>required</b> to close the process watcher after the
process exits.</p>

<h3>Changing process parameters
<a name="Changing process parameters"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Before the child
process is launched you can control the execution
environment using fields in <b>uv_process_options_t</b>.</p>

<h3>Change execution directory
<a name="Change execution directory"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Set
<b>uv_process_options_t.cwd</b> to the corresponding
directory.</p>

<h3>Set environment variables
<a name="Set environment variables"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>uv_process_options_t.env</b>
is a null-terminated array of strings, each of the form
<b>VAR=VALUE</b> used to set up the environment variables
for the process. Set this to <b>NULL</b> to inherit the
environment from the parent (this) process.</p>

<h3>Option flags
<a name="Option flags"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Setting
<b>uv_process_options_t.flags</b> to a bitwise OR of the
following flags, modifies the child process behaviour:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em"><b>UV_PROCESS_SETUID</b> - sets
the child's execution user ID to
<b>uv_process_options_t.uid</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p><b>UV_PROCESS_SETGID</b> - sets the child's execution
group ID to <b>uv_process_options_t.gid</b>.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Changing the
UID/GID is only supported on Unix, <b>uv_spawn</b> will fail
on Windows with <b>UV_ENOTSUP</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">



<p style="margin-top: 1em"><b>UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS</b>
- No quoting or escaping of <b>uv_process_options_t.args</b>
is done on Windows. Ignored on Unix.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p><b>UV_PROCESS_DETACHED</b> - Starts the child process in
a new session, which will keep running after the parent
process exits. See example below.</p></td></tr>
</table>

<h3>Detaching processes
<a name="Detaching processes"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Passing the flag
<b>UV_PROCESS_DETACHED</b> can be used to launch daemons, or
child processes which are independent of the parent so that
the parent exiting does not affect it.</p>


<p style="margin-left:9%; margin-top: 1em">detach/main.c</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
loop = uv_default_loop();</p>

<p style="margin-left:13%; margin-top: 1em">char* args[3];
<br>
args[0] = &quot;sleep&quot;; <br>
args[1] = &quot;100&quot;; <br>
args[2] = NULL;</p>


<p style="margin-left:13%; margin-top: 1em">options.exit_cb
= NULL; <br>
options.file = &quot;sleep&quot;; <br>
options.args = args; <br>
options.flags = UV_PROCESS_DETACHED;</p>

<p style="margin-left:13%; margin-top: 1em">int r; <br>
if ((r = uv_spawn(loop, &amp;child_req, &amp;options))) {
<br>
fprintf(stderr, &quot;%s\n&quot;, uv_strerror(r)); <br>
return 1; <br>
} <br>
fprintf(stderr, &quot;Launched sleep with PID %d\n&quot;,
child_req.pid); <br>
uv_unref((uv_handle_t*) &amp;child_req);</p>

<p style="margin-left:13%; margin-top: 1em">return
uv_run(loop, UV_RUN_DEFAULT);</p>

<p style="margin-left:9%; margin-top: 1em">Just remember
that the handle is still monitoring the child, so your
program won't exit. Use <b>uv_unref()</b> if you want to be
more <i>fire-and-forget</i>.</p>

<h3>Sending signals to processes
<a name="Sending signals to processes"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv wraps the
standard <b>kill(2)</b> system call on Unix and implements
one with similar semantics on Windows, with <i>one
caveat</i>: all of <b>SIGTERM</b>, <b>SIGINT</b> and
<b>SIGKILL</b>, lead to termination of the process. The
signature of <b>uv_kill</b> is:</p>

<p style="margin-left:13%; margin-top: 1em">uv_err_t
uv_kill(int pid, int signum);</p>

<p style="margin-left:9%; margin-top: 1em">For processes
started using libuv, you may use <b>uv_process_kill</b>
instead, which accepts the <b>uv_process_t</b> watcher as
the first argument, rather than the pid. In this case,
<b>remember to call uv_close</b> on the watcher _after_ the
exit callback has been called.</p>

<h3>Signals
<a name="Signals"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv provides
wrappers around Unix signals with <i>some Windows
support</i> as well.</p>

<p style="margin-left:9%; margin-top: 1em">Use
<b>uv_signal_init()</b> to initialize a handle and associate
it with a loop. To listen for particular signals on that
handler, use <b>uv_signal_start()</b> with the handler
function. Each handler can only be associated with one
signal number, with subsequent calls to
<b>uv_signal_start()</b> overwriting earlier associations.
Use <b>uv_signal_stop()</b> to stop watching. Here is a
small example demonstrating the various possibilities:</p>


<p style="margin-left:9%; margin-top: 1em">signal/main.c</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;unistd.h&gt; <br>
#include &lt;uv.h&gt;</p>

<p style="margin-left:13%; margin-top: 1em">uv_loop_t*
create_loop() <br>
{ <br>
uv_loop_t *loop = malloc(sizeof(uv_loop_t)); <br>
if (loop) { <br>
uv_loop_init(loop); <br>
} <br>
return loop; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
signal_handler(uv_signal_t *handle, int signum) <br>
{ <br>
printf(&quot;Signal received: %d\n&quot;, signum); <br>
uv_signal_stop(handle); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// two signal
handlers in one loop <br>
void thread1_worker(void *userp) <br>
{ <br>
uv_loop_t *loop1 = create_loop();</p>

<p style="margin-left:13%; margin-top: 1em">uv_signal_t
sig1a, sig1b; <br>
uv_signal_init(loop1, &amp;sig1a); <br>
uv_signal_start(&amp;sig1a, signal_handler, SIGUSR1);</p>


<p style="margin-left:13%; margin-top: 1em">uv_signal_init(loop1,
&amp;sig1b); <br>
uv_signal_start(&amp;sig1b, signal_handler, SIGUSR1);</p>

<p style="margin-left:13%; margin-top: 1em">uv_run(loop1,
UV_RUN_DEFAULT); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">// two signal
handlers, each in its own loop <br>
void thread2_worker(void *userp) <br>
{ <br>
uv_loop_t *loop2 = create_loop(); <br>
uv_loop_t *loop3 = create_loop();</p>

<p style="margin-left:13%; margin-top: 1em">uv_signal_t
sig2; <br>
uv_signal_init(loop2, &amp;sig2); <br>
uv_signal_start(&amp;sig2, signal_handler, SIGUSR1);</p>

<p style="margin-left:13%; margin-top: 1em">uv_signal_t
sig3; <br>
uv_signal_init(loop3, &amp;sig3); <br>
uv_signal_start(&amp;sig3, signal_handler, SIGUSR1);</p>

<p style="margin-left:13%; margin-top: 1em">while
(uv_run(loop2, UV_RUN_NOWAIT) || uv_run(loop3,
UV_RUN_NOWAIT)) { <br>
} <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int main() <br>
{ <br>
printf(&quot;PID %d\n&quot;, getpid());</p>

<p style="margin-left:13%; margin-top: 1em">uv_thread_t
thread1, thread2;</p>


<p style="margin-left:13%; margin-top: 1em">uv_thread_create(&amp;thread1,
thread1_worker, 0); <br>
uv_thread_create(&amp;thread2, thread2_worker, 0);</p>


<p style="margin-left:13%; margin-top: 1em">uv_thread_join(&amp;thread1);
<br>
uv_thread_join(&amp;thread2); <br>
return 0; <br>
}</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;"><b>uv_run(loop,
UV_RUN_NOWAIT)</b> is similar to <b>uv_run(loop,
UV_RUN_ONCE)</b> in that it will process only one event.
UV_RUN_ONCE blocks if there are no pending events, while
UV_RUN_NOWAIT will return immediately. We use NOWAIT so that
one of the loops isn't starved because the other one has no
pending activity.</p>

<p style="margin-left:9%; margin-top: 1em">Send
<b>SIGUSR1</b> to the process, and you'll find the handler
being invoked 4 times, one for each <b>uv_signal_t</b>. The
handler just stops each handle, so that the program exits.
This sort of dispatch to all handlers is very useful. A
server using multiple event loops could ensure that all data
was safely saved before termination, simply by every loop
adding a watcher for <b>SIGINT</b>.</p>

<h3>Child Process I/O
<a name="Child Process I/O"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">A normal, newly
spawned process has its own set of file descriptors, with 0,
1 and 2 being <b>stdin</b>, <b>stdout</b> and <b>stderr</b>
respectively. Sometimes you may want to share file
descriptors with the child. For example, perhaps your
applications launches a sub-command and you want any errors
to go in the log file, but ignore <b>stdout</b>. For this
you'd like to have <b>stderr</b> of the child be the same as
the stderr of the parent. In this case, libuv supports
<i>inheriting</i> file descriptors. In this sample, we
invoke the test program, which is:</p>


<p style="margin-left:9%; margin-top: 1em">proc-streams/test.c</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;stdio.h&gt;</p>

<p style="margin-left:13%; margin-top: 1em">int main() <br>
{ <br>
fprintf(stderr, &quot;This is stderr\n&quot;); <br>
printf(&quot;This is stdout\n&quot;); <br>
return 0; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The actual
program <b>proc-streams</b> runs this while sharing only
<b>stderr</b>. The file descriptors of the child process are
set using the <b>stdio</b> field in
<b>uv_process_options_t</b>. First set the
<b>stdio_count</b> field to the number of file descriptors
being set. <b>uv_process_options_t.stdio</b> is an array of
<b>uv_stdio_container_t</b>, which is:</p>

<p style="margin-left:13%; margin-top: 1em">typedef struct
uv_stdio_container_s { <br>
uv_stdio_flags flags;</p>

<p style="margin-left:13%; margin-top: 1em">union { <br>
uv_stream_t* stream; <br>
int fd; <br>
} data; <br>
} uv_stdio_container_t;</p>

<p style="margin-left:9%; margin-top: 1em">where flags can
have several values. Use <b>UV_IGNORE</b> if it isn't going
to be used. If the first three <b>stdio</b> fields are
marked as <b>UV_IGNORE</b> they'll redirect to
<b>/dev/null</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Since we want to
pass on an existing descriptor, we'll use
<b>UV_INHERIT_FD</b>. Then we set the <b>fd</b> to
<b>stderr</b>.</p>


<p style="margin-left:9%; margin-top: 1em">proc-streams/main.c</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
loop = uv_default_loop();</p>

<p style="margin-left:13%; margin-top: 1em">/* ... */</p>


<p style="margin-left:13%; margin-top: 1em">options.stdio_count
= 3; <br>
uv_stdio_container_t child_stdio[3]; <br>
child_stdio[0].flags = UV_IGNORE; <br>
child_stdio[1].flags = UV_IGNORE; <br>
child_stdio[2].flags = UV_INHERIT_FD; <br>
child_stdio[2].data.fd = 2; <br>
options.stdio = child_stdio;</p>


<p style="margin-left:13%; margin-top: 1em">options.exit_cb
= on_exit; <br>
options.file = args[0]; <br>
options.args = args;</p>

<p style="margin-left:13%; margin-top: 1em">int r; <br>
if ((r = uv_spawn(loop, &amp;child_req, &amp;options))) {
<br>
fprintf(stderr, &quot;%s\n&quot;, uv_strerror(r)); <br>
return 1; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">return
uv_run(loop, UV_RUN_DEFAULT); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">If you run
<b>proc-stream</b> you'll see that only the line &quot;This
is stderr&quot; will be displayed. Try marking <b>stdout</b>
as being inherited and see the output.</p>

<p style="margin-left:9%; margin-top: 1em">It is dead
simple to apply this redirection to streams. By setting
<b>flags</b> to <b>UV_INHERIT_STREAM</b> and setting
<b>data.stream</b> to the stream in the parent process, the
child process can treat that stream as standard I/O. This
can be used to implement something like <i>CGI</i>.</p>

<p style="margin-left:9%; margin-top: 1em">A sample CGI
script/executable is:</p>

<p style="margin-left:9%; margin-top: 1em">cgi/tick.c</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
#include &lt;unistd.h&gt;</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
int i; <br>
for (i = 0; i &lt; 10; i++) { <br>
printf(&quot;tick\n&quot;); <br>
fflush(stdout); <br>
sleep(1); <br>
} <br>
printf(&quot;BOOM!\n&quot;); <br>
return 0; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The CGI server
combines the concepts from this chapter and
<i>Networking</i> so that every client is sent ten ticks
after which that connection is closed.</p>

<p style="margin-left:9%; margin-top: 1em">cgi/main.c</p>

<p style="margin-left:13%; margin-top: 1em">void
on_new_connection(uv_stream_t *server, int status) { <br>
if (status == -1) { <br>
// error! <br>
return; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">uv_tcp_t
*client = (uv_tcp_t*) malloc(sizeof(uv_tcp_t)); <br>
uv_tcp_init(loop, client); <br>
if (uv_accept(server, (uv_stream_t*) client) == 0) { <br>
invoke_cgi_script(client); <br>
} <br>
else { <br>
uv_close((uv_handle_t*) client, NULL); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Here we simply
accept the TCP connection and pass on the socket
(<i>stream</i>) to <b>invoke_cgi_script</b>.</p>

<p style="margin-left:9%; margin-top: 1em">cgi/main.c</p>

<p style="margin-left:13%; margin-top: 1em">args[1] =
NULL;</p>

<p style="margin-left:13%; margin-top: 1em">/* ... finding
the executable path and setting up arguments ... */</p>


<p style="margin-left:13%; margin-top: 1em">options.stdio_count
= 3; <br>
uv_stdio_container_t child_stdio[3]; <br>
child_stdio[0].flags = UV_IGNORE; <br>
child_stdio[1].flags = UV_INHERIT_STREAM; <br>
child_stdio[1].data.stream = (uv_stream_t*) client; <br>
child_stdio[2].flags = UV_IGNORE; <br>
options.stdio = child_stdio;</p>


<p style="margin-left:13%; margin-top: 1em">options.exit_cb
= cleanup_handles; <br>
options.file = args[0]; <br>
options.args = args;</p>

<p style="margin-left:13%; margin-top: 1em">// Set this so
we can close the socket after the child process exits. <br>
child_req.data = (void*) client; <br>
int r; <br>
if ((r = uv_spawn(loop, &amp;child_req, &amp;options))) {
<br>
fprintf(stderr, &quot;%s\n&quot;, uv_strerror(r));</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>stdout</b> of the CGI script is set to the socket so that
whatever our tick script prints, gets sent to the client. By
using processes, we can offload the read/write buffering to
the operating system, so in terms of convenience this is
great. Just be warned that creating processes is a costly
task.</p>

<h3>Parent-child IPC
<a name="Parent-child IPC"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">A parent and
child can have one or two way communication over a pipe
created by settings <b>uv_stdio_container_t.flags</b> to a
bit-wise combination of <b>UV_CREATE_PIPE</b> and
<b>UV_READABLE_PIPE</b> or <b>UV_WRITABLE_PIPE</b>. The
read/write flag is from the perspective of the child
process. In this case, the <b>uv_stream_t* stream</b> field
must be set to point to an initialized, unopened
<b>uv_pipe_t</b> instance.</p>

<h3>New stdio Pipes
<a name="New stdio Pipes"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<b>uv_pipe_t</b> structure represents more than just
<i>pipe(7)</i> (or <b>|</b>), but supports any streaming
file-like objects. On Windows, the only object of that
description is the <i>Named Pipe</i>. On Unix, this could be
any of - <i>Unix Domain Socket</i>, or derived from
<i>mkfifo(1)</i>, or it could actually be a <i>pipe(7)</i>.
When <b>uv_spawn</b> initializes a <b>uv_pipe_t</b> due to
the <i>UV_CREATE_PIPE</i> flag, it opts for creating a
<i>socketpair(2)</i>.</p>

<p style="margin-left:9%; margin-top: 1em">This is intended
for the purpose of allowing multiple libuv processes to
communicate with IPC. This is discussed below.</p>

<h3>Arbitrary process IPC
<a name="Arbitrary process IPC"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Since domain
sockets [1] can have a well known name and a location in the
file-system they can be used for IPC between unrelated
processes. The <i>D-BUS</i> system used by open source
desktop environments uses domain sockets for event
notification. Various applications can then react when a
contact comes online or new hardware is detected. The MySQL
server also runs a domain socket on which clients can
interact with it.</p>

<p style="margin-left:9%; margin-top: 1em">When using
domain sockets, a client-server pattern is usually followed
with the creator/owner of the socket acting as the server.
After the initial setup, messaging is no different from TCP,
so we'll re-use the echo server example.</p>


<p style="margin-left:9%; margin-top: 1em">pipe-echo-server/main.c</p>

<p style="margin-left:13%; margin-top: 1em">void
remove_sock(int sig) { <br>
uv_fs_t req; <br>
uv_fs_unlink(loop, &amp;req, PIPENAME, NULL); <br>
exit(0); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
loop = uv_default_loop();</p>

<p style="margin-left:13%; margin-top: 1em">uv_pipe_t
server; <br>
uv_pipe_init(loop, &amp;server, 0);</p>

<p style="margin-left:13%; margin-top: 1em">signal(SIGINT,
remove_sock);</p>

<p style="margin-left:13%; margin-top: 1em">int r; <br>
if ((r = uv_pipe_bind(&amp;server, PIPENAME))) { <br>
fprintf(stderr, &quot;Bind error %s\n&quot;,
uv_err_name(r)); <br>
return 1; <br>
} <br>
if ((r = uv_listen((uv_stream_t*) &amp;server, 128,
on_new_connection))) { <br>
fprintf(stderr, &quot;Listen error %s\n&quot;,
uv_err_name(r)); <br>
return 2; <br>
} <br>
return uv_run(loop, UV_RUN_DEFAULT); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">We name the
socket <b>echo.sock</b> which means it will be created in
the local directory. This socket now behaves no different
from TCP sockets as far as the stream API is concerned. You
can test this server using - <i>socat</i>:</p>

<p style="margin-left:13%; margin-top: 1em">$ socat -
/path/to/socket</p>

<p style="margin-left:9%; margin-top: 1em">A client which
wants to connect to a domain socket will use:</p>

<p style="margin-left:13%; margin-top: 1em">void
uv_pipe_connect(uv_connect_t *req, uv_pipe_t *handle, const
char *name, uv_connect_cb cb);</p>

<p style="margin-left:9%; margin-top: 1em">where
<b>name</b> will be <b>echo.sock</b> or similar. On Unix
systems, <b>name</b> must point to a valid file (e.g.
<b>/tmp/echo.sock</b>). On Windows, <b>name</b> follows a
<b>\\?\pipe\echo.sock</b> format.</p>

<h3>Sending file descriptors over pipes
<a name="Sending file descriptors over pipes"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The cool thing
about domain sockets is that file descriptors can be
exchanged between processes by sending them over a domain
socket. This allows processes to hand off their I/O to other
processes. Applications include load-balancing servers,
worker processes and other ways to make optimum use of CPU.
libuv only supports sending <b>TCP sockets or other
pipes</b> over pipes for now.</p>

<p style="margin-left:9%; margin-top: 1em">To demonstrate,
we will look at an echo server implementation that hands off
clients to worker processes in a round-robin fashion. This
program is a bit involved, and while only snippets are
included in the book, it is recommended to read the full
code to really understand it.</p>

<p style="margin-left:9%; margin-top: 1em">The worker
process is quite simple, since the file-descriptor is handed
over to it by the master.</p>


<p style="margin-left:9%; margin-top: 1em">multi-echo-server/worker.c</p>

<p style="margin-left:13%; margin-top: 1em">uv_loop_t
*loop; <br>
uv_pipe_t queue; <br>
int main() { <br>
loop = uv_default_loop();</p>


<p style="margin-left:13%; margin-top: 1em">uv_pipe_init(loop,
&amp;queue, 1 /* ipc */); <br>
uv_pipe_open(&amp;queue, 0); <br>
uv_read_start((uv_stream_t*)&amp;queue, alloc_buffer,
on_new_connection); <br>
return uv_run(loop, UV_RUN_DEFAULT); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em"><b>queue</b> is
the pipe connected to the master process on the other end,
along which new file descriptors get sent. It is important
to set the <b>ipc</b> argument of <b>uv_pipe_init</b> to 1
to indicate this pipe will be used for inter-process
communication! Since the master will write the file handle
to the standard input of the worker, we connect the pipe to
<b>stdin</b> using <b>uv_pipe_open</b>.</p>


<p style="margin-left:9%; margin-top: 1em">multi-echo-server/worker.c</p>

<p style="margin-left:13%; margin-top: 1em">void
on_new_connection(uv_stream_t *q, ssize_t nread, const
uv_buf_t *buf) { <br>
if (nread &lt; 0) { <br>
if (nread != UV_EOF) <br>
fprintf(stderr, &quot;Read error %s\n&quot;,
uv_err_name(nread)); <br>
uv_close((uv_handle_t*) q, NULL); <br>
return; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">uv_pipe_t *pipe
= (uv_pipe_t*) q; <br>
if (!uv_pipe_pending_count(pipe)) { <br>
fprintf(stderr, &quot;No pending count\n&quot;); <br>
return; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">uv_handle_type
pending = uv_pipe_pending_type(pipe); <br>
assert(pending == UV_TCP);</p>

<p style="margin-left:13%; margin-top: 1em">uv_tcp_t
*client = (uv_tcp_t*) malloc(sizeof(uv_tcp_t)); <br>
uv_tcp_init(loop, client); <br>
if (uv_accept(q, (uv_stream_t*) client) == 0) { <br>
uv_os_fd_t fd; <br>
uv_fileno((const uv_handle_t*) client, &amp;fd); <br>
fprintf(stderr, &quot;Worker %d: Accepted fd %d\n&quot;,
getpid(), fd); <br>
uv_read_start((uv_stream_t*) client, alloc_buffer,
echo_read); <br>
} <br>
else { <br>
uv_close((uv_handle_t*) client, NULL); <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">First we call
<b>uv_pipe_pending_count()</b> to ensure that a handle is
available to read out. If your program could deal with
different types of handles, <b>uv_pipe_pending_type()</b>
can be used to determine the type. Although <b>accept</b>
seems odd in this code, it actually makes sense. What
<b>accept</b> traditionally does is get a file descriptor
(the client) from another file descriptor (The listening
socket). Which is exactly what we do here. Fetch the file
descriptor (<b>client</b>) from <b>queue</b>. From this
point the worker does standard echo server stuff.</p>

<p style="margin-left:9%; margin-top: 1em">Turning now to
the master, let's take a look at how the workers are
launched to allow load balancing.</p>


<p style="margin-left:9%; margin-top: 1em">multi-echo-server/main.c</p>

<p style="margin-left:13%; margin-top: 1em">struct
child_worker { <br>
uv_process_t req; <br>
uv_process_options_t options; <br>
uv_pipe_t pipe; <br>
} *workers;</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>child_worker</b> structure wraps the process, and the
pipe between the master and the individual process.</p>


<p style="margin-left:9%; margin-top: 1em">multi-echo-server/main.c</p>

<p style="margin-left:13%; margin-top: 1em">void
setup_workers() { <br>
round_robin_counter = 0;</p>

<p style="margin-left:13%; margin-top: 1em">// ...</p>

<p style="margin-left:13%; margin-top: 1em">// launch same
number of workers as number of CPUs <br>
uv_cpu_info_t *info; <br>
int cpu_count; <br>
uv_cpu_info(&amp;info, &amp;cpu_count); <br>
uv_free_cpu_info(info, cpu_count);</p>


<p style="margin-left:13%; margin-top: 1em">child_worker_count
= cpu_count;</p>

<p style="margin-left:13%; margin-top: 1em">workers =
calloc(cpu_count, sizeof(struct child_worker)); <br>
while (cpu_count--) { <br>
struct child_worker *worker = &amp;workers[cpu_count]; <br>
uv_pipe_init(loop, &amp;worker-&gt;pipe, 1);</p>


<p style="margin-left:13%; margin-top: 1em">uv_stdio_container_t
child_stdio[3]; <br>
child_stdio[0].flags = UV_CREATE_PIPE | UV_READABLE_PIPE;
<br>
child_stdio[0].data.stream = (uv_stream_t*)
&amp;worker-&gt;pipe; <br>
child_stdio[1].flags = UV_IGNORE; <br>
child_stdio[2].flags = UV_INHERIT_FD; <br>
child_stdio[2].data.fd = 2;</p>


<p style="margin-left:13%; margin-top: 1em">worker-&gt;options.stdio
= child_stdio; <br>
worker-&gt;options.stdio_count = 3;</p>


<p style="margin-left:13%; margin-top: 1em">worker-&gt;options.exit_cb
= close_process_handle; <br>
worker-&gt;options.file = args[0]; <br>
worker-&gt;options.args = args;</p>

<p style="margin-left:13%; margin-top: 1em">uv_spawn(loop,
&amp;worker-&gt;req, &amp;worker-&gt;options); <br>
fprintf(stderr, &quot;Started worker %d\n&quot;,
worker-&gt;req.pid); <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In setting up
the workers, we use the nifty libuv function
<b>uv_cpu_info</b> to get the number of CPUs so we can
launch an equal number of workers. Again it is important to
initialize the pipe acting as the IPC channel with the third
argument as 1. We then indicate that the child process'
<b>stdin</b> is to be a readable pipe (from the point of
view of the child). Everything is straightforward till here.
The workers are launched and waiting for file descriptors to
be written to their standard input.</p>

<p style="margin-left:9%; margin-top: 1em">It is in
<b>on_new_connection</b> (the TCP infrastructure is
initialized in <b>main()</b>), that we accept the client
socket and pass it along to the next worker in the
round-robin.</p>


<p style="margin-left:9%; margin-top: 1em">multi-echo-server/main.c</p>

<p style="margin-left:13%; margin-top: 1em">void
on_new_connection(uv_stream_t *server, int status) { <br>
if (status == -1) { <br>
// error! <br>
return; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">uv_tcp_t
*client = (uv_tcp_t*) malloc(sizeof(uv_tcp_t)); <br>
uv_tcp_init(loop, client); <br>
if (uv_accept(server, (uv_stream_t*) client) == 0) { <br>
uv_write_t *write_req = (uv_write_t*)
malloc(sizeof(uv_write_t)); <br>
dummy_buf = uv_buf_init(&quot;a&quot;, 1); <br>
struct child_worker *worker =
&amp;workers[round_robin_counter]; <br>
uv_write2(write_req, (uv_stream_t*) &amp;worker-&gt;pipe,
&amp;dummy_buf, 1, (uv_stream_t*) client, NULL); <br>
round_robin_counter = (round_robin_counter + 1) %
child_worker_count; <br>
} <br>
else { <br>
uv_close((uv_handle_t*) client, NULL); <br>
} <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>uv_write2</b> call handles all the abstraction and it is
simply a matter of passing in the handle (<b>client</b>) as
the right argument. With this our multi-process echo server
is operational.</p>

<p style="margin-left:9%; margin-top: 1em">Thanks to Kyle
for <i>pointing out</i> that <b>uv_write2()</b> requires a
non-empty buffer even when sending handles.</p>

<p align="center" style="margin-top: 1em">----</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p style="margin-top: 1em">[1]</p></td>
<td width="2%"></td>
<td width="85%">


<p style="margin-top: 1em">In this section domain sockets
stands in for named pipes on Windows as well.</p></td></tr>
</table>

<h3>Advanced event loops
<a name="Advanced event loops"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv provides
considerable user control over event loops, and you can
achieve interesting results by juggling multiple loops. You
can also embed libuv's event loop into another event loop
based library -- imagine a Qt based UI, and Qt's event loop
driving a libuv backend which does intensive system level
tasks.</p>

<h3>Stopping an event loop
<a name="Stopping an event loop"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>uv_stop()</b>
can be used to stop an event loop. The earliest the loop
will stop running is <i>on the next iteration</i>, possibly
later. This means that events that are ready to be processed
in this iteration of the loop will still be processed, so
<b>uv_stop()</b> can't be used as a kill switch. When
<b>uv_stop()</b> is called, the loop <b>won't</b> block for
i/o on this iteration. The semantics of these things can be
a bit difficult to understand, so let's look at
<b>uv_run()</b> where all the control flow occurs.</p>

<p style="margin-left:9%; margin-top: 1em">src/unix/core.c
- uv_run</p>

<p style="margin-left:13%; margin-top: 1em">uv_signal_t*
sh;</p>

<p style="margin-left:13%; margin-top: 1em">/* Note: while
the handle is in the UV_HANDLE_CLOSING state now, it's still
<br>
* possible for it to be active in the sense that
uv__is_active() returns <br>
* true. <br>
* <br>
* A good example is when the user calls uv_shutdown(),
immediately followed <br>
* by uv_close(). The handle is considered active at this
point because the <br>
* completion of the shutdown req is still pending. <br>
*/ <br>
assert(handle-&gt;flags &amp; UV_HANDLE_CLOSING); <br>
assert(!(handle-&gt;flags &amp; UV_HANDLE_CLOSED)); <br>
handle-&gt;flags |= UV_HANDLE_CLOSED;</p>

<p style="margin-left:13%; margin-top: 1em">switch
(handle-&gt;type) { <br>
case UV_PREPARE: <br>
case UV_CHECK: <br>
case UV_IDLE: <br>
case UV_ASYNC: <br>
case UV_TIMER: <br>
case UV_PROCESS:</p>


<p style="margin-left:9%; margin-top: 1em"><b>stop_flag</b>
is set by <b>uv_stop()</b>. Now all libuv callbacks are
invoked within the event loop, which is why invoking
<b>uv_stop()</b> in them will still lead to this iteration
of the loop occurring. First libuv updates timers, then runs
pending timer, idle and prepare callbacks, and invokes any
pending I/O callbacks. If you were to call <b>uv_stop()</b>
in any of them, <b>stop_flag</b> would be set. This causes
<b>uv_backend_timeout()</b> to return <b>0</b>, which is why
the loop does not block on I/O. If on the other hand, you
called <b>uv_stop()</b> in one of the check handlers, I/O
has already finished and is not affected.</p>


<p style="margin-left:9%; margin-top: 1em"><b>uv_stop()</b>
is useful to shutdown a loop when a result has been computed
or there is an error, without having to ensure that all
handlers are stopped one by one.</p>

<p style="margin-left:9%; margin-top: 1em">Here is a simple
example that stops the loop and demonstrates how the current
iteration of the loop still takes places.</p>


<p style="margin-left:9%; margin-top: 1em">uvstop/main.c</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
#include &lt;uv.h&gt;</p>

<p style="margin-left:13%; margin-top: 1em">int64_t counter
= 0;</p>

<p style="margin-left:13%; margin-top: 1em">void
idle_cb(uv_idle_t *handle) { <br>
printf(&quot;Idle callback\n&quot;); <br>
counter++;</p>

<p style="margin-left:13%; margin-top: 1em">if (counter
&gt;= 5) { <br>
uv_stop(uv_default_loop()); <br>
printf(&quot;uv_stop() called\n&quot;); <br>
} <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
prep_cb(uv_prepare_t *handle) { <br>
printf(&quot;Prep callback\n&quot;); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
uv_idle_t idler; <br>
uv_prepare_t prep;</p>


<p style="margin-left:13%; margin-top: 1em">uv_idle_init(uv_default_loop(),
&amp;idler); <br>
uv_idle_start(&amp;idler, idle_cb);</p>


<p style="margin-left:13%; margin-top: 1em">uv_prepare_init(uv_default_loop(),
&amp;prep); <br>
uv_prepare_start(&amp;prep, prep_cb);</p>


<p style="margin-left:13%; margin-top: 1em">uv_run(uv_default_loop(),
UV_RUN_DEFAULT);</p>

<p style="margin-left:13%; margin-top: 1em">return 0; <br>
}</p>

<h3>Utilities
<a name="Utilities"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This chapter
catalogues tools and techniques which are useful for common
tasks. The <i>libev man page</i> already covers some
patterns which can be adopted to libuv through simple API
changes. It also covers parts of the libuv API that don't
require entire chapters dedicated to them.</p>

<h3>Timers
<a name="Timers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Timers invoke
the callback after a certain time has elapsed since the
timer was started. libuv timers can also be set to invoke at
regular intervals instead of just once.</p>

<p style="margin-left:9%; margin-top: 1em">Simple use is to
init a watcher and start it with a <b>timeout</b>, and
optional <b>repeat</b>. Timers can be stopped at any
time.</p>

<p style="margin-left:13%; margin-top: 1em">uv_timer_t
timer_req;</p>


<p style="margin-left:13%; margin-top: 1em">uv_timer_init(loop,
&amp;timer_req); <br>
uv_timer_start(&amp;timer_req, callback, 5000, 2000);</p>

<p style="margin-left:9%; margin-top: 1em">will start a
repeating timer, which first starts 5 seconds (the
<b>timeout</b>) after the execution of
<b>uv_timer_start</b>, then repeats every 2 seconds (the
<b>repeat</b>). Use:</p>


<p style="margin-left:13%; margin-top: 1em">uv_timer_stop(&amp;timer_req);</p>

<p style="margin-left:9%; margin-top: 1em">to stop the
timer. This can be used safely from within the callback as
well.</p>

<p style="margin-left:9%; margin-top: 1em">The repeat
interval can be modified at any time with:</p>


<p style="margin-left:13%; margin-top: 1em">uv_timer_set_repeat(uv_timer_t
*timer, int64_t repeat);</p>

<p style="margin-left:9%; margin-top: 1em">which will take
effect <b>when possible</b>. If this function is called from
a timer callback, it means:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">If the timer was non-repeating,
the timer has already been stopped. Use
<b>uv_timer_start</b> again.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>If the timer is repeating, the next timeout has already
been scheduled, so the old repeat interval will be used once
more before the timer switches to the new interval.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">The utility
function:</p>

<p style="margin-left:13%; margin-top: 1em">int
uv_timer_again(uv_timer_t *)</p>

<p style="margin-left:9%; margin-top: 1em">applies <b>only
to repeating timers</b> and is equivalent to stopping the
timer and then starting it with both initial <b>timeout</b>
and <b>repeat</b> set to the old <b>repeat</b> value. If the
timer hasn't been started it fails (error code
<b>UV_EINVAL</b>) and returns -1.</p>

<p style="margin-left:9%; margin-top: 1em">An actual timer
example is in the <i>reference count section</i>.</p>

<h3>Event loop reference count
<a name="Event loop reference count"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The event loop
only runs as long as there are active handles. This system
works by having every handle increase the reference count of
the event loop when it is started and decreasing the
reference count when stopped. It is also possible to
manually change the reference count of handles using:</p>

<p style="margin-left:13%; margin-top: 1em">void
uv_ref(uv_handle_t*); <br>
void uv_unref(uv_handle_t*);</p>

<p style="margin-left:9%; margin-top: 1em">These functions
can be used to allow a loop to exit even when a watcher is
active or to use custom objects to keep the loop alive.</p>

<p style="margin-left:9%; margin-top: 1em">The latter can
be used with interval timers. You might have a garbage
collector which runs every X seconds, or your network
service might send a heartbeat to others periodically, but
you don't want to have to stop them along all clean exit
paths or error scenarios. Or you want the program to exit
when all your other watchers are done. In that case just
unref the timer immediately after creation so that if it is
the only watcher running then <b>uv_run</b> will still
exit.</p>

<p style="margin-left:9%; margin-top: 1em">This is also
used in node.js where some libuv methods are being bubbled
up to the JS API. A <b>uv_handle_t</b> (the superclass of
all watchers) is created per JS object and can be
ref/unrefed.</p>


<p style="margin-left:9%; margin-top: 1em">ref-timer/main.c</p>

<p style="margin-left:13%; margin-top: 1em">uv_loop_t
*loop; <br>
uv_timer_t gc_req; <br>
uv_timer_t fake_job_req;</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
loop = uv_default_loop();</p>


<p style="margin-left:13%; margin-top: 1em">uv_timer_init(loop,
&amp;gc_req); <br>
uv_unref((uv_handle_t*) &amp;gc_req);</p>


<p style="margin-left:13%; margin-top: 1em">uv_timer_start(&amp;gc_req,
gc, 0, 2000);</p>

<p style="margin-left:13%; margin-top: 1em">// could
actually be a TCP download or something <br>
uv_timer_init(loop, &amp;fake_job_req); <br>
uv_timer_start(&amp;fake_job_req, fake_job, 9000, 0); <br>
return uv_run(loop, UV_RUN_DEFAULT); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">We initialize
the garbage collector timer, then immediately <b>unref</b>
it. Observe how after 9 seconds, when the fake job is done,
the program automatically exits, even though the garbage
collector is still running.</p>

<h3>Idler pattern
<a name="Idler pattern"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The callbacks of
idle handles are invoked once per event loop. The idle
callback can be used to perform some very low priority
activity. For example, you could dispatch a summary of the
daily application performance to the developers for analysis
during periods of idleness, or use the application's CPU
time to perform SETI calculations :) An idle watcher is also
useful in a GUI application. Say you are using an event loop
for a file download. If the TCP socket is still being
established and no other events are present your event loop
will pause (<b>block</b>), which means your progress bar
will freeze and the user will face an unresponsive
application. In such a case queue up and idle watcher to
keep the UI operational.</p>


<p style="margin-left:9%; margin-top: 1em">idle-compute/main.c</p>

<p style="margin-left:13%; margin-top: 1em">uv_loop_t
*loop; <br>
uv_fs_t stdin_watcher; <br>
uv_idle_t idler; <br>
char buffer[1024];</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
loop = uv_default_loop();</p>


<p style="margin-left:13%; margin-top: 1em">uv_idle_init(loop,
&amp;idler);</p>

<p style="margin-left:13%; margin-top: 1em">uv_buf_t buf =
uv_buf_init(buffer, 1024); <br>
uv_fs_read(loop, &amp;stdin_watcher, 0, &amp;buf, 1, -1,
on_type); <br>
uv_idle_start(&amp;idler, crunch_away); <br>
return uv_run(loop, UV_RUN_DEFAULT); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Here we
initialize the idle watcher and queue it up along with the
actual events we are interested in. <b>crunch_away</b> will
now be called repeatedly until the user types something and
presses Return. Then it will be interrupted for a brief
amount as the loop deals with the input data, after which it
will keep calling the idle callback again.</p>


<p style="margin-left:9%; margin-top: 1em">idle-compute/main.c</p>

<p style="margin-left:13%; margin-top: 1em">void
crunch_away(uv_idle_t* handle) { <br>
// Compute extra-terrestrial life <br>
// fold proteins <br>
// computer another digit of PI <br>
// or similar <br>
fprintf(stderr, &quot;Computing PI...\n&quot;); <br>
// just to avoid overwhelming your terminal emulator <br>
uv_idle_stop(handle); <br>
}</p>

<h3>Passing data to worker thread
<a name="Passing data to worker thread"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">When using
<b>uv_queue_work</b> you'll usually need to pass complex
data through to the worker thread. The solution is to use a
<b>struct</b> and set <b>uv_work_t.data</b> to point to it.
A slight variation is to have the <b>uv_work_t</b> itself as
the first member of this struct (called a baton [1]). This
allows cleaning up the work request and all the data in one
free call.</p>

<p style="margin-left:13%; margin-top: 1em">struct
ftp_baton { <br>
uv_work_t req; <br>
char *host; <br>
int port; <br>
char *username; <br>
char *password; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">ftp_baton
*baton = (ftp_baton*) malloc(sizeof(ftp_baton)); <br>
baton-&gt;req.data = (void*) baton; <br>
baton-&gt;host = strdup(&quot;my.webhost.com&quot;); <br>
baton-&gt;port = 21; <br>
// ...</p>


<p style="margin-left:13%; margin-top: 1em">uv_queue_work(loop,
&amp;baton-&gt;req, ftp_session, ftp_cleanup);</p>

<p style="margin-left:9%; margin-top: 1em">Here we create
the baton and queue the task.</p>

<p style="margin-left:9%; margin-top: 1em">Now the task
function can extract the data it needs:</p>

<p style="margin-left:13%; margin-top: 1em">void
ftp_session(uv_work_t *req) { <br>
ftp_baton *baton = (ftp_baton*) req-&gt;data;</p>


<p style="margin-left:13%; margin-top: 1em">fprintf(stderr,
&quot;Connecting to %s\n&quot;, baton-&gt;host); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
ftp_cleanup(uv_work_t *req) { <br>
ftp_baton *baton = (ftp_baton*) req-&gt;data;</p>


<p style="margin-left:13%; margin-top: 1em">free(baton-&gt;host);
<br>
// ... <br>
free(baton); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">We then free the
baton which also frees the watcher.</p>

<h3>External I/O with polling
<a name="External I/O with polling"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Usually
third-party libraries will handle their own I/O, and keep
track of their sockets and other files internally. In this
case it isn't possible to use the standard stream I/O
operations, but the library can still be integrated into the
libuv event loop. All that is required is that the library
allow you to access the underlying file descriptors and
provide functions that process tasks in small increments as
decided by your application. Some libraries though will not
allow such access, providing only a standard blocking
function which will perform the entire I/O transaction and
only then return. It is unwise to use these in the event
loop thread, use the <i>Thread pool work scheduling</i>
instead. Of course, this will also mean losing granular
control on the library.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>uv_poll</b> section of libuv simply watches file
descriptors using the operating system notification
mechanism. In some sense, all the I/O operations that libuv
implements itself are also backed by <b>uv_poll</b> like
code. Whenever the OS notices a change of state in file
descriptors being polled, libuv will invoke the associated
callback.</p>

<p style="margin-left:9%; margin-top: 1em">Here we will
walk through a simple download manager that will use -
<i>libcurl</i> to download files. Rather than give all
control to libcurl, we'll instead be using the libuv event
loop, and use the non-blocking, async <i>multi</i> interface
to progress with the download whenever libuv notifies of I/O
readiness.</p>

<p style="margin-left:9%; margin-top: 1em">uvwget/main.c -
The setup</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;assert.h&gt; <br>
#include &lt;stdio.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;uv.h&gt; <br>
#include &lt;curl/curl.h&gt;</p>

<p style="margin-left:13%; margin-top: 1em">uv_loop_t
*loop; <br>
CURLM *curl_handle; <br>
uv_timer_t timeout; <br>
int main(int argc, char **argv) { <br>
loop = uv_default_loop();</p>

<p style="margin-left:13%; margin-top: 1em">if (argc &lt;=
1) <br>
return 0;</p>

<p style="margin-left:13%; margin-top: 1em">if
(curl_global_init(CURL_GLOBAL_ALL)) { <br>
fprintf(stderr, &quot;Could not init cURL\n&quot;); <br>
return 1; <br>
}</p>


<p style="margin-left:13%; margin-top: 1em">uv_timer_init(loop,
&amp;timeout);</p>

<p style="margin-left:13%; margin-top: 1em">curl_handle =
curl_multi_init(); <br>
curl_multi_setopt(curl_handle, CURLMOPT_SOCKETFUNCTION,
handle_socket); <br>
curl_multi_setopt(curl_handle, CURLMOPT_TIMERFUNCTION,
start_timeout);</p>

<p style="margin-left:13%; margin-top: 1em">while (argc--
&gt; 1) { <br>
add_download(argv[argc], argc); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">uv_run(loop,
UV_RUN_DEFAULT); <br>
curl_multi_cleanup(curl_handle); <br>
return 0; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The way each
library is integrated with libuv will vary. In the case of
libcurl, we can register two callbacks. The socket callback
<b>handle_socket</b> is invoked whenever the state of a
socket changes and we have to start polling it.
<b>start_timeout</b> is called by libcurl to notify us of
the next timeout interval, after which we should drive
libcurl forward regardless of I/O status. This is so that
libcurl can handle errors or do whatever else is required to
get the download moving.</p>

<p style="margin-left:9%; margin-top: 1em">Our downloader
is to be invoked as:</p>

<p style="margin-left:13%; margin-top: 1em">$ ./uvwget
[url1] [url2] ...</p>

<p style="margin-left:9%; margin-top: 1em">So we add each
argument as a URL</p>

<p style="margin-left:9%; margin-top: 1em">uvwget/main.c -
Adding urls</p>

<p style="margin-left:13%; margin-top: 1em">void
add_download(const char *url, int num) { <br>
char filename[50]; <br>
sprintf(filename, &quot;%d.download&quot;, num); <br>
FILE *file;</p>

<p style="margin-left:13%; margin-top: 1em">file =
fopen(filename, &quot;w&quot;); <br>
if (file == NULL) { <br>
fprintf(stderr, &quot;Error opening %s\n&quot;, filename);
<br>
return; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">CURL *handle =
curl_easy_init(); <br>
curl_easy_setopt(handle, CURLOPT_WRITEDATA, file); <br>
curl_easy_setopt(handle, CURLOPT_URL, url); <br>
curl_multi_add_handle(curl_handle, handle); <br>
fprintf(stderr, &quot;Added download %s -&gt; %s\n&quot;,
url, filename); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">We let libcurl
directly write the data to a file, but much more is possible
if you so desire.</p>


<p style="margin-left:9%; margin-top: 1em"><b>start_timeout</b>
will be called immediately the first time by libcurl, so
things are set in motion. This simply starts a libuv
<i>timer</i> which drives <b>curl_multi_socket_action</b>
with <b>CURL_SOCKET_TIMEOUT</b> whenever it times out.
<b>curl_multi_socket_action</b> is what drives libcurl, and
what we call whenever sockets change state. But before we go
into that, we need to poll on sockets whenever
<b>handle_socket</b> is called.</p>

<p style="margin-left:9%; margin-top: 1em">uvwget/main.c -
Setting up polling</p>

<p style="margin-left:13%; margin-top: 1em">void
start_timeout(CURLM *multi, long timeout_ms, void *userp) {
<br>
if (timeout_ms &lt;= 0) <br>
timeout_ms = 1; /* 0 means directly call socket_action, but
we'll do it in a bit */ <br>
uv_timer_start(&amp;timeout, on_timeout, timeout_ms, 0);
<br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int
handle_socket(CURL *easy, curl_socket_t s, int action, void
*userp, void *socketp) { <br>
curl_context_t *curl_context; <br>
if (action == CURL_POLL_IN || action == CURL_POLL_OUT) {
<br>
if (socketp) { <br>
curl_context = (curl_context_t*) socketp; <br>
} <br>
else { <br>
curl_context = create_curl_context(s); <br>
curl_multi_assign(curl_handle, s, (void *) curl_context);
<br>
} <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">switch (action)
{ <br>
case CURL_POLL_IN: <br>
uv_poll_start(&amp;curl_context-&gt;poll_handle,
UV_READABLE, curl_perform); <br>
break; <br>
case CURL_POLL_OUT: <br>
uv_poll_start(&amp;curl_context-&gt;poll_handle,
UV_WRITABLE, curl_perform); <br>
break; <br>
case CURL_POLL_REMOVE: <br>
if (socketp) { <br>

uv_poll_stop(&amp;((curl_context_t*)socketp)-&gt;poll_handle);
<br>
destroy_curl_context((curl_context_t*) socketp); <br>
curl_multi_assign(curl_handle, s, NULL); <br>
} <br>
break; <br>
default: <br>
abort(); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">return 0; <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">We are
interested in the socket fd <b>s</b>, and the <b>action</b>.
For every socket we create a <b>uv_poll_t</b> handle if it
doesn't exist, and associate it with the socket using
<b>curl_multi_assign</b>. This way <b>socketp</b> points to
it whenever the callback is invoked.</p>

<p style="margin-left:9%; margin-top: 1em">In the case that
the download is done or fails, libcurl requests removal of
the poll. So we stop and free the poll handle.</p>

<p style="margin-left:9%; margin-top: 1em">Depending on
what events libcurl wishes to watch for, we start polling
with <b>UV_READABLE</b> or <b>UV_WRITABLE</b>. Now libuv
will invoke the poll callback whenever the socket is ready
for reading or writing. Calling <b>uv_poll_start</b>
multiple times on the same handle is acceptable, it will
just update the events mask with the new value.
<b>curl_perform</b> is the crux of this program.</p>

<p style="margin-left:9%; margin-top: 1em">uvwget/main.c -
Driving libcurl.</p>

<p style="margin-left:13%; margin-top: 1em">void
curl_perform(uv_poll_t *req, int status, int events) { <br>
uv_timer_stop(&amp;timeout); <br>
int running_handles; <br>
int flags = 0; <br>
if (status &lt; 0) flags = CURL_CSELECT_ERR; <br>
if (!status &amp;&amp; events &amp; UV_READABLE) flags |=
CURL_CSELECT_IN; <br>
if (!status &amp;&amp; events &amp; UV_WRITABLE) flags |=
CURL_CSELECT_OUT;</p>

<p style="margin-left:13%; margin-top: 1em">curl_context_t
*context;</p>

<p style="margin-left:13%; margin-top: 1em">context =
(curl_context_t*)req;</p>


<p style="margin-left:13%; margin-top: 1em">curl_multi_socket_action(curl_handle,
context-&gt;sockfd, flags, &amp;running_handles); <br>
check_multi_info(); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The first thing
we do is to stop the timer, since there has been some
progress in the interval. Then depending on what event
triggered the callback, we set the correct flags. Then we
call <b>curl_multi_socket_action</b> with the socket that
progressed and the flags informing about what events
happened. At this point libcurl does all of its internal
tasks in small increments, and will attempt to return as
fast as possible, which is exactly what an evented program
wants in its main thread. libcurl keeps queueing messages
into its own queue about transfer progress. In our case we
are only interested in transfers that are completed. So we
extract these messages, and clean up handles whose transfers
are done.</p>

<p style="margin-left:9%; margin-top: 1em">uvwget/main.c -
Reading transfer status.</p>

<p style="margin-left:13%; margin-top: 1em">void
check_multi_info(void) { <br>
char *done_url; <br>
CURLMsg *message; <br>
int pending;</p>

<p style="margin-left:13%; margin-top: 1em">while ((message
= curl_multi_info_read(curl_handle, &amp;pending))) { <br>
switch (message-&gt;msg) { <br>
case CURLMSG_DONE: <br>
curl_easy_getinfo(message-&gt;easy_handle,
CURLINFO_EFFECTIVE_URL, <br>
&amp;done_url); <br>
printf(&quot;%s DONE\n&quot;, done_url);</p>


<p style="margin-left:13%; margin-top: 1em">curl_multi_remove_handle(curl_handle,
message-&gt;easy_handle); <br>
curl_easy_cleanup(message-&gt;easy_handle); <br>
break;</p>

<p style="margin-left:13%; margin-top: 1em">default: <br>
fprintf(stderr, &quot;CURLMSG default\n&quot;); <br>
abort(); <br>
} <br>
} <br>
}</p>

<h3>Check &amp; Prepare watchers
<a name="Check &amp; Prepare watchers"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">TODO</p>

<h3>Loading libraries
<a name="Loading libraries"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv provides a
cross platform API to dynamically load <i>shared
libraries</i>. This can be used to implement your own
plugin/extension/module system and is used by node.js to
implement <b>require()</b> support for bindings. The usage
is quite simple as long as your library exports the right
symbols. Be careful with sanity and security checks when
loading third party code, otherwise your program will behave
unpredictably. This example implements a very simple plugin
system which does nothing except print the name of the
plugin.</p>

<p style="margin-left:9%; margin-top: 1em">Let us first
look at the interface provided to plugin authors.</p>


<p style="margin-left:9%; margin-top: 1em">plugin/plugin.h</p>

<p style="margin-left:13%; margin-top: 1em">#ifndef
UVBOOK_PLUGIN_SYSTEM <br>
#define UVBOOK_PLUGIN_SYSTEM</p>

<p style="margin-left:13%; margin-top: 1em">// Plugin
authors should use this to register their plugins with mfp.
<br>
void mfp_register(const char *name);</p>

<p style="margin-left:13%; margin-top: 1em">#endif</p>

<p style="margin-left:9%; margin-top: 1em">You can
similarly add more functions that plugin authors can use to
do useful things in your application [2]. A sample plugin
using this API is:</p>


<p style="margin-left:9%; margin-top: 1em">plugin/hello.c</p>

<p style="margin-left:13%; margin-top: 1em">#include
&quot;plugin.h&quot;</p>

<p style="margin-left:13%; margin-top: 1em">void
initialize() { <br>
mfp_register(&quot;Hello World!&quot;); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">Our interface
defines that all plugins should have an <b>initialize</b>
function which will be called by the application. This
plugin is compiled as a shared library and can be loaded by
running our application:</p>

<p style="margin-left:13%; margin-top: 1em">$ ./plugin
libhello.dylib <br>
Loading libhello.dylib <br>
Registered plugin &quot;Hello World!&quot;</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">The shared library filename
will be different depending on platforms. On Linux it is
<b>libhello.so</b>.</p>

<p style="margin-left:9%; margin-top: 1em">This is done by
using <b>uv_dlopen</b> to first load the shared library
<b>libhello.dylib</b>. Then we get access to the
<b>initialize</b> function using <b>uv_dlsym</b> and invoke
it.</p>


<p style="margin-left:9%; margin-top: 1em">plugin/main.c</p>

<p style="margin-left:13%; margin-top: 1em">#include
&quot;plugin.h&quot;</p>

<p style="margin-left:13%; margin-top: 1em">typedef void
(*init_plugin_function)();</p>

<p style="margin-left:13%; margin-top: 1em">void
mfp_register(const char *name) { <br>
fprintf(stderr, &quot;Registered plugin
\&quot;%s\&quot;\n&quot;, name); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int main(int
argc, char **argv) { <br>
if (argc == 1) { <br>
fprintf(stderr, &quot;Usage: %s [plugin1] [plugin2]
...\n&quot;, argv[0]); <br>
return 0; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">uv_lib_t *lib =
(uv_lib_t*) malloc(sizeof(uv_lib_t)); <br>
while (--argc) { <br>
fprintf(stderr, &quot;Loading %s\n&quot;, argv[argc]); <br>
if (uv_dlopen(argv[argc], lib)) { <br>
fprintf(stderr, &quot;Error: %s\n&quot;, uv_dlerror(lib));
<br>
continue; <br>
}</p>


<p style="margin-left:13%; margin-top: 1em">init_plugin_function
init_plugin; <br>
if (uv_dlsym(lib, &quot;initialize&quot;, (void **)
&amp;init_plugin)) { <br>
fprintf(stderr, &quot;dlsym error: %s\n&quot;,
uv_dlerror(lib)); <br>
continue; <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">init_plugin();
<br>
}</p>

<p style="margin-left:13%; margin-top: 1em">return 0; <br>
}</p>


<p style="margin-left:9%; margin-top: 1em"><b>uv_dlopen</b>
expects a path to the shared library and sets the opaque
<b>uv_lib_t</b> pointer. It returns 0 on success, -1 on
error. Use <b>uv_dlerror</b> to get the error message.</p>

<p style="margin-left:9%; margin-top: 1em"><b>uv_dlsym</b>
stores a pointer to the symbol in the second argument in the
third argument. <b>init_plugin_function</b> is a function
pointer to the sort of function we are looking for in the
application's plugins.</p>

<h3>TTY
<a name="TTY"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Text terminals
have supported basic formatting for a long time, with a
<i>pretty standardised</i> command set. This formatting is
often used by programs to improve the readability of
terminal output. For example <b>grep --colour</b>. libuv
provides the <b>uv_tty_t</b> abstraction (a stream) and
related functions to implement the ANSI escape codes across
all platforms. By this I mean that libuv converts ANSI codes
to the Windows equivalent, and provides functions to get
terminal information.</p>

<p style="margin-left:9%; margin-top: 1em">The first thing
to do is to initialize a <b>uv_tty_t</b> with the file
descriptor it reads/writes from. This is achieved with:</p>

<p style="margin-left:13%; margin-top: 1em">int
uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int
unused)</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>unused</b> parameter is now auto-detected and ignored. It
previously needed to be set to use <b>uv_read_start()</b> on
the stream.</p>

<p style="margin-left:9%; margin-top: 1em">It is then best
to use <b>uv_tty_set_mode</b> to set the mode to
<i>normal</i> which enables most TTY formatting,
flow-control and other settings. <i>Other</i> modes are also
available.</p>

<p style="margin-left:9%; margin-top: 1em">Remember to call
<b>uv_tty_reset_mode</b> when your program exits to restore
the state of the terminal. Just good manners. Another set of
good manners is to be aware of redirection. If the user
redirects the output of your command to a file, control
sequences should not be written as they impede readability
and <b>grep</b>. To check if the file descriptor is indeed a
TTY, call <b>uv_guess_handle</b> with the file descriptor
and compare the return value with <b>UV_TTY</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Here is a simple
example which prints white text on a red background:</p>

<p style="margin-left:9%; margin-top: 1em">tty/main.c</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
#include &lt;string.h&gt; <br>
#include &lt;unistd.h&gt; <br>
#include &lt;uv.h&gt;</p>

<p style="margin-left:13%; margin-top: 1em">uv_loop_t
*loop; <br>
uv_tty_t tty;</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
uv_write_t req; <br>
uv_buf_t buf; <br>
uv_write_t req1; <br>
uv_buf_t buf1;</p>

<p style="margin-left:13%; margin-top: 1em">loop =
uv_default_loop(); <br>
uv_tty_init(loop, &amp;tty, STDOUT_FILENO, 0); <br>
uv_tty_set_mode(&amp;tty, UV_TTY_MODE_NORMAL);</p>

<p style="margin-left:13%; margin-top: 1em">if
(uv_guess_handle(1) == UV_TTY) { <br>
buf1.base = &quot;\033[41;37m&quot;; <br>
buf1.len = strlen(buf1.base); <br>
uv_write(&amp;req1, (uv_stream_t*) &amp;tty, &amp;buf1, 1,
NULL); <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">buf.base =
&quot;Hello TTY\n&quot;; <br>
buf.len = strlen(buf.base); <br>
uv_write(&amp;req, (uv_stream_t*) &amp;tty, &amp;buf, 1,
NULL);</p>


<p style="margin-left:13%; margin-top: 1em">uv_tty_reset_mode();
<br>
return uv_run(loop, UV_RUN_DEFAULT); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The final TTY
helper is <b>uv_tty_get_winsize()</b> which is used to get
the width and height of the terminal and returns <b>0</b> on
success. Here is a small program which does some animation
using the function and character position escape codes.</p>


<p style="margin-left:9%; margin-top: 1em">tty-gravity/main.c</p>

<p style="margin-left:13%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
#include &lt;string.h&gt; <br>
#include &lt;unistd.h&gt; <br>
#include &lt;uv.h&gt;</p>

<p style="margin-left:13%; margin-top: 1em">uv_loop_t
*loop; <br>
uv_tty_t tty; <br>
uv_timer_t tick; <br>
uv_write_t write_req; <br>
int width, height; <br>
int pos = 0; <br>
char *message = &quot; Hello TTY &quot;;</p>

<p style="margin-left:13%; margin-top: 1em">void
update(uv_timer_t *req) { <br>
char data[500];</p>

<p style="margin-left:13%; margin-top: 1em">uv_buf_t buf;
<br>
buf.base = data; <br>
buf.len = sprintf(data,
&quot;\033[2J\033[H\033[%dB\033[%luC\033[42;37m%s&quot;,
<br>
pos, <br>
(unsigned long) (width-strlen(message))/2, <br>
message); <br>
uv_write(&amp;write_req, (uv_stream_t*) &amp;tty, &amp;buf,
1, NULL);</p>

<p style="margin-left:13%; margin-top: 1em">pos++; <br>
if (pos &gt; height) { <br>
uv_tty_reset_mode(); <br>
uv_timer_stop(&amp;tick); <br>
} <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">int main() {
<br>
loop = uv_default_loop();</p>


<p style="margin-left:13%; margin-top: 1em">uv_tty_init(loop,
&amp;tty, STDOUT_FILENO, 0); <br>
uv_tty_set_mode(&amp;tty, 0);</p>

<p style="margin-left:13%; margin-top: 1em">if
(uv_tty_get_winsize(&amp;tty, &amp;width, &amp;height)) {
<br>
fprintf(stderr, &quot;Could not get TTY
information\n&quot;); <br>
uv_tty_reset_mode(); <br>
return 1; <br>
}</p>


<p style="margin-left:13%; margin-top: 1em">fprintf(stderr,
&quot;Width %d, height %d\n&quot;, width, height); <br>
uv_timer_init(loop, &amp;tick); <br>
uv_timer_start(&amp;tick, update, 200, 200); <br>
return uv_run(loop, UV_RUN_DEFAULT); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">The escape codes
are: <br>
As you can see this is very useful to produce nicely
formatted output, or even console based arcade games if that
tickles your fancy. For fancier control you can try
<i>ncurses</i>.</p>

<p style="margin-left:9%; margin-top: 1em">Changed in
version 1.23.1:: the <i>readable</i> parameter is now unused
and ignored. The appropriate value will now be auto-detected
from the kernel.</p>

<p align="center" style="margin-top: 1em">----</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p style="margin-top: 1em">[1]</p></td>
<td width="2%"></td>
<td width="85%">


<p style="margin-top: 1em">I was first introduced to the
term baton in this context, in Konstantin K&auml;fer's
excellent slides on writing node.js bindings --
<i>https://kkaefer.com/node-cpp-modules/#baton</i></p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p>[2]</p></td>
<td width="2%"></td>
<td width="85%">


<p>mfp is My Fancy Plugin</p></td></tr>
</table>

<h3>About
<a name="About"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><i>Nikhil
Marathe</i> started writing this book one afternoon (June
16, 2012) when he didn't feel like programming. He had
recently been stung by the lack of good documentation on
libuv while working on <i>node-taglib</i>. Although
reference documentation was present, there were no
comprehensive tutorials. This book is the output of that
need and tries to be accurate. That said, the book may have
mistakes. Pull requests are encouraged.</p>

<p style="margin-left:9%; margin-top: 1em">Nikhil is
indebted to Marc Lehmann's comprehensive <i>man page</i>
about libev which describes much of the semantics of the two
libraries.</p>

<p style="margin-left:9%; margin-top: 1em">This book was
made using <i>Sphinx</i> and <i>vim</i>.</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">In 2017 the libuv project
incorporated the Nikhil's work into the official
documentation and it's maintained there henceforth.</p>

<h3>Upgrading
<a name="Upgrading"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Migration guides
for different libuv versions, starting with 1.0.</p>

<h3>libuv 0.10 -&gt; 1.0.0 migration guide
<a name="libuv 0.10 -&gt; 1.0.0 migration guide"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Some APIs
changed quite a bit throughout the 1.0.0 development
process. Here is a migration guide for the most significant
changes that happened after 0.10 was released.</p>

<h3>Loop initialization and closing
<a name="Loop initialization and closing"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">In libuv 0.10
(and previous versions), loops were created with
<i>uv_loop_new</i>, which allocated memory for a new loop
and initialized it; and destroyed with
<i>uv_loop_delete</i>, which destroyed the loop and freed
the memory. Starting with 1.0, those are deprecated and the
user is responsible for allocating the memory and then
initializing the loop.</p>

<p style="margin-left:9%; margin-top: 1em">libuv 0.10</p>

<p style="margin-left:13%; margin-top: 1em">uv_loop_t* loop
= uv_loop_new(); <br>
... <br>
uv_loop_delete(loop);</p>

<p style="margin-left:9%; margin-top: 1em">libuv 1.0</p>

<p style="margin-left:13%; margin-top: 1em">uv_loop_t* loop
= malloc(sizeof *loop); <br>
uv_loop_init(loop); <br>
... <br>
uv_loop_close(loop); <br>
free(loop);</p>


<p style="margin-left:9%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:13%;">Error handling was omitted for
brevity. Check the documentation for <i>uv_loop_init()</i>
and <i>uv_loop_close()</i>.</p>

<h3>Error handling
<a name="Error handling"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Error handling
had a major overhaul in libuv 1.0. In general, functions and
status parameters would get 0 for success and -1 for failure
on libuv 0.10, and the user had to use <i>uv_last_error</i>
to fetch the error code, which was a positive number.</p>

<p style="margin-left:9%; margin-top: 1em">In 1.0,
functions and status parameters contain the actual error
code, which is 0 for success, or a negative number in case
of error.</p>

<p style="margin-left:9%; margin-top: 1em">libuv 0.10</p>

<p style="margin-left:13%; margin-top: 1em">... assume
'server' is a TCP server which is already listening <br>
r = uv_listen((uv_stream_t*) server, 511, NULL); <br>
if (r == -1) { <br>
uv_err_t err = uv_last_error(uv_default_loop()); <br>
/* err.code contains UV_EADDRINUSE */ <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">libuv 1.0</p>

<p style="margin-left:13%; margin-top: 1em">... assume
'server' is a TCP server which is already listening <br>
r = uv_listen((uv_stream_t*) server, 511, NULL); <br>
if (r &lt; 0) { <br>
/* r contains UV_EADDRINUSE */ <br>
}</p>

<h3>Threadpool changes
<a name="Threadpool changes"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">In libuv 0.10
Unix used a threadpool which defaulted to 4 threads, while
Windows used the <i>QueueUserWorkItem</i> API, which uses a
Windows internal threadpool, which defaults to 512 threads
per process.</p>

<p style="margin-left:9%; margin-top: 1em">In 1.0, we
unified both implementations, so Windows now uses the same
implementation Unix does. The threadpool size can be set by
exporting the <b>UV_THREADPOOL_SIZE</b> environment
variable. See <i>Thread pool work scheduling</i>.</p>

<h3>Allocation callback API change
<a name="Allocation callback API change"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">In libuv 0.10
the callback had to return a filled <i>uv_buf_t</i> by
value:</p>

<p style="margin-left:13%; margin-top: 1em">uv_buf_t
alloc_cb(uv_handle_t* handle, size_t size) { <br>
return uv_buf_init(malloc(size), size); <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In libuv 1.0 a
pointer to a buffer is passed to the callback, which the
user needs to fill:</p>

<p style="margin-left:13%; margin-top: 1em">void
alloc_cb(uv_handle_t* handle, size_t size, uv_buf_t* buf) {
<br>
buf-&gt;base = malloc(size); <br>
buf-&gt;len = size; <br>
}</p>

<h3>Unification of IPv4 / IPv6 APIs
<a name="Unification of IPv4 / IPv6 APIs"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">libuv 1.0
unified the IPv4 and IPv6 APIS. There is no longer a
<i>uv_tcp_bind</i> and <i>uv_tcp_bind6</i> duality, there is
only <i>uv_tcp_bind()</i> now.</p>

<p style="margin-left:9%; margin-top: 1em">IPv4 functions
took <b>struct sockaddr_in</b> structures by value, and IPv6
functions took <b>struct sockaddr_in6</b>. Now functions
take a <b>struct sockaddr*</b> (note it's a pointer). It can
be stack allocated.</p>

<p style="margin-left:9%; margin-top: 1em">libuv 0.10</p>

<p style="margin-left:13%; margin-top: 1em">struct
sockaddr_in addr = uv_ip4_addr(&quot;0.0.0.0&quot;, 1234);
<br>
... <br>
uv_tcp_bind(&amp;server, addr)</p>

<p style="margin-left:9%; margin-top: 1em">libuv 1.0</p>

<p style="margin-left:13%; margin-top: 1em">struct
sockaddr_in addr; <br>
uv_ip4_addr(&quot;0.0.0.0&quot;, 1234, &amp;addr) <br>
... <br>
uv_tcp_bind(&amp;server, (const struct sockaddr*) &amp;addr,
0);</p>

<p style="margin-left:9%; margin-top: 1em">The IPv4 and
IPv6 struct creating functions (<i>uv_ip4_addr()</i> and
<i>uv_ip6_addr()</i>) have also changed, make sure you check
the documentation. <b><br>
..note::</b></p>

<p style="margin-left:18%;">This change applies to all
functions that made a distinction between IPv4 and IPv6
addresses.</p>

<h3>Streams / UDP data receive callback API change
<a name="Streams / UDP data receive callback API change"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The streams and
UDP data receive callbacks now get a pointer to a
<i>uv_buf_t</i> buffer, not a structure by value.</p>

<p style="margin-left:9%; margin-top: 1em">libuv 0.10</p>

<p style="margin-left:13%; margin-top: 1em">void
on_read(uv_stream_t* handle, <br>
ssize_t nread, <br>
uv_buf_t buf) { <br>
... <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
recv_cb(uv_udp_t* handle, <br>
ssize_t nread, <br>
uv_buf_t buf, <br>
struct sockaddr* addr, <br>
unsigned flags) { <br>
... <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">libuv 1.0</p>

<p style="margin-left:13%; margin-top: 1em">void
on_read(uv_stream_t* handle, <br>
ssize_t nread, <br>
const uv_buf_t* buf) { <br>
... <br>
}</p>

<p style="margin-left:13%; margin-top: 1em">void
recv_cb(uv_udp_t* handle, <br>
ssize_t nread, <br>
const uv_buf_t* buf, <br>
const struct sockaddr* addr, <br>
unsigned flags) { <br>
... <br>
}</p>

<h3>Receiving handles over pipes API change
<a name="Receiving handles over pipes API change"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">In libuv 0.10
(and earlier versions) the <i>uv_read2_start</i> function
was used to start reading data on a pipe, which could also
result in the reception of handles over it. The callback for
such function looked like this:</p>

<p style="margin-left:13%; margin-top: 1em">void
on_read(uv_pipe_t* pipe, <br>
ssize_t nread, <br>
uv_buf_t buf, <br>
uv_handle_type pending) { <br>
... <br>
}</p>

<p style="margin-left:9%; margin-top: 1em">In libuv 1.0,
<i>uv_read2_start</i> was removed, and the user needs to
check if there are pending handles using
<i>uv_pipe_pending_count()</i> and
<i>uv_pipe_pending_type()</i> while in the read
callback:</p>

<p style="margin-left:13%; margin-top: 1em">void
on_read(uv_stream_t* handle, <br>
ssize_t nread, <br>
const uv_buf_t* buf) { <br>
... <br>
while (uv_pipe_pending_count((uv_pipe_t*) handle) != 0) {
<br>
pending = uv_pipe_pending_type((uv_pipe_t*) handle); <br>
... <br>
} <br>
... <br>
}</p>

<h3>Extracting the file descriptor out of a handle
<a name="Extracting the file descriptor out of a handle"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">While it wasn't
supported by the API, users often accessed the libuv
internals in order to get access to the file descriptor of a
TCP handle, for example.</p>

<p style="margin-left:13%; margin-top: 1em">fd =
handle-&gt;io_watcher.fd;</p>

<p style="margin-left:9%; margin-top: 1em">This is now
properly exposed through the <i>uv_fileno()</i>
function.</p>

<h3>uv_fs_readdir rename and API change
<a name="uv_fs_readdir rename and API change"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><i>uv_fs_readdir</i>
returned a list of strings in the <i>req-&gt;ptr</i> field
upon completion in libuv 0.10. In 1.0, this function got
renamed to <i>uv_fs_scandir()</i>, since it's actually
implemented using <b>scandir(3)</b>.</p>

<p style="margin-left:9%; margin-top: 1em">In addition,
instead of allocating a full list strings, the user is able
to get one result at a time by using the
<i>uv_fs_scandir_next()</i> function. This function does not
need to make a roundtrip to the threadpool, because libuv
will keep the list of <i>dents</i> returned by
<b>scandir(3)</b> around.</p>

<h2>DOWNLOADS
<a name="DOWNLOADS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">libuv can be
downloaded from <i>here</i>.</p>

<h2>INSTALLATION
<a name="INSTALLATION"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">Installation
instructions can be found in <i>the README</i>.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">libuv
contributors</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">2014-present,
libuv contributors</p>
<hr>
</body>
</html>
