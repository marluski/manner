<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Mon Apr  7 17:30:02 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>READTAGS</title>

</head>
<body>

<h1 align="center">READTAGS</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#ACTIONS">ACTIONS</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#Controlling the Tags Reading Behavior">Controlling the Tags Reading Behavior</a><br>
<a href="#Controlling the NAME Action Behavior">Controlling the NAME Action Behavior</a><br>
<a href="#Controlling the Output">Controlling the Output</a><br>
<a href="#Filtering, Sorting, and Formatting">Filtering, Sorting, and Formatting</a><br>
<a href="#Examples">Examples</a><br>
<a href="#EXPRESSION">EXPRESSION</a><br>
<a href="#Filtering">Filtering</a><br>
<a href="#Sorting">Sorting</a><br>
<a href="#Formatting">Formatting</a><br>
<a href="#Inspecting the Behavior of Expressions">Inspecting the Behavior of Expressions</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#CREDITS">CREDITS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">readtags - Find
tag file entries matching specified names</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em"><b>readtags</b>
-h | --help <b><br>
readtags</b> (-H | --help-expression)
(filter|sorter|formatter) <b><br>
readtags</b> -v | --version <b><br>
readtags</b> [OPTION]... ACTION</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">The
<b>readtags</b> program filters, sorts and prints tag
entries in a tags file. The basic filtering is done using
<b>actions</b>, by which you can list all regular tags,
pseudo tags or regular tags matching specific name. Then,
further filtering, sorting, and formatting can be done using
<b>post processors</b>, namely <b>filter expressions</b>,
<b>sorter expressions</b>, and <b>formatter
expressions</b>.</p>

<h2>ACTIONS
<a name="ACTIONS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em"><b>-l,
--list</b></p>

<p style="margin-left:18%;">List regular tags.</p>

<p style="margin-left:9%;"><b>[-] NAME</b></p>

<p style="margin-left:18%;">List regular tags matching
NAME. &quot;-&quot; as NAME indicates arguments after this
as NAME even if they start with -.</p>

<p style="margin-left:9%;"><b>-D,
--list-pseudo-tags</b></p>

<p style="margin-left:18%;">Equivalent to
<b>--list-pseudo-tags</b>.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<h3>Controlling the Tags Reading Behavior
<a name="Controlling the Tags Reading Behavior"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The behavior of
reading tags can be controlled using these options: <b><br>
-t TAGFILE, --tag-file TAGFILE</b></p>

<p style="margin-left:18%;">Use specified tag file
(default: &quot;tags&quot;). Giving &quot;-&quot; as TAGFILE
indicates reading the tags file content from the standard
input. &quot;-&quot; can make the command line simpler.
However, it doesn't mean efficient; readtags stores the data
to a temorary file and reads that file for taking the
ACTION.</p>

<p style="margin-left:9%;"><b>-s[0|1|2],
--override-sort-detection METHOD</b></p>

<p style="margin-left:18%;">Override sort detection of tag
file. METHOD: unsorted|sorted|foldcase</p>

<p style="margin-left:9%; margin-top: 1em">The NAME action
will perform binary search on sorted (including
&quot;foldcase&quot;) tags files, which is much faster then
on unsorted tags files.</p>

<h3>Controlling the NAME Action Behavior
<a name="Controlling the NAME Action Behavior"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The behavior of
the NAME action can be controlled using these options:
<b><br>
-i, --icase-match</b></p>

<p style="margin-left:18%;">Perform case-insensitive
matching in the NAME action.</p>

<p style="margin-left:9%;"><b>-p, --prefix-match</b></p>

<p style="margin-left:18%;">Perform prefix matching in the
NAME action.</p>

<h3>Controlling the Output
<a name="Controlling the Output"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">By default, the
output of readtags contains only the name, input and pattern
field. The Output can be tweaked using these options:
<b><br>
-A, --absolute-input</b></p>

<p style="margin-left:18%;">Do the same as <b>-C</b> option
but use only absolute path form.</p>

<p style="margin-left:9%;"><b>-C,
--canonicalize-input</b></p>

<p style="margin-left:18%;">Resolve '..' and '.' in input
fields of regular tags. This produces a unique
representation of the input path. This option works only
with tags files having <b>!_TAG_PROC_CWD</b> pseudo tag.</p>

<p style="margin-left:18%; margin-top: 1em">NOTE: The
current implementation accepts only <b>!_TAG_PROC_CWD</b>
starting with <b>/</b>; a Windows directory name starting
with a drive letter like <b>C:\Somewhere</b> is not
acceptable.</p>

<p style="margin-left:9%;"><b>-d, --debug</b></p>

<p style="margin-left:18%;">Turn on debugging output.</p>

<p style="margin-left:9%;"><b>-E, --escape-output</b></p>

<p style="margin-left:18%;">Escape characters like tabs in
output as described in tags(5).</p>

<p style="margin-left:9%;"><b>-e,
--extension-fields</b></p>

<p style="margin-left:18%;">Include extension fields in
output.</p>

<p style="margin-left:9%;"><b>-n, --line-number</b></p>

<p style="margin-left:18%;">Also include the line number
field when <b>-e</b> option is give.</p>

<p style="margin-left:9%;"><b>-P,
--with-pseudo-tags</b></p>

<p style="margin-left:18%;">List pseudo tags as if
<b>-D</b> option is specified but continues processing
without exiting.</p>

<p style="margin-left:9%; margin-top: 1em">About the
<b>-E</b> option: certain characters are escaped in a tags
file, to make it machine-readable. e.g., ensuring no tabs
character appear in fields other than the pattern field. By
default, readtags translates them to make it human-readable,
but when utilizing readtags output in a script or a client
tool, <b>-E</b> option should be used. See
ctags-client-tools(7) for more discussion on this.</p>

<p style="margin-left:9%; margin-top: 1em">About printing
input fields ({tagfile} in tags(5)) with <b>-E</b> option:
readtags always prints the input field literally (as it is
in the tags file), and when ctags writes the tags file, the
escaping rules are applied only when <b>TAG_OUTPUT_MODE</b>
pseudo tag has &quot;u-ctags&quot; and
<b>TAG_OUTPUT_FILESEP</b> has &quot;slash&quot; as values
for their input fields, as explained in
ctags-client-tools(7).</p>

<h3>Filtering, Sorting, and Formatting
<a name="Filtering, Sorting, and Formatting"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Further
filtering, sorting, and formatting on the tags listed by
actions are performed using: <b><br>
-Q EXP, --filter EXP</b></p>

<p style="margin-left:18%;">Filter the tags listed by
ACTION with EXP before printing.</p>

<p style="margin-left:9%;"><b>-S EXP, --sorter EXP</b></p>

<p style="margin-left:18%;">Sort the tags listed by ACTION
with EXP before printing.</p>

<p style="margin-left:9%;"><b>-F EXP, --formatter
EXP</b></p>

<p style="margin-left:18%;">Format the tags listed by
ACTION with EXP when printing.</p>

<p style="margin-left:9%; margin-top: 1em">These are
discussed in the <i>EXPRESSION</i> section.</p>

<h3>Examples
<a name="Examples"></a>
</h3>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="42%">


<p style="margin-top: 1em">List all tags in
&quot;/path/to/tags&quot;:</p> </td>
<td width="46%">
</td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">$ readtags -t /path/to/tags -l</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="65%">


<p style="margin-top: 1em">List all tags in
&quot;tags&quot; that start with &quot;mymethod&quot;:</p></td>
<td width="23%">
</td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">$ readtags -p - mymethod</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p style="margin-top: 1em">List all tags matching
&quot;mymethod&quot;, case insensitively:</p></td>
<td width="19%">
</td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">$ readtags -i - mymethod</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">List all tags start with
&quot;myvar&quot;, and printing all fields (i.e., the whole
line):</p> </td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">$ readtags -p -ne - myvar</pre>


<h2>EXPRESSION
<a name="EXPRESSION"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">Scheme-style
expressions are used for the <b>-Q</b>, <b>-S</b>, and
<b>-F</b> options. For those who doesn't know Scheme or
Lisp, just remember:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">A function call is wrapped in a
pair of parenthesis. The first item in it is the
function/operator name, the others are arguments.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Function calls can be nested.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p>Missing values and boolean false are represented by
<b>#f</b>. <b>#t</b> and all other values are considered to
be true.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">So, <b>(+ 1 (+ 2
3))</b> means add 2 and 3 first, then add the result with 1.
<b>(and &quot;string&quot; 1 #t)</b> means logical AND on
<b>&quot;string&quot;</b>, <b>1</b> and <b>#t</b>, and the
result is true since there is no <b>#f</b>.</p>

<h3>Filtering
<a name="Filtering"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The tag entries
that make the filter expression produces true value are
printed by readtags.</p>

<p style="margin-left:9%; margin-top: 1em">The basic
operators for filtering are <b>eq?</b>, <b>prefix?</b>,
<b>suffix?</b>, <b>substr?</b>, and <b>#/PATTERN/</b>.
Language common fields can be accessed using variables
starting with <b>$</b>, e.g., <b>$language</b> represents
the language field. For example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="70%">


<p style="margin-top: 1em">List all tags start with
&quot;myfunc&quot; in Python code files:</p></td>
<td width="18%">
</td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">$ readtags -p -Q '(eq? $language &quot;Python&quot;)' - myfunc</pre>


<p style="margin-left:9%; margin-top: 1em"><b>downcase</b>
or <b>upcase</b> operators can be used to perform
case-insensitive matching:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="64%">


<p style="margin-top: 1em">List all tags containing
&quot;my&quot;, case insensitively:</p></td>
<td width="24%">
</td></tr>
</table>

<pre style="margin-left:21%; margin-top: 1em">$ readtags -Q '(substr? (downcase $name) &quot;my&quot;)' -l</pre>


<p style="margin-left:9%; margin-top: 1em">We have logical
operators like <b>and</b>, <b>or</b> and <b>not</b>. The
value of a missing field is #f, so we could deal with
missing fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="88%">


<p style="margin-top: 1em">List all tags containing
&quot;impl&quot; in Python code files, but allow the
<b>language:</b> field to be missing:</p></td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">$ readtags -Q '(and (substr? $name &quot;impl&quot;)\
                    (or (not $language)\
                        (eq? $language &quot;Python&quot;)))' -l</pre>



<p style="margin-left:9%; margin-top: 1em"><b>#/PATTERN/</b>
is for the case when string predicates (<b>prefix?</b>,
<b>suffix?</b>, and <b>substr?</b>) are not enough. You can
use &quot;Posix extended regular expression&quot; as
PATTERN.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="53%">


<p style="margin-top: 1em">List all tags inherits from the
class &quot;A&quot;:</p></td>
<td width="35%">
</td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">$ readtags -Q '(#/(&#710;|,) ?A(,|$)/ $inherits)' -l</pre>


<p style="margin-left:9%; margin-top: 1em">Here
<b>$inherits</b> is a comma-separated class list like
&quot;A,B,C&quot;, &quot;P, A, Q&quot;, or just
&quot;A&quot;. Notice that this filter works on both
situations where there's a space after each comma or there's
not.</p>


<p style="margin-left:9%; margin-top: 1em">Case-insensitive
matching can be performed by <b>#/PATTERN/i</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="62%">


<p style="margin-top: 1em">List all tags inherits from the
class &quot;A&quot; or &quot;a&quot;:</p></td>
<td width="26%">
</td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">$ readtags -Q '(#/(&#710;|,) ?A(,|$)/i $inherits)' -l</pre>


<p style="margin-left:9%; margin-top: 1em">To include
&quot;/&quot; in a pattern, prefix <b>\</b> to the
&quot;/&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">NOTE: The above
regular expression pattern for inspecting inheritances is
just an example to show how to use <b>#/PATTERN/</b>
expression. Tags file generators have no consensus about the
format of <b>inherits:</b>, e.g., whether there should be a
space after a comma. Even parsers in ctags have no
consensus. Noticing the format of the <b>inherits:</b> field
of specific languages is needed for such queries.</p>

<p style="margin-left:9%; margin-top: 1em">The expressions
<b>#/PATTERN/</b> and <b>#/PATTERN/i</b> are for interactive
use. Readtags also offers an alias <b>string-&gt;regexp</b>,
so <b>#/PATTERN/</b> is equal to <b>(string-&gt;regexp
&quot;PATTERN&quot;)</b>, and <b>#/PATTERN/i</b> is equal to
<b>(string-&gt;regexp &quot;PATTERN&quot; :case-fold
#t)</b>. <b>string-&gt;regexp</b> doesn't need to prefix
<b>\</b> for including &quot;/&quot; in a pattern.
<b>string-&gt;regexp</b> may simplify a client tool building
an expression. See also ctags-client-tools(7) for building
expressions in your tool.</p>

<p style="margin-left:9%; margin-top: 1em">Let's now
consider missing fields. The tags file may have tag entries
that has no <b>inherits:</b> field. In that case
<b>$inherits</b> is #f, and the regular expression matching
raises an error, since string operators only work for
strings. To avoid this problem:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="62%">


<p style="margin-top: 1em">Safely list all tags inherits
from the class &quot;A&quot;:</p></td>
<td width="26%">
</td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">$ readtags -Q '(and $inherits (#/(&#710;|,) ?A(,|$)/ $inherits))' -l</pre>


<p style="margin-left:9%; margin-top: 1em">This makes sure
<b>$inherits</b> is not missing first, then match it by
regexp.</p>

<p style="margin-left:9%; margin-top: 1em">Sometimes you
want to keep tags where the field <i>is</i> missing. For
example, your want to exclude reference tags, which is
marked by the <b>extras:</b> field, then you want to keep
tags who doesn't have <b>extras:</b> field since they are
also not reference tags. Here's how to do it:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="47%">


<p style="margin-top: 1em">List all tags but the reference
tags:</p> </td>
<td width="41%">
</td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">$ readtags -Q '(or (not $extras) (#/(&#710;|,) ?reference(,|$)/ $extras))' -l</pre>


<p style="margin-left:9%; margin-top: 1em">Notice that
<b>(not $extras)</b> produces <b>#t</b> when <b>$extras</b>
is missing, so the whole <b>or</b> expression produces
<b>#t</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The combination
of <b>ctags -o -</b> and <b>readtags -t -</b> is handy for
inspecting a source file as far as the source file is enough
short.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="67%">


<p style="margin-top: 1em">List all the large (&gt; 100
lines) functions in a file:</p></td>
<td width="21%">
</td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">$ ctags -o - --fields=+neKz input.c \
  | ./readtags -t - -en \
               -Q '(and (eq? $kind &quot;function&quot;) $end $line (&gt; (- $end $line) 100))' \
               -l</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="59%">


<p style="margin-top: 1em">List all the tags including line
80 in a file:</p></td>
<td width="29%">
</td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">$ ctags -o - --fields=+neKz input.c \
  | readtags -t - -ne \
             -Q '(and $line
                      (or (eq? $line 80)
                          (and $end (&lt; $line 80) (&lt; 80 $end))))' \
    -l</pre>


<p style="margin-left:9%; margin-top: 1em">Run
&quot;readtags -H filter&quot; to know about all valid
functions and variables.</p>

<h3>Sorting
<a name="Sorting"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">When sorting,
the sorter expression is evaluated on two tag entries to
decide which should sort before the other one, until the
order of all tag entries is decided.</p>

<p style="margin-left:9%; margin-top: 1em">In a sorter
expression, <b>$</b> and <b>&amp;</b> are used to access the
fields in the two tag entries, and let's call them $-entry
and &amp;-entry. The sorter expression should have a value
of -1, 0 or 1. The value -1 means the $-entry should be put
above the &amp;-entry, 1 means the contrary, and 0 makes
their order in the output uncertain.</p>

<p style="margin-left:9%; margin-top: 1em">The core
operator of sorting is <b>&lt;&gt;</b>. It's used to compare
two strings or two numbers (numbers are for the <b>line:</b>
or <b>end:</b> fields). In <b>(&lt;&gt; a b)</b>, if
<b>a</b> &lt; <b>b</b>, the result is -1; <b>a</b> &gt;
<b>b</b> produces 1, and <b>a</b> = <b>b</b> produces 0.
Strings are compared using the <b>strcmp</b> function, see
strcmp(3).</p>

<p style="margin-left:9%; margin-top: 1em">For example,
sort by names, and make those shorter or alphabetically
smaller ones appear before the others:</p>

<pre style="margin-left:13%; margin-top: 1em">$ readtags -S '(&lt;&gt; $name &amp;name)' -l</pre>


<p style="margin-left:9%; margin-top: 1em">This reads
&quot;If the tag name in the $-entry is smaller, it goes
before the &amp;-entry&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>&lt;or&gt;</b> operator is used to chain multiple
expressions until one returns -1 or 1. For example, sort by
input file names, then line numbers if in the same file:</p>

<pre style="margin-left:13%; margin-top: 1em">$ readtags -S '(&lt;or&gt; (&lt;&gt; $input &amp;input) (&lt;&gt; $line &amp;line))' -l</pre>


<p style="margin-left:9%; margin-top: 1em">The <b>*-</b>
operator is used to flip the compare result. i.e., <b>(*-
(&lt;&gt; a b))</b> is the same as <b>(&lt;&gt; b
a)</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Filter
expressions can be used in sorter expressions. The technique
is use <b>if</b> to produce integers that can be compared
based on the filter, like:</p>

<pre style="margin-left:13%; margin-top: 1em">(&lt;&gt; (if filter-expr-on-$-entry -1 1)
    (if filter-expr-on-&amp;-entry -1 1))</pre>


<p style="margin-left:9%; margin-top: 1em">So if $-entry
satisfies the filter, while &amp;-entry doesn't, it's the
same as <b>(&lt;&gt; -1 1)</b>, which produces
<b>-1</b>.</p>

<p style="margin-left:9%; margin-top: 1em">For example, we
want to put tags with &quot;file&quot; kind below other
tags, then the sorter would look like:</p>

<pre style="margin-left:13%; margin-top: 1em">(&lt;&gt; (if (eq? $kind &quot;file&quot;) 1 -1)
    (if (eq? &amp;kind &quot;file&quot;) 1 -1))</pre>


<p style="margin-left:9%; margin-top: 1em">A quick read
tells us: If $-entry has &quot;file&quot; kind, and
&amp;-entry doesn't, the sorter becomes <b>(&lt;&gt; 1
-1)</b>, which produces <b>1</b>, so the $-entry is put
below the &amp;-entry, exactly what we want.</p>

<h3>Formatting
<a name="Formatting"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">A formatter
expression defines how readtags prints tag entries.</p>

<p style="margin-left:9%; margin-top: 1em">A formatter
expression may produce a string, a boolean, an integer, or a
list. Readtags prints the produced string, and integer as
is. Readtags prints nothing for <b>#f</b>, and a newline for
<b>#t</b>.</p>

<p style="margin-left:9%; margin-top: 1em">A list could
contain any number of strings, booleans, integers, and/or
lists. Readtags prints the elements of a list sequentially
and recursively.</p>

<p style="margin-left:9%; margin-top: 1em">All the
operators for filtering are also available in formatter
expressions. In addition to the operators, <b>list</b> is
available in formatter expressions. As the name shows,
<b>list</b> is for making a list. <b>list</b> makes a list
containing arguments passed to the operator. e.g., the
following expression makes a list contains <b>1</b>,
<b>#f</b>, and <b>&quot;hello&quot;</b>:</p>

<pre style="margin-left:13%; margin-top: 1em">(list 1 #f &quot;hello&quot;)</pre>


<p style="margin-left:9%; margin-top: 1em">NOTE: Unlike
real-Lisp, backquote constructs are not available.</p>

<p style="margin-left:9%; margin-top: 1em">To show some
examples, the following tags file (<b>output.tags</b>) is
assumed as input for readtags:</p>

<pre style="margin-left:13%; margin-top: 1em">M    input.c 4;&quot;     macro   file:
N    input.c 3;&quot;     macro   file:
bar  input.c 11;&quot;    f       typeref:typename:void   file:   signature:(char ** argv,int * r)
foo  input.c 6;&quot;     f       typeref:typename:int    file:   signature:(int v)
main input.c 16;&quot;    f       typeref:typename:int    signature:(int argc,char ** argv)</pre>


<p style="margin-left:9%; margin-top: 1em">An exapmle for
printing only function names:</p>

<pre style="margin-left:13%; margin-top: 1em">$ readtags -t output.tags -Q '(eq? $kind &quot;function&quot;)' -F '(list $name #t)' -l
bar
foo
main</pre>


<p style="margin-left:9%; margin-top: 1em">Doing the same
only with a formatter expression:</p>

<pre style="margin-left:13%; margin-top: 1em">$ readtags -t output.tags -F '(if (eq? $kind &quot;function&quot;) (list $name #t) #f)' -l
bar
foo
main</pre>


<p style="margin-left:9%; margin-top: 1em">Generating
declarations for the functions:</p>

<pre style="margin-left:13%; margin-top: 1em">$ readtags -t output.tags -F \
  '(if (eq? $kind &quot;function&quot;)
      (list (if $file &quot;static &quot; #f) $typeref-name &quot; &quot; $name $signature &quot;;&quot; #t)
     #f)' -l
static void bar(char ** argv,int * r);
static int foo(int v);
int main(int argc,char ** argv);</pre>


<h3>Inspecting the Behavior of Expressions
<a name="Inspecting the Behavior of Expressions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The <i>print</i>
operator can be used to print the value of an expression.
For example:</p>

<pre style="margin-left:13%; margin-top: 1em">$ readtags -Q '(print $name)' -l</pre>


<p style="margin-left:9%; margin-top: 1em">prints the name
of each tag entry before it. Since the return value of
<b>print</b> is not #f, all the tag entries are printed. We
could control this using the <b>begin</b> or <b>begin0</b>
operator. <b>begin</b> returns the value of its last
argument, and <b>begin0</b> returns the value of its first
argument. For example:</p>

<pre style="margin-left:13%; margin-top: 1em">$ readtags -Q '(begin0 #f (print (prefix? &quot;ctags&quot; &quot;ct&quot;)))' -l</pre>


<p style="margin-left:9%; margin-top: 1em">prints a bunch
of &quot;#t&quot; (depending on how many lines are in the
tags file), and the actual tag entries are not printed.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">See tags(5) for
the details of tags file format.</p>

<p style="margin-left:9%; margin-top: 1em">See
ctags-client-tools(7) for the tips writing a tool utilizing
tags file.</p>

<p style="margin-left:9%; margin-top: 1em">The official
Universal Ctags web site at:</p>


<p style="margin-left:9%; margin-top: 1em"><i>https://ctags.io/</i></p>

<p style="margin-left:9%; margin-top: 1em">The git
repository for the library used in readtags command:</p>


<p style="margin-left:9%; margin-top: 1em"><i>https://github.com/universal-ctags/libreadtags</i></p>

<h2>CREDITS
<a name="CREDITS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">Universal Ctags
project <i>https://ctags.io/</i></p>

<p style="margin-left:9%; margin-top: 1em">Darren Hiebert
&lt;<i>dhiebert@users.sourceforge.net</i>&gt;
<i>http://DarrenHiebert.com/</i></p>

<p style="margin-left:9%; margin-top: 1em">The readtags
command and libreadtags maintained at Universal Ctags are
derived from readtags.c and readtags.h developd at
<i>http://ctags.sourceforge.net</i>.</p>
<hr>
</body>
</html>
