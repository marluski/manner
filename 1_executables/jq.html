<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Mon Apr  7 17:27:27 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>JQ</title>

</head>
<body>

<h1 align="center">JQ</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#FILTERS">FILTERS</a><br>
<a href="#INVOKING JQ">INVOKING JQ</a><br>
<a href="#BASIC FILTERS">BASIC FILTERS</a><br>
<a href="#Identity: .">Identity: .</a><br>
<a href="#Object Identifier-Index: .foo, .foo.bar">Object Identifier-Index: .foo, .foo.bar</a><br>
<a href="#Optional Object Identifier-Index: .foo?">Optional Object Identifier-Index: .foo?</a><br>
<a href="#Object Index: .[&lt;string&gt;]">Object Index: .[&lt;string&gt;]</a><br>
<a href="#Array Index: .[&lt;number&gt;]">Array Index: .[&lt;number&gt;]</a><br>
<a href="#Array/String Slice: .[&lt;number&gt;:&lt;number&gt;]">Array/String Slice: .[&lt;number&gt;:&lt;number&gt;]</a><br>
<a href="#Array/Object Value Iterator: .[]">Array/Object Value Iterator: .[]</a><br>
<a href="#.[]?">.[]?</a><br>
<a href="#Comma: ,">Comma: ,</a><br>
<a href="#Pipe: |">Pipe: |</a><br>
<a href="#Parenthesis">Parenthesis</a><br>
<a href="#TYPES AND VALUES">TYPES AND VALUES</a><br>
<a href="#Array construction: []">Array construction: []</a><br>
<a href="#Object Construction: {}">Object Construction: {}</a><br>
<a href="#Recursive Descent: ..">Recursive Descent: ..</a><br>
<a href="#BUILTIN OPERATORS AND FUNCTIONS">BUILTIN OPERATORS AND FUNCTIONS</a><br>
<a href="#Addition: +">Addition: +</a><br>
<a href="#Subtraction: -">Subtraction: -</a><br>
<a href="#Multiplication, division, modulo: *, /, %">Multiplication, division, modulo: *, /, %</a><br>
<a href="#abs">abs</a><br>
<a href="#length">length</a><br>
<a href="#utf8bytelength">utf8bytelength</a><br>
<a href="#keys, keys_unsorted">keys, keys_unsorted</a><br>
<a href="#has(key)">has(key)</a><br>
<a href="#in">in</a><br>
<a href="#map(f), map_values(f)">map(f), map_values(f)</a><br>
<a href="#pick(pathexps)">pick(pathexps)</a><br>
<a href="#path(path_expression)">path(path_expression)</a><br>
<a href="#del(path_expression)">del(path_expression)</a><br>
<a href="#getpath(PATHS)">getpath(PATHS)</a><br>
<a href="#setpath(PATHS; VALUE)">setpath(PATHS; VALUE)</a><br>
<a href="#delpaths(PATHS)">delpaths(PATHS)</a><br>
<a href="#to_entries, from_entries, with_entries(f)">to_entries, from_entries, with_entries(f)</a><br>
<a href="#select(boolean_expression)">select(boolean_expression)</a><br>
<a href="#arrays, objects, iterables, booleans, numbers, normals, finites, strings,nulls, values, scalars">arrays, objects, iterables, booleans, numbers, normals, finites, strings,nulls, values, scalars</a><br>
<a href="#empty">empty</a><br>
<a href="#error, error(message)">error, error(message)</a><br>
<a href="#halt">halt</a><br>
<a href="#halt_error, halt_error(exit_code)">halt_error, halt_error(exit_code)</a><br>
<a href="#$__loc__">$__loc__</a><br>
<a href="#paths, paths(node_filter)">paths, paths(node_filter)</a><br>
<a href="#add">add</a><br>
<a href="#any, any(condition), any(generator; condition)">any, any(condition), any(generator; condition)</a><br>
<a href="#all, all(condition), all(generator; condition)">all, all(condition), all(generator; condition)</a><br>
<a href="#flatten, flatten(depth)">flatten, flatten(depth)</a><br>
<a href="#range(upto), range(from; upto), range(from; upto; by)">range(upto), range(from; upto), range(from; upto; by)</a><br>
<a href="#floor">floor</a><br>
<a href="#sqrt">sqrt</a><br>
<a href="#tonumber">tonumber</a><br>
<a href="#tostring">tostring</a><br>
<a href="#type">type</a><br>
<a href="#infinite, nan, isinfinite, isnan, isfinite, isnormal">infinite, nan, isinfinite, isnan, isfinite, isnormal</a><br>
<a href="#sort, sort_by(path_expression)">sort, sort_by(path_expression)</a><br>
<a href="#group_by(path_expression)">group_by(path_expression)</a><br>
<a href="#min, max, min_by(path_exp), max_by(path_exp)">min, max, min_by(path_exp), max_by(path_exp)</a><br>
<a href="#unique, unique_by(path_exp)">unique, unique_by(path_exp)</a><br>
<a href="#reverse">reverse</a><br>
<a href="#contains(element)">contains(element)</a><br>
<a href="#indices(s)">indices(s)</a><br>
<a href="#index(s), rindex(s)">index(s), rindex(s)</a><br>
<a href="#inside">inside</a><br>
<a href="#startswith(str)">startswith(str)</a><br>
<a href="#endswith(str)">endswith(str)</a><br>
<a href="#combinations, combinations(n)">combinations, combinations(n)</a><br>
<a href="#ltrimstr(str)">ltrimstr(str)</a><br>
<a href="#rtrimstr(str)">rtrimstr(str)</a><br>
<a href="#explode">explode</a><br>
<a href="#implode">implode</a><br>
<a href="#split(str)">split(str)</a><br>
<a href="#join(str)">join(str)</a><br>
<a href="#ascii_downcase, ascii_upcase">ascii_downcase, ascii_upcase</a><br>
<a href="#while(cond; update)">while(cond; update)</a><br>
<a href="#repeat(exp)">repeat(exp)</a><br>
<a href="#until(cond; next)">until(cond; next)</a><br>
<a href="#recurse(f), recurse, recurse(f; condition)">recurse(f), recurse, recurse(f; condition)</a><br>
<a href="#walk(f)">walk(f)</a><br>
<a href="#$JQ_BUILD_CONFIGURATION">$JQ_BUILD_CONFIGURATION</a><br>
<a href="#$ENV, env">$ENV, env</a><br>
<a href="#transpose">transpose</a><br>
<a href="#bsearch(x)">bsearch(x)</a><br>
<a href="#String interpolation: \(exp)">String interpolation: \(exp)</a><br>
<a href="#Convert to/from JSON">Convert to/from JSON</a><br>
<a href="#Format strings and escaping">Format strings and escaping</a><br>
<a href="#Dates">Dates</a><br>
<a href="#SQL-Style Operators">SQL-Style Operators</a><br>
<a href="#builtins">builtins</a><br>
<a href="#CONDITIONALS AND COMPARISONS">CONDITIONALS AND COMPARISONS</a><br>
<a href="#==, !=">==, !=</a><br>
<a href="#if-then-else-end">if-then-else-end</a><br>
<a href="#&gt;, &gt;=, &lt;=, &lt;">&gt;, &gt;=, &lt;=, &lt;</a><br>
<a href="#and, or, not">and, or, not</a><br>
<a href="#Alternative operator: //">Alternative operator: //</a><br>
<a href="#try-catch">try-catch</a><br>
<a href="#Breaking out of control structures">Breaking out of control structures</a><br>
<a href="#Error Suppression / Optional Operator: ?">Error Suppression / Optional Operator: ?</a><br>
<a href="#REGULAR EXPRESSIONS">REGULAR EXPRESSIONS</a><br>
<a href="#test(val), test(regex; flags)">test(val), test(regex; flags)</a><br>
<a href="#match(val), match(regex; flags)">match(val), match(regex; flags)</a><br>
<a href="#capture(val), capture(regex; flags)">capture(val), capture(regex; flags)</a><br>
<a href="#scan(regex), scan(regex; flags)">scan(regex), scan(regex; flags)</a><br>
<a href="#split(regex; flags)">split(regex; flags)</a><br>
<a href="#splits(regex), splits(regex; flags)">splits(regex), splits(regex; flags)</a><br>
<a href="#sub(regex; tostring), sub(regex; tostring; flags)">sub(regex; tostring), sub(regex; tostring; flags)</a><br>
<a href="#gsub(regex; tostring), gsub(regex; tostring; flags)">gsub(regex; tostring), gsub(regex; tostring; flags)</a><br>
<a href="#ADVANCED FEATURES">ADVANCED FEATURES</a><br>
<a href="#Variable / Symbolic Binding Operator: ... as $identifier | ...">Variable / Symbolic Binding Operator: ... as $identifier | ...</a><br>
<a href="#Destructuring Alternative Operator: ?//">Destructuring Alternative Operator: ?//</a><br>
<a href="#Defining Functions">Defining Functions</a><br>
<a href="#Scoping">Scoping</a><br>
<a href="#isempty(exp)">isempty(exp)</a><br>
<a href="#limit(n; exp)">limit(n; exp)</a><br>
<a href="#first(expr), last(expr), nth(n; expr)">first(expr), last(expr), nth(n; expr)</a><br>
<a href="#first, last, nth(n)">first, last, nth(n)</a><br>
<a href="#reduce">reduce</a><br>
<a href="#foreach">foreach</a><br>
<a href="#Recursion">Recursion</a><br>
<a href="#Generators and iterators">Generators and iterators</a><br>
<a href="#MATH">MATH</a><br>
<a href="#I/O">I/O</a><br>
<a href="#input">input</a><br>
<a href="#inputs">inputs</a><br>
<a href="#debug, debug(msgs)">debug, debug(msgs)</a><br>
<a href="#stderr">stderr</a><br>
<a href="#input_filename">input_filename</a><br>
<a href="#input_line_number">input_line_number</a><br>
<a href="#STREAMING">STREAMING</a><br>
<a href="#truncate_stream(stream_expression)">truncate_stream(stream_expression)</a><br>
<a href="#fromstream(stream_expression)">fromstream(stream_expression)</a><br>
<a href="#tostream">tostream</a><br>
<a href="#ASSIGNMENT">ASSIGNMENT</a><br>
<a href="#Update-assignment: |=">Update-assignment: |=</a><br>
<a href="#Arithmetic update-assignment: +=, -=, *=, /=, %=, //=">Arithmetic update-assignment: +=, -=, *=, /=, %=, //=</a><br>
<a href="#Plain assignment: =">Plain assignment: =</a><br>
<a href="#Complex assignments">Complex assignments</a><br>
<a href="#MODULES">MODULES</a><br>
<a href="#import RelativePathString as NAME [&lt;metadata&gt;];">import RelativePathString as NAME [&lt;metadata&gt;];</a><br>
<a href="#include RelativePathString [&lt;metadata&gt;];">include RelativePathString [&lt;metadata&gt;];</a><br>
<a href="#import RelativePathString as $NAME [&lt;metadata&gt;];">import RelativePathString as $NAME [&lt;metadata&gt;];</a><br>
<a href="#module &lt;metadata&gt;;">module &lt;metadata&gt;;</a><br>
<a href="#modulemeta">modulemeta</a><br>
<a href="#COLORS">COLORS</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em"><b>jq</b> -
Command-line JSON processor</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em"><b>jq</b>
[<i>options</i>...] <i>filter</i> [<i>files</i>...]</p>

<p style="margin-left:9%; margin-top: 1em"><b>jq</b> can
transform JSON in various ways, by selecting, iterating,
reducing and otherwise mangling JSON documents. For
instance, running the command <b>jq &acute;map(.price) |
add&acute;</b> will take an array of JSON objects as input
and return the sum of their &quot;price&quot; fields.</p>

<p style="margin-left:9%; margin-top: 1em"><b>jq</b> can
accept text input as well, but by default, <b>jq</b> reads a
stream of JSON entities (including numbers and other
literals) from <b>stdin</b>. Whitespace is only needed to
separate entities such as 1 and 2, and true and false. One
or more <i>files</i> may be specified, in which case
<b>jq</b> will read input from those instead.</p>

<p style="margin-left:9%; margin-top: 1em">The
<i>options</i> are described in the [INVOKING JQ] section;
they mostly concern input and output formatting. The
<i>filter</i> is written in the jq language and specifies
how to transform the input file or document.</p>

<h2>FILTERS
<a name="FILTERS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">A jq program is
a &quot;filter&quot;: it takes an input, and produces an
output. There are a lot of builtin filters for extracting a
particular field of an object, or converting a number to a
string, or various other standard tasks.</p>

<p style="margin-left:9%; margin-top: 1em">Filters can be
combined in various ways - you can pipe the output of one
filter into another filter, or collect the output of a
filter into an array.</p>

<p style="margin-left:9%; margin-top: 1em">Some filters
produce multiple results, for instance there&acute;s one
that produces all the elements of its input array. Piping
that filter into a second runs the second filter for each
element of the array. Generally, things that would be done
with loops and iteration in other languages are just done by
gluing filters together in jq.</p>

<p style="margin-left:9%; margin-top: 1em">It&acute;s
important to remember that every filter has an input and an
output. Even literals like &quot;hello&quot; or 42 are
filters - they take an input but always produce the same
literal as output. Operations that combine two filters, like
addition, generally feed the same input to both and combine
the results. So, you can implement an averaging filter as
<b>add / length</b> - feeding the input array both to the
<b>add</b> filter and the <b>length</b> filter and then
performing the division.</p>

<p style="margin-left:9%; margin-top: 1em">But that&acute;s
getting ahead of ourselves. :) Let&acute;s start with
something simpler:</p>

<h2>INVOKING JQ
<a name="INVOKING JQ"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">jq filters run
on a stream of JSON data. The input to jq is parsed as a
sequence of whitespace-separated JSON values which are
passed through the provided filter one at a time. The
output(s) of the filter are written to standard output, as a
sequence of newline-separated JSON data.</p>

<p style="margin-left:9%; margin-top: 1em">The simplest and
most common filter (or jq program) is <b>.</b>, which is the
identity operator, copying the inputs of the jq processor to
the output stream. Because the default behavior of the jq
processor is to read JSON texts from the input stream, and
to pretty-print outputs, the <b>.</b> program&acute;s main
use is to validate and pretty-print the inputs. The jq
programming language is quite rich and allows for much more
than just validation and pretty-printing.</p>

<p style="margin-left:9%; margin-top: 1em">Note: it is
important to mind the shell&acute;s quoting rules. As a
general rule it&acute;s best to always quote (with
single-quote characters on Unix shells) the jq program, as
too many characters with special meaning to jq are also
shell meta-characters. For example, <b>jq
&quot;foo&quot;</b> will fail on most Unix shells because
that will be the same as <b>jq foo</b>, which will generally
fail because <b>foo is not defined</b>. When using the
Windows command shell (cmd.exe) it&acute;s best to use
double quotes around your jq program when given on the
command-line (instead of the <b>-f program-file</b> option),
but then double-quotes in the jq program need backslash
escaping. When using the Powershell (<b>powershell.exe</b>)
or the Powershell Core (<b>pwsh</b>/<b>pwsh.exe</b>), use
single-quote characters around the jq program and
backslash-escaped double-quotes (<b>\&quot;</b>) inside the
jq program.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="49%">


<p>Unix shells: <b>jq
&acute;.[&quot;foo&quot;]&acute;</b></p> </td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="49%">


<p>Powershell: <b>jq
&acute;.[\&quot;foo\&quot;]&acute;</b></p> </td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="49%">


<p>Windows command shell: <b>jq
&quot;.[\&quot;foo\&quot;]&quot;</b></p> </td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Note: jq allows
user-defined functions, but every jq program must have a
top-level expression.</p>

<p style="margin-left:9%; margin-top: 1em">You can affect
how jq reads and writes its input and output using some
command-line options: <b><br>
--null-input</b> / <b>-n</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Don&acute;t
read any input at all. Instead, the filter is run once using
<b>null</b> as the input. This is useful when using jq as a
simple calculator or to construct JSON data from
scratch.</p>

<p style="margin-left:9%;"><b>--raw-input</b> /
<b>-R</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Don&acute;t
parse the input as JSON. Instead, each line of text is
passed to the filter as a string. If combined with
<b>--slurp</b>, then the entire input is passed to the
filter as a single long string.</p>

<p style="margin-left:9%;"><b>--slurp</b> / <b>-s</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Instead of
running the filter for each JSON object in the input, read
the entire input stream into a large array and run the
filter just once.</p>

<p style="margin-left:9%;"><b>--compact-output</b> /
<b>-c</b>:</p>

<p style="margin-left:18%; margin-top: 1em">By default, jq
pretty-prints JSON output. Using this option will result in
more compact output by instead putting each JSON object on a
single line.</p>

<p style="margin-left:9%;"><b>--raw-output</b> /
<b>-r</b>:</p>

<p style="margin-left:18%; margin-top: 1em">With this
option, if the filter&acute;s result is a string then it
will be written directly to standard output rather than
being formatted as a JSON string with quotes. This can be
useful for making jq filters talk to non-JSON-based
systems.</p>

<p style="margin-left:9%;"><b>--raw-output0</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Like <b>-r</b>
but jq will print NUL instead of newline after each output.
This can be useful when the values being output can contain
newlines. When the output value contains NUL, jq exits with
non-zero code.</p>

<p style="margin-left:9%;"><b>--join-output</b> /
<b>-j</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Like <b>-r</b>
but jq won&acute;t print a newline after each output.</p>

<p style="margin-left:9%;"><b>--ascii-output</b> /
<b>-a</b>:</p>

<p style="margin-left:18%; margin-top: 1em">jq usually
outputs non-ASCII Unicode codepoints as UTF-8, even if the
input specified them as escape sequences (like
&quot;\u03bc&quot;). Using this option, you can force jq to
produce pure ASCII output with every non-ASCII character
replaced with the equivalent escape sequence.</p>

<p style="margin-left:9%;"><b>--sort-keys</b> /
<b>-S</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Output the
fields of each object with the keys in sorted order.</p>

<p style="margin-left:9%;"><b>--color-output</b> /
<b>-C</b> and <b>--monochrome-output</b> / <b>-M</b>:</p>

<p style="margin-left:18%; margin-top: 1em">By default, jq
outputs colored JSON if writing to a terminal. You can force
it to produce color even if writing to a pipe or a file
using <b>-C</b>, and disable color with <b>-M</b>. When the
<b>NO_COLOR</b> environment variable is not empty, jq
disables colored output by default, but you can enable it by
<b>-C</b>.</p>

<p style="margin-left:18%; margin-top: 1em">Colors can be
configured with the <b>JQ_COLORS</b> environment variable
(see below).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p><b>--tab</b>:</p></td>
<td width="83%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Use a tab for
each indentation level instead of two spaces.</p>

<p style="margin-left:9%;"><b>--indent n</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Use the given
number of spaces (no more than 7) for indentation.</p>

<p style="margin-left:9%;"><b>--unbuffered</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Flush the
output after each JSON object is printed (useful if
you&acute;re piping a slow data source into jq and piping
jq&acute;s output elsewhere).</p>

<p style="margin-left:9%;"><b>--stream</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Parse the input
in streaming fashion, outputting arrays of path and leaf
values (scalars and empty arrays or empty objects). For
example, <b>&quot;a&quot;</b> becomes
<b>[[],&quot;a&quot;]</b>, and
<b>[[],&quot;a&quot;,[&quot;b&quot;]]</b> becomes
<b>[[0],[]]</b>, <b>[[1],&quot;a&quot;]</b>, and
<b>[[2,0],&quot;b&quot;]</b>.</p>

<p style="margin-left:18%; margin-top: 1em">This is useful
for processing very large inputs. Use this in conjunction
with filtering and the <b>reduce</b> and <b>foreach</b>
syntax to reduce large inputs incrementally.</p>

<p style="margin-left:9%;"><b>--stream-errors</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Like
<b>--stream</b>, but invalid JSON inputs yield array values
where the first element is the error and the second is a
path. For example, <b>[&quot;a&quot;,n]</b> produces
<b>[&quot;Invalid literal at line 1, column
7&quot;,[1]]</b>.</p>

<p style="margin-left:18%; margin-top: 1em">Implies
<b>--stream</b>. Invalid JSON inputs produce no error values
when <b>--stream</b> without <b>--stream-errors</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p><b>--seq</b>:</p></td>
<td width="83%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Use the
<b>application/json-seq</b> MIME type scheme for separating
JSON texts in jq&acute;s input and output. This means that
an ASCII RS (record separator) character is printed before
each value on output and an ASCII LF (line feed) is printed
after every output. Input JSON texts that fail to parse are
ignored (but warned about), discarding all subsequent input
until the next RS. This mode also parses the output of jq
without the <b>--seq</b> option.</p>

<p style="margin-left:9%;"><b>-f filename</b> /
<b>--from-file filename</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Read filter
from the file rather than from a command line, like
awk&acute;s -f option. You can also use &acute;#&acute; to
make comments.</p>

<p style="margin-left:9%;"><b>-L directory</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Prepend
<b>directory</b> to the search list for modules. If this
option is used then no builtin search list is used. See the
section on modules below.</p>

<p style="margin-left:9%;"><b>--arg name value</b>:</p>

<p style="margin-left:18%; margin-top: 1em">This option
passes a value to the jq program as a predefined variable.
If you run jq with <b>--arg foo bar</b>, then <b>$foo</b> is
available in the program and has the value
<b>&quot;bar&quot;</b>. Note that <b>value</b> will be
treated as a string, so <b>--arg foo 123</b> will bind
<b>$foo</b> to <b>&quot;123&quot;</b>.</p>

<p style="margin-left:18%; margin-top: 1em">Named arguments
are also available to the jq program as
<b>$ARGS.named</b>.</p>

<p style="margin-left:9%;"><b>--argjson name
JSON-text</b>:</p>

<p style="margin-left:18%; margin-top: 1em">This option
passes a JSON-encoded value to the jq program as a
predefined variable. If you run jq with <b>--argjson foo
123</b>, then <b>$foo</b> is available in the program and
has the value <b>123</b>.</p>

<p style="margin-left:9%;"><b>--slurpfile variable-name
filename</b>:</p>

<p style="margin-left:18%; margin-top: 1em">This option
reads all the JSON texts in the named file and binds an
array of the parsed JSON values to the given global
variable. If you run jq with <b>--slurpfile foo bar</b>,
then <b>$foo</b> is available in the program and has an
array whose elements correspond to the texts in the file
named <b>bar</b>.</p>

<p style="margin-left:9%;"><b>--rawfile variable-name
filename</b>:</p>

<p style="margin-left:18%; margin-top: 1em">This option
reads in the named file and binds its contents to the given
global variable. If you run jq with <b>--rawfile foo
bar</b>, then <b>$foo</b> is available in the program and
has a string whose contents are to the texts in the file
named <b>bar</b>.</p>

<p style="margin-left:9%;"><b>--args</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Remaining
arguments are positional string arguments. These are
available to the jq program as
<b>$ARGS.positional[]</b>.</p>

<p style="margin-left:9%;"><b>--jsonargs</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Remaining
arguments are positional JSON text arguments. These are
available to the jq program as
<b>$ARGS.positional[]</b>.</p>

<p style="margin-left:9%;"><b>--exit-status</b> /
<b>-e</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Sets the exit
status of jq to 0 if the last output value was neither
<b>false</b> nor <b>null</b>, 1 if the last output value was
either <b>false</b> or <b>null</b>, or 4 if no valid result
was ever produced. Normally jq exits with 2 if there was any
usage problem or system error, 3 if there was a jq program
compile error, or 0 if the jq program ran.</p>

<p style="margin-left:18%; margin-top: 1em">Another way to
set the exit status is with the <b>halt_error</b> builtin
function.</p>

<p style="margin-left:9%;"><b>--binary</b> / <b>-b</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Windows users
using WSL, MSYS2, or Cygwin, should use this option when
using a native jq.exe, otherwise jq will turn newlines (LFs)
into carriage-return-then-newline (CRLF).</p>

<p style="margin-left:9%;"><b>--version</b> /
<b>-V</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Output the jq
version and exit with zero.</p>


<p style="margin-left:9%;"><b>--build-configuration</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Output the
build configuration of jq and exit with zero. This output
has no supported format or structure and may change without
notice in future releases.</p>

<p style="margin-left:9%;"><b>--help</b> / <b>-h</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Output the jq
help and exit with zero.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">


<p><b>--</b>:</p></td>
<td width="87%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Terminates
argument processing. Remaining arguments are not interpreted
as options.</p>

<p style="margin-left:9%;"><b>--run-tests
[filename]</b>:</p>

<p style="margin-left:18%; margin-top: 1em">Runs the tests
in the given file or standard input. This must be the last
option given and does not honor all preceding options. The
input consists of comment lines, empty lines, and program
lines followed by one input line, as many lines of output as
are expected (one per output), and a terminating empty line.
Compilation failure tests start with a line containing only
<b>%%FAIL</b>, then a line containing the program to
compile, then a line containing an error message to compare
to the actual.</p>

<p style="margin-left:18%; margin-top: 1em">Be warned that
this option can change backwards-incompatibly.</p>

<h2>BASIC FILTERS
<a name="BASIC FILTERS"></a>
</h2>


<h3>Identity: .
<a name="Identity: ."></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The absolute
simplest filter is <b>.</b> . This filter takes its input
and produces the same value as output. That is, this is the
identity operator.</p>

<p style="margin-left:9%; margin-top: 1em">Since jq by
default pretty-prints all output, a trivial program
consisting of nothing but <b>.</b> can be used to format
JSON output from, say, <b>curl</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Although the
identity filter never modifies the value of its input, jq
processing can sometimes make it appear as though it does.
For example, using the current implementation of jq, we
would see that the expression:</p>

<p style="margin-top: 1em">1E1234567890 | .</p>

<p style="margin-left:9%; margin-top: 1em">produces
<b>1.7976931348623157e+308</b> on at least one platform.
This is because, in the process of parsing the number, this
particular version of jq has converted it to an IEEE754
double-precision representation, losing precision.</p>

<p style="margin-left:9%; margin-top: 1em">The way in which
jq handles numbers has changed over time and further changes
are likely within the parameters set by the relevant JSON
standards. The following remarks are therefore offered with
the understanding that they are intended to be descriptive
of the current version of jq and should not be interpreted
as being prescriptive:</p>

<p style="margin-left:9%; margin-top: 1em">(1) Any
arithmetic operation on a number that has not already been
converted to an IEEE754 double precision representation will
trigger a conversion to the IEEE754 representation.</p>

<p style="margin-left:9%; margin-top: 1em">(2) jq will
attempt to maintain the original decimal precision of number
literals, but in expressions such <b>1E1234567890</b>,
precision will be lost if the exponent is too large.</p>

<p style="margin-left:9%; margin-top: 1em">(3) In jq
programs, a leading minus sign will trigger the conversion
of the number to an IEEE754 representation.</p>

<p style="margin-left:9%; margin-top: 1em">(4) Comparisons
are carried out using the untruncated big decimal
representation of numbers if available, as illustrated in
one of the following examples.</p></table>

<p style="margin-top: 1em">jq &acute;.&acute; <br>
&quot;Hello, world!&quot; <br>
=&gt; &quot;Hello, world!&quot;</p>

<p style="margin-top: 1em">jq &acute;.&acute; <br>
0.12345678901234567890123456789 <br>
=&gt; 0.12345678901234567890123456789</p>

<p style="margin-top: 1em">jq &acute;[., tojson]&acute;
<br>
12345678909876543212345 <br>
=&gt;
[12345678909876543212345,&quot;12345678909876543212345&quot;]</p>

<p style="margin-top: 1em">jq &acute;. &lt;
0.12345678901234567890123456788&acute; <br>
0.12345678901234567890123456789 <br>
=&gt; false</p>

<p style="margin-top: 1em">jq &acute;map([., . == 1]) |
tojson&acute; <br>
[1, 1.000, 1.0, 100e-2] <br>
=&gt;
&quot;[[1,true],[1.000,true],[1.0,true],[1.00,true]]&quot;</p>

<p style="margin-top: 1em">jq &acute;. as $big | [$big,
$big + 1] | map(. &gt;
10000000000000000000000000000000)&acute; <br>
10000000000000000000000000000001 <br>
=&gt; [true, false]</p>

<h3>Object Identifier-Index: .foo, .foo.bar
<a name="Object Identifier-Index: .foo, .foo.bar"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The simplest
<i>useful</i> filter has the form <b>.foo</b>. When given a
JSON object (aka dictionary or hash) as input, <b>.foo</b>
produces the value at the key &quot;foo&quot; if the key is
present, or null otherwise.</p>

<p style="margin-left:9%; margin-top: 1em">A filter of the
form <b>.foo.bar</b> is equivalent to <b>.foo |
.bar</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The <b>.foo</b>
syntax only works for simple, identifier-like keys, that is,
keys that are all made of alphanumeric characters and
underscore, and which do not start with a digit.</p>

<p style="margin-left:9%; margin-top: 1em">If the key
contains special characters or starts with a digit, you need
to surround it with double quotes like this:
<b>.&quot;foo$&quot;</b>, or else
<b>.[&quot;foo$&quot;]</b>.</p>

<p style="margin-left:9%; margin-top: 1em">For example
<b>.[&quot;foo::bar&quot;]</b> and
<b>.[&quot;foo.bar&quot;]</b> work while <b>.foo::bar</b>
does not.</p></table>

<p style="margin-top: 1em">jq &acute;.foo&acute; <br>
{&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less
interesting data&quot;} <br>
=&gt; 42</p>

<p style="margin-top: 1em">jq &acute;.foo&acute; <br>
{&quot;notfoo&quot;: true, &quot;alsonotfoo&quot;: false}
<br>
=&gt; null</p>

<p style="margin-top: 1em">jq
&acute;.[&quot;foo&quot;]&acute; <br>
{&quot;foo&quot;: 42} <br>
=&gt; 42</p>

<h3>Optional Object Identifier-Index: .foo?
<a name="Optional Object Identifier-Index: .foo?"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Just like
<b>.foo</b>, but does not output an error when <b>.</b> is
not an object.</p></table>

<p style="margin-top: 1em">jq &acute;.foo?&acute; <br>
{&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less
interesting data&quot;} <br>
=&gt; 42</p>

<p style="margin-top: 1em">jq &acute;.foo?&acute; <br>
{&quot;notfoo&quot;: true, &quot;alsonotfoo&quot;: false}
<br>
=&gt; null</p>

<p style="margin-top: 1em">jq
&acute;.[&quot;foo&quot;]?&acute; <br>
{&quot;foo&quot;: 42} <br>
=&gt; 42</p>

<p style="margin-top: 1em">jq &acute;[.foo?]&acute; <br>
[1,2] <br>
=&gt; []</p>

<h3>Object Index: .[&lt;string&gt;]
<a name="Object Index: .[&lt;string&gt;]"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">You can also
look up fields of an object using syntax like
<b>.[&quot;foo&quot;]</b> (<b>.foo</b> above is a shorthand
version of this, but only for identifier-like strings).</p>

<h3>Array Index: .[&lt;number&gt;]
<a name="Array Index: .[&lt;number&gt;]"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">When the index
value is an integer, <b>.[&lt;number&gt;]</b> can index
arrays. Arrays are zero-based, so <b>.[2]</b> returns the
third element.</p>

<p style="margin-left:9%; margin-top: 1em">Negative indices
are allowed, with -1 referring to the last element, -2
referring to the next to last element, and so on.</p></table>

<p style="margin-top: 1em">jq &acute;.[0]&acute; <br>
[{&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true},
{&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false}]
<br>
=&gt; {&quot;name&quot;:&quot;JSON&quot;,
&quot;good&quot;:true}</p>

<p style="margin-top: 1em">jq &acute;.[2]&acute; <br>
[{&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true},
{&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false}]
<br>
=&gt; null</p>

<p style="margin-top: 1em">jq &acute;.[-2]&acute; <br>
[1,2,3] <br>
=&gt; 2</p>

<h3>Array/String Slice: .[&lt;number&gt;:&lt;number&gt;]
<a name="Array/String Slice: .[&lt;number&gt;:&lt;number&gt;]"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<b>.[&lt;number&gt;:&lt;number&gt;]</b> syntax can be used
to return a subarray of an array or substring of a string.
The array returned by <b>.[10:15]</b> will be of length 5,
containing the elements from index 10 (inclusive) to index
15 (exclusive). Either index may be negative (in which case
it counts backwards from the end of the array), or omitted
(in which case it refers to the start or end of the array).
Indices are zero-based.</p></table>

<p style="margin-top: 1em">jq &acute;.[2:4]&acute; <br>

[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]
<br>
=&gt; [&quot;c&quot;, &quot;d&quot;]</p>

<p style="margin-top: 1em">jq &acute;.[2:4]&acute; <br>
&quot;abcdefghi&quot; <br>
=&gt; &quot;cd&quot;</p>

<p style="margin-top: 1em">jq &acute;.[:3]&acute; <br>

[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]
<br>
=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</p>

<p style="margin-top: 1em">jq &acute;.[-2:]&acute; <br>

[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]
<br>
=&gt; [&quot;d&quot;, &quot;e&quot;]</p>

<h3>Array/Object Value Iterator: .[]
<a name="Array/Object Value Iterator: .[]"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">If you use the
<b>.[index]</b> syntax, but omit the index entirely, it will
return <i>all</i> of the elements of an array. Running
<b>.[]</b> with the input <b>[1,2,3]</b> will produce the
numbers as three separate results, rather than as a single
array. A filter of the form <b>.foo[]</b> is equivalent to
<b>.foo | .[]</b>.</p>

<p style="margin-left:9%; margin-top: 1em">You can also use
this on an object, and it will return all the values of the
object.</p>

<p style="margin-left:9%; margin-top: 1em">Note that the
iterator operator is a generator of values.</p></table>

<p style="margin-top: 1em">jq &acute;.[]&acute; <br>
[{&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true},
{&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false}]
<br>
=&gt; {&quot;name&quot;:&quot;JSON&quot;,
&quot;good&quot;:true}, {&quot;name&quot;:&quot;XML&quot;,
&quot;good&quot;:false}</p>

<p style="margin-top: 1em">jq &acute;.[]&acute; <br>
[] <br>
=&gt;</p>

<p style="margin-top: 1em">jq &acute;.foo[]&acute; <br>
{&quot;foo&quot;:[1,2,3]} <br>
=&gt; 1, 2, 3</p>

<p style="margin-top: 1em">jq &acute;.[]&acute; <br>
{&quot;a&quot;: 1, &quot;b&quot;: 1} <br>
=&gt; 1, 1</p>

<h3>.[]?
<a name=".[]?"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Like <b>.[]</b>,
but no errors will be output if . is not an array or object.
A filter of the form <b>.foo[]?</b> is equivalent to <b>.foo
| .[]?</b>.</p>

<h3>Comma: ,
<a name="Comma: ,"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">If two filters
are separated by a comma, then the same input will be fed
into both and the two filters&acute; output value streams
will be concatenated in order: first, all of the outputs
produced by the left expression, and then all of the outputs
produced by the right. For instance, filter <b>.foo,
.bar</b>, produces both the &quot;foo&quot; fields and
&quot;bar&quot; fields as separate outputs.</p>

<p style="margin-left:9%; margin-top: 1em">The <b>,</b>
operator is one way to contruct generators.</p></table>

<p style="margin-top: 1em">jq &acute;.foo, .bar&acute; <br>
{&quot;foo&quot;: 42, &quot;bar&quot;: &quot;something
else&quot;, &quot;baz&quot;: true} <br>
=&gt; 42, &quot;something else&quot;</p>

<p style="margin-top: 1em">jq &acute;.user,
.projects[]&acute; <br>
{&quot;user&quot;:&quot;stedolan&quot;,
&quot;projects&quot;: [&quot;jq&quot;,
&quot;wikiflow&quot;]} <br>
=&gt; &quot;stedolan&quot;, &quot;jq&quot;,
&quot;wikiflow&quot;</p>

<p style="margin-top: 1em">jq &acute;.[4,2]&acute; <br>

[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]
<br>
=&gt; &quot;e&quot;, &quot;c&quot;</p>

<h3>Pipe: |
<a name="Pipe: |"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The | operator
combines two filters by feeding the output(s) of the one on
the left into the input of the one on the right. It&acute;s
similar to the Unix shell&acute;s pipe, if you&acute;re used
to that.</p>

<p style="margin-left:9%; margin-top: 1em">If the one on
the left produces multiple results, the one on the right
will be run for each of those results. So, the expression
<b>.[] | .foo</b> retrieves the &quot;foo&quot; field of
each element of the input array. This is a cartesian
product, which can be surprising.</p>

<p style="margin-left:9%; margin-top: 1em">Note that
<b>.a.b.c</b> is the same as <b>.a | .b | .c</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Note too that
<b>.</b> is the input value at the particular stage in a
&quot;pipeline&quot;, specifically: where the <b>.</b>
expression appears. Thus <b>.a | . | .b</b> is the same as
<b>.a.b</b>, as the <b>.</b> in the middle refers to
whatever value <b>.a</b> produced.</p></table>

<p style="margin-top: 1em">jq &acute;.[] | .name&acute;
<br>
[{&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true},
{&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false}]
<br>
=&gt; &quot;JSON&quot;, &quot;XML&quot;</p>

<h3>Parenthesis
<a name="Parenthesis"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Parenthesis work
as a grouping operator just as in any typical programming
language.</p> </table>

<p style="margin-top: 1em">jq &acute;(. + 2) * 5&acute;
<br>
1 <br>
=&gt; 15</p>

<h2>TYPES AND VALUES
<a name="TYPES AND VALUES"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">jq supports the
same set of datatypes as JSON - numbers, strings, booleans,
arrays, objects (which in JSON-speak are hashes with only
string keys), and &quot;null&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">Booleans, null,
strings and numbers are written the same way as in JSON.
Just like everything else in jq, these simple values take an
input and produce an output - <b>42</b> is a valid jq
expression that takes an input, ignores it, and returns 42
instead.</p>

<p style="margin-left:9%; margin-top: 1em">Numbers in jq
are internally represented by their IEEE754 double precision
approximation. Any arithmetic operation with numbers,
whether they are literals or results of previous filters,
will produce a double precision floating point result.</p>

<p style="margin-left:9%; margin-top: 1em">However, when
parsing a literal jq will store the original literal string.
If no mutation is applied to this value then it will make to
the output in its original form, even if conversion to
double would result in a loss.</p>

<h3>Array construction: []
<a name="Array construction: []"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">As in JSON,
<b>[]</b> is used to construct arrays, as in <b>[1,2,3]</b>.
The elements of the arrays can be any jq expression,
including a pipeline. All of the results produced by all of
the expressions are collected into one big array. You can
use it to construct an array out of a known quantity of
values (as in <b>[.foo, .bar, .baz]</b>) or to
&quot;collect&quot; all the results of a filter into an
array (as in <b>[.items[].name]</b>)</p>

<p style="margin-left:9%; margin-top: 1em">Once you
understand the &quot;,&quot; operator, you can look at
jq&acute;s array syntax in a different light: the expression
<b>[1,2,3]</b> is not using a built-in syntax for
comma-separated arrays, but is instead applying the
<b>[]</b> operator (collect results) to the expression 1,2,3
(which produces three different results).</p>

<p style="margin-left:9%; margin-top: 1em">If you have a
filter <b>X</b> that produces four results, then the
expression <b>[X]</b> will produce a single result, an array
of four elements.</p></table>

<p style="margin-top: 1em">jq &acute;[.user,
.projects[]]&acute; <br>
{&quot;user&quot;:&quot;stedolan&quot;,
&quot;projects&quot;: [&quot;jq&quot;,
&quot;wikiflow&quot;]} <br>
=&gt; [&quot;stedolan&quot;, &quot;jq&quot;,
&quot;wikiflow&quot;]</p>

<p style="margin-top: 1em">jq &acute;[ .[] | . * 2]&acute;
<br>
[1, 2, 3] <br>
=&gt; [2, 4, 6]</p>

<h3>Object Construction: {}
<a name="Object Construction: {}"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Like JSON,
<b>{}</b> is for constructing objects (aka dictionaries or
hashes), as in: <b>{&quot;a&quot;: 42, &quot;b&quot;:
17}</b>.</p>

<p style="margin-left:9%; margin-top: 1em">If the keys are
&quot;identifier-like&quot;, then the quotes can be left
off, as in <b>{a:42, b:17}</b>. Variable references as key
expressions use the value of the variable as the key. Key
expressions other than constant literals, identifiers, or
variable references, need to be parenthesized, e.g.,
<b>{(&quot;a&quot;+&quot;b&quot;):59}</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The value can be
any expression (although you may need to wrap it in
parentheses if, for example, it contains colons), which gets
applied to the {} expression&acute;s input (remember, all
filters have an input and an output).</p></table>

<p style="margin-top: 1em">{foo: .bar}</p>

<p style="margin-left:9%; margin-top: 1em">will produce the
JSON object <b>{&quot;foo&quot;: 42}</b> if given the JSON
object <b>{&quot;bar&quot;:42, &quot;baz&quot;:43}</b> as
its input. You can use this to select particular fields of
an object: if the input is an object with &quot;user&quot;,
&quot;title&quot;, &quot;id&quot;, and &quot;content&quot;
fields and you just want &quot;user&quot; and
&quot;title&quot;, you can write</p></table>

<p style="margin-top: 1em">{user: .user, title: .title}</p>

<p style="margin-left:9%; margin-top: 1em">Because that is
so common, there&acute;s a shortcut syntax for it: <b>{user,
title}</b>.</p>

<p style="margin-left:9%; margin-top: 1em">If one of the
expressions produces multiple results, multiple dictionaries
will be produced. If the input&acute;s</p></table>


<p style="margin-top: 1em">{&quot;user&quot;:&quot;stedolan&quot;,&quot;titles&quot;:[&quot;JQ
Primer&quot;, &quot;More JQ&quot;]}</p>

<p style="margin-left:9%; margin-top: 1em">then the
expression</p> </table>

<p style="margin-top: 1em">{user, title: .titles[]}</p>

<p style="margin-left:9%; margin-top: 1em">will produce two
outputs:</p> </table>


<p style="margin-top: 1em">{&quot;user&quot;:&quot;stedolan&quot;,
&quot;title&quot;: &quot;JQ Primer&quot;} <br>
{&quot;user&quot;:&quot;stedolan&quot;, &quot;title&quot;:
&quot;More JQ&quot;}</p>

<p style="margin-left:9%; margin-top: 1em">Putting
parentheses around the key means it will be evaluated as an
expression. With the same input as above,</p></table>

<p style="margin-top: 1em">{(.user): .titles}</p>

<p style="margin-left:9%; margin-top: 1em">produces</p></table>

<p style="margin-top: 1em">{&quot;stedolan&quot;: [&quot;JQ
Primer&quot;, &quot;More JQ&quot;]}</p>

<p style="margin-left:9%; margin-top: 1em">Variable
references as keys use the value of the variable as the key.
Without a value then the variable&acute;s name becomes the
key and its value becomes the value,</p></table>

<p style="margin-top: 1em">&quot;f o o&quot; as $foo |
&quot;b a r&quot; as $bar | {$foo, $bar:$foo}</p>

<p style="margin-left:9%; margin-top: 1em">produces</p></table>

<p style="margin-top: 1em">{&quot;foo&quot;:&quot;f o
o&quot;,&quot;b a r&quot;:&quot;f o o&quot;}</p>

<p style="margin-top: 1em">jq &acute;{user, title:
.titles[]}&acute; <br>

{&quot;user&quot;:&quot;stedolan&quot;,&quot;titles&quot;:[&quot;JQ
Primer&quot;, &quot;More JQ&quot;]} <br>
=&gt; {&quot;user&quot;:&quot;stedolan&quot;,
&quot;title&quot;: &quot;JQ Primer&quot;},
{&quot;user&quot;:&quot;stedolan&quot;, &quot;title&quot;:
&quot;More JQ&quot;}</p>

<p style="margin-top: 1em">jq &acute;{(.user):
.titles}&acute; <br>

{&quot;user&quot;:&quot;stedolan&quot;,&quot;titles&quot;:[&quot;JQ
Primer&quot;, &quot;More JQ&quot;]} <br>
=&gt; {&quot;stedolan&quot;: [&quot;JQ Primer&quot;,
&quot;More JQ&quot;]}</p>

<h3>Recursive Descent: ..
<a name="Recursive Descent: .."></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Recursively
descends <b>.</b>, producing every value. This is the same
as the zero-argument <b>recurse</b> builtin (see below).
This is intended to resemble the XPath <b>//</b> operator.
Note that <b>..a</b> does not work; use <b>.. | .a</b>
instead. In the example below we use <b>.. | .a?</b> to find
all the values of object keys &quot;a&quot; in any object
found &quot;below&quot; <b>.</b>.</p>

<p style="margin-left:9%; margin-top: 1em">This is
particularly useful in conjunction with <b>path(EXP)</b>
(also see below) and the <b>?</b> operator.</p></table>

<p style="margin-top: 1em">jq &acute;.. | .a?&acute; <br>
[[{&quot;a&quot;:1}]] <br>
=&gt; 1</p>

<h2>BUILTIN OPERATORS AND FUNCTIONS
<a name="BUILTIN OPERATORS AND FUNCTIONS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">Some jq
operators (for instance, <b>+</b>) do different things
depending on the type of their arguments (arrays, numbers,
etc.). However, jq never does implicit type conversions. If
you try to add a string to an object you&acute;ll get an
error message and no result.</p>

<p style="margin-left:9%; margin-top: 1em">Please note that
all numbers are converted to IEEE754 double precision
floating point representation. Arithmetic and logical
operators are working with these converted doubles. Results
of all such operations are also limited to the double
precision.</p>

<p style="margin-left:9%; margin-top: 1em">The only
exception to this behaviour of number is a snapshot of
original number literal. When a number which originally was
provided as a literal is never mutated until the end of the
program then it is printed to the output in its original
literal form. This also includes cases when the original
literal would be truncated when converted to the IEEE754
double precision floating point number.</p>

<h3>Addition: +
<a name="Addition: +"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The operator
<b>+</b> takes two filters, applies them both to the same
input, and adds the results together. What
&quot;adding&quot; means depends on the types involved:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p><b>Numbers</b> are added by normal arithmetic.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p><b>Arrays</b> are added by being concatenated into a
larger array.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p><b>Strings</b> are added by being joined into a larger
string.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p><b>Objects</b> are added by merging, that is, inserting
all the key-value pairs from both objects into a single
combined object. If both objects contain a value for the
same key, the object on the right of the <b>+</b> wins. (For
recursive merge use the <b>*</b> operator.)</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em"><b>null</b> can
be added to any value, and returns the other value
unchanged.</p>

<p style="margin-top: 1em">jq &acute;.a + 1&acute; <br>
{&quot;a&quot;: 7} <br>
=&gt; 8</p>

<p style="margin-top: 1em">jq &acute;.a + .b&acute; <br>
{&quot;a&quot;: [1,2], &quot;b&quot;: [3,4]} <br>
=&gt; [1,2,3,4]</p>

<p style="margin-top: 1em">jq &acute;.a + null&acute; <br>
{&quot;a&quot;: 1} <br>
=&gt; 1</p>

<p style="margin-top: 1em">jq &acute;.a + 1&acute; <br>
{} <br>
=&gt; 1</p>

<p style="margin-top: 1em">jq &acute;{a: 1} + {b: 2} + {c:
3} + {a: 42}&acute; <br>
null <br>
=&gt; {&quot;a&quot;: 42, &quot;b&quot;: 2, &quot;c&quot;:
3}</p>

<h3>Subtraction: -
<a name="Subtraction: -"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">As well as
normal arithmetic subtraction on numbers, the <b>-</b>
operator can be used on arrays to remove all occurrences of
the second array&acute;s elements from the first array.</p></table>

<p style="margin-top: 1em">jq &acute;4 - .a&acute; <br>
{&quot;a&quot;:3} <br>
=&gt; 1</p>

<p style="margin-top: 1em">jq &acute;. - [&quot;xml&quot;,
&quot;yaml&quot;]&acute; <br>
[&quot;xml&quot;, &quot;yaml&quot;, &quot;json&quot;] <br>
=&gt; [&quot;json&quot;]</p>

<h3>Multiplication, division, modulo: *, /, %
<a name="Multiplication, division, modulo: *, /, %"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">These infix
operators behave as expected when given two numbers.
Division by zero raises an error. <b>x % y</b> computes x
modulo y.</p>

<p style="margin-left:9%; margin-top: 1em">Multiplying a
string by a number produces the concatenation of that string
that many times. <b>&quot;x&quot; * 0</b> produces
<b>&quot;&quot;</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Dividing a
string by another splits the first using the second as
separators.</p>

<p style="margin-left:9%; margin-top: 1em">Multiplying two
objects will merge them recursively: this works like
addition but if both objects contain a value for the same
key, and the values are objects, the two are merged with the
same strategy.</p></table>

<p style="margin-top: 1em">jq &acute;10 / . * 3&acute; <br>
5 <br>
=&gt; 6</p>

<p style="margin-top: 1em">jq &acute;. / &quot;,
&quot;&acute; <br>
&quot;a, b,c,d, e&quot; <br>
=&gt; [&quot;a&quot;,&quot;b,c,d&quot;,&quot;e&quot;]</p>

<p style="margin-top: 1em">jq &acute;{&quot;k&quot;:
{&quot;a&quot;: 1, &quot;b&quot;: 2}} * {&quot;k&quot;:
{&quot;a&quot;: 0,&quot;c&quot;: 3}}&acute; <br>
null <br>
=&gt; {&quot;k&quot;: {&quot;a&quot;: 0, &quot;b&quot;: 2,
&quot;c&quot;: 3}}</p>

<p style="margin-top: 1em">jq &acute;.[] | (1 / .)?&acute;
<br>
[1,0,-1] <br>
=&gt; 1, -1</p>

<h3>abs
<a name="abs"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The builtin
function <b>abs</b> is defined naively as: <b>if . &lt; 0
then - . else . end</b>.</p>

<p style="margin-left:9%; margin-top: 1em">For numeric
input, this is the absolute value. See the section on the
identity filter for the implications of this definition for
numeric input.</p>

<p style="margin-left:9%; margin-top: 1em">To compute the
absolute value of a number as a floating point number, you
may wish use <b>fabs</b>.</p></table>

<p style="margin-top: 1em">jq &acute;map(abs)&acute; <br>
[-10, -1.1, -1e-1] <br>
=&gt; [10,1.1,1e-1]</p>

<h3>length
<a name="length"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The builtin
function <b>length</b> gets the length of various different
types of value:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>The length of a <b>string</b> is the number of Unicode
codepoints it contains (which will be the same as its
JSON-encoded length in bytes if it&acute;s pure ASCII).</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>The length of a <b>number</b> is its absolute value.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>The length of an <b>array</b> is the number of
elements.</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>The length of an <b>object</b> is the number of
key-value pairs.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>The length of <b>null</b> is zero.</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>It is an error to use <b>length</b> on a
<b>boolean</b>.</p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">jq &acute;.[] |
length&acute; <br>
[[1,2], &quot;string&quot;, {&quot;a&quot;:2}, null, -5]
<br>
=&gt; 2, 6, 1, 0, 5</p>

<h3>utf8bytelength
<a name="utf8bytelength"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The builtin
function <b>utf8bytelength</b> outputs the number of bytes
used to encode a string in UTF-8.</p>

<p style="margin-top: 1em">jq &acute;utf8bytelength&acute;
<br>
&quot;\u03bc&quot; <br>
=&gt; 2</p>

<h3>keys, keys_unsorted
<a name="keys, keys_unsorted"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The builtin
function <b>keys</b>, when given an object, returns its keys
in an array.</p>

<p style="margin-left:9%; margin-top: 1em">The keys are
sorted &quot;alphabetically&quot;, by unicode codepoint
order. This is not an order that makes particular sense in
any particular language, but you can count on it being the
same for any two objects with the same set of keys,
regardless of locale settings.</p>

<p style="margin-left:9%; margin-top: 1em">When <b>keys</b>
is given an array, it returns the valid indices for that
array: the integers from 0 to length-1.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>keys_unsorted</b> function is just like <b>keys</b>, but
if the input is an object then the keys will not be sorted,
instead the keys will roughly be in insertion order.</p></table>

<p style="margin-top: 1em">jq &acute;keys&acute; <br>
{&quot;abc&quot;: 1, &quot;abcd&quot;: 2, &quot;Foo&quot;:
3} <br>
=&gt; [&quot;Foo&quot;, &quot;abc&quot;,
&quot;abcd&quot;]</p>

<p style="margin-top: 1em">jq &acute;keys&acute; <br>
[42,3,35] <br>
=&gt; [0,1,2]</p>

<h3>has(key)
<a name="has(key)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The builtin
function <b>has</b> returns whether the input object has the
given key, or the input array has an element at the given
index.</p>


<p style="margin-left:9%; margin-top: 1em"><b>has($key)</b>
has the same effect as checking whether <b>$key</b> is a
member of the array returned by <b>keys</b>, although
<b>has</b> will be faster.</p></table>

<p style="margin-top: 1em">jq
&acute;map(has(&quot;foo&quot;))&acute; <br>
[{&quot;foo&quot;: 42}, {}] <br>
=&gt; [true, false]</p>

<p style="margin-top: 1em">jq &acute;map(has(2))&acute;
<br>
[[0,1], [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]] <br>
=&gt; [false, true]</p>

<h3>in
<a name="in"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The builtin
function <b>in</b> returns whether or not the input key is
in the given object, or the input index corresponds to an
element in the given array. It is, essentially, an inversed
version of <b>has</b>.</p></table>

<p style="margin-top: 1em">jq &acute;.[] |
in({&quot;foo&quot;: 42})&acute; <br>
[&quot;foo&quot;, &quot;bar&quot;] <br>
=&gt; true, false</p>

<p style="margin-top: 1em">jq &acute;map(in([0,1]))&acute;
<br>
[2, 0] <br>
=&gt; [false, true]</p>

<h3>map(f), map_values(f)
<a name="map(f), map_values(f)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">For any filter
<b>f</b>, <b>map(f)</b> and <b>map_values(f)</b> apply
<b>f</b> to each of the values in the input array or object,
that is, to the values of <b>.[]</b>.</p>

<p style="margin-left:9%; margin-top: 1em">In the absence
of errors, <b>map(f)</b> always outputs an array whereas
<b>map_values(f)</b> outputs an array if given an array, or
an object if given an object.</p>

<p style="margin-left:9%; margin-top: 1em">When the input
to <b>map_values(f)</b> is an object, the output object has
the same keys as the input object except for those keys
whose values when piped to <b>f</b> produce no values at
all.</p>

<p style="margin-left:9%; margin-top: 1em">The key
difference between <b>map(f)</b> and <b>map_values(f)</b> is
that the former simply forms an array from all the values of
<b>($x|f)</b> for each value, $x, in the input array or
object, but <b>map_values(f)</b> only uses
<b>first($x|f)</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Specifically,
for object inputs, <b>map_value(f)</b> constructs the output
object by examining in turn the value of
<b>first(.[$k]|f)</b> for each key, $k, of the input. If
this expression produces no values, then the corresponding
key will be dropped; otherwise, the output object will have
that value at the key, $k.</p>

<p style="margin-left:9%; margin-top: 1em">Here are some
examples to clarify the behavior of <b>map</b> and
<b>map_values</b> when applied to arrays. These examples
assume the input is <b>[1]</b> in all cases:</p></table>

<p style="margin-top: 1em">map(.+1) #=&gt; [2] <br>
map(., .) #=&gt; [1,1] <br>
map(empty) #=&gt; []</p>

<p style="margin-top: 1em">map_values(.+1) #=&gt; [2] <br>
map_values(., .) #=&gt; [1] <br>
map_values(empty) #=&gt; []</p>

<p style="margin-left:9%; margin-top: 1em"><b>map(f)</b> is
equivalent to <b>[.[] | f]</b> and <b>map_values(f)</b> is
equivalent to <b>.[] |= f</b>.</p>

<p style="margin-left:9%; margin-top: 1em">In fact, these
are their implementations.</p></table>

<p style="margin-top: 1em">jq &acute;map(.+1)&acute; <br>
[1,2,3] <br>
=&gt; [2,3,4]</p>

<p style="margin-top: 1em">jq &acute;map_values(.+1)&acute;
<br>
{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3} <br>
=&gt; {&quot;a&quot;: 2, &quot;b&quot;: 3, &quot;c&quot;:
4}</p>

<p style="margin-top: 1em">jq &acute;map(., .)&acute; <br>
[1,2] <br>
=&gt; [1,1,2,2]</p>

<p style="margin-top: 1em">jq &acute;map_values(. //
empty)&acute; <br>
{&quot;a&quot;: null, &quot;b&quot;: true, &quot;c&quot;:
false} <br>
=&gt; {&quot;b&quot;:true}</p>

<h3>pick(pathexps)
<a name="pick(pathexps)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Emit the
projection of the input object or array defined by the
specified sequence of path expressions, such that if
<b>p</b> is any one of these specifications, then <b>(. |
p)</b> will evaluate to the same value as <b>(. |
pick(pathexps) | p)</b>. For arrays, negative indices and
<b>.[m:n]</b> specifications should not be used.</p></table>

<p style="margin-top: 1em">jq &acute;pick(.a, .b.c,
.x)&acute; <br>
{&quot;a&quot;: 1, &quot;b&quot;: {&quot;c&quot;: 2,
&quot;d&quot;: 3}, &quot;e&quot;: 4} <br>
=&gt;
{&quot;a&quot;:1,&quot;b&quot;:{&quot;c&quot;:2},&quot;x&quot;:null}</p>

<p style="margin-top: 1em">jq &acute;pick(.[2], .[0],
.[0])&acute; <br>
[1,2,3,4] <br>
=&gt; [1,null,3]</p>

<h3>path(path_expression)
<a name="path(path_expression)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Outputs array
representations of the given path expression in <b>.</b>.
The outputs are arrays of strings (object keys) and/or
numbers (array indices).</p>

<p style="margin-left:9%; margin-top: 1em">Path expressions
are jq expressions like <b>.a</b>, but also <b>.[]</b>.
There are two types of path expressions: ones that can match
exactly, and ones that cannot. For example, <b>.a.b.c</b> is
an exact match path expression, while <b>.a[].b</b> is
not.</p>


<p style="margin-left:9%; margin-top: 1em"><b>path(exact_path_expression)</b>
will produce the array representation of the path expression
even if it does not exist in <b>.</b>, if <b>.</b> is
<b>null</b> or an array or an object.</p>


<p style="margin-left:9%; margin-top: 1em"><b>path(pattern)</b>
will produce array representations of the paths matching
<b>pattern</b> if the paths exist in <b>.</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Note that the
path expressions are not different from normal expressions.
The expression
<b>path(..|select(type==&quot;boolean&quot;))</b> outputs
all the paths to boolean values in <b>.</b>, and only those
paths.</p> </table>

<p style="margin-top: 1em">jq &acute;path(.a[0].b)&acute;
<br>
null <br>
=&gt; [&quot;a&quot;,0,&quot;b&quot;]</p>

<p style="margin-top: 1em">jq &acute;[path(..)]&acute; <br>
{&quot;a&quot;:[{&quot;b&quot;:1}]} <br>
=&gt;
[[],[&quot;a&quot;],[&quot;a&quot;,0],[&quot;a&quot;,0,&quot;b&quot;]]</p>

<h3>del(path_expression)
<a name="del(path_expression)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The builtin
function <b>del</b> removes a key and its corresponding
value from an object.</p></table>

<p style="margin-top: 1em">jq &acute;del(.foo)&acute; <br>
{&quot;foo&quot;: 42, &quot;bar&quot;: 9001,
&quot;baz&quot;: 42} <br>
=&gt; {&quot;bar&quot;: 9001, &quot;baz&quot;: 42}</p>

<p style="margin-top: 1em">jq &acute;del(.[1, 2])&acute;
<br>
[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;] <br>
=&gt; [&quot;foo&quot;]</p>

<h3>getpath(PATHS)
<a name="getpath(PATHS)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The builtin
function <b>getpath</b> outputs the values in <b>.</b> found
at each path in <b>PATHS</b>.</p></table>

<p style="margin-top: 1em">jq
&acute;getpath([&quot;a&quot;,&quot;b&quot;])&acute; <br>
null <br>
=&gt; null</p>

<p style="margin-top: 1em">jq
&acute;[getpath([&quot;a&quot;,&quot;b&quot;],
[&quot;a&quot;,&quot;c&quot;])]&acute; <br>
{&quot;a&quot;:{&quot;b&quot;:0, &quot;c&quot;:1}} <br>
=&gt; [0, 1]</p>

<h3>setpath(PATHS; VALUE)
<a name="setpath(PATHS; VALUE)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The builtin
function <b>setpath</b> sets the <b>PATHS</b> in <b>.</b> to
<b>VALUE</b>.</p> </table>

<p style="margin-top: 1em">jq
&acute;setpath([&quot;a&quot;,&quot;b&quot;]; 1)&acute; <br>
null <br>
=&gt; {&quot;a&quot;: {&quot;b&quot;: 1}}</p>

<p style="margin-top: 1em">jq
&acute;setpath([&quot;a&quot;,&quot;b&quot;]; 1)&acute; <br>
{&quot;a&quot;:{&quot;b&quot;:0}} <br>
=&gt; {&quot;a&quot;: {&quot;b&quot;: 1}}</p>

<p style="margin-top: 1em">jq
&acute;setpath([0,&quot;a&quot;]; 1)&acute; <br>
null <br>
=&gt; [{&quot;a&quot;:1}]</p>

<h3>delpaths(PATHS)
<a name="delpaths(PATHS)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The builtin
function <b>delpaths</b> deletes the <b>PATHS</b> in
<b>.</b>. <b>PATHS</b> must be an array of paths, where each
path is an array of strings and numbers.</p></table>

<p style="margin-top: 1em">jq
&acute;delpaths([[&quot;a&quot;,&quot;b&quot;]])&acute; <br>

{&quot;a&quot;:{&quot;b&quot;:1},&quot;x&quot;:{&quot;y&quot;:2}}
<br>
=&gt; {&quot;a&quot;:{},&quot;x&quot;:{&quot;y&quot;:2}}</p>

<h3>to_entries, from_entries, with_entries(f)
<a name="to_entries, from_entries, with_entries(f)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">These functions
convert between an object and an array of key-value pairs.
If <b>to_entries</b> is passed an object, then for each
<b>k: v</b> entry in the input, the output array includes
<b>{&quot;key&quot;: k, &quot;value&quot;: v}</b>.</p>


<p style="margin-left:9%; margin-top: 1em"><b>from_entries</b>
does the opposite conversion, and <b>with_entries(f)</b> is
a shorthand for <b>to_entries | map(f) | from_entries</b>,
useful for doing some operation to all keys and values of an
object. <b>from_entries</b> accepts <b>&quot;key&quot;</b>,
<b>&quot;Key&quot;</b>, <b>&quot;name&quot;</b>,
<b>&quot;Name&quot;</b>, <b>&quot;value&quot;</b>, and
<b>&quot;Value&quot;</b> as keys.</p></table>

<p style="margin-top: 1em">jq &acute;to_entries&acute; <br>
{&quot;a&quot;: 1, &quot;b&quot;: 2} <br>
=&gt; [{&quot;key&quot;:&quot;a&quot;, &quot;value&quot;:1},
{&quot;key&quot;:&quot;b&quot;, &quot;value&quot;:2}]</p>

<p style="margin-top: 1em">jq &acute;from_entries&acute;
<br>
[{&quot;key&quot;:&quot;a&quot;, &quot;value&quot;:1},
{&quot;key&quot;:&quot;b&quot;, &quot;value&quot;:2}] <br>
=&gt; {&quot;a&quot;: 1, &quot;b&quot;: 2}</p>

<p style="margin-top: 1em">jq &acute;with_entries(.key |=
&quot;KEY_&quot; + .)&acute; <br>
{&quot;a&quot;: 1, &quot;b&quot;: 2} <br>
=&gt; {&quot;KEY_a&quot;: 1, &quot;KEY_b&quot;: 2}</p>

<h3>select(boolean_expression)
<a name="select(boolean_expression)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The function
<b>select(f)</b> produces its input unchanged if <b>f</b>
returns true for that input, and produces no output
otherwise.</p>

<p style="margin-left:9%; margin-top: 1em">It&acute;s
useful for filtering lists: <b>[1,2,3] | map(select(. &gt;=
2))</b> will give you <b>[2,3]</b>.</p></table>

<p style="margin-top: 1em">jq &acute;map(select(. &gt;=
2))&acute; <br>
[1,5,3,0,7] <br>
=&gt; [5,3,7]</p>

<p style="margin-top: 1em">jq &acute;.[] | select(.id ==
&quot;second&quot;)&acute; <br>
[{&quot;id&quot;: &quot;first&quot;, &quot;val&quot;: 1},
{&quot;id&quot;: &quot;second&quot;, &quot;val&quot;: 2}]
<br>
=&gt; {&quot;id&quot;: &quot;second&quot;, &quot;val&quot;:
2}</p>

<h3>arrays, objects, iterables, booleans, numbers, normals, finites, strings,nulls, values, scalars
<a name="arrays, objects, iterables, booleans, numbers, normals, finites, strings,nulls, values, scalars"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">These built-ins
select only inputs that are arrays, objects, iterables
(arrays or objects), booleans, numbers, normal numbers,
finite numbers, strings, null, non-null values, and
non-iterables, respectively.</p></table>

<p style="margin-top: 1em">jq &acute;.[]|numbers&acute;
<br>
[[],{},1,&quot;foo&quot;,null,true,false] <br>
=&gt; 1</p>

<h3>empty
<a name="empty"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>empty</b>
returns no results. None at all. Not even <b>null</b>.</p>

<p style="margin-left:9%; margin-top: 1em">It&acute;s
useful on occasion. You&acute;ll know if you need it :)</p></table>

<p style="margin-top: 1em">jq &acute;1, empty, 2&acute;
<br>
null <br>
=&gt; 1, 2</p>

<p style="margin-top: 1em">jq &acute;[1,2,empty,3]&acute;
<br>
null <br>
=&gt; [1,2,3]</p>

<h3>error, error(message)
<a name="error, error(message)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Produces an
error with the input value, or with the message given as the
argument. Errors can be caught with try/catch; see
below.</p> </table>

<p style="margin-top: 1em">jq &acute;try error catch
.&acute; <br>
&quot;error message&quot; <br>
=&gt; &quot;error message&quot;</p>

<p style="margin-top: 1em">jq &acute;try
error(&quot;invalid value: \(.)&quot;) catch .&acute; <br>
42 <br>
=&gt; &quot;invalid value: 42&quot;</p>

<h3>halt
<a name="halt"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Stops the jq
program with no further outputs. jq will exit with exit
status <b>0</b>.</p>

<h3>halt_error, halt_error(exit_code)
<a name="halt_error, halt_error(exit_code)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Stops the jq
program with no further outputs. The input will be printed
on <b>stderr</b> as raw output (i.e., strings will not have
double quotes) with no decoration, not even a newline.</p>

<p style="margin-left:9%; margin-top: 1em">The given
<b>exit_code</b> (defaulting to <b>5</b>) will be jq&acute;s
exit status.</p>

<p style="margin-left:9%; margin-top: 1em">For example,
<b>&quot;Error: something went
wrong\n&quot;|halt_error(1)</b>.</p>

<h3>$__loc__
<a name="$__loc__"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Produces an
object with a &quot;file&quot; key and a &quot;line&quot;
key, with the filename and line number where <b>$__loc__</b>
occurs, as values.</p></table>

<p style="margin-top: 1em">jq &acute;try
error(&quot;\($__loc__)&quot;) catch .&acute; <br>
null <br>
=&gt;
&quot;{\&quot;file\&quot;:\&quot;&lt;top-level&gt;\&quot;,\&quot;line\&quot;:1}&quot;</p>

<h3>paths, paths(node_filter)
<a name="paths, paths(node_filter)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>paths</b>
outputs the paths to all the elements in its input (except
it does not output the empty list, representing .
itself).</p>

<p style="margin-left:9%; margin-top: 1em"><b>paths(f)</b>
outputs the paths to any values for which <b>f</b> is
<b>true</b>. That is, <b>paths(type ==
&quot;number&quot;)</b> outputs the paths to all numeric
values.</p> </table>

<p style="margin-top: 1em">jq &acute;[paths]&acute; <br>
[1,[[],{&quot;a&quot;:2}]] <br>
=&gt; [[0],[1],[1,0],[1,1],[1,1,&quot;a&quot;]]</p>

<p style="margin-top: 1em">jq &acute;[paths(type ==
&quot;number&quot;)]&acute; <br>
[1,[[],{&quot;a&quot;:2}]] <br>
=&gt; [[0],[1,1,&quot;a&quot;]]</p>

<h3>add
<a name="add"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The filter
<b>add</b> takes as input an array, and produces as output
the elements of the array added together. This might mean
summed, concatenated or merged depending on the types of the
elements of the input array - the rules are the same as
those for the <b>+</b> operator (described above).</p>

<p style="margin-left:9%; margin-top: 1em">If the input is
an empty array, <b>add</b> returns <b>null</b>.</p></table>

<p style="margin-top: 1em">jq &acute;add&acute; <br>
[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] <br>
=&gt; &quot;abc&quot;</p>

<p style="margin-top: 1em">jq &acute;add&acute; <br>
[1, 2, 3] <br>
=&gt; 6</p>

<p style="margin-top: 1em">jq &acute;add&acute; <br>
[] <br>
=&gt; null</p>

<h3>any, any(condition), any(generator; condition)
<a name="any, any(condition), any(generator; condition)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The filter
<b>any</b> takes as input an array of boolean values, and
produces <b>true</b> as output if any of the elements of the
array are <b>true</b>.</p>

<p style="margin-left:9%; margin-top: 1em">If the input is
an empty array, <b>any</b> returns <b>false</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>any(condition)</b> form applies the given condition to
the elements of the input array.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>any(generator; condition)</b> form applies the given
condition to all the outputs of the given generator.</p></table>

<p style="margin-top: 1em">jq &acute;any&acute; <br>
[true, false] <br>
=&gt; true</p>

<p style="margin-top: 1em">jq &acute;any&acute; <br>
[false, false] <br>
=&gt; false</p>

<p style="margin-top: 1em">jq &acute;any&acute; <br>
[] <br>
=&gt; false</p>

<h3>all, all(condition), all(generator; condition)
<a name="all, all(condition), all(generator; condition)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The filter
<b>all</b> takes as input an array of boolean values, and
produces <b>true</b> as output if all of the elements of the
array are <b>true</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>all(condition)</b> form applies the given condition to
the elements of the input array.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>all(generator; condition)</b> form applies the given
condition to all the outputs of the given generator.</p>

<p style="margin-left:9%; margin-top: 1em">If the input is
an empty array, <b>all</b> returns <b>true</b>.</p></table>

<p style="margin-top: 1em">jq &acute;all&acute; <br>
[true, false] <br>
=&gt; false</p>

<p style="margin-top: 1em">jq &acute;all&acute; <br>
[true, true] <br>
=&gt; true</p>

<p style="margin-top: 1em">jq &acute;all&acute; <br>
[] <br>
=&gt; true</p>

<h3>flatten, flatten(depth)
<a name="flatten, flatten(depth)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The filter
<b>flatten</b> takes as input an array of nested arrays, and
produces a flat array in which all arrays inside the
original array have been recursively replaced by their
values. You can pass an argument to it to specify how many
levels of nesting to flatten.</p>


<p style="margin-left:9%; margin-top: 1em"><b>flatten(2)</b>
is like <b>flatten</b>, but going only up to two levels
deep.</p> </table>

<p style="margin-top: 1em">jq &acute;flatten&acute; <br>
[1, [2], [[3]]] <br>
=&gt; [1, 2, 3]</p>

<p style="margin-top: 1em">jq &acute;flatten(1)&acute; <br>
[1, [2], [[3]]] <br>
=&gt; [1, 2, [3]]</p>

<p style="margin-top: 1em">jq &acute;flatten&acute; <br>
[[]] <br>
=&gt; []</p>

<p style="margin-top: 1em">jq &acute;flatten&acute; <br>
[{&quot;foo&quot;: &quot;bar&quot;}, [{&quot;foo&quot;:
&quot;baz&quot;}]] <br>
=&gt; [{&quot;foo&quot;: &quot;bar&quot;}, {&quot;foo&quot;:
&quot;baz&quot;}]</p>

<h3>range(upto), range(from; upto), range(from; upto; by)
<a name="range(upto), range(from; upto), range(from; upto; by)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The <b>range</b>
function produces a range of numbers. <b>range(4; 10)</b>
produces 6 numbers, from 4 (inclusive) to 10 (exclusive).
The numbers are produced as separate outputs. Use
<b>[range(4; 10)]</b> to get a range as an array.</p>

<p style="margin-left:9%; margin-top: 1em">The one argument
form generates numbers from 0 to the given number, with an
increment of 1.</p>

<p style="margin-left:9%; margin-top: 1em">The two argument
form generates numbers from <b>from</b> to <b>upto</b> with
an increment of 1.</p>

<p style="margin-left:9%; margin-top: 1em">The three
argument form generates numbers <b>from</b> to <b>upto</b>
with an increment of <b>by</b>.</p></table>

<p style="margin-top: 1em">jq &acute;range(2; 4)&acute;
<br>
null <br>
=&gt; 2, 3</p>

<p style="margin-top: 1em">jq &acute;[range(2; 4)]&acute;
<br>
null <br>
=&gt; [2,3]</p>

<p style="margin-top: 1em">jq &acute;[range(4)]&acute; <br>
null <br>
=&gt; [0,1,2,3]</p>

<p style="margin-top: 1em">jq &acute;[range(0; 10;
3)]&acute; <br>
null <br>
=&gt; [0,3,6,9]</p>

<p style="margin-top: 1em">jq &acute;[range(0; 10;
-1)]&acute; <br>
null <br>
=&gt; []</p>

<p style="margin-top: 1em">jq &acute;[range(0; -5;
-1)]&acute; <br>
null <br>
=&gt; [0,-1,-2,-3,-4]</p>

<h3>floor
<a name="floor"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The <b>floor</b>
function returns the floor of its numeric input.</p></table>

<p style="margin-top: 1em">jq &acute;floor&acute; <br>
3.14159 <br>
=&gt; 3</p>

<h3>sqrt
<a name="sqrt"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The <b>sqrt</b>
function returns the square root of its numeric input.</p></table>

<p style="margin-top: 1em">jq &acute;sqrt&acute; <br>
9 <br>
=&gt; 3</p>

<h3>tonumber
<a name="tonumber"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<b>tonumber</b> function parses its input as a number. It
will convert correctly-formatted strings to their numeric
equivalent, leave numbers alone, and give an error on all
other input.</p></table>

<p style="margin-top: 1em">jq &acute;.[] | tonumber&acute;
<br>
[1, &quot;1&quot;] <br>
=&gt; 1, 1</p>

<h3>tostring
<a name="tostring"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<b>tostring</b> function prints its input as a string.
Strings are left unchanged, and all other values are
JSON-encoded.</p> </table>

<p style="margin-top: 1em">jq &acute;.[] | tostring&acute;
<br>
[1, &quot;1&quot;, [1]] <br>
=&gt; &quot;1&quot;, &quot;1&quot;, &quot;[1]&quot;</p>

<h3>type
<a name="type"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The <b>type</b>
function returns the type of its argument as a string, which
is one of null, boolean, number, string, array or
object.</p> </table>

<p style="margin-top: 1em">jq &acute;map(type)&acute; <br>
[0, false, [], {}, null, &quot;hello&quot;] <br>
=&gt; [&quot;number&quot;, &quot;boolean&quot;,
&quot;array&quot;, &quot;object&quot;, &quot;null&quot;,
&quot;string&quot;]</p>

<h3>infinite, nan, isinfinite, isnan, isfinite, isnormal
<a name="infinite, nan, isinfinite, isnan, isfinite, isnormal"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Some arithmetic
operations can yield infinities and &quot;not a number&quot;
(NaN) values. The <b>isinfinite</b> builtin returns
<b>true</b> if its input is infinite. The <b>isnan</b>
builtin returns <b>true</b> if its input is a NaN. The
<b>infinite</b> builtin returns a positive infinite value.
The <b>nan</b> builtin returns a NaN. The <b>isnormal</b>
builtin returns true if its input is a normal number.</p>

<p style="margin-left:9%; margin-top: 1em">Note that
division by zero raises an error.</p>

<p style="margin-left:9%; margin-top: 1em">Currently most
arithmetic operations operating on infinities, NaNs, and
sub-normals do not raise errors.</p></table>

<p style="margin-top: 1em">jq &acute;.[] | (infinite * .)
&lt; 0&acute; <br>
[-1, 1] <br>
=&gt; true, false</p>

<p style="margin-top: 1em">jq &acute;infinite, nan |
type&acute; <br>
null <br>
=&gt; &quot;number&quot;, &quot;number&quot;</p>

<h3>sort, sort_by(path_expression)
<a name="sort, sort_by(path_expression)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The <b>sort</b>
functions sorts its input, which must be an array. Values
are sorted in the following order:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="76%">


<p><b>null</b></p></td>
<td width="10%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="76%">


<p><b>false</b></p></td>
<td width="10%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="76%">


<p><b>true</b></p></td>
<td width="10%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="76%">


<p>numbers</p></td>
<td width="10%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="76%">


<p>strings, in alphabetical order (by unicode codepoint
value)</p> </td>
<td width="10%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="76%">


<p>arrays, in lexical order</p></td>
<td width="10%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="76%">


<p>objects</p></td>
<td width="10%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">The ordering for
objects is a little complex: first they&acute;re compared by
comparing their sets of keys (as arrays in sorted order),
and if their keys are equal then the values are compared key
by key.</p>

<p style="margin-left:9%; margin-top: 1em"><b>sort_by</b>
may be used to sort by a particular field of an object, or
by applying any jq filter. <b>sort_by(f)</b> compares two
elements by comparing the result of <b>f</b> on each
element. When <b>f</b> produces multiple values, it firstly
compares the first values, and the second values if the
first values are equal, and so on.</p>

<p style="margin-top: 1em">jq &acute;sort&acute; <br>
[8,3,null,6] <br>
=&gt; [null,3,6,8]</p>

<p style="margin-top: 1em">jq &acute;sort_by(.foo)&acute;
<br>
[{&quot;foo&quot;:4, &quot;bar&quot;:10},
{&quot;foo&quot;:3, &quot;bar&quot;:10}, {&quot;foo&quot;:2,
&quot;bar&quot;:1}] <br>
=&gt; [{&quot;foo&quot;:2, &quot;bar&quot;:1},
{&quot;foo&quot;:3, &quot;bar&quot;:10}, {&quot;foo&quot;:4,
&quot;bar&quot;:10}]</p>

<p style="margin-top: 1em">jq &acute;sort_by(.foo,
.bar)&acute; <br>
[{&quot;foo&quot;:4, &quot;bar&quot;:10},
{&quot;foo&quot;:3, &quot;bar&quot;:20}, {&quot;foo&quot;:2,
&quot;bar&quot;:1}, {&quot;foo&quot;:3, &quot;bar&quot;:10}]
<br>
=&gt; [{&quot;foo&quot;:2, &quot;bar&quot;:1},
{&quot;foo&quot;:3, &quot;bar&quot;:10}, {&quot;foo&quot;:3,
&quot;bar&quot;:20}, {&quot;foo&quot;:4,
&quot;bar&quot;:10}]</p>

<h3>group_by(path_expression)
<a name="group_by(path_expression)"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>group_by(.foo)</b>
takes as input an array, groups the elements having the same
<b>.foo</b> field into separate arrays, and produces all of
these arrays as elements of a larger array, sorted by the
value of the <b>.foo</b> field.</p>

<p style="margin-left:9%; margin-top: 1em">Any jq
expression, not just a field access, may be used in place of
<b>.foo</b>. The sorting order is the same as described in
the <b>sort</b> function above.</p></table>

<p style="margin-top: 1em">jq &acute;group_by(.foo)&acute;
<br>
[{&quot;foo&quot;:1, &quot;bar&quot;:10},
{&quot;foo&quot;:3, &quot;bar&quot;:100},
{&quot;foo&quot;:1, &quot;bar&quot;:1}] <br>
=&gt; [[{&quot;foo&quot;:1, &quot;bar&quot;:10},
{&quot;foo&quot;:1, &quot;bar&quot;:1}],
[{&quot;foo&quot;:3, &quot;bar&quot;:100}]]</p>

<h3>min, max, min_by(path_exp), max_by(path_exp)
<a name="min, max, min_by(path_exp), max_by(path_exp)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Find the minimum
or maximum element of the input array.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>min_by(path_exp)</b> and <b>max_by(path_exp)</b>
functions allow you to specify a particular field or
property to examine, e.g. <b>min_by(.foo)</b> finds the
object with the smallest <b>foo</b> field.</p></table>

<p style="margin-top: 1em">jq &acute;min&acute; <br>
[5,4,2,7] <br>
=&gt; 2</p>

<p style="margin-top: 1em">jq &acute;max_by(.foo)&acute;
<br>
[{&quot;foo&quot;:1, &quot;bar&quot;:14},
{&quot;foo&quot;:2, &quot;bar&quot;:3}] <br>
=&gt; {&quot;foo&quot;:2, &quot;bar&quot;:3}</p>

<h3>unique, unique_by(path_exp)
<a name="unique, unique_by(path_exp)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<b>unique</b> function takes as input an array and produces
an array of the same elements, in sorted order, with
duplicates removed.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>unique_by(path_exp)</b> function will keep only one
element for each value obtained by applying the argument.
Think of it as making an array by taking one element out of
every group produced by <b>group</b>.</p></table>

<p style="margin-top: 1em">jq &acute;unique&acute; <br>
[1,2,5,3,5,3,1,3] <br>
=&gt; [1,2,3,5]</p>

<p style="margin-top: 1em">jq &acute;unique_by(.foo)&acute;
<br>
[{&quot;foo&quot;: 1, &quot;bar&quot;: 2}, {&quot;foo&quot;:
1, &quot;bar&quot;: 3}, {&quot;foo&quot;: 4,
&quot;bar&quot;: 5}] <br>
=&gt; [{&quot;foo&quot;: 1, &quot;bar&quot;: 2},
{&quot;foo&quot;: 4, &quot;bar&quot;: 5}]</p>

<p style="margin-top: 1em">jq
&acute;unique_by(length)&acute; <br>
[&quot;chunky&quot;, &quot;bacon&quot;, &quot;kitten&quot;,
&quot;cicada&quot;, &quot;asparagus&quot;] <br>
=&gt; [&quot;bacon&quot;, &quot;chunky&quot;,
&quot;asparagus&quot;]</p>

<h3>reverse
<a name="reverse"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This function
reverses an array.</p></table>

<p style="margin-top: 1em">jq &acute;reverse&acute; <br>
[1,2,3,4] <br>
=&gt; [4,3,2,1]</p>

<h3>contains(element)
<a name="contains(element)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The filter
<b>contains(b)</b> will produce true if b is completely
contained within the input. A string B is contained in a
string A if B is a substring of A. An array B is contained
in an array A if all elements in B are contained in any
element in A. An object B is contained in object A if all of
the values in B are contained in the value in A with the
same key. All other types are assumed to be contained in
each other if they are equal.</p></table>

<p style="margin-top: 1em">jq
&acute;contains(&quot;bar&quot;)&acute; <br>
&quot;foobar&quot; <br>
=&gt; true</p>

<p style="margin-top: 1em">jq
&acute;contains([&quot;baz&quot;, &quot;bar&quot;])&acute;
<br>
[&quot;foobar&quot;, &quot;foobaz&quot;, &quot;blarp&quot;]
<br>
=&gt; true</p>

<p style="margin-top: 1em">jq
&acute;contains([&quot;bazzzzz&quot;,
&quot;bar&quot;])&acute; <br>
[&quot;foobar&quot;, &quot;foobaz&quot;, &quot;blarp&quot;]
<br>
=&gt; false</p>

<p style="margin-top: 1em">jq &acute;contains({foo: 12,
bar: [{barp: 12}]})&acute; <br>
{&quot;foo&quot;: 12,
&quot;bar&quot;:[1,2,{&quot;barp&quot;:12,
&quot;blip&quot;:13}]} <br>
=&gt; true</p>

<p style="margin-top: 1em">jq &acute;contains({foo: 12,
bar: [{barp: 15}]})&acute; <br>
{&quot;foo&quot;: 12,
&quot;bar&quot;:[1,2,{&quot;barp&quot;:12,
&quot;blip&quot;:13}]} <br>
=&gt; false</p>

<h3>indices(s)
<a name="indices(s)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Outputs an array
containing the indices in <b>.</b> where <b>s</b> occurs.
The input may be an array, in which case if <b>s</b> is an
array then the indices output will be those where all
elements in <b>.</b> match those of <b>s</b>.</p></table>

<p style="margin-top: 1em">jq &acute;indices(&quot;,
&quot;)&acute; <br>
&quot;a,b, cd, efg, hijk&quot; <br>
=&gt; [3,7,12]</p>

<p style="margin-top: 1em">jq &acute;indices(1)&acute; <br>
[0,1,2,1,3,1,4] <br>
=&gt; [1,3,5]</p>

<p style="margin-top: 1em">jq &acute;indices([1,2])&acute;
<br>
[0,1,2,3,1,4,2,5,1,2,6,7] <br>
=&gt; [1,8]</p>

<h3>index(s), rindex(s)
<a name="index(s), rindex(s)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Outputs the
index of the first (<b>index</b>) or last (<b>rindex</b>)
occurrence of <b>s</b> in the input.</p></table>

<p style="margin-top: 1em">jq &acute;index(&quot;,
&quot;)&acute; <br>
&quot;a,b, cd, efg, hijk&quot; <br>
=&gt; 3</p>

<p style="margin-top: 1em">jq &acute;index(1)&acute; <br>
[0,1,2,1,3,1,4] <br>
=&gt; 1</p>

<p style="margin-top: 1em">jq &acute;index([1,2])&acute;
<br>
[0,1,2,3,1,4,2,5,1,2,6,7] <br>
=&gt; 1</p>

<p style="margin-top: 1em">jq &acute;rindex(&quot;,
&quot;)&acute; <br>
&quot;a,b, cd, efg, hijk&quot; <br>
=&gt; 12</p>

<p style="margin-top: 1em">jq &acute;rindex(1)&acute; <br>
[0,1,2,1,3,1,4] <br>
=&gt; 5</p>

<p style="margin-top: 1em">jq &acute;rindex([1,2])&acute;
<br>
[0,1,2,3,1,4,2,5,1,2,6,7] <br>
=&gt; 8</p>

<h3>inside
<a name="inside"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The filter
<b>inside(b)</b> will produce true if the input is
completely contained within b. It is, essentially, an
inversed version of <b>contains</b>.</p></table>

<p style="margin-top: 1em">jq
&acute;inside(&quot;foobar&quot;)&acute; <br>
&quot;bar&quot; <br>
=&gt; true</p>

<p style="margin-top: 1em">jq
&acute;inside([&quot;foobar&quot;, &quot;foobaz&quot;,
&quot;blarp&quot;])&acute; <br>
[&quot;baz&quot;, &quot;bar&quot;] <br>
=&gt; true</p>

<p style="margin-top: 1em">jq
&acute;inside([&quot;foobar&quot;, &quot;foobaz&quot;,
&quot;blarp&quot;])&acute; <br>
[&quot;bazzzzz&quot;, &quot;bar&quot;] <br>
=&gt; false</p>

<p style="margin-top: 1em">jq
&acute;inside({&quot;foo&quot;: 12,
&quot;bar&quot;:[1,2,{&quot;barp&quot;:12,
&quot;blip&quot;:13}]})&acute; <br>
{&quot;foo&quot;: 12, &quot;bar&quot;: [{&quot;barp&quot;:
12}]} <br>
=&gt; true</p>

<p style="margin-top: 1em">jq
&acute;inside({&quot;foo&quot;: 12,
&quot;bar&quot;:[1,2,{&quot;barp&quot;:12,
&quot;blip&quot;:13}]})&acute; <br>
{&quot;foo&quot;: 12, &quot;bar&quot;: [{&quot;barp&quot;:
15}]} <br>
=&gt; false</p>

<h3>startswith(str)
<a name="startswith(str)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Outputs
<b>true</b> if . starts with the given string argument.</p></table>

<p style="margin-top: 1em">jq
&acute;[.[]|startswith(&quot;foo&quot;)]&acute; <br>
[&quot;fo&quot;, &quot;foo&quot;, &quot;barfoo&quot;,
&quot;foobar&quot;, &quot;barfoob&quot;] <br>
=&gt; [false, true, false, true, false]</p>

<h3>endswith(str)
<a name="endswith(str)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Outputs
<b>true</b> if . ends with the given string argument.</p></table>

<p style="margin-top: 1em">jq
&acute;[.[]|endswith(&quot;foo&quot;)]&acute; <br>
[&quot;foobar&quot;, &quot;barfoo&quot;] <br>
=&gt; [false, true]</p>

<h3>combinations, combinations(n)
<a name="combinations, combinations(n)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Outputs all
combinations of the elements of the arrays in the input
array. If given an argument <b>n</b>, it outputs all
combinations of <b>n</b> repetitions of the input array.</p></table>

<p style="margin-top: 1em">jq &acute;combinations&acute;
<br>
[[1,2], [3, 4]] <br>
=&gt; [1, 3], [1, 4], [2, 3], [2, 4]</p>

<p style="margin-top: 1em">jq &acute;combinations(2)&acute;
<br>
[0, 1] <br>
=&gt; [0, 0], [0, 1], [1, 0], [1, 1]</p>

<h3>ltrimstr(str)
<a name="ltrimstr(str)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Outputs its
input with the given prefix string removed, if it starts
with it.</p></table>

<p style="margin-top: 1em">jq
&acute;[.[]|ltrimstr(&quot;foo&quot;)]&acute; <br>
[&quot;fo&quot;, &quot;foo&quot;, &quot;barfoo&quot;,
&quot;foobar&quot;, &quot;afoo&quot;] <br>
=&gt;
[&quot;fo&quot;,&quot;&quot;,&quot;barfoo&quot;,&quot;bar&quot;,&quot;afoo&quot;]</p>

<h3>rtrimstr(str)
<a name="rtrimstr(str)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Outputs its
input with the given suffix string removed, if it ends with
it.</p> </table>

<p style="margin-top: 1em">jq
&acute;[.[]|rtrimstr(&quot;foo&quot;)]&acute; <br>
[&quot;fo&quot;, &quot;foo&quot;, &quot;barfoo&quot;,
&quot;foobar&quot;, &quot;foob&quot;] <br>
=&gt;
[&quot;fo&quot;,&quot;&quot;,&quot;bar&quot;,&quot;foobar&quot;,&quot;foob&quot;]</p>

<h3>explode
<a name="explode"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Converts an
input string into an array of the string&acute;s codepoint
numbers.</p> </table>

<p style="margin-top: 1em">jq &acute;explode&acute; <br>
&quot;foobar&quot; <br>
=&gt; [102,111,111,98,97,114]</p>

<h3>implode
<a name="implode"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The inverse of
explode.</p> </table>

<p style="margin-top: 1em">jq &acute;implode&acute; <br>
[65, 66, 67] <br>
=&gt; &quot;ABC&quot;</p>

<h3>split(str)
<a name="split(str)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Splits an input
string on the separator argument.</p>

<p style="margin-left:9%; margin-top: 1em"><b>split</b> can
also split on regex matches when called with two arguments
(see the regular expressions section below).</p></table>

<p style="margin-top: 1em">jq &acute;split(&quot;,
&quot;)&acute; <br>
&quot;a, b,c,d, e, &quot; <br>
=&gt;
[&quot;a&quot;,&quot;b,c,d&quot;,&quot;e&quot;,&quot;&quot;]</p>

<h3>join(str)
<a name="join(str)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Joins the array
of elements given as input, using the argument as separator.
It is the inverse of <b>split</b>: that is, running
<b>split(&quot;foo&quot;) | join(&quot;foo&quot;)</b> over
any input string returns said input string.</p>

<p style="margin-left:9%; margin-top: 1em">Numbers and
booleans in the input are converted to strings. Null values
are treated as empty strings. Arrays and objects in the
input are not supported.</p></table>

<p style="margin-top: 1em">jq &acute;join(&quot;,
&quot;)&acute; <br>
[&quot;a&quot;,&quot;b,c,d&quot;,&quot;e&quot;] <br>
=&gt; &quot;a, b,c,d, e&quot;</p>

<p style="margin-top: 1em">jq &acute;join(&quot;
&quot;)&acute; <br>
[&quot;a&quot;,1,2.3,true,null,false] <br>
=&gt; &quot;a 1 2.3 true false&quot;</p>

<h3>ascii_downcase, ascii_upcase
<a name="ascii_downcase, ascii_upcase"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Emit a copy of
the input string with its alphabetic characters (a-z and
A-Z) converted to the specified case.</p></table>

<p style="margin-top: 1em">jq &acute;ascii_upcase&acute;
<br>
&quot;useful but not for &eacute;&quot; <br>
=&gt; &quot;USEFUL BUT NOT FOR &eacute;&quot;</p>

<h3>while(cond; update)
<a name="while(cond; update)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<b>while(cond; update)</b> function allows you to repeatedly
apply an update to <b>.</b> until <b>cond</b> is false.</p>

<p style="margin-left:9%; margin-top: 1em">Note that
<b>while(cond; update)</b> is internally defined as a
recursive jq function. Recursive calls within <b>while</b>
will not consume additional memory if <b>update</b> produces
at most one output for each input. See advanced topics
below.</p> </table>

<p style="margin-top: 1em">jq &acute;[while(.&lt;100;
.*2)]&acute; <br>
1 <br>
=&gt; [1,2,4,8,16,32,64]</p>

<h3>repeat(exp)
<a name="repeat(exp)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<b>repeat(exp)</b> function allows you to repeatedly apply
expression <b>exp</b> to <b>.</b> until an error is
raised.</p>

<p style="margin-left:9%; margin-top: 1em">Note that
<b>repeat(exp)</b> is internally defined as a recursive jq
function. Recursive calls within <b>repeat</b> will not
consume additional memory if <b>exp</b> produces at most one
output for each input. See advanced topics below.</p></table>

<p style="margin-top: 1em">jq &acute;[repeat(.*2,
error)?]&acute; <br>
1 <br>
=&gt; [2]</p>

<h3>until(cond; next)
<a name="until(cond; next)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<b>until(cond; next)</b> function allows you to repeatedly
apply the expression <b>next</b>, initially to <b>.</b> then
to its own output, until <b>cond</b> is true. For example,
this can be used to implement a factorial function (see
below).</p>

<p style="margin-left:9%; margin-top: 1em">Note that
<b>until(cond; next)</b> is internally defined as a
recursive jq function. Recursive calls within <b>until()</b>
will not consume additional memory if <b>next</b> produces
at most one output for each input. See advanced topics
below.</p> </table>

<p style="margin-top: 1em">jq &acute;[.,1]|until(.[0] &lt;
1; [.[0] - 1, .[1] * .[0]])|.[1]&acute; <br>
4 <br>
=&gt; 24</p>

<h3>recurse(f), recurse, recurse(f; condition)
<a name="recurse(f), recurse, recurse(f; condition)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<b>recurse(f)</b> function allows you to search through a
recursive structure, and extract interesting data from all
levels. Suppose your input represents a filesystem:</p></table>

<p style="margin-top: 1em">{&quot;name&quot;:
&quot;/&quot;, &quot;children&quot;: [ <br>
{&quot;name&quot;: &quot;/bin&quot;, &quot;children&quot;: [
<br>
{&quot;name&quot;: &quot;/bin/ls&quot;,
&quot;children&quot;: []}, <br>
{&quot;name&quot;: &quot;/bin/sh&quot;,
&quot;children&quot;: []}]}, <br>
{&quot;name&quot;: &quot;/home&quot;, &quot;children&quot;:
[ <br>
{&quot;name&quot;: &quot;/home/stephen&quot;,
&quot;children&quot;: [ <br>
{&quot;name&quot;: &quot;/home/stephen/jq&quot;,
&quot;children&quot;: []}]}]}]}</p>

<p style="margin-left:9%; margin-top: 1em">Now suppose you
want to extract all of the filenames present. You need to
retrieve <b>.name</b>, <b>.children[].name</b>,
<b>.children[].children[].name</b>, and so on. You can do
this with:</p></table>

<p style="margin-top: 1em">recurse(.children[]) | .name</p>

<p style="margin-left:9%; margin-top: 1em">When called
without an argument, <b>recurse</b> is equivalent to
<b>recurse(.[]?)</b>.</p>


<p style="margin-left:9%; margin-top: 1em"><b>recurse(f)</b>
is identical to <b>recurse(f; true)</b> and can be used
without concerns about recursion depth.</p>

<p style="margin-left:9%; margin-top: 1em"><b>recurse(f;
condition)</b> is a generator which begins by emitting . and
then emits in turn .|f, .|f|f, .|f|f|f, ... so long as the
computed value satisfies the condition. For example, to
generate all the integers, at least in principle, one could
write <b>recurse(.+1; true)</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The recursive
calls in <b>recurse</b> will not consume additional memory
whenever <b>f</b> produces at most a single output for each
input.</p> </table>

<p style="margin-top: 1em">jq &acute;recurse(.foo[])&acute;
<br>
{&quot;foo&quot;:[{&quot;foo&quot;: []},
{&quot;foo&quot;:[{&quot;foo&quot;:[]}]}]} <br>
=&gt;
{&quot;foo&quot;:[{&quot;foo&quot;:[]},{&quot;foo&quot;:[{&quot;foo&quot;:[]}]}]},
{&quot;foo&quot;:[]},
{&quot;foo&quot;:[{&quot;foo&quot;:[]}]},
{&quot;foo&quot;:[]}</p>

<p style="margin-top: 1em">jq &acute;recurse&acute; <br>
{&quot;a&quot;:0,&quot;b&quot;:[1]} <br>
=&gt; {&quot;a&quot;:0,&quot;b&quot;:[1]}, 0, [1], 1</p>

<p style="margin-top: 1em">jq &acute;recurse(. * .; . &lt;
20)&acute; <br>
2 <br>
=&gt; 2, 4, 16</p>

<h3>walk(f)
<a name="walk(f)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<b>walk(f)</b> function applies f recursively to every
component of the input entity. When an array is encountered,
f is first applied to its elements and then to the array
itself; when an object is encountered, f is first applied to
all the values and then to the object. In practice, f will
usually test the type of its input, as illustrated in the
following examples. The first example highlights the
usefulness of processing the elements of an array of arrays
before processing the array itself. The second example shows
how all the keys of all the objects within the input can be
considered for alteration.</p></table>

<p style="margin-top: 1em">jq &acute;walk(if type ==
&quot;array&quot; then sort else . end)&acute; <br>
[[4, 1, 7], [8, 5, 2], [3, 6, 9]] <br>
=&gt; [[1,4,7],[2,5,8],[3,6,9]]</p>

<p style="margin-top: 1em">jq &acute;walk( if type ==
&quot;object&quot; then with_entries( .key |= sub(
&quot;&#710;_+&quot;; &quot;&quot;) ) else . end )&acute;
<br>
[ { &quot;_a&quot;: { &quot;__b&quot;: 2 } } ] <br>
=&gt; [{&quot;a&quot;:{&quot;b&quot;:2}}]</p>

<h3>$JQ_BUILD_CONFIGURATION
<a name="$JQ_BUILD_CONFIGURATION"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This builtin
binding shows the jq executable&acute;s build configuration.
Its value has no particular format, but it can be expected
to be at least the <b>./configure</b> command-line
arguments, and may be enriched in the future to include the
version strings for the build tooling used.</p>

<p style="margin-left:9%; margin-top: 1em">Note that this
can be overriden in the command-line with <b>--arg</b> and
related options.</p>

<h3>$ENV, env
<a name="$ENV, env"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>$ENV</b> is
an object representing the environment variables as set when
the jq program started.</p>

<p style="margin-left:9%; margin-top: 1em"><b>env</b>
outputs an object representing jq&acute;s current
environment.</p>

<p style="margin-left:9%; margin-top: 1em">At the moment
there is no builtin for setting environment variables.</p></table>

<p style="margin-top: 1em">jq &acute;$ENV.PAGER&acute; <br>
null <br>
=&gt; &quot;less&quot;</p>

<p style="margin-top: 1em">jq &acute;env.PAGER&acute; <br>
null <br>
=&gt; &quot;less&quot;</p>

<h3>transpose
<a name="transpose"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Transpose a
possibly jagged matrix (an array of arrays). Rows are padded
with nulls so the result is always rectangular.</p></table>

<p style="margin-top: 1em">jq &acute;transpose&acute; <br>
[[1], [2,3]] <br>
=&gt; [[1,2],[null,3]]</p>

<h3>bsearch(x)
<a name="bsearch(x)"></a>
</h3>



<p style="margin-left:9%; margin-top: 1em"><b>bsearch(x)</b>
conducts a binary search for x in the input array. If the
input is sorted and contains x, then <b>bsearch(x)</b> will
return its index in the array; otherwise, if the array is
sorted, it will return (-1 - ix) where ix is an insertion
point such that the array would still be sorted after the
insertion of x at ix. If the array is not sorted,
<b>bsearch(x)</b> will return an integer that is probably of
no interest.</p></table>

<p style="margin-top: 1em">jq &acute;bsearch(0)&acute; <br>
[0,1] <br>
=&gt; 0</p>

<p style="margin-top: 1em">jq &acute;bsearch(0)&acute; <br>
[1,2,3] <br>
=&gt; -1</p>

<p style="margin-top: 1em">jq &acute;bsearch(4) as $ix | if
$ix &lt; 0 then .[-(1+$ix)] = 4 else . end&acute; <br>
[1,2,3] <br>
=&gt; [1,2,3,4]</p>

<h3>String interpolation: \(exp)
<a name="String interpolation: \(exp)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Inside a string,
you can put an expression inside parens after a backslash.
Whatever the expression returns will be interpolated into
the string.</p></table>

<p style="margin-top: 1em">jq &acute;&quot;The input was
\(.), which is one less than \(.+1)&quot;&acute; <br>
42 <br>
=&gt; &quot;The input was 42, which is one less than
43&quot;</p>

<h3>Convert to/from JSON
<a name="Convert to/from JSON"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<b>tojson</b> and <b>fromjson</b> builtins dump values as
JSON texts or parse JSON texts into values, respectively.
The <b>tojson</b> builtin differs from <b>tostring</b> in
that <b>tostring</b> returns strings unmodified, while
<b>tojson</b> encodes strings as JSON strings.</p></table>

<p style="margin-top: 1em">jq &acute;[.[]|tostring]&acute;
<br>
[1, &quot;foo&quot;, [&quot;foo&quot;]] <br>
=&gt;
[&quot;1&quot;,&quot;foo&quot;,&quot;[\&quot;foo\&quot;]&quot;]</p>

<p style="margin-top: 1em">jq &acute;[.[]|tojson]&acute;
<br>
[1, &quot;foo&quot;, [&quot;foo&quot;]] <br>
=&gt;
[&quot;1&quot;,&quot;\&quot;foo\&quot;&quot;,&quot;[\&quot;foo\&quot;]&quot;]</p>

<p style="margin-top: 1em">jq
&acute;[.[]|tojson|fromjson]&acute; <br>
[1, &quot;foo&quot;, [&quot;foo&quot;]] <br>
=&gt; [1,&quot;foo&quot;,[&quot;foo&quot;]]</p>

<h3>Format strings and escaping
<a name="Format strings and escaping"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The <b>@foo</b>
syntax is used to format and escape strings, which is useful
for building URLs, documents in a language like HTML or XML,
and so forth. <b>@foo</b> can be used as a filter on its
own, the possible escapings are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p><b>@text</b>:</p></td>
<td width="83%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Calls
<b>tostring</b>, see that function for details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p style="margin-top: 1em"><b>@json</b>:</p></td>
<td width="83%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Serializes the
input as JSON.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p style="margin-top: 1em"><b>@html</b>:</p></td>
<td width="83%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Applies
HTML/XML escaping, by mapping the characters
<b>&lt;&gt;&amp;&acute;&quot;</b> to their entity
equivalents <b>&amp;lt;</b>, <b>&amp;gt;</b>,
<b>&amp;amp;</b>, <b>&amp;apos;</b>, <b>&amp;quot;</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>@uri</b>:</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Applies
percent-encoding, by mapping all reserved URI characters to
a <b>%XX</b> sequence.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>@csv</b>:</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The input must
be an array, and it is rendered as CSV with double quotes
for strings, and quotes escaped by repetition.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>@tsv</b>:</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The input must
be an array, and it is rendered as TSV (tab-separated
values). Each input array will be printed as a single line.
Fields are separated by a single tab (ascii <b>0x09</b>).
Input characters line-feed (ascii <b>0x0a</b>),
carriage-return (ascii <b>0x0d</b>), tab (ascii <b>0x09</b>)
and backslash (ascii <b>0x5c</b>) will be output as escape
sequences <b>\n</b>, <b>\r</b>, <b>\t</b>, <b>\\</b>
respectively.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="5%">


<p style="margin-top: 1em"><b>@sh</b>:</p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The input is
escaped suitable for use in a command-line for a POSIX
shell. If the input is an array, the output will be a series
of space-separated strings.</p>

<p style="margin-left:9%;"><b>@base64</b>:</p>

<p style="margin-left:18%; margin-top: 1em">The input is
converted to base64 as specified by RFC 4648.</p>

<p style="margin-left:9%;"><b>@base64d</b>:</p>

<p style="margin-left:18%; margin-top: 1em">The inverse of
<b>@base64</b>, input is decoded as specified by RFC 4648.
Note\: If the decoded string is not UTF-8, the results are
undefined.</p>

<p style="margin-left:9%; margin-top: 1em">This syntax can
be combined with string interpolation in a useful way. You
can follow a <b>@foo</b> token with a string literal. The
contents of the string literal will <i>not</i> be escaped.
However, all interpolations made inside that string literal
will be escaped. For instance,</p>

<p style="margin-top: 1em">@uri
&quot;https://www.google.com/search?q=\(.search)&quot;</p>

<p style="margin-left:9%; margin-top: 1em">will produce the
following output for the input
<b>{&quot;search&quot;:&quot;what is jq?&quot;}</b>:</p></table>


<p style="margin-top: 1em">&quot;https://www.google.com/search?q=what%20is%20jq%3F&quot;</p>

<p style="margin-left:9%; margin-top: 1em">Note that the
slashes, question mark, etc. in the URL are not escaped, as
they were part of the string literal.</p></table>

<p style="margin-top: 1em">jq &acute;@html&acute; <br>
&quot;This works if x &lt; y&quot; <br>
=&gt; &quot;This works if x &amp;lt; y&quot;</p>

<p style="margin-top: 1em">jq &acute;@sh &quot;echo
\(.)&quot;&acute; <br>
&quot;O&acute;Hara&acute;s Ale&quot; <br>
=&gt; &quot;echo
&acute;O&acute;\\&acute;&acute;Hara&acute;\\&acute;&acute;s
Ale&acute;&quot;</p>

<p style="margin-top: 1em">jq &acute;@base64&acute; <br>
&quot;This is a message&quot; <br>
=&gt; &quot;VGhpcyBpcyBhIG1lc3NhZ2U=&quot;</p>

<p style="margin-top: 1em">jq &acute;@base64d&acute; <br>
&quot;VGhpcyBpcyBhIG1lc3NhZ2U=&quot; <br>
=&gt; &quot;This is a message&quot;</p>

<h3>Dates
<a name="Dates"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">jq provides some
basic date handling functionality, with some high-level and
low-level builtins. In all cases these builtins deal
exclusively with time in UTC.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>fromdateiso8601</b> builtin parses datetimes in the ISO
8601 format to a number of seconds since the Unix epoch
(1970-01-01T00:00:00Z). The <b>todateiso8601</b> builtin
does the inverse.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>fromdate</b> builtin parses datetime strings. Currently
<b>fromdate</b> only supports ISO 8601 datetime strings, but
in the future it will attempt to parse datetime strings in
more formats.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>todate</b> builtin is an alias for
<b>todateiso8601</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The <b>now</b>
builtin outputs the current time, in seconds since the Unix
epoch.</p>

<p style="margin-left:9%; margin-top: 1em">Low-level jq
interfaces to the C-library time functions are also
provided: <b>strptime</b>, <b>strftime</b>,
<b>strflocaltime</b>, <b>mktime</b>, <b>gmtime</b>, and
<b>localtime</b>. Refer to your host operating
system&acute;s documentation for the format strings used by
<b>strptime</b> and <b>strftime</b>. Note: these are not
necessarily stable interfaces in jq, particularly as to
their localization functionality.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>gmtime</b> builtin consumes a number of seconds since the
Unix epoch and outputs a &quot;broken down time&quot;
representation of Greenwich Mean Time as an array of numbers
representing (in this order): the year, the month
(zero-based), the day of the month (one-based), the hour of
the day, the minute of the hour, the second of the minute,
the day of the week, and the day of the year -- all
one-based unless otherwise stated. The day of the week
number may be wrong on some systems for dates before March
1st 1900, or after December 31 2099.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>localtime</b> builtin works like the <b>gmtime</b>
builtin, but using the local timezone setting.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>mktime</b> builtin consumes &quot;broken down time&quot;
representations of time output by <b>gmtime</b> and
<b>strptime</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>strptime(fmt)</b> builtin parses input strings matching
the <b>fmt</b> argument. The output is in the &quot;broken
down time&quot; representation consumed by <b>gmtime</b> and
output by <b>mktime</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>strftime(fmt)</b> builtin formats a time (GMT) with the
given format. The <b>strflocaltime</b> does the same, but
using the local timezone setting.</p>

<p style="margin-left:9%; margin-top: 1em">The format
strings for <b>strptime</b> and <b>strftime</b> are
described in typical C library documentation. The format
string for ISO 8601 datetime is
<b>&quot;%Y-%m-%dT%H:%M:%SZ&quot;</b>.</p>

<p style="margin-left:9%; margin-top: 1em">jq may not
support some or all of this date functionality on some
systems. In particular, the <b>%u</b> and <b>%j</b>
specifiers for <b>strptime(fmt)</b> are not supported on
macOS.</p> </table>

<p style="margin-top: 1em">jq &acute;fromdate&acute; <br>
&quot;2015-03-05T23:51:47Z&quot; <br>
=&gt; 1425599507</p>

<p style="margin-top: 1em">jq
&acute;strptime(&quot;%Y-%m-%dT%H:%M:%SZ&quot;)&acute; <br>
&quot;2015-03-05T23:51:47Z&quot; <br>
=&gt; [2015,2,5,23,51,47,4,63]</p>

<p style="margin-top: 1em">jq
&acute;strptime(&quot;%Y-%m-%dT%H:%M:%SZ&quot;)|mktime&acute;
<br>
&quot;2015-03-05T23:51:47Z&quot; <br>
=&gt; 1425599507</p>

<h3>SQL-Style Operators
<a name="SQL-Style Operators"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">jq provides a
few SQL-style operators. <br>
INDEX(stream; index_expression):</p>

<p style="margin-left:18%; margin-top: 1em">This builtin
produces an object whose keys are computed by the given
index expression applied to each value from the given
stream.</p>

<p style="margin-left:9%;">JOIN($idx; stream; idx_expr;
join_expr):</p>

<p style="margin-left:18%; margin-top: 1em">This builtin
joins the values from the given stream to the given index.
The index&acute;s keys are computed by applying the given
index expression to each value from the given stream. An
array of the value in the stream and the corresponding value
from the index is fed to the given join expression to
produce each result.</p>

<p style="margin-left:9%;">JOIN($idx; stream;
idx_expr):</p>

<p style="margin-left:18%; margin-top: 1em">Same as
<b>JOIN($idx; stream; idx_expr; .)</b>.</p>

<p style="margin-left:9%;">JOIN($idx; idx_expr):</p>

<p style="margin-left:18%; margin-top: 1em">This builtin
joins the input <b>.</b> to the given index, applying the
given index expression to <b>.</b> to compute the index key.
The join operation is as described above.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="8%">


<p>IN(s):</p></td>
<td width="83%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">This builtin
outputs <b>true</b> if <b>.</b> appears in the given stream,
otherwise it outputs <b>false</b>.</p>

<p style="margin-left:9%;">IN(source; s):</p>

<p style="margin-left:18%; margin-top: 1em">This builtin
outputs <b>true</b> if any value in the source stream
appears in the second stream, otherwise it outputs
<b>false</b>.</p>

<h3>builtins
<a name="builtins"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Returns a list
of all builtin functions in the format <b>name/arity</b>.
Since functions with the same name but different arities are
considered separate functions, <b>all/0</b>, <b>all/1</b>,
and <b>all/2</b> would all be present in the list.</p>

<h2>CONDITIONALS AND COMPARISONS
<a name="CONDITIONALS AND COMPARISONS"></a>
</h2>


<h3>==, !=
<a name="==, !="></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The expression
&acute;a == b&acute; will produce &acute;true&acute; if the
results of evaluating a and b are equal (that is, if they
represent equivalent JSON values) and &acute;false&acute;
otherwise. In particular, strings are never considered equal
to numbers. In checking for the equality of JSON objects,
the ordering of keys is irrelevant. If you&acute;re coming
from JavaScript, please note that jq&acute;s <b>==</b> is
like JavaScript&acute;s <b>===</b>, the &quot;strict
equality&quot; operator.</p>

<p style="margin-left:9%; margin-top: 1em">!= is &quot;not
equal&quot;, and &acute;a != b&acute; returns the opposite
value of &acute;a == b&acute;</p>

<p style="margin-top: 1em">jq &acute;. == false&acute; <br>
null <br>
=&gt; false</p>

<p style="margin-top: 1em">jq &acute;. == {&quot;b&quot;:
{&quot;d&quot;: (4 + 1e-20), &quot;c&quot;: 3},
&quot;a&quot;:1}&acute; <br>
{&quot;a&quot;:1, &quot;b&quot;: {&quot;c&quot;: 3,
&quot;d&quot;: 4}} <br>
=&gt; true</p>

<p style="margin-top: 1em">jq &acute;.[] == 1&acute; <br>
[1, 1.0, &quot;1&quot;, &quot;banana&quot;] <br>
=&gt; true, true, false, false</p>

<h3>if-then-else-end
<a name="if-then-else-end"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>if A then B
else C end</b> will act the same as <b>B</b> if <b>A</b>
produces a value other than false or null, but act the same
as <b>C</b> otherwise.</p>

<p style="margin-left:9%; margin-top: 1em"><b>if A then B
end</b> is the same as <b>if A then B else . end</b>. That
is, the <b>else</b> branch is optional, and if absent is the
same as <b>.</b>. This also applies to <b>elif</b> with
absent ending <b>else</b> branch.</p>

<p style="margin-left:9%; margin-top: 1em">Checking for
false or null is a simpler notion of &quot;truthiness&quot;
than is found in JavaScript or Python, but it means that
you&acute;ll sometimes have to be more explicit about the
condition you want. You can&acute;t test whether, e.g. a
string is empty using <b>if .name then A else B end</b>;
you&acute;ll need something like <b>if .name == &quot;&quot;
then A else B end</b> instead.</p>

<p style="margin-left:9%; margin-top: 1em">If the condition
<b>A</b> produces multiple results, then <b>B</b> is
evaluated once for each result that is not false or null,
and <b>C</b> is evaluated once for each false or null.</p>

<p style="margin-left:9%; margin-top: 1em">More cases can
be added to an if using <b>elif A then B</b> syntax.</p></table>

<p style="margin-top: 1em">jq &acute;if . == 0 then <br>
&quot;zero&quot; <br>
elif . == 1 then <br>
&quot;one&quot; <br>
else <br>
&quot;many&quot; <br>
end&acute; <br>
2 <br>
=&gt; &quot;many&quot;</p>

<h3>&gt;, &gt;=, &lt;=, &lt;
<a name="&gt;, &gt;=, &lt;=, &lt;"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The comparison
operators <b>&gt;</b>, <b>&gt;=</b>, <b>&lt;=</b>,
<b>&lt;</b> return whether their left argument is greater
than, greater than or equal to, less than or equal to or
less than their right argument (respectively).</p>

<p style="margin-left:9%; margin-top: 1em">The ordering is
the same as that described for <b>sort</b>, above.</p></table>

<p style="margin-top: 1em">jq &acute;. &lt; 5&acute; <br>
2 <br>
=&gt; true</p>

<h3>and, or, not
<a name="and, or, not"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">jq supports the
normal Boolean operators <b>and</b>, <b>or</b>, <b>not</b>.
They have the same standard of truth as if expressions -
<b>false</b> and <b>null</b> are considered &quot;false
values&quot;, and anything else is a &quot;true
value&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">If an operand of
one of these operators produces multiple results, the
operator itself will produce a result for each input.</p>

<p style="margin-left:9%; margin-top: 1em"><b>not</b> is in
fact a builtin function rather than an operator, so it is
called as a filter to which things can be piped rather than
with special syntax, as in <b>.foo and .bar | not</b>.</p>

<p style="margin-left:9%; margin-top: 1em">These three only
produce the values <b>true</b> and <b>false</b>, and so are
only useful for genuine Boolean operations, rather than the
common Perl/Python/Ruby idiom of
&quot;value_that_may_be_null or default&quot;. If you want
to use this form of &quot;or&quot;, picking between two
values rather than evaluating a condition, see the <b>//</b>
operator below.</p></table>

<p style="margin-top: 1em">jq &acute;42 and &quot;a
string&quot;&acute; <br>
null <br>
=&gt; true</p>

<p style="margin-top: 1em">jq &acute;(true, false) or
false&acute; <br>
null <br>
=&gt; true, false</p>

<p style="margin-top: 1em">jq &acute;(true, true) and
(true, false)&acute; <br>
null <br>
=&gt; true, false, true, false</p>

<p style="margin-top: 1em">jq &acute;[true, false |
not]&acute; <br>
null <br>
=&gt; [false, true]</p>

<h3>Alternative operator: //
<a name="Alternative operator: //"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The <b>//</b>
operator produces all the values of its left-hand side that
are neither <b>false</b> nor <b>null</b>. If the left-hand
side produces no values other than <b>false</b> or
<b>null</b>, then <b>//</b> produces all the values of its
right-hand side.</p>

<p style="margin-left:9%; margin-top: 1em">A filter of the
form <b>a // b</b> produces all the results of <b>a</b> that
are not <b>false</b> or <b>null</b>. If <b>a</b> produces no
results, or no results other than <b>false</b> or
<b>null</b>, then <b>a // b</b> produces the results of
<b>b</b>.</p>

<p style="margin-left:9%; margin-top: 1em">This is useful
for providing defaults: <b>.foo // 1</b> will evaluate to
<b>1</b> if there&acute;s no <b>.foo</b> element in the
input. It&acute;s similar to how <b>or</b> is sometimes used
in Python (jq&acute;s <b>or</b> operator is reserved for
strictly Boolean operations).</p>

<p style="margin-left:9%; margin-top: 1em">Note:
<b>some_generator // defaults_here</b> is not the same as
<b>some_generator | . // defaults_here</b>. The latter will
produce default values for all non-<b>false</b>,
non-<b>null</b> values of the left-hand side, while the
former will not. Precedence rules can make this confusing.
For example, in <b>false, 1 // 2</b> the left-hand side of
<b>//</b> is <b>1</b>, not <b>false, 1</b> -- <b>false, 1 //
2</b> parses the same way as <b>false, (1 // 2)</b>. In
<b>(false, null, 1) | . // 42</b> the left-hand side of
<b>//</b> is <b>.</b>, which always produces just one value,
while in <b>(false, null, 1) // 42</b> the left-hand side is
a generator of three values, and since it produces a value
other <b>false</b> and <b>null</b>, the default <b>42</b> is
not produced.</p></table>

<p style="margin-top: 1em">jq &acute;empty // 42&acute;
<br>
null <br>
=&gt; 42</p>

<p style="margin-top: 1em">jq &acute;.foo // 42&acute; <br>
{&quot;foo&quot;: 19} <br>
=&gt; 19</p>

<p style="margin-top: 1em">jq &acute;.foo // 42&acute; <br>
{} <br>
=&gt; 42</p>

<p style="margin-top: 1em">jq &acute;(false, null, 1) //
42&acute; <br>
null <br>
=&gt; 1</p>

<p style="margin-top: 1em">jq &acute;(false, null, 1) | .
// 42&acute; <br>
null <br>
=&gt; 42, 42, 1</p>

<h3>try-catch
<a name="try-catch"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Errors can be
caught by using <b>try EXP catch EXP</b>. The first
expression is executed, and if it fails then the second is
executed with the error message. The output of the handler,
if any, is output as if it had been the output of the
expression to try.</p>

<p style="margin-left:9%; margin-top: 1em">The <b>try
EXP</b> form uses <b>empty</b> as the exception handler.</p></table>

<p style="margin-top: 1em">jq &acute;try .a catch &quot;.
is not an object&quot;&acute; <br>
true <br>
=&gt; &quot;. is not an object&quot;</p>

<p style="margin-top: 1em">jq &acute;[.[]|try .a]&acute;
<br>
[{}, true, {&quot;a&quot;:1}] <br>
=&gt; [null, 1]</p>

<p style="margin-top: 1em">jq &acute;try error(&quot;some
exception&quot;) catch .&acute; <br>
true <br>
=&gt; &quot;some exception&quot;</p>

<h3>Breaking out of control structures
<a name="Breaking out of control structures"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">A convenient use
of try/catch is to break out of control structures like
<b>reduce</b>, <b>foreach</b>, <b>while</b>, and so on.</p>

<p style="margin-left:9%; margin-top: 1em">For example:</p></table>

<p style="margin-top: 1em"># Repeat an expression until it
raises &quot;break&quot; as an <br>
# error, then stop repeating without re-raising the error.
<br>
# But if the error caught is not &quot;break&quot; then
re-raise it. <br>
try repeat(exp) catch if .==&quot;break&quot; then empty
else error</p>

<p style="margin-left:9%; margin-top: 1em">jq has a syntax
for named lexical labels to &quot;break&quot; or &quot;go
(back) to&quot;:</p></table>

<p style="margin-top: 1em">label $out | ... break $out
...</p>

<p style="margin-left:9%; margin-top: 1em">The <b>break
$label_name</b> expression will cause the program to to act
as though the nearest (to the left) <b>label $label_name</b>
produced <b>empty</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The relationship
between the <b>break</b> and corresponding <b>label</b> is
lexical: the label has to be &quot;visible&quot; from the
break.</p>

<p style="margin-left:9%; margin-top: 1em">To break out of
a <b>reduce</b>, for example:</p></table>

<p style="margin-top: 1em">label $out | reduce .[] as $item
(null; if .==false then break $out else ... end)</p>

<p style="margin-left:9%; margin-top: 1em">The following jq
program produces a syntax error:</p></table>

<p style="margin-top: 1em">break $out</p>

<p style="margin-left:9%; margin-top: 1em">because no label
<b>$out</b> is visible.</p>

<h3>Error Suppression / Optional Operator: ?
<a name="Error Suppression / Optional Operator: ?"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The <b>?</b>
operator, used as <b>EXP?</b>, is shorthand for <b>try
EXP</b>.</p> </table>

<p style="margin-top: 1em">jq &acute;[.[] | .a?]&acute;
<br>
[{}, true, {&quot;a&quot;:1}] <br>
=&gt; [null, 1]</p>

<p style="margin-top: 1em">jq &acute;[.[] |
tonumber?]&acute; <br>
[&quot;1&quot;, &quot;invalid&quot;, &quot;3&quot;, 4] <br>
=&gt; [1, 3, 4]</p>

<h2>REGULAR EXPRESSIONS
<a name="REGULAR EXPRESSIONS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">jq uses the
Oniguruma regular expression library, as do PHP, TextMate,
Sublime Text, etc, so the description here will focus on jq
specifics.</p>

<p style="margin-left:9%; margin-top: 1em">Oniguruma
supports several flavors of regular expression, so it is
important to know that jq uses the &quot;Perl NG&quot; (Perl
with named groups) flavor.</p>

<p style="margin-left:9%; margin-top: 1em">The jq regex
filters are defined so that they can be used using one of
these patterns:</p></table>

<p style="margin-top: 1em">STRING | FILTER(REGEX) <br>
STRING | FILTER(REGEX; FLAGS) <br>
STRING | FILTER([REGEX]) <br>
STRING | FILTER([REGEX, FLAGS])</p>

<p style="margin-left:9%; margin-top: 1em">where:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>STRING, REGEX, and FLAGS are jq strings and subject to
jq string interpolation;</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>REGEX, after string interpolation, should be a valid
regular expression;</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p>FILTER is one of <b>test</b>, <b>match</b>, or
<b>capture</b>, as described below.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Since REGEX must
evaluate to a JSON string, some characters that are needed
to form a regular expression must be escaped. For example,
the regular expression <b>\s</b> signifying a whitespace
character would be written as <b>&quot;\\s&quot;</b>.</p>

<p style="margin-left:9%; margin-top: 1em">FLAGS is a
string consisting of one of more of the supported flags:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="74%">


<p><b>g</b> - Global search (find all matches, not just the
first)</p> </td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="74%">


<p><b>i</b> - Case insensitive search</p></td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="74%">


<p><b>m</b> - Multi line mode (<b>.</b> will match
newlines)</p> </td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="74%">


<p><b>n</b> - Ignore empty matches</p></td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="74%">


<p><b>p</b> - Both s and m modes are enabled</p></td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="74%">


<p><b>s</b> - Single line mode (<b>&#710;</b> -&gt;
<b>\A</b>, <b>$</b> -&gt; <b>\Z</b>)</p></td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="74%">


<p><b>l</b> - Find longest possible matches</p></td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="74%">


<p><b>x</b> - Extended regex format (ignore whitespace and
comments)</p> </td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">To match a
whitespace with the <b>x</b> flag, use <b>\s</b>, e.g.</p>

<p style="margin-top: 1em">jq -n &acute;&quot;a b&quot; |
test(&quot;a\\sb&quot;; &quot;x&quot;)&acute;</p>

<p style="margin-left:9%; margin-top: 1em">Note that
certain flags may also be specified within REGEX, e.g.</p></table>

<p style="margin-top: 1em">jq -n &acute;(&quot;test&quot;,
&quot;TEst&quot;, &quot;teST&quot;, &quot;TEST&quot;) |
test(&quot;(?i)te(?-i)st&quot;)&acute;</p>

<p style="margin-left:9%; margin-top: 1em">evaluates to:
<b>true</b>, <b>true</b>, <b>false</b>, <b>false</b>.</p>

<h3>test(val), test(regex; flags)
<a name="test(val), test(regex; flags)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Like
<b>match</b>, but does not return match objects, only
<b>true</b> or <b>false</b> for whether or not the regex
matches the input.</p></table>

<p style="margin-top: 1em">jq
&acute;test(&quot;foo&quot;)&acute; <br>
&quot;foo&quot; <br>
=&gt; true</p>

<p style="margin-top: 1em">jq &acute;.[] | test(&quot;a b c
# spaces are ignored&quot;; &quot;ix&quot;)&acute; <br>
[&quot;xabcd&quot;, &quot;ABC&quot;] <br>
=&gt; true, true</p>

<h3>match(val), match(regex; flags)
<a name="match(val), match(regex; flags)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>match</b>
outputs an object for each match it finds. Matches have the
following fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p><b>offset</b> - offset in UTF-8 codepoints from the
beginning of the input</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p><b>length</b> - length in UTF-8 codepoints of the
match</p> </td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p><b>string</b> - the string that it matched</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p><b>captures</b> - an array of objects representing
capturing groups.</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Capturing group
objects have the following fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p><b>offset</b> - offset in UTF-8 codepoints from the
beginning of the input</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p><b>length</b> - length in UTF-8 codepoints of this
capturing group</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p><b>string</b> - the string that was captured</p></td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="86%">


<p><b>name</b> - the name of the capturing group (or
<b>null</b> if it was unnamed)</p></td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">Capturing groups
that did not match anything return an offset of -1</p>

<p style="margin-top: 1em">jq
&acute;match(&quot;(abc)+&quot;; &quot;g&quot;)&acute; <br>
&quot;abc abc&quot; <br>
=&gt; {&quot;offset&quot;: 0, &quot;length&quot;: 3,
&quot;string&quot;: &quot;abc&quot;, &quot;captures&quot;:
[{&quot;offset&quot;: 0, &quot;length&quot;: 3,
&quot;string&quot;: &quot;abc&quot;, &quot;name&quot;:
null}]}, {&quot;offset&quot;: 4, &quot;length&quot;: 3,
&quot;string&quot;: &quot;abc&quot;, &quot;captures&quot;:
[{&quot;offset&quot;: 4, &quot;length&quot;: 3,
&quot;string&quot;: &quot;abc&quot;, &quot;name&quot;:
null}]}</p>

<p style="margin-top: 1em">jq
&acute;match(&quot;foo&quot;)&acute; <br>
&quot;foo bar foo&quot; <br>
=&gt; {&quot;offset&quot;: 0, &quot;length&quot;: 3,
&quot;string&quot;: &quot;foo&quot;, &quot;captures&quot;:
[]}</p>

<p style="margin-top: 1em">jq
&acute;match([&quot;foo&quot;, &quot;ig&quot;])&acute; <br>
&quot;foo bar FOO&quot; <br>
=&gt; {&quot;offset&quot;: 0, &quot;length&quot;: 3,
&quot;string&quot;: &quot;foo&quot;, &quot;captures&quot;:
[]}, {&quot;offset&quot;: 8, &quot;length&quot;: 3,
&quot;string&quot;: &quot;FOO&quot;, &quot;captures&quot;:
[]}</p>

<p style="margin-top: 1em">jq &acute;match(&quot;foo
(?&lt;bar123&gt;bar)? foo&quot;; &quot;ig&quot;)&acute; <br>
&quot;foo bar foo foo foo&quot; <br>
=&gt; {&quot;offset&quot;: 0, &quot;length&quot;: 11,
&quot;string&quot;: &quot;foo bar foo&quot;,
&quot;captures&quot;: [{&quot;offset&quot;: 4,
&quot;length&quot;: 3, &quot;string&quot;: &quot;bar&quot;,
&quot;name&quot;: &quot;bar123&quot;}]},
{&quot;offset&quot;: 12, &quot;length&quot;: 8,
&quot;string&quot;: &quot;foo foo&quot;,
&quot;captures&quot;: [{&quot;offset&quot;: -1,
&quot;length&quot;: 0, &quot;string&quot;: null,
&quot;name&quot;: &quot;bar123&quot;}]}</p>

<p style="margin-top: 1em">jq &acute;[ match(&quot;.&quot;;
&quot;g&quot;)] | length&acute; <br>
&quot;abc&quot; <br>
=&gt; 3</p>

<h3>capture(val), capture(regex; flags)
<a name="capture(val), capture(regex; flags)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Collects the
named captures in a JSON object, with the name of each
capture as the key, and the matched string as the
corresponding value.</p></table>

<p style="margin-top: 1em">jq
&acute;capture(&quot;(?&lt;a&gt;[a-z]+)-(?&lt;n&gt;[0-9]+)&quot;)&acute;
<br>
&quot;xyzzy-14&quot; <br>
=&gt; { &quot;a&quot;: &quot;xyzzy&quot;, &quot;n&quot;:
&quot;14&quot; }</p>

<h3>scan(regex), scan(regex; flags)
<a name="scan(regex), scan(regex; flags)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Emit a stream of
the non-overlapping substrings of the input that match the
regex in accordance with the flags, if any have been
specified. If there is no match, the stream is empty. To
capture all the matches for each input string, use the idiom
<b>[ expr ]</b>, e.g. <b>[ scan(regex) ]</b>.</p></table>

<p style="margin-top: 1em">jq
&acute;scan(&quot;c&quot;)&acute; <br>
&quot;abcdefabc&quot; <br>
=&gt; &quot;c&quot;, &quot;c&quot;</p>

<h3>split(regex; flags)
<a name="split(regex; flags)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Splits an input
string on each regex match.</p>

<p style="margin-left:9%; margin-top: 1em">For backwards
compatibility, when called with a single argument,
<b>split</b> splits on a string, not a regex.</p></table>

<p style="margin-top: 1em">jq &acute;split(&quot;, *&quot;;
null)&acute; <br>
&quot;ab,cd, ef&quot; <br>
=&gt; [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</p>

<h3>splits(regex), splits(regex; flags)
<a name="splits(regex), splits(regex; flags)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">These provide
the same results as their <b>split</b> counterparts, but as
a stream instead of an array.</p></table>

<p style="margin-top: 1em">jq &acute;splits(&quot;,
*&quot;)&acute; <br>
&quot;ab,cd, ef, gh&quot; <br>
=&gt; &quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;,
&quot;gh&quot;</p>

<h3>sub(regex; tostring), sub(regex; tostring; flags)
<a name="sub(regex; tostring), sub(regex; tostring; flags)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Emit the string
obtained by replacing the first match of regex in the input
string with <b>tostring</b>, after interpolation.
<b>tostring</b> should be a jq string or a stream of such
strings, each of which may contain references to named
captures. The named captures are, in effect, presented as a
JSON object (as constructed by <b>capture</b>) to
<b>tostring</b>, so a reference to a captured variable named
&quot;x&quot; would take the form:
<b>&quot;\(.x)&quot;</b>.</p> </table>

<p style="margin-top: 1em">jq
&acute;sub(&quot;[&#710;a-z]*(?&lt;x&gt;[a-z]+)&quot;;
&quot;Z\(.x)&quot;; &quot;g&quot;)&acute; <br>
&quot;123abc456def&quot; <br>
=&gt; &quot;ZabcZdef&quot;</p>

<p style="margin-top: 1em">jq
&acute;[sub(&quot;(?&lt;a&gt;.)&quot;;
&quot;\(.a|ascii_upcase)&quot;,
&quot;\(.a|ascii_downcase)&quot;)]&acute; <br>
&quot;aB&quot; <br>
=&gt; [&quot;AB&quot;,&quot;aB&quot;]</p>

<h3>gsub(regex; tostring), gsub(regex; tostring; flags)
<a name="gsub(regex; tostring), gsub(regex; tostring; flags)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em"><b>gsub</b> is
like <b>sub</b> but all the non-overlapping occurrences of
the regex are replaced by <b>tostring</b>, after
interpolation. If the second argument is a stream of jq
strings, then <b>gsub</b> will produce a corresponding
stream of JSON strings.</p></table>

<p style="margin-top: 1em">jq
&acute;gsub(&quot;(?&lt;x&gt;.)[&#710;a]*&quot;;
&quot;+\(.x)-&quot;)&acute; <br>
&quot;Abcabc&quot; <br>
=&gt; &quot;+A-+a-&quot;</p>

<p style="margin-top: 1em">jq &acute;[gsub(&quot;p&quot;;
&quot;a&quot;, &quot;b&quot;)]&acute; <br>
&quot;p&quot; <br>
=&gt; [&quot;a&quot;,&quot;b&quot;]</p>

<h2>ADVANCED FEATURES
<a name="ADVANCED FEATURES"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">Variables are an
absolute necessity in most programming languages, but
they&acute;re relegated to an &quot;advanced feature&quot;
in jq.</p>

<p style="margin-left:9%; margin-top: 1em">In most
languages, variables are the only means of passing around
data. If you calculate a value, and you want to use it more
than once, you&acute;ll need to store it in a variable. To
pass a value to another part of the program, you&acute;ll
need that part of the program to define a variable (as a
function parameter, object member, or whatever) in which to
place the data.</p>

<p style="margin-left:9%; margin-top: 1em">It is also
possible to define functions in jq, although this is is a
feature whose biggest use is defining jq&acute;s standard
library (many jq functions such as <b>map</b> and
<b>select</b> are in fact written in jq).</p>

<p style="margin-left:9%; margin-top: 1em">jq has reduction
operators, which are very powerful but a bit tricky. Again,
these are mostly used internally, to define some useful bits
of jq&acute;s standard library.</p>

<p style="margin-left:9%; margin-top: 1em">It may not be
obvious at first, but jq is all about generators (yes, as
often found in other languages). Some utilities are provided
to help deal with generators.</p>

<p style="margin-left:9%; margin-top: 1em">Some minimal I/O
support (besides reading JSON from standard input, and
writing JSON to standard output) is available.</p>

<p style="margin-left:9%; margin-top: 1em">Finally, there
is a module/library system.</p>

<h3>Variable / Symbolic Binding Operator: ... as $identifier | ...
<a name="Variable / Symbolic Binding Operator: ... as $identifier | ..."></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">In jq, all
filters have an input and an output, so manual plumbing is
not necessary to pass a value from one part of a program to
the next. Many expressions, for instance <b>a + b</b>, pass
their input to two distinct subexpressions (here <b>a</b>
and <b>b</b> are both passed the same input), so variables
aren&acute;t usually necessary in order to use a value
twice.</p>

<p style="margin-left:9%; margin-top: 1em">For instance,
calculating the average value of an array of numbers
requires a few variables in most languages - at least one to
hold the array, perhaps one for each element or for a loop
counter. In jq, it&acute;s simply <b>add / length</b> - the
<b>add</b> expression is given the array and produces its
sum, and the <b>length</b> expression is given the array and
produces its length.</p>

<p style="margin-left:9%; margin-top: 1em">So,
there&acute;s generally a cleaner way to solve most problems
in jq than defining variables. Still, sometimes they do make
things easier, so jq lets you define variables using
<b>expression as $variable</b>. All variable names start
with <b>$</b>. Here&acute;s a slightly uglier version of the
array-averaging example:</p></table>

<p style="margin-top: 1em">length as $array_length | add /
$array_length</p>

<p style="margin-left:9%; margin-top: 1em">We&acute;ll need
a more complicated problem to find a situation where using
variables actually makes our lives easier.</p>

<p style="margin-left:9%; margin-top: 1em">Suppose we have
an array of blog posts, with &quot;author&quot; and
&quot;title&quot; fields, and another object which is used
to map author usernames to real names. Our input looks
like:</p> </table>

<p style="margin-top: 1em">{&quot;posts&quot;:
[{&quot;title&quot;: &quot;First post&quot;,
&quot;author&quot;: &quot;anon&quot;}, <br>
{&quot;title&quot;: &quot;A well-written article&quot;,
&quot;author&quot;: &quot;person1&quot;}], <br>
&quot;realnames&quot;: {&quot;anon&quot;: &quot;Anonymous
Coward&quot;, <br>
&quot;person1&quot;: &quot;Person McPherson&quot;}}</p>

<p style="margin-left:9%; margin-top: 1em">We want to
produce the posts with the author field containing a real
name, as in:</p></table>

<p style="margin-top: 1em">{&quot;title&quot;: &quot;First
post&quot;, &quot;author&quot;: &quot;Anonymous
Coward&quot;} <br>
{&quot;title&quot;: &quot;A well-written article&quot;,
&quot;author&quot;: &quot;Person McPherson&quot;}</p>

<p style="margin-left:9%; margin-top: 1em">We use a
variable, $names, to store the realnames object, so that we
can refer to it later when looking up author usernames:</p></table>

<p style="margin-top: 1em">.realnames as $names | .posts[]
| {title, author: $names[.author]}</p>

<p style="margin-left:9%; margin-top: 1em">The expression
<b>exp as $x | ...</b> means: for each value of expression
<b>exp</b>, run the rest of the pipeline with the entire
original input, and with <b>$x</b> set to that value. Thus
<b>as</b> functions as something of a foreach loop.</p>

<p style="margin-left:9%; margin-top: 1em">Just as
<b>{foo}</b> is a handy way of writing <b>{foo: .foo}</b>,
so <b>{$foo}</b> is a handy way of writing <b>{foo:
$foo}</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Multiple
variables may be declared using a single <b>as</b>
expression by providing a pattern that matches the structure
of the input (this is known as
&quot;destructuring&quot;):</p> </table>

<p style="margin-top: 1em">. as {realnames: $names, posts:
[$first, $second]} | ...</p>

<p style="margin-left:9%; margin-top: 1em">The variable
declarations in array patterns (e.g., <b>. as [$first,
$second]</b>) bind to the elements of the array in from the
element at index zero on up, in order. When there is no
value at the index for an array pattern element, <b>null</b>
is bound to that variable.</p>

<p style="margin-left:9%; margin-top: 1em">Variables are
scoped over the rest of the expression that defines them,
so</p> </table>

<p style="margin-top: 1em">.realnames as $names | (.posts[]
| {title, author: $names[.author]})</p>

<p style="margin-left:9%; margin-top: 1em">will work,
but</p> </table>

<p style="margin-top: 1em">(.realnames as $names |
.posts[]) | {title, author: $names[.author]}</p>


<p style="margin-left:9%; margin-top: 1em">won&acute;t.</p>

<p style="margin-left:9%; margin-top: 1em">For programming
language theorists, it&acute;s more accurate to say that jq
variables are lexically-scoped bindings. In particular
there&acute;s no way to change the value of a binding; one
can only setup a new binding with the same name, but which
will not be visible where the old one was.</p></table>

<p style="margin-top: 1em">jq &acute;.bar as $x | .foo | .
+ $x&acute; <br>
{&quot;foo&quot;:10, &quot;bar&quot;:200} <br>
=&gt; 210</p>

<p style="margin-top: 1em">jq &acute;. as $i|[(.*2|. as $i|
$i), $i]&acute; <br>
5 <br>
=&gt; [10,5]</p>

<p style="margin-top: 1em">jq &acute;. as [$a, $b, {c: $c}]
| $a + $b + $c&acute; <br>
[2, 3, {&quot;c&quot;: 4, &quot;d&quot;: 5}] <br>
=&gt; 9</p>

<p style="margin-top: 1em">jq &acute;.[] as [$a, $b] | {a:
$a, b: $b}&acute; <br>
[[0], [0, 1], [2, 1, 0]] <br>
=&gt; {&quot;a&quot;:0,&quot;b&quot;:null},
{&quot;a&quot;:0,&quot;b&quot;:1},
{&quot;a&quot;:2,&quot;b&quot;:1}</p>

<h3>Destructuring Alternative Operator: ?//
<a name="Destructuring Alternative Operator: ?//"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
destructuring alternative operator provides a concise
mechanism for destructuring an input that can take one of
several forms.</p>

<p style="margin-left:9%; margin-top: 1em">Suppose we have
an API that returns a list of resources and events
associated with them, and we want to get the user_id and
timestamp of the first event for each resource. The API
(having been clumsily converted from XML) will only wrap the
events in an array if the resource has multiple events:</p></table>

<p style="margin-top: 1em">{&quot;resources&quot;:
[{&quot;id&quot;: 1, &quot;kind&quot;: &quot;widget&quot;,
&quot;events&quot;: {&quot;action&quot;: &quot;create&quot;,
&quot;user_id&quot;: 1, &quot;ts&quot;: 13}}, <br>
{&quot;id&quot;: 2, &quot;kind&quot;: &quot;widget&quot;,
&quot;events&quot;: [{&quot;action&quot;:
&quot;create&quot;, &quot;user_id&quot;: 1, &quot;ts&quot;:
14}, {&quot;action&quot;: &quot;destroy&quot;,
&quot;user_id&quot;: 1, &quot;ts&quot;: 15}]}]}</p>

<p style="margin-left:9%; margin-top: 1em">We can use the
destructuring alternative operator to handle this structural
change simply:</p></table>

<p style="margin-top: 1em">.resources[] as {$id, $kind,
events: {$user_id, $ts}} ?// {$id, $kind, events:
[{$user_id, $ts}]} | {$user_id, $kind, $id, $ts}</p>

<p style="margin-left:9%; margin-top: 1em">Or, if we
aren&acute;t sure if the input is an array of values or an
object:</p> </table>

<p style="margin-top: 1em">.[] as [$id, $kind, $user_id,
$ts] ?// {$id, $kind, $user_id, $ts} | ...</p>

<p style="margin-left:9%; margin-top: 1em">Each alternative
need not define all of the same variables, but all named
variables will be available to the subsequent expression.
Variables not matched in the alternative that succeeded will
be <b>null</b>:</p></table>

<p style="margin-top: 1em">.resources[] as {$id, $kind,
events: {$user_id, $ts}} ?// {$id, $kind, events:
[{$first_user_id, $first_ts}]} | {$user_id, $first_user_id,
$kind, $id, $ts, $first_ts}</p>

<p style="margin-left:9%; margin-top: 1em">Additionally, if
the subsequent expression returns an error, the alternative
operator will attempt to try the next binding. Errors that
occur during the final alternative are passed through.</p></table>

<p style="margin-top: 1em">[[3]] | .[] as [$a] ?// [$b] |
if $a != null then error(&quot;err: \($a)&quot;) else
{$a,$b} end</p>

<p style="margin-top: 1em">jq &acute;.[] as {$a, $b, c:
{$d, $e}} ?// {$a, $b, c: [{$d, $e}]} | {$a, $b, $d,
$e}&acute; <br>
[{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;:
{&quot;d&quot;: 3, &quot;e&quot;: 4}}, {&quot;a&quot;: 1,
&quot;b&quot;: 2, &quot;c&quot;: [{&quot;d&quot;: 3,
&quot;e&quot;: 4}]}] <br>
=&gt;
{&quot;a&quot;:1,&quot;b&quot;:2,&quot;d&quot;:3,&quot;e&quot;:4},
{&quot;a&quot;:1,&quot;b&quot;:2,&quot;d&quot;:3,&quot;e&quot;:4}</p>

<p style="margin-top: 1em">jq &acute;.[] as {$a, $b, c:
{$d}} ?// {$a, $b, c: [{$e}]} | {$a, $b, $d, $e}&acute; <br>
[{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;:
{&quot;d&quot;: 3, &quot;e&quot;: 4}}, {&quot;a&quot;: 1,
&quot;b&quot;: 2, &quot;c&quot;: [{&quot;d&quot;: 3,
&quot;e&quot;: 4}]}] <br>
=&gt;
{&quot;a&quot;:1,&quot;b&quot;:2,&quot;d&quot;:3,&quot;e&quot;:null},
{&quot;a&quot;:1,&quot;b&quot;:2,&quot;d&quot;:null,&quot;e&quot;:4}</p>

<p style="margin-top: 1em">jq &acute;.[] as [$a] ?// [$b] |
if $a != null then error(&quot;err: \($a)&quot;) else
{$a,$b} end&acute; <br>
[[3]] <br>
=&gt; {&quot;a&quot;:null,&quot;b&quot;:3}</p>

<h3>Defining Functions
<a name="Defining Functions"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">You can give a
filter a name using &quot;def&quot; syntax:</p></table>

<p style="margin-top: 1em">def increment: . + 1;</p>

<p style="margin-left:9%; margin-top: 1em">From then on,
<b>increment</b> is usable as a filter just like a builtin
function (in fact, this is how many of the builtins are
defined). A function may take arguments:</p></table>

<p style="margin-top: 1em">def map(f): [.[] | f];</p>

<p style="margin-left:9%; margin-top: 1em">Arguments are
passed as <i>filters</i> (functions with no arguments),
<i>not</i> as values. The same argument may be referenced
multiple times with different inputs (here <b>f</b> is run
for each element of the input array). Arguments to a
function work more like callbacks than like value arguments.
This is important to understand. Consider:</p></table>

<p style="margin-top: 1em">def foo(f): f|f; <br>
5|foo(.*2)</p>

<p style="margin-left:9%; margin-top: 1em">The result will
be 20 because <b>f</b> is <b>.*2</b>, and during the first
invocation of <b>f .</b> will be 5, and the second time it
will be 10 (5 * 2), so the result will be 20. Function
arguments are filters, and filters expect an input when
invoked.</p>

<p style="margin-left:9%; margin-top: 1em">If you want the
value-argument behaviour for defining simple functions, you
can just use a variable:</p></table>

<p style="margin-top: 1em">def addvalue(f): f as $f | map(.
+ $f);</p>

<p style="margin-left:9%; margin-top: 1em">Or use the
short-hand:</p> </table>

<p style="margin-top: 1em">def addvalue($f): ...;</p>

<p style="margin-left:9%; margin-top: 1em">With either
definition, <b>addvalue(.foo)</b> will add the current
input&acute;s <b>.foo</b> field to each element of the
array. Do note that calling <b>addvalue(.[])</b> will cause
the <b>map(. + $f)</b> part to be evaluated once per value
in the value of <b>.</b> at the call site.</p>

<p style="margin-left:9%; margin-top: 1em">Multiple
definitions using the same function name are allowed. Each
re-definition replaces the previous one for the same number
of function arguments, but only for references from
functions (or main program) subsequent to the re-definition.
See also the section below on scoping.</p></table>

<p style="margin-top: 1em">jq &acute;def addvalue(f): . +
[f]; map(addvalue(.[0]))&acute; <br>
[[1,2],[10,20]] <br>
=&gt; [[1,2,1], [10,20,10]]</p>

<p style="margin-top: 1em">jq &acute;def addvalue(f): f as
$x | map(. + $x); addvalue(.[0])&acute; <br>
[[1,2],[10,20]] <br>
=&gt; [[1,2,1,2], [10,20,1,2]]</p>

<h3>Scoping
<a name="Scoping"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">There are two
types of symbols in jq: value bindings (a.k.a.,
&quot;variables&quot;), and functions. Both are scoped
lexically, with expressions being able to refer only to
symbols that have been defined &quot;to the left&quot; of
them. The only exception to this rule is that functions can
refer to themselves so as to be able to create recursive
functions.</p>

<p style="margin-left:9%; margin-top: 1em">For example, in
the following expression there is a binding which is visible
&quot;to the right&quot; of it, <b>... | .*3 as $times_three
| [. + $times_three] | ...</b>, but not &quot;to the
left&quot;. Consider this expression now, <b>... | (.*3 as
$times_three | [. + $times_three]) | ...</b>: here the
binding <b>$times_three</b> is <i>not</i> visible past the
closing parenthesis.</p>

<h3>isempty(exp)
<a name="isempty(exp)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Returns true if
<b>exp</b> produces no outputs, false otherwise.</p></table>

<p style="margin-top: 1em">jq &acute;isempty(empty)&acute;
<br>
null <br>
=&gt; true</p>

<p style="margin-top: 1em">jq &acute;isempty(.[])&acute;
<br>
[] <br>
=&gt; true</p>

<p style="margin-top: 1em">jq &acute;isempty(.[])&acute;
<br>
[1,2,3] <br>
=&gt; false</p>

<h3>limit(n; exp)
<a name="limit(n; exp)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The <b>limit</b>
function extracts up to <b>n</b> outputs from
<b>exp</b>.</p> </table>

<p style="margin-top: 1em">jq &acute;[limit(3;.[])]&acute;
<br>
[0,1,2,3,4,5,6,7,8,9] <br>
=&gt; [0,1,2]</p>

<h3>first(expr), last(expr), nth(n; expr)
<a name="first(expr), last(expr), nth(n; expr)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<b>first(expr)</b> and <b>last(expr)</b> functions extract
the first and last values from <b>expr</b>,
respectively.</p>

<p style="margin-left:9%; margin-top: 1em">The <b>nth(n;
expr)</b> function extracts the nth value output by
<b>expr</b>. Note that <b>nth(n; expr)</b> doesn&acute;t
support negative values of <b>n</b>.</p></table>

<p style="margin-top: 1em">jq &acute;[first(range(.)),
last(range(.)), nth(./2; range(.))]&acute; <br>
10 <br>
=&gt; [0,9,5]</p>

<h3>first, last, nth(n)
<a name="first, last, nth(n)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The <b>first</b>
and <b>last</b> functions extract the first and last values
from any array at <b>.</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>nth(n)</b> function extracts the nth value of any array
at <b>.</b>.</p></table>

<p style="margin-top: 1em">jq &acute;[range(.)]|[first,
last, nth(5)]&acute; <br>
10 <br>
=&gt; [0,9,5]</p>

<h3>reduce
<a name="reduce"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<b>reduce</b> syntax allows you to combine all of the
results of an expression by accumulating them into a single
answer. The form is <b>reduce EXP as $var (INIT;
UPDATE)</b>. As an example, we&acute;ll pass <b>[1,2,3]</b>
to this expression:</p></table>

<p style="margin-top: 1em">reduce .[] as $item (0; . +
$item)</p>

<p style="margin-left:9%; margin-top: 1em">For each result
that <b>.[]</b> produces, <b>. + $item</b> is run to
accumulate a running total, starting from 0 as the input
value. In this example, <b>.[]</b> produces the results
<b>1</b>, <b>2</b>, and <b>3</b>, so the effect is similar
to running something like this:</p></table>

<p style="margin-top: 1em">0 | 1 as $item | . + $item |
<br>
2 as $item | . + $item | <br>
3 as $item | . + $item</p>

<p style="margin-top: 1em">jq &acute;reduce .[] as $item
(0; . + $item)&acute; <br>
[1,2,3,4,5] <br>
=&gt; 15</p>

<p style="margin-top: 1em">jq &acute;reduce .[] as [$i,$j]
(0; . + $i * $j)&acute; <br>
[[1,2],[3,4],[5,6]] <br>
=&gt; 44</p>

<p style="margin-top: 1em">jq &acute;reduce .[] as {$x,$y}
(null; .x += $x | .y += [$y])&acute; <br>

[{&quot;x&quot;:&quot;a&quot;,&quot;y&quot;:1},{&quot;x&quot;:&quot;b&quot;,&quot;y&quot;:2},{&quot;x&quot;:&quot;c&quot;,&quot;y&quot;:3}]
<br>
=&gt;
{&quot;x&quot;:&quot;abc&quot;,&quot;y&quot;:[1,2,3]}</p>

<h3>foreach
<a name="foreach"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<b>foreach</b> syntax is similar to <b>reduce</b>, but
intended to allow the construction of <b>limit</b> and
reducers that produce intermediate results.</p>

<p style="margin-left:9%; margin-top: 1em">The form is
<b>foreach EXP as $var (INIT; UPDATE; EXTRACT)</b>. As an
example, we&acute;ll pass <b>[1,2,3]</b> to this
expression:</p> </table>

<p style="margin-top: 1em">foreach .[] as $item (0; . +
$item; [$item, . * 2])</p>

<p style="margin-left:9%; margin-top: 1em">Like the
<b>reduce</b> syntax, <b>. + $item</b> is run for each
result that <b>.[]</b> produces, but <b>[$item, . * 2]</b>
is run for each intermediate values. In this example, since
the intermediate values are <b>1</b>, <b>3</b>, and
<b>6</b>, the <b>foreach</b> expression produces
<b>[1,2]</b>, <b>[2,6]</b>, and <b>[3,12]</b>. So the effect
is similar to running something like this:</p></table>

<p style="margin-top: 1em">0 | 1 as $item | . + $item |
[$item, . * 2], <br>
2 as $item | . + $item | [$item, . * 2], <br>
3 as $item | . + $item | [$item, . * 2]</p>

<p style="margin-left:9%; margin-top: 1em">When
<b>EXTRACT</b> is omitted, the identity filter is used. That
is, it outputs the intermediate values as they are.</p></table>

<p style="margin-top: 1em">jq &acute;foreach .[] as $item
(0; . + $item)&acute; <br>
[1,2,3,4,5] <br>
=&gt; 1, 3, 6, 10, 15</p>

<p style="margin-top: 1em">jq &acute;foreach .[] as $item
(0; . + $item; [$item, . * 2])&acute; <br>
[1,2,3,4,5] <br>
=&gt; [1,2], [2,6], [3,12], [4,20], [5,30]</p>

<p style="margin-top: 1em">jq &acute;foreach .[] as $item
(0; . + 1; {index: ., $item})&acute; <br>
[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;] <br>
=&gt;
{&quot;index&quot;:1,&quot;item&quot;:&quot;foo&quot;},
{&quot;index&quot;:2,&quot;item&quot;:&quot;bar&quot;},
{&quot;index&quot;:3,&quot;item&quot;:&quot;baz&quot;}</p>

<h3>Recursion
<a name="Recursion"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">As described
above, <b>recurse</b> uses recursion, and any jq function
can be recursive. The <b>while</b> builtin is also
implemented in terms of recursion.</p>

<p style="margin-left:9%; margin-top: 1em">Tail calls are
optimized whenever the expression to the left of the
recursive call outputs its last value. In practice this
means that the expression to the left of the recursive call
should not produce more than one output for each input.</p>

<p style="margin-left:9%; margin-top: 1em">For example:</p></table>

<p style="margin-top: 1em">def recurse(f): def r: ., (f |
select(. != null) | r); r;</p>

<p style="margin-top: 1em">def while(cond; update): <br>
def _while: <br>
if cond then ., (update | _while) else empty end; <br>
_while;</p>

<p style="margin-top: 1em">def repeat(exp): <br>
def _repeat: <br>
exp, _repeat; <br>
_repeat;</p>

<h3>Generators and iterators
<a name="Generators and iterators"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Some jq
operators and functions are actually generators in that they
can produce zero, one, or more values for each input, just
as one might expect in other programming languages that have
generators. For example, <b>.[]</b> generates all the values
in its input (which must be an array or an object),
<b>range(0; 10)</b> generates the integers between 0 and 10,
and so on.</p>

<p style="margin-left:9%; margin-top: 1em">Even the comma
operator is a generator, generating first the values
generated by the expression to the left of the comma, then
the values generated by the expression on the right of the
comma.</p>

<p style="margin-left:9%; margin-top: 1em">The <b>empty</b>
builtin is the generator that produces zero outputs. The
<b>empty</b> builtin backtracks to the preceding generator
expression.</p>

<p style="margin-left:9%; margin-top: 1em">All jq functions
can be generators just by using builtin generators. It is
also possible to construct new generators using only
recursion and the comma operator. If recursive calls are
&quot;in tail position&quot; then the generator will be
efficient. In the example below the recursive call by
<b>_range</b> to itself is in tail position. The example
shows off three advanced topics: tail recursion, generator
construction, and sub-functions.</p></table>

<p style="margin-top: 1em">jq &acute;def range(init; upto;
by): def _range: if (by &gt; 0 and . &lt; upto) or (by &lt;
0 and . &gt; upto) then ., ((.+by)|_range) else . end; if by
== 0 then init else init|_range end | select((by &gt; 0 and
. &lt; upto) or (by &lt; 0 and . &gt; upto)); range(0; 10;
3)&acute; <br>
null <br>
=&gt; 0, 3, 6, 9</p>

<p style="margin-top: 1em">jq &acute;def while(cond;
update): def _while: if cond then ., (update | _while) else
empty end; _while; [while(.&lt;100; .*2)]&acute; <br>
1 <br>
=&gt; [1,2,4,8,16,32,64]</p>

<h2>MATH
<a name="MATH"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">jq currently
only has IEEE754 double-precision (64-bit) floating point
number support.</p>

<p style="margin-left:9%; margin-top: 1em">Besides simple
arithmetic operators such as <b>+</b>, jq also has most
standard math functions from the C math library. C math
functions that take a single input argument (e.g.,
<b>sin()</b>) are available as zero-argument jq functions. C
math functions that take two input arguments (e.g.,
<b>pow()</b>) are available as two-argument jq functions
that ignore <b>.</b>. C math functions that take three input
arguments are available as three-argument jq functions that
ignore <b>.</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Availability of
standard math functions depends on the availability of the
corresponding math functions in your operating system and C
math library. Unavailable math functions will be defined but
will raise an error.</p>

<p style="margin-left:9%; margin-top: 1em">One-input C math
functions: <b>acos acosh asin asinh atan atanh cbrt ceil cos
cosh erf erfc exp exp10 exp2 expm1 fabs floor gamma j0 j1
lgamma log log10 log1p log2 logb nearbyint pow10 rint round
significand sin sinh sqrt tan tanh tgamma trunc y0
y1</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Two-input C math
functions: <b>atan2 copysign drem fdim fmax fmin fmod frexp
hypot jn ldexp modf nextafter nexttoward pow remainder scalb
scalbln yn</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Three-input C
math functions: <b>fma</b>.</p>

<p style="margin-left:9%; margin-top: 1em">See your
system&acute;s manual for more information on each of
these.</p>

<h2>I/O
<a name="I/O"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">At this time jq
has minimal support for I/O, mostly in the form of control
over when inputs are read. Two builtins functions are
provided for this, <b>input</b> and <b>inputs</b>, that read
from the same sources (e.g., <b>stdin</b>, files named on
the command-line) as jq itself. These two builtins, and
jq&acute;s own reading actions, can be interleaved with each
other. They are commonly used in combination with the null
input option <b>-n</b> to prevent one input from being read
implicitly.</p>

<p style="margin-left:9%; margin-top: 1em">Two builtins
provide minimal output capabilities, <b>debug</b>, and
<b>stderr</b>. (Recall that a jq program&acute;s output
values are always output as JSON texts on <b>stdout</b>.)
The <b>debug</b> builtin can have application-specific
behavior, such as for executables that use the libjq C API
but aren&acute;t the jq executable itself. The <b>stderr</b>
builtin outputs its input in raw mode to stder with no
additional decoration, not even a newline.</p>

<p style="margin-left:9%; margin-top: 1em">Most jq builtins
are referentially transparent, and yield constant and
repeatable value streams when applied to constant inputs.
This is not true of I/O builtins.</p>

<h3>input
<a name="input"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Outputs one new
input.</p>

<p style="margin-left:9%; margin-top: 1em">Note that when
using <b>input</b> it is generally be necessary to invoke jq
with the <b>-n</b> command-line option, otherwise the first
entity will be lost.</p></table>

<p style="margin-top: 1em">echo 1 2 3 4 | jq &acute;[.,
input]&acute; # [1,2] [3,4]</p>

<h3>inputs
<a name="inputs"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Outputs all
remaining inputs, one by one.</p>

<p style="margin-left:9%; margin-top: 1em">This is
primarily useful for reductions over a program&acute;s
inputs. Note that when using <b>inputs</b> it is generally
necessary to invoke jq with the <b>-n</b> command-line
option, otherwise the first entity will be lost.</p></table>

<p style="margin-top: 1em">echo 1 2 3 | jq -n &acute;reduce
inputs as $i (0; . + $i)&acute; # 6</p>

<h3>debug, debug(msgs)
<a name="debug, debug(msgs)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">These two
filters are like <b>.</b> but have as a side-effect the
production of one or more messages on stderr.</p>

<p style="margin-left:9%; margin-top: 1em">The message
produced by the <b>debug</b> filter has the form</p></table>


<p style="margin-top: 1em">[&quot;DEBUG:&quot;,&lt;input-value&gt;]</p>

<p style="margin-left:9%; margin-top: 1em">where
<b>&lt;input-value&gt;</b> is a compact rendition of the
input value. This format may change in the future.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>debug(msgs)</b> filter is defined as <b>(msgs | debug |
empty), .</b> thus allowing great flexibility in the content
of the message, while also allowing multi-line debugging
statements to be created.</p>

<p style="margin-left:9%; margin-top: 1em">For example, the
expression:</p> </table>

<p style="margin-top: 1em">1 as $x | 2 |
debug(&quot;Entering function foo with $x == \($x)&quot;, .)
| (.+1)</p>

<p style="margin-left:9%; margin-top: 1em">would produce
the value 3 but with the following two lines being written
to stderr:</p></table>


<p style="margin-top: 1em">[&quot;DEBUG:&quot;,&quot;Entering
function foo with $x == 1&quot;] <br>
[&quot;DEBUG:&quot;,2]</p>

<h3>stderr
<a name="stderr"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Prints its input
in raw and compact mode to stderr with no additional
decoration, not even a newline.</p>

<h3>input_filename
<a name="input_filename"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Returns the name
of the file whose input is currently being filtered. Note
that this will not work well unless jq is running in a UTF-8
locale.</p>

<h3>input_line_number
<a name="input_line_number"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Returns the line
number of the input currently being filtered.</p>

<h2>STREAMING
<a name="STREAMING"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">With the
<b>--stream</b> option jq can parse input texts in a
streaming fashion, allowing jq programs to start processing
large JSON texts immediately rather than after the parse
completes. If you have a single JSON text that is 1GB in
size, streaming it will allow you to process it much more
quickly.</p>

<p style="margin-left:9%; margin-top: 1em">However,
streaming isn&acute;t easy to deal with as the jq program
will have <b>[&lt;path&gt;, &lt;leaf-value&gt;]</b> (and a
few other forms) as inputs.</p>

<p style="margin-left:9%; margin-top: 1em">Several builtins
are provided to make handling streams easier.</p>

<p style="margin-left:9%; margin-top: 1em">The examples
below use the streamed form of <b>[0,[1]]</b>, which is
<b>[[0],0],[[1,0],1],[[1,0]],[[1]]</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Streaming forms
include <b>[&lt;path&gt;, &lt;leaf-value&gt;]</b> (to
indicate any scalar value, empty array, or empty object),
and <b>[&lt;path&gt;]</b> (to indicate the end of an array
or object). Future versions of jq run with <b>--stream</b>
and <b>--seq</b> may output additional forms such as
<b>[&quot;error message&quot;]</b> when an input text fails
to parse.</p>

<h3>truncate_stream(stream_expression)
<a name="truncate_stream(stream_expression)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Consumes a
number as input and truncates the corresponding number of
path elements from the left of the outputs of the given
streaming expression.</p></table>

<p style="margin-top: 1em">jq
&acute;truncate_stream([[0],1],[[1,0],2],[[1,0]],[[1]])&acute;
<br>
1 <br>
=&gt; [[0],2], [[0]]</p>

<h3>fromstream(stream_expression)
<a name="fromstream(stream_expression)"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Outputs values
corresponding to the stream expression&acute;s outputs.</p></table>

<p style="margin-top: 1em">jq
&acute;fromstream(1|truncate_stream([[0],1],[[1,0],2],[[1,0]],[[1]]))&acute;
<br>
null <br>
=&gt; [2]</p>

<h3>tostream
<a name="tostream"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">The
<b>tostream</b> builtin outputs the streamed form of its
input.</p> </table>

<p style="margin-top: 1em">jq &acute;. as
$dot|fromstream($dot|tostream)|.==$dot&acute; <br>
[0,[1,{&quot;a&quot;:1},{&quot;b&quot;:2}]] <br>
=&gt; true</p>

<h2>ASSIGNMENT
<a name="ASSIGNMENT"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">Assignment works
a little differently in jq than in most programming
languages. jq doesn&acute;t distinguish between references
to and copies of something - two objects or arrays are
either equal or not equal, without any further notion of
being &quot;the same object&quot; or &quot;not the same
object&quot;.</p>

<p style="margin-left:9%; margin-top: 1em">If an object has
two fields which are arrays, <b>.foo</b> and <b>.bar</b>,
and you append something to <b>.foo</b>, then <b>.bar</b>
will not get bigger, even if you&acute;ve previously set
<b>.bar = .foo</b>. If you&acute;re used to programming in
languages like Python, Java, Ruby, JavaScript, etc. then you
can think of it as though jq does a full deep copy of every
object before it does the assignment (for performance it
doesn&acute;t actually do that, but that&acute;s the general
idea).</p>

<p style="margin-left:9%; margin-top: 1em">This means that
it&acute;s impossible to build circular values in jq (such
as an array whose first element is itself). This is quite
intentional, and ensures that anything a jq program can
produce can be represented in JSON.</p>

<p style="margin-left:9%; margin-top: 1em">All the
assignment operators in jq have path expressions on the
left-hand side (LHS). The right-hand side (RHS) provides
values to set to the paths named by the LHS path
expressions.</p>

<p style="margin-left:9%; margin-top: 1em">Values in jq are
always immutable. Internally, assignment works by using a
reduction to compute new, replacement values for <b>.</b>
that have had all the desired assignments applied to
<b>.</b>, then outputting the modified value. This might be
made clear by this example: <b>{a:{b:{c:1}}} | (.a.b|=3),
.</b>. This will output
<b>{&quot;a&quot;:{&quot;b&quot;:3}}</b> and
<b>{&quot;a&quot;:{&quot;b&quot;:{&quot;c&quot;:1}}}</b>
because the last sub-expression, <b>.</b>, sees the original
value, not the modified value.</p>

<p style="margin-left:9%; margin-top: 1em">Most users will
want to use modification assignment operators, such as
<b>|=</b> or <b>+=</b>, rather than <b>=</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Note that the
LHS of assignment operators refers to a value in <b>.</b>.
Thus <b>$var.foo = 1</b> won&acute;t work as expected
(<b>$var.foo</b> is not a valid or useful path expression in
<b>.</b>); use <b>$var | .foo = 1</b> instead.</p>

<p style="margin-left:9%; margin-top: 1em">Note too that
<b>.a,.b=0</b> does not set <b>.a</b> and <b>.b</b>, but
<b>(.a,.b)=0</b> sets both.</p>

<h3>Update-assignment: |=
<a name="Update-assignment: |="></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This is the
&quot;update&quot; operator <b>|=</b>. It takes a filter on
the right-hand side and works out the new value for the
property of <b>.</b> being assigned to by running the old
value through this expression. For instance, <b>(.foo, .bar)
|= .+1</b> will build an object with the <b>foo</b> field
set to the input&acute;s <b>foo</b> plus 1, and the
<b>bar</b> field set to the input&acute;s <b>bar</b> plus
1.</p>

<p style="margin-left:9%; margin-top: 1em">The left-hand
side can be any general path expression; see
<b>path()</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Note that the
left-hand side of <b>|=</b> refers to a value in <b>.</b>.
Thus <b>$var.foo |= . + 1</b> won&acute;t work as expected
(<b>$var.foo</b> is not a valid or useful path expression in
<b>.</b>); use <b>$var | .foo |= . + 1</b> instead.</p>

<p style="margin-left:9%; margin-top: 1em">If the
right-hand side outputs no values (i.e., <b>empty</b>), then
the left-hand side path will be deleted, as with
<b>del(path)</b>.</p>

<p style="margin-left:9%; margin-top: 1em">If the
right-hand side outputs multiple values, only the first one
will be used (COMPATIBILITY NOTE: in jq 1.5 and earlier
releases, it used to be that only the last one was
used).</p> </table>

<p style="margin-top: 1em">jq
&acute;(..|select(type==&quot;boolean&quot;)) |= if . then 1
else 0 end&acute; <br>
[true,false,[5,true,[true,[false]],false]] <br>
=&gt; [1,0,[5,1,[1,[0]],0]]</p>

<h3>Arithmetic update-assignment: +=, -=, *=, /=, %=, //=
<a name="Arithmetic update-assignment: +=, -=, *=, /=, %=, //="></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">jq has a few
operators of the form <b>a op= b</b>, which are all
equivalent to <b>a |= . op b</b>. So, <b>+= 1</b> can be
used to increment values, being the same as <b>|= . +
1</b>.</p> </table>

<p style="margin-top: 1em">jq &acute;.foo += 1&acute; <br>
{&quot;foo&quot;: 42} <br>
=&gt; {&quot;foo&quot;: 43}</p>

<h3>Plain assignment: =
<a name="Plain assignment: ="></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This is the
plain assignment operator. Unlike the others, the input to
the right-hand side (RHS) is the same as the input to the
left-hand side (LHS) rather than the value at the LHS path,
and all values output by the RHS will be used (as shown
below).</p>

<p style="margin-left:9%; margin-top: 1em">If the RHS of
<b>=</b> produces multiple values, then for each such value
jq will set the paths on the left-hand side to the value and
then it will output the modified <b>.</b>. For example,
<b>(.a,.b) = range(2)</b> outputs
<b>{&quot;a&quot;:0,&quot;b&quot;:0}</b>, then
<b>{&quot;a&quot;:1,&quot;b&quot;:1}</b>. The
&quot;update&quot; assignment forms (see above) do not do
this.</p>

<p style="margin-left:9%; margin-top: 1em">This example
should show the difference between <b>=</b> and
<b>|=</b>:</p>

<p style="margin-left:9%; margin-top: 1em">Provide input
<b>{&quot;a&quot;: {&quot;b&quot;: 10}, &quot;b&quot;:
20}</b> to the programs</p></table>

<p style="margin-top: 1em">.a = .b</p>

<p style="margin-left:9%; margin-top: 1em">and</p></table>

<p style="margin-top: 1em">.a |= .b</p>

<p style="margin-left:9%; margin-top: 1em">The former will
set the <b>a</b> field of the input to the <b>b</b> field of
the input, and produce the output <b>{&quot;a&quot;: 20,
&quot;b&quot;: 20}</b>. The latter will set the <b>a</b>
field of the input to the <b>a</b> field&acute;s <b>b</b>
field, producing <b>{&quot;a&quot;: 10, &quot;b&quot;:
20}</b>.</p> </table>

<p style="margin-top: 1em">jq &acute;.a = .b&acute; <br>
{&quot;a&quot;: {&quot;b&quot;: 10}, &quot;b&quot;: 20} <br>
=&gt; {&quot;a&quot;:20,&quot;b&quot;:20}</p>

<p style="margin-top: 1em">jq &acute;.a |= .b&acute; <br>
{&quot;a&quot;: {&quot;b&quot;: 10}, &quot;b&quot;: 20} <br>
=&gt; {&quot;a&quot;:10,&quot;b&quot;:20}</p>

<p style="margin-top: 1em">jq &acute;(.a, .b) =
range(3)&acute; <br>
null <br>
=&gt; {&quot;a&quot;:0,&quot;b&quot;:0},
{&quot;a&quot;:1,&quot;b&quot;:1},
{&quot;a&quot;:2,&quot;b&quot;:2}</p>

<p style="margin-top: 1em">jq &acute;(.a, .b) |=
range(3)&acute; <br>
null <br>
=&gt; {&quot;a&quot;:0,&quot;b&quot;:0}</p>

<h3>Complex assignments
<a name="Complex assignments"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Lots more things
are allowed on the left-hand side of a jq assignment than in
most languages. We&acute;ve already seen simple field
accesses on the left hand side, and it&acute;s no surprise
that array accesses work just as well:</p></table>

<p style="margin-top: 1em">.posts[0].title = &quot;JQ
Manual&quot;</p>

<p style="margin-left:9%; margin-top: 1em">What may come as
a surprise is that the expression on the left may produce
multiple results, referring to different points in the input
document:</p> </table>

<p style="margin-top: 1em">.posts[].comments |= . +
[&quot;this is great&quot;]</p>

<p style="margin-left:9%; margin-top: 1em">That example
appends the string &quot;this is great&quot; to the
&quot;comments&quot; array of each post in the input (where
the input is an object with a field &quot;posts&quot; which
is an array of posts).</p>

<p style="margin-left:9%; margin-top: 1em">When jq
encounters an assignment like &acute;a = b&acute;, it
records the &quot;path&quot; taken to select a part of the
input document while executing a. This path is then used to
find which part of the input to change while executing the
assignment. Any filter may be used on the left-hand side of
an equals - whichever paths it selects from the input will
be where the assignment is performed.</p>

<p style="margin-left:9%; margin-top: 1em">This is a very
powerful operation. Suppose we wanted to add a comment to
blog posts, using the same &quot;blog&quot; input above.
This time, we only want to comment on the posts written by
&quot;stedolan&quot;. We can find those posts using the
&quot;select&quot; function described earlier:</p></table>

<p style="margin-top: 1em">.posts[] | select(.author ==
&quot;stedolan&quot;)</p>

<p style="margin-left:9%; margin-top: 1em">The paths
provided by this operation point to each of the posts that
&quot;stedolan&quot; wrote, and we can comment on each of
them in the same way that we did before:</p></table>

<p style="margin-top: 1em">(.posts[] | select(.author ==
&quot;stedolan&quot;) | .comments) |= <br>
. + [&quot;terrible.&quot;]</p>

<h2>MODULES
<a name="MODULES"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">jq has a
library/module system. Modules are files whose names end in
<b>.jq</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Modules imported
by a program are searched for in a default search path (see
below). The <b>import</b> and <b>include</b> directives
allow the importer to alter this path.</p>

<p style="margin-left:9%; margin-top: 1em">Paths in the a
search path are subject to various substitutions.</p>

<p style="margin-left:9%; margin-top: 1em">For paths
starting with <b>&#732;/</b>, the user&acute;s home
directory is substituted for <b>&#732;</b>.</p>

<p style="margin-left:9%; margin-top: 1em">For paths
starting with <b>$ORIGIN/</b>, the directory where the jq
executable is located is substituted for <b>$ORIGIN</b>.</p>

<p style="margin-left:9%; margin-top: 1em">For paths
starting with <b>./</b> or paths that are <b>.</b>, the path
of the including file is substituted for <b>.</b>. For
top-level programs given on the command-line, the current
directory is used.</p>

<p style="margin-left:9%; margin-top: 1em">Import
directives can optionally specify a search path to which the
default is appended.</p>

<p style="margin-left:9%; margin-top: 1em">The default
search path is the search path given to the <b>-L</b>
command-line option, else <b>[&quot;&#732;/.jq&quot;,
&quot;$ORIGIN/../lib/jq&quot;,
&quot;$ORIGIN/../lib&quot;]</b>.</p>

<p style="margin-left:9%; margin-top: 1em">Null and empty
string path elements terminate search path processing.</p>

<p style="margin-left:9%; margin-top: 1em">A dependency
with relative path <b>foo/bar</b> would be searched for in
<b>foo/bar.jq</b> and <b>foo/bar/bar.jq</b> in the given
search path. This is intended to allow modules to be placed
in a directory along with, for example, version control
files, README files, and so on, but also to allow for
single-file modules.</p>

<p style="margin-left:9%; margin-top: 1em">Consecutive
components with the same name are not allowed to avoid
ambiguities (e.g., <b>foo/foo</b>).</p>

<p style="margin-left:9%; margin-top: 1em">For example,
with <b>-L$HOME/.jq</b> a module <b>foo</b> can be found in
<b>$HOME/.jq/foo.jq</b> and <b>$HOME/.jq/foo/foo.jq</b>.</p>

<p style="margin-left:9%; margin-top: 1em">If
<b>$HOME/.jq</b> is a file, it is sourced into the main
program.</p>

<h3>import RelativePathString as NAME [&lt;metadata&gt;];
<a name="import RelativePathString as NAME [&lt;metadata&gt;];"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Imports a module
found at the given path relative to a directory in a search
path. A <b>.jq</b> suffix will be added to the relative path
string. The module&acute;s symbols are prefixed with
<b>NAME::</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The optional
metadata must be a constant jq expression. It should be an
object with keys like <b>homepage</b> and so on. At this
time jq only uses the <b>search</b> key/value of the
metadata. The metadata is also made available to users via
the <b>modulemeta</b> builtin.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>search</b> key in the metadata, if present, should have a
string or array value (array of strings); this is the search
path to be prefixed to the top-level search path.</p>

<h3>include RelativePathString [&lt;metadata&gt;];
<a name="include RelativePathString [&lt;metadata&gt;];"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Imports a module
found at the given path relative to a directory in a search
path as if it were included in place. A <b>.jq</b> suffix
will be added to the relative path string. The
module&acute;s symbols are imported into the caller&acute;s
namespace as if the module&acute;s content had been included
directly.</p>

<p style="margin-left:9%; margin-top: 1em">The optional
metadata must be a constant jq expression. It should be an
object with keys like <b>homepage</b> and so on. At this
time jq only uses the <b>search</b> key/value of the
metadata. The metadata is also made available to users via
the <b>modulemeta</b> builtin.</p>

<h3>import RelativePathString as $NAME [&lt;metadata&gt;];
<a name="import RelativePathString as $NAME [&lt;metadata&gt;];"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Imports a JSON
file found at the given path relative to a directory in a
search path. A <b>.json</b> suffix will be added to the
relative path string. The file&acute;s data will be
available as <b>$NAME::NAME</b>.</p>

<p style="margin-left:9%; margin-top: 1em">The optional
metadata must be a constant jq expression. It should be an
object with keys like <b>homepage</b> and so on. At this
time jq only uses the <b>search</b> key/value of the
metadata. The metadata is also made available to users via
the <b>modulemeta</b> builtin.</p>

<p style="margin-left:9%; margin-top: 1em">The
<b>search</b> key in the metadata, if present, should have a
string or array value (array of strings); this is the search
path to be prefixed to the top-level search path.</p>

<h3>module &lt;metadata&gt;;
<a name="module &lt;metadata&gt;;"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">This directive
is entirely optional. It&acute;s not required for proper
operation. It serves only the purpose of providing metadata
that can be read with the <b>modulemeta</b> builtin.</p>

<p style="margin-left:9%; margin-top: 1em">The metadata
must be a constant jq expression. It should be an object
with keys like <b>homepage</b>. At this time jq
doesn&acute;t use this metadata, but it is made available to
users via the <b>modulemeta</b> builtin.</p>

<h3>modulemeta
<a name="modulemeta"></a>
</h3>


<p style="margin-left:9%; margin-top: 1em">Takes a module
name as input and outputs the module&acute;s metadata as an
object, with the module&acute;s imports (including metadata)
as an array value for the <b>deps</b> key and the
module&acute;s defined functions as an array value for the
<b>defs</b> key.</p>

<p style="margin-left:9%; margin-top: 1em">Programs can use
this to query a module&acute;s metadata, which they could
then use to, for example, search for, download, and install
missing dependencies.</p>

<h2>COLORS
<a name="COLORS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">To configure
alternative colors just set the <b>JQ_COLORS</b> environment
variable to colon-delimited list of partial terminal escape
sequences like <b>&quot;1;31&quot;</b>, in this order:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="27%">


<p>color for <b>null</b></p></td>
<td width="59%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="27%">


<p>color for <b>false</b></p></td>
<td width="59%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="27%">


<p>color for <b>true</b></p></td>
<td width="59%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="27%">


<p>color for numbers</p></td>
<td width="59%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="27%">


<p>color for strings</p></td>
<td width="59%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="27%">


<p>color for arrays</p></td>
<td width="59%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="27%">


<p>color for objects</p></td>
<td width="59%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="27%">


<p>color for object keys</p></td>
<td width="59%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">The default
color scheme is the same as setting
<b>JQ_COLORS=&quot;0;90:0;39:0;39:0;39:0;32:1;39:1;39:1;34&quot;</b>.</p>

<p style="margin-left:9%; margin-top: 1em">This is not a
manual for VT100/ANSI escapes. However, each of these color
specifications should consist of two numbers separated by a
semi-colon, where the first number is one of these:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="18%">


<p>1 (bright)</p></td>
<td width="68%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="18%">


<p>2 (dim)</p></td>
<td width="68%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="18%">


<p>4 (underscore)</p></td>
<td width="68%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="18%">


<p>5 (blink)</p></td>
<td width="68%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="18%">


<p>7 (reverse)</p></td>
<td width="68%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="18%">


<p>8 (hidden)</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:9%; margin-top: 1em">and the second
is one of these:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="15%">


<p>30 (black)</p></td>
<td width="71%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="15%">


<p>31 (red)</p></td>
<td width="71%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="15%">


<p>32 (green)</p></td>
<td width="71%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="15%">


<p>33 (yellow)</p></td>
<td width="71%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="15%">


<p>34 (blue)</p></td>
<td width="71%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="15%">


<p>35 (magenta)</p></td>
<td width="71%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="15%">


<p>36 (cyan)</p></td>
<td width="71%">
</td></tr>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="15%">


<p>37 (white)</p></td>
<td width="71%">
</td></tr>
</table>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">Presumably.
Report them or discuss them at:</p>


<p style="margin-top: 1em">https://github.com/jqlang/jq/issues</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:9%; margin-top: 1em">Stephen Dolan
<b>&lt;mu@netsoc.tcd.ie&gt;</b></p>
<hr>
</body>
</html>
